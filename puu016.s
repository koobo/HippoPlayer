;APS00000000000000000000000000000000000000000000000000000000000000000000000000000000
*******************************************************************************
*                                HippoPlayer
*******************************************************************************
* Aloitettu 5.2.-94

ver	macro
;	dc.b	"v2.30 (5.8.1996)"
;	dc.b	"v2.31ﬂA (24.8.-96)"
;	dc.b	"v2.31ﬂC (?.?.1996)"
;	dc.b	"v2.35 (23.11.1996)"
;	dc.b	"v2.37 (31.12.1996)"
;	dc.b	"v2.38 (9.2.1997)"
;	dc.b	"v2.40 (29.6.1997)"
;	dc.b	"v2.41 (25.10.1997)"
;	dc.b	"v2.42 (20.12.1997)"
;	dc.b	"v2.44 (16.8.1998)"
;	dc.b	"v2.44 (16.8.1998)"
;	dc.b	"v2.45 (10.1.2000)"
;	dc.b	"v2.47ﬂ (?.?.2021)"
;	dc.b	"v2.47 (31.8.2021)"
;	dc.b	"v2.48 (31.10.2021)"
;	dc.b	"v2.49ﬂ (?.?.2021)"
;	dc.b	"v2.49 (29.11.2021)"
;	dc.b	"v2.50ﬂ (?.?.202?)"
;	dc.b	"v2.50 (31.12.2021)"
;	dc.b	"v2.52ﬂ (?.?.202?)"
;	dc.b	"v2.52 (30.4.2022)"
;	dc.b	"v2.53 (13.7.2022)"
;	dc.b	"v2.54ﬂ (?.?.2022)"
;	dc.b	"v2.54 (30.8.2022)"
;	dc.b	"v2.55ﬂ (?.?.2022)"
;	dc.b	"v2.55 (10.11.2022)"
;	dc.b	"v2.56ﬂ (?.?.202?)"
;	dc.b	"v2.56 (15.2.2023)"
;	dc.b	"v2.57ﬂ (?.?.2023)"
;	dc.b	"v2.57 (1.4.2023)"
;	dc.b	"v2.58ﬂ (?.?.2023)"
;	dc.b	"v2.58 (22.6.2023)"
;	dc.b	"v2.59ﬂ (?.?.2023)"
;	dc.b	"v2.59 (29.11.2023)"
;	dc.b	"v2.60ﬂ (?.?.2023)"
;	dc.b	"v2.60 (18.2.2024)"
;	dc.b	"v2.61ﬂ (?.?.2024)"
;	dc.b	"v2.61 (28.5.2024)"
;	dc.b	"v2.62ﬂ (?.?.2025)"
;	dc.b	"v2.62 (4.4.2025)"
	dc.b	"v2.63ﬂ (?.?.2025)"
	endm	


 ifnd DEBUG
* AsmOne setting:
* Enable debug logging 
DEBUG = 1
 endif

 ifnd SERIALDEBUG
SERIALDEBUG = 0
 endif

 ifnd __VASM
* AsmOne setting:
* 1: Run from AsmOne
* 0: CLI/Workbench  
asm = 1
 else
asm = 0
 endif


BETA	= 0	* 0: ei beta, 1: public beta, 2: private beta
zoom	= 0	* 1: zoomaava hippo
fprog	= 0 * 1: file add progress indicator, ei oikein toimi (kaataa)
floadpr = 1	* 1: unpacked file load progress indicator
PILA	= 0	* 1: pikku pila niille joilla on wRECin key muttei 060:aa
TARK	= 0	* 1: tekstien tarkistus
EFEKTI  = 0	* 1: efekti volumesliderill‰
ANNOY	= 0 * 1: Unregistered version tekstej‰ ymp‰riins‰

DELI_TEST_MODE 		= 	0
FEATURE_FREQSCOPE	=	0
FEATURE_SPECTRUMSCOPE	= 	1
FEATURE_P61A        =   1
FEATURE_PASTE       =   0

 ifeq (FEATURE_FREQSCOPE+FEATURE_SPECTRUMSCOPE)
    fail "Enable only one"
 endif
 
 ifeq (FEATURE_FREQSCOPE+FEATURE_SPECTRUMSCOPE-2)
    fail "Enable only one"
 endif

; Magic constants used with playingmodule and chosenmodule
; Positive value:
; - playingmodule: index of the module being played
; - chosenmodule: index of the module that is selected
; Negative value: 
; - playingmodule: there is no module being played 
; - chosenmodule: there is no module chosen in the list
; Special value 0x7fffffff: 
; - playingmodule: there is a module being played, but it is not in the list (deleted or list cleared)
; - chosenmodule: TODO, what is it
PLAYING_MODULE_NONE 	= -1	 	* needs to be negative
PLAYING_MODULE_REMOVED	= $7fffffff	* needs to be positive
MAX_MODULES		= $1ffff 		    * this should be enough!

; Where boxsize(a5) used this is the amount that should
; be first reduced from it if the bottom search layout
; is active. That is, the bottom stuff takes two lines
; out of the file list.
SEARCH_BOXSIZE_DELTA = 2
	
 ;ifne TARK
 ;ifeq asm
 ;printt "Onko CHECKSUMMI oikea? Molemmat!"
 ;printt "Onko CHECKSUMMI oikea?"
 ;endc
 ;endc
 

WINX	= 2	* X ja Y lis‰ykset p‰‰ikkunan grafiikkaan
WINY	= 3

* This char as the first char in filename indicates a list divider
DIVIDER_MAGIC = '˜' ; UTF8=c3b7
* Another magic char for dividers to be drawn differently, stealthy
DIVIDER_MAGIC_ALT = '¢' ; UTF8=c2a2

;isListDivider macro 
;	cmp.b 	#DIVIDER_MAGIC,\1
;	endm

isFavoriteModule macro 
	tst.b 	l_favorite(\1)
	endm

;
;* Checks if list is in favorite mode
;* Z is set if in normal mode, otherwise favorite mode
;isListInFavoriteMode macro
;	cmp.b #LISTMODE_FAVORITES,listMode(a5)
;	endm
;

iword	macro
	ror	#8,\1
	endm

ilword	macro
	ror	#8,\1
	swap	\1
	ror	#8,\1
	endm

tlword	macro
	move.b	\1,\2
	ror.l	#8,\2
	move.b	\1,\2
	ror.l	#8,\2
	move.b	\1,\2
	ror.l	#8,\2
	move.b	\1,\2
	ror.l	#8,\2
	endm

tword	macro
	move.b	\1,\2
	ror	#8,\2
	move.b	\1,\2
	ror	#8,\2
	endm

***** Tarkistaa rekisterˆitymiseen liittyv‰t tekstit


check	macro

 ifne TARK
 ifeq asm
	lea	CHECKSTART(pc),a0	
	moveq	#0,d0
	moveq	#0,d1
	moveq	#8,d2
.qghg\1	move.b	(a0)+,d1
	neg.b	d1
	add	d2,d0
	add	d1,d0
	addq	#1,d2
	cmp.b	#$ff,(a0)
	bne.b	.qghg\1
 ifeq BETA
	tst.b	eicheck(a5)
	bne.b	.fghz\1
	sub	textchecksum(a5),d0
	sne	exitmainprogram(a5)
.fghz\1
 endc
 endc
 endc

	endm

  ifd __VASM
	NOLIST
  endif
 	incdir	include:
	include	exec/exec_lib.i
	include	exec/ports.i
	include	exec/types.i
	include	exec/execbase.i
	include	exec/memory.i
	include	exec/lists.i
	include exec/semaphores.i

	include	graphics/gfxbase.i
	include	graphics/graphics_lib.i
	include	graphics/rastport.i
	include graphics/scale.i
	include	graphics/text.i

;	include	graphics/rpattr.i

	include	intuition/intuition_lib.i
	include	intuition/intuition.i

	include	dos/dos_lib.i
	include	dos/dosextens.i
	include	dos/var.i
	include	dos/dostags.i
    include dos/rdargs.i

	include	rexx/rxslib.i

	include	devices/audio.i
	include	devices/input.i
	include	devices/inputevent.i

	include	workbench/startup.i
	include	workbench/workbench.i
	include	workbench/wb_lib.i

	include	hardware/intbits.i
	include	hardware/cia.i

	include	resources/cia_lib.i
	include	libraries/diskfont_lib.i
	


	include	libraries/powerpacker_lib.i
	include	libraries/reqtools.i
	include	libraries/reqtools_lib.i
	include	libraries/xpk.i
	include	libraries/xpkmaster_lib.i
	include	playsid.library/playsidbase.i
	include	playsid.library/playsid_lib.i
	include	libraries/xfdmaster_lib.i
	include	libraries/xfdmaster.i
	include	libraries/screennotify_lib.i
	include	libraries/screennotify.i
	include	graphics/layers_lib.i
	
	include	devices/ahi.i
	include	devices/ahi_lib.i

	include	misc/deliplayer.i
	include	misc/eagleplayer.i

	include	math/mathffp_lib.i
	include	math/mathtrans_lib.i
	
	include	libraries/timer_lib.i
	include	devices/timer.i
	include	intuition/sghooks.i

    include libraries/expansion_lib.i
    include libraries/configvars.i

 ifne FEATURE_PASTE
    include libraries/iffparse_lib.i
    include libraries/iffparse.i
 endif

	incdir include/
	include	mucro.i
	include	med.i
	include	Guru.i
	include	ps3m.i
	include	patternInfo.i
 ifne FEATURE_P61A
use = 0
	include	player61.i
 endif

	include	playerIds.i
	include	kpl_offsets.S


  ifd __VASM
	LIST
  endif

*******************************************************************************
*
* Prefs tiedoston rakenne
*

prefsversio	=	21	* Prefs-tiedoston versio
		rsreset
prefs_versio		rs.b	1
prefs_play		rs.b	1
prefs_show		rs.b	1
prefs_tempo		rs.b	1
prefs_tfmxrate		rs.b	1
prefs_s3mmode1		rs.b	1
prefs_s3mmode2		rs.b	1
prefs_s3mmode3		rs.b	1
prefs_ps3mb		rs.b	1
prefs_timeoutmode	rs.b	1
XXXprefs_quadmode	rs.b	1
XXXprefs_quadon		rs.b	1		* 1: quad oli p‰‰ll‰
prefs_ptmix		rs.b	1		* 0: chip, 1: fast, 2: ps3m
prefs_xpkid		rs.b	1
prefs_fade		rs.b	1
prefs_pri		rs.b	1
prefs_boxsize		rs.b	1
prefs_infoon		rs.b	1
prefs_doubleclick	rs.b	1
prefs_startuponoff	rs.b	1
prefs_hotkey		rs.b	1
prefs_cerr		rs.b	1
prefs_nasty		rs.b	1
prefs_dbf		rs.b	1
prefs_filter		rs.b	1
prefs_vbtimer		rs.b	1
prefs_timeout		rs	1
prefs_s3mrate		rs.l	1
prefs_mainpos1		rs.l	1
prefs_mainpos2		rs.l	1
prefs_prefspos		rs.l	1
Xprefs_quadpos		rs.l	1
			rs	1
prefs_alarm		rs	1
prefs_moddir		rs.b	150
prefs_prgdir		rs.b	150-1
prefs_stereofactor	rs.b	1
prefs_arclha		rs.b	100
prefs_arczip		rs.b	100
prefs_arclzx		rs.b	100
prefs_pubscreen		rs.b	MAXPUBSCREENNAME+1
prefs_startup		rs.b	120
prefs_fkeys		rs.b	120*10
prefs_textattr		rs.b	ta_SIZEOF-4
prefs_fontname		rs.b	20
prefs_groupmode		rs.b	1
prefs_groupname		rs.b	99
prefs_div		rs.b	1
prefs_early		rs.b	1
prefs_prefix		rs.b	1
prefs_xfd			rs.b	1
					rs.w	1
prefs_windowWidth	rs.w	1
prefs_infopos2		rs.l	1
prefs_arcdir		rs.b	150
prefs_pattern		rs.b	70
prefs_infosize		rs	1
prefs_ps3msettings	rs.b	1
prefs_prefsivu		rs.b	1
prefs_kokolippu		rs.b	1		* 0: ikkuna pieni
prefs_samplebufsiz	rs.b	1
prefs_cybercalibration	rs.b 1
prefs_calibrationfile	rs.b	99
prefs_forcerate		rs	1

prefs_ahi_use		rs.b	1
prefs_ahi_muutpois	rs.b	1
prefs_ahi_rate		rs.l	1
prefs_ahi_mastervol	rs	1
prefs_ahi_stereolev	rs	1
prefs_ahi_mode		rs.l	1
prefs_ahi_name		rs.b	44

prefs_autosort		rs.b	1

prefs_samplecyber	rs.b	1
prefs_mpegaqua		rs.b	1
prefs_mpegadiv		rs.b	1
prefs_medmode		rs.b	1
prefs_favorites		rs.b	1
prefs_medrate		rs	1

prefs_tooltips		rs.b 	1
prefs_savestate		rs.b 	1
prefs_altbuttons	rs.b	1

prefs_quadraScope        rs.b    1
prefs_quadraScopeBars    rs.b    1
prefs_quadraScopeF       rs.b    1
prefs_quadraScopeFBars   rs.b    1
prefs_hippoScope         rs.b    1
prefs_hippoScopeBars     rs.b    1
prefs_patternScope       rs.b    1
prefs_patternScopeXL     rs.b    1
prefs_spectrumScope      rs.b    1
prefs_spectrumScopeBars  rs.b    1
prefs_sidmode            rs.b    1

prefs_quadraScopePos     rs.l    1
prefs_quadraScopeFPos    rs.l    1
prefs_hippoScopePos      rs.l    1
prefs_patternScopePos    rs.l    1
prefs_spectrumScopePos   rs.l    1

prefs_listtextattr      rs.b      ta_SIZEOF-4
prefs_listfontname      rs.b      30
    printt    "TODO TODO: dangerous buffer size"

prefs_xmaplay         rs.b      1
prefs_residmode       rs.b      1
prefs_residfilter     rs.b      1
* This does not have a prefs setting, instead it serves as a way to persist
* the search selection.
prefs_selectedSearch  rs.b      1 
prefs_mhiEnable       rs.b      1
MHILIB_SIZE         =   40
prefs_mhiLib          rs.b      MHILIB_SIZE
prefs_medfastmemplay  rs.b     1
prefs_showPositionSlider rs.b  1
prefs_residboost      rs.b      1
prefs_midimode        rs.b      1
prefs_ps3mamigus      rs.b      1 
prefs_size            rs.b      0

	ifne	prefs_size&1
	fail
	endc


*******************************************************************************
*
* Scope variables for one audio channel
* Values are copied here from replay code internal structures.
* Originally only Protracker supported, now also many others.

* Scope data for one channel
* This should correspond go the "PTch" structure in hippoport
              rsreset
ns_start      rs.l       1 * Sample start address
ns_length     rs         1 * Length in words
ns_loopstart  rs.l       1 * Loop start address
ns_replen     rs         1 * Loop length in words
ns_tempvol    rs         1 * Volume
ns_period     rs         1 * Period
;Unused:
;ns_tempvol2	rs	1
ns_size       rs.b       0 * = 16 bytes

* Combined scope data structure
              rsreset
scope_ch1	  rs.b	ns_size
scope_ch2	  rs.b	ns_size
scope_ch3	  rs.b	ns_size
scope_ch4	  rs.b	ns_size
scope_trigger rs.b  1 * Audio channel enable DMA flags
scope_pad	  rs.b  1
scope_size    rs.b  0

 if ns_size<>16
    fail "This is assumed to be 16 in code"
 endif

*******************************************************************************
*
* Message sent to HippoPort by another instances of Hippo
*

MESSAGE_MAGIC_ID = "K-P!"
MESSAGE_COMMAND_HIDE = "HIDE"
MESSAGE_COMMAND_QUIT = "QUIT"
MESSAGE_COMMAND_PRG = "PRGM"

	STRUCTURE 	HippoMessage,MN_SIZE
	LONG		HM_Identifier	* "K-P!"
	APTR		HM_Arguments	* sv_argvArray. May contain above commands
	LABEL		HippoMessage_SIZEOF 

*******************************************************************************
*
* "HiP-Port" structure
*

	STRUCTURE	HippoPort,MP_SIZE
	LONG		hip_private1	* Private..
	APTR		hip_kplbase	* Protracker replayer data area
	WORD		hip_reserved0	* Private..
	BYTE		hip_quit	* If non-zero, your program should quit
	BYTE		hip_opencount	* Open count
	BYTE		hip_mainvolume	* Main volume, 0-64
	BYTE		hip_play	* If non-zero, HiP is playing
	BYTE		hip_playertype 	* 33 = Protracker, 49 = PS3M. 

	*** Protracker ***
	BYTE		hip_reserved2
	APTR		hip_PTch1	* Protracker channel data for ch1
	APTR		hip_PTch2	* ch2
	APTR		hip_PTch3	* ch3
	APTR		hip_PTch4	* ch4

	*** PS3M ***
	APTR		hip_ps3mleft	* Buffer for the left side
	APTR		hip_ps3mright	* Buffer for the right side
	LONG		hip_ps3moffs	* Playing position
	LONG		hip_ps3mmaxoffs	* Max value for hip_ps3moffs

	BYTE		hip_PTtrigger1
	BYTE		hip_PTtrigger2
	BYTE		hip_PTtrigger3
	BYTE		hip_PTtrigger4

	APTR		hip_moduleListHeader	* pointer to the moduleListHeader of modules
	LONG		hip_playtime	* time played in secs
	LONG		hip_colordiv	*
	WORD		hip_ps3mrate	* ps3m mix rate

	LABEL		HippoPort_SIZEOF 


	*** PT channel data block
	STRUCTURE	PTch,0
	LONG		PTch_start	* Start address of sample
	WORD		PTch_length	* Length of sample in words
	LONG		PTch_loopstart	* Start address of loop
	WORD		PTch_replen	* Loop length in words
	WORD		PTch_volume	* Channel volume
	WORD		PTch_period	* Channel period
	WORD		PTch_private1	* Private...
	
*******************************************************************************
*
* Local stream config structure

    rsreset
localStream_currentDir     rs.l    1 * Directory to change to, or NULL
localStream_cliName        rs.l    1 * Command
localStream_command        rs.l    1 * Full command line with arguments
localStream_pipe           rs.l    1 * PIPE path for reading
localStream_setup          rs.l    1 * Setup routine to call or NULL
localStream_stack          rs.l    1 * Stack requested, or NULL if default
localStream_poll           rs.l    1 * If streamer is sent CTRL-D this routine is called
localStream_additionalParam rs.l   1 * Used as the 3rd formatting parameter

*******************************************************************************
*
* Global variables and work space
*

	rsreset
_ExecBase	rs.l	1
_GFXBase	rs.l	1
_IntuiBase	rs.l	1
_DosBase	rs.l	1
_ReqBase	rs.l	1
_WBBase		rs.l	1
_RexxBase	rs.l	1
_ScrNotifyBase	rs.l	1
_DiskFontBase	rs.l	1
_PPBase		rs.l	1
_XPKBase	rs.l	1
_SIDBase	rs.l	1
_MedPlayerBase	rs.l	1
_MedPlayerBase1	rs.l	1
_MedPlayerBase2	rs.l	1
_MedPlayerBase3	rs.l	1
_MlineBase		rs.l	1
_XFDBase	rs.l	1
_FFPBase	rs.l 1
_MTBase     rs.l 1
_LayersBase rs.l 1
_ExpansionBase rs.l 1
_TntBase    rs.l    1
 ifne DEBUG
output		rs.l	1
 endc

owntask		rs.l	1
lockhere	rs.l	1		* currentdir-lock
homelock	rs.l 	1		* homedir-lock (V36)
cli			rs.l	1
segment		rs.l	1	* Toisiks ekan hunkin segmentti
* Fileinfoblock used by main task
fileinfoblock	rs.b	260		* 4:ll‰ jaollisessa osoitteessa!
* Fileinfoblock used by file req task
fileinfoblock2	rs.b	260		

 if fileinfoblock&%11
	fail Not divisible by 4
 endif
 if fileinfoblock2&%11
	fail Not divisible by 4
 endif

filecomment	rs.b	80+4		* tiedoston kommentti
windowbase	rs.l	1		* p‰‰ohjelma
mainWindowLock rs.l 1
appwindow	rs.l	1		* appwindowbase
screenlock	rs.l	1       * kick2.0+: public screen lock
rastport	rs.l	1		*
userport	rs.l	1		*
windowbase2	rs.l	1		* prefs
rastport2	rs.l	1		* 
userport2	rs.l	1		*
fontbase	rs.l	1		* ordinary font to be used everywhere
topazbase	rs.l	1
minifontbase 	rs.l	1
listfontbase	rs.l	1		* points to some font base
notifyhandle	rs.l	1		* Screennotifylle
windowtop	rs	1		* ikkunoiden eisysteemialueen yl‰reuna
windowright	rs	1
windowleft	rs	1
windowbottom	rs	1
windowtopb	rs	1		* sc_BorTop
gotscreeninfo	rs.b	1
infolag		rs.b	1 * mit‰ n‰ytet‰‰n infoikkunassa: 0=sample, ~0=about

infotaz		rs.l	1 * infoikkunan datan osoite

listFontHeight	rs.w	1

windowtop2	rs	1
windowleft2	rs	1
windowbottom2	rs	1


nilfile		rs.l	1		* NIL:

keycheckroutine	rs.l	1		* check_keyfile rutiinin osoite

pen_0		rs.l	1		* piirtokyn‰t
pen_1		rs.l	1
pen_2		rs.l	1
pen_3		rs.l	1

WINSIZX		rs	1		* p‰‰ikkunan koot
WINSIZY		rs	1

previousWindowWidth 	rs 	1
previousWindowHeight 	rs 	1

eicheck		rs.b	1
reghippo	rs.b 	1 		* ensimm‰inen hippo hieman sivummalle

req_file	rs.l	1		* p‰‰requesteri
req_file2	rs.l	1		* load/save program
req_file3	rs.l	1		* prefs
kokolippu	rs	1		* 0: pieni
windowpos	rs	2		* Ison ikkunan paikka
windowZippedPos	rs	2	* Pienen ikkunan paikka (ZipWindow). Must be together
windowZippedSize rs	2	* ja koko
infopos2	rs	2		* sampleikkunan ja sidinfon paikka

screenaddr	rs.l	1		* N‰ytˆn osoite
windowpos_p	rs	2		* Prefs ikkunan paikka
Xquadpos		rs	2		* Quad-ikkunan paikka
wbkorkeus	rs	1		* Workbench n‰ytˆn korkeus
wbleveys	rs	1
prefs_prosessi	rs	1		* ei-0: Prefs-prosessi p‰‰ll‰
filereq_prosessi rs	1		* ei-0: Files-prosessi p‰‰ll‰
info_prosessi	rs	1		* ...
about_moodi	rs.b	1		* 0: normaali, 1: moduleinfo
filereqmode	rs.b	1		* 0: add mode, ~0: insert mode 
fileinsert	rs.l	1		* node jonka j‰lkeen insertti
haluttiinuusimodi rs	1		* new-nappulaa ja play:t‰ varten
confirmFavoritesModificationDisabled		rs.b	1
infoon		rs.b	1		* 1: info on

exitmainprogram	rs.b	1		* <>1: poistu ohjelmasta
startuperror	rs.b	1		* virhe k‰ynnistyksess‰
oldchip		rs	1		* free memille vertailua varten
oldfast		rs	1		* ...

prefsexit	rs.b	1		* ~0: prefssist‰ poistuttu
lprgadd		rs.b	1		* ~0: loadprg addaa vanhan per‰‰n (join)
prefsivu	rs	1		* 0..5: sivu prefs-ikkunassa
prefsivugads	rs.l	1		* vastaavien gadgettien alkuosoite

seed		rs.l	1		* randomgeneratorin SEED
freezegads	rs.b	1		* ~0: Mainwindowin gadgetit OFF
hippoporton	rs.b	1		* ~0: hippo portti initattu

ciasaatu	rs.b	1		* 1: saatiin cia timeri
vbsaatu		rs.b	1		* 1: saatiin vb intti

prefs_task	rs.l	1		* prefs-prosessi

* Prefs window will close if it receives this signal
prefs_closeSignal	rs.b	1		* prefs-signaali

* Prefs window will update contents when receiving this
prefs_updateContentsSignal	rs.b	1		* prefs-signaali 2

songHasEndedSignal	rs.b	1	* Kappale soinut
ownsignal2	rs.b	1	* window update, prefs update 
uiRefreshSignal	rs.b	1	* lootan p‰ivitys
posUpdateSignal	rs.b	1	
audioPortSignal	rs.b	1	* AudioIO:n signaali
fileReqSignal	rs.b	1	* Filereqprosessin signaali
rawKeySignal	rs.b	1	* rawkey inputhandlerilta
info_signal	rs.b	1	* about signaali infojen p‰ivitykseen
info_signal2	rs.b	1	* about signaali infojen p‰ivitykseen
tooltipSignal	rs.b  	1	* signal for opening tooltip popup

* Flag used to discard unnecessary mousemove IDCMP-messages
ignoreMouseMoveMessage 	rs.b  	1

oli_infoa	rs.b	1	* freemodulea ennen inforequn tila (0:eip‰‰ll‰)

info_task	rs.l	1	* infoikkunan taski

ciabasea	rs.l	1	* ciaa resource base
ciabaseb	rs.l	1	* ciab
ciabase		rs.l	1	* jompikumpi kumpi on k‰ytˆss‰
ciaddr		rs.l	1	* ...
timerhi		rs.b	1	* timerin arvo
timerlo		rs.b	1	* ...
whichtimer	rs.b	1	* Kumpi cia timeri
kelattiintaakse	rs.b	1	* <>0: kelattiin taakkepp‰in

mousex		rs	1		* hiiren paikka x,y
mousey		rs	1

******* Scope variables

taskQuadraScope		     rs.b TC_SIZE
taskQuadraScopeF	 rs.b TC_SIZE
taskHippoScope		     rs.b TC_SIZE
taskSpectrumScope	     rs.b TC_SIZE
taskPatternScope         rs.b  TC_SIZE

* Status for scope tasks:
RUNNING_NOT       = 0
RUNNING_YES       = 1
* Request scope shutdown
RUNNING_SHUT_IT   = $80
quadraScopeRunning	rs.b 1
quadraScopeFRunning 	rs.b 1
hippoScopeRunning	rs.b 1
patternScopeRunning     rs.b 1
spectrumScopeRunning    rs.b 1
scopeToggleTable        rs.b 5 * Used by toggleScopes()

* This turns to 1 if user has manually activated the scope
* by LMB click, when scope was passivated because not being
* visible. As this is global user does not need to do that again.
scopeManualActivation	rs.b 1	

* Special flag to display a clarifying error message
moduleWasRSID  	        rs.b 1

scopeData  rs.b	 scope_size

 if DEBUG
;; Scope performance measurement data
scopeStartTimeSecs		rs.l	1
scopeStartTimeMicros	rs.l	1
scopeStopTimeSecs		rs.l	1
scopeStopTimeMicros		rs.l	1
scopeFrameCounter		rs.l	1
scopeRenderTime         rs.l    1
;; Timer.device stuff
timerOpen               rs.w    1
timerRequest	        rs.b    IOTV_SIZE
clockStart              rs.b    EV_SIZE
clockEnd                rs.b    EV_SIZE
 endif

ps3mchannels	rs.l	1	* Osoitin PS3M mixer channel blockeihin

**** Sampleplayerin datat

sampleforcerate		rs	1
sampleforcerate_new 	rs	1
sampleforceratepot_new	rs	1
samplebufsizpot_new	rs.l	1
samplebufsiz_new	rs.b	1
samplebufsiz0		rs.b	1
samplebufsiz		rs.l	1

* How many bytes to skip to get to next sample in data,
* 1 for 8-bit data 2 for 16-bit. Used when accessing AHI sample
* data, which can be both.
ahiSampleModulo      rs.w    1
* Sample playback rate, bytes per frame.
sampleadd		    rs.l	1
* Pointer to a pointer to the sample position.
* This is reset to zero by sample player when a buffer
* is played through.
samplefollow		rs.l	1
* Sample pointer for mono samples, or the other stereo channel
samplepointer		rs.l	1
* Sample pointer to the other stereo channel
samplepointer2		rs.l	1
* Pointer to text describing the output mode: empty, 14-bit, 14-bit calib, AHI
sampleOutputInfoText rs.l   1
* Set to non-zero if sample being played is stereo
samplestereo		rs.b	1

* This is set in loadfile() to indicate a sample is found.
* Actual loading is then skipped.
sampleinit		rs.b	1		
* Sample format
SAMPLE_FORMAT_NONE = 0
SAMPLE_FORMAT_IFF  = 1
SAMPLE_FORMAT_AIFF = 2
SAMPLE_FORMAT_WAV  = 3
SAMPLE_FORMAT_MP3  = 4
sampleformat   rs.b    1
                rs.b        1   * PAD

****** Prefs asetukset, joita k‰sitell‰‰n

mixingrate_new	rs.l	1		* Prefs-uudet arvot kaikille
ps3mb_new	rs.b	1
timeoutmode_new	rs.b	1
s3mmixpot_new	rs	1		* Propgadgettien arvot
tfmxmixpot_new	rs	1
volumeboostpot_new rs	1
stereofactorpot_new rs	1
tfmxmixingrate_new rs	1
lootamoodi_new	rs	1
timeout_new	rs	1
timeoutpot_new	rs	1
tempoflag_new	rs.b	1
playmode_new	rs.b	1
s3mmode1_new	rs.b	1
s3mmode2_new	rs.b	1
s3mmode3_new	rs.b	1
stereofactor_new rs.b	1
div_new		rs.b	1
Xquadmode_new	rs.b	1
moduledir_new	rs.b	150
prgdir_new	rs.b	150
arcdir_new	rs.b	150
ptmix_new	rs.b	1
xpkid_new	rs.b	1
fade_new	rs.b	1
pri_new		rs.b	1
ps3msettings_new rs.b	1
ps3msettings	rs.b	1

dclick_new	rs.b	1
centname_new	rs.b	1
startuponoff_new rs.b	1
newdir_new	rs.b	1
hotkey_new	rs.b	1
cerr_new	rs.b	1
dbf_new		rs.b	1
nasty_new	rs.b	1
pubscreen_new	rs.b	MAXPUBSCREENNAME+1 ; = 140
arclha_new	rs.b	100
arczip_new	rs.b	100
arclzx_new	rs.b	100
pattern_new	rs.b	70
startup_new	rs.b	120
fkeys_new	rs.b	120*10
xfd_new		rs.b	1
fontname_new	rs.b	20+1
listfontname_new rs.b 	20+1
early_new	rs.b	1
prefix_new	rs.b	1
autosort_new	rs.b	1
favorites_new	rs.b	1	
tooltips_new	rs.b 	1	
savestate_new	rs.b 	1
altbuttons_new  rs.b   1
	
samplecyber_new	rs.b	1
mpegaqua_new	rs.b	1
mpegadiv_new	rs.b	1
medmode_new	rs.b	1
medrate_new	rs	1
medratepot_new	rs	1
sidmode_new     rs.b    1
residmode_new   rs.b    1
xmaplay_new     rs.b    1
medfastmemplay_new rs.b  1
mhiEnable_new   rs.b 1
residfilter_new rs.b    1
residboost_new  rs.b    1
midimode_new    rs.b    1 
alarmpot_new	rs.l	1
alarm_new	rs	1
vbtimer_new	rs.b	1
Xscopechanged	rs.b	1		* scopea muutettu
contonerr_laskuri rs.b 1		* kuinka monta virheellist‰ lataus
;cybercalibration_new rs.b 1		* yrityst‰
;calibrationfile_new rs.b 100
;newcalibrationfile rs.b	1
ps3mamigus_new    rs.b   1
                  rs.b   1 * pad

mhiLib_new      rs.b MHILIB_SIZE

prefs_exit	rs.b	1		* Prefs exit-flaggi

slider4oldheight rs	1
slider1old	rs	1		* previous VertPot value to detect changes
slider4old	rs	1		* previous VertPot value to detect changes
mainvolume	rs	1		* p‰‰-‰‰nenvoimakkuus
mixirate	rs.l	1		* miksaustaajuus S3M:‰lle
textchecksum	rs	1
priority	rs.l	1		* ohjelman prioriteetti
tfmxmixingrate	rs	1		* rate 1-22
s3mmode1	rs.b	1		* prioriteetti / killeri
s3mmode2	rs.b	1	* surround,stereo,mono,real surround,14-bit
s3mmode3	rs.b	1		* Volume boost
stereofactor	rs.b	1		* stereofactor
xfd		rs.b	1		* ~0: k‰ytet‰‰n xfdmaster.libb°‰
ps3mb		rs.b	1

QUADMODE_QUADRASCOPE = 0
QUADMODE_HIPPOSCOPE = 1
QUADMODE_FREQANALYZER = 2
QUADMODE_PATTERNSCOPE = 3
QUADMODE_FQUADRASCOPE = 4
QUADMODE_PATTERNSCOPEXL = 5


* Store the original window height to switch between
* large and normal height mode
quadWindowHeightOriginal	rs.w	1

* Timeout mode: 0=all modules, $ff=only thos with no end-detection
timeoutmode	rs.b	1
filterstatus	rs.b	1		* filtterin 
modulefilterstate rs.b	1		* ..
ptmix		rs.b	1		* 0: normi ptreplay, 1:mixireplay
xpkid		rs.b	1		* 0: ei xpktunnistusta, 1:joo
							* seems to be that 0 enables xpkid here
fade		rs.b	1		* 0: ei feidausta
boxsize		rs	1		* montako nime‰ mahtuu fileboksiin
						* size of the module name box
* filebox slider value set in prefs, range: 2..48
boxsize_new	rs	1		
boxsizepot_new	rs	1
* This value represents the y-difference compared to
* a box of 8 lines height. Many places it is assumed that
* the box is 8 lines, afterwards resizing was added on top of it.
boxy		rs	1		* 8-nimisen lootaan y-kokomuutos
boxsize0	rs	1		* previous boxsize value to detect changes
boxsize00	rs	1		* magic flag that causes reopening the main window
boxsizez	rs	1		* rmb + ? zoomausta varten
						* alternative boxsize for RMB 
doubleclick	rs.b	1		* <>0: tiedoston doubleclick-play
tabularasa	rs.b	1		* aloitettiinko tyhjalla modilistalla?
startuponoff	rs.b	1		* <>0: startupsoitto p‰‰ll‰
hotkey		rs.b	1		* <>0: hotkeyt p‰‰ll‰
contonerr	rs.b	1		* <>0: jatketaan latauserrorin sattuessa
vbtimer		rs.b	1		* ~0: K‰ytet‰‰n vb ajastusta	
vbtimeruse	rs.b	1		* ~0: t‰m‰n hetkinen
groupmode_new	rs.b	1
groupname_new	rs.b	100
infosize_new	rs	1		* module infon koko
infosize	rs	1
infosizepot_new	rs	1

prefixcut	rs.b	1   * prefix cut setting recycled to scope priority
scopePriority = prefixcut 
earlyload	rs.b	1
divdir		rs.b	1
cybercalibration rs.b	1

* Playtime in seconds when module should be stopped automatically,
* zero if not enabled
timeout		rs	1		* moduulin soittoaika

alarm		rs	1		* alarm aika
do_alarm	rs.b	1		* ~0: her‰tys! :)

new		rs.b	1		* onko painettu New:i‰?
new2		rs.b	1		* onko painettu New:i‰?

gfxcard		rs.b 	1		* jos ~0, k‰ytˆss‰ n‰yttˆkortti

samplecyber	rs.b	1		* ~0: sampleplayer k‰ytt‰‰ cybercalibr.
mpegaqua	rs.b	1		* MPEGA quality
mpegadiv	rs.b	1		* MPEGA freq. division
medmode		rs.b	1		* MED mode
medrate		rs	1		* MED mixing rate
sidmode     rs.b    1

RESIDMODE_NORMAL = 0
RESIDMODE_OVERSAMPLE2 = 1
RESIDMODE_OVERSAMPLE3 = 2
RESIDMODE_OVERSAMPLE4 = 3
RESIDMODE_INTERPOLATE = 4
residmode   rs.b    1

xmaplay     rs.b    1
residfilter rs.b    1
residboost  rs.b    1
medfastmemplay rs.b     1

MIDI_TIMIDITY = 0
MIDI_GMPLAY   = 1
MIDI_SERIAL   = 2
midimode            rs.b    1
                    rs.b    1 * pad
*******

sortbuf		rs.l	1		* sorttaukseen puskuri

TITLEBAR_TIME_POSLEN_SONG 		= 0
TITLEBAR_CLOCK_FREEMEM			= 1
TITLEBAR_NAME					= 2
TITLEBAR_TIMEDUR_POSLEN			= 3 * now same as TITLEBAR_TIME_POSLEN_SONG
TITLEBAR_MODE_MAX               = 2
lootamoodi	rs	1		* lootan moodi, titlebar mode

lootassa	rs	1		* viimeisin tieto lootassa
colordiv	rs.l	1		* colorclock/vbtaajuus
vertfreq	rs	1		* virkistystaajuudet
horizfreq	rs	1

clockconstant	rs.l	1		* Clock Constant PAL/NTSC

pos_nykyinen	rs	1		* moduulin position
pos_maksimi	rs	1		
positionmuutos	rs	1

aika1		rs.l	1
aika2		rs.l	1
vanhaaika	rs	1
ticktack	rs	1	* vb tick count for titlebar refresh
tooltipTick	rs 	1	* vb tick count for tooltips, counts from positive to 0
userIdleTick rs  1	* refresh counter updated each ui refresh tick, cleared on mouse
kokonaisaika	rs	2	* pt-moduille laskettu kesto aika, min/sec
				* tai sampleille

modamount		rs.l	1	* modien m‰‰r‰
divideramount	rs.l	1	* dividereitten m‰‰r‰ (info window)
firstname		rs.l	1	* nimi ikkunan ekan nimen numero
firstname2		rs.l	1	* 

* List node represeneting an index
* Should be zeroed if list structure
* changes above the node.
cachedNodeIndex	rs.l	1
cachedNode	rs.l	1	

markedline	rs.l	1	* merkitty rivi
				* Highlighted line inside the box, range is from 0
				* to current boxsize

playingmodule	rs.l	1	* index of the module that is being played
chosenmodule	rs.l	1	* index of the chosen module in the list

GROUPMODE_ALL_ON_STARTUP = 0
GROUPMODE_ALL_ON_DEMAND = 1
GROUPMODE_DISABLE = 2
GROUPMODE_LOAD_SINGLE = 3
groupmode	rs.b	1	* player group handling mode

movenode	rs.b	1	* ~0: move p‰‰ll‰
nodetomove	rs.l	1	* t‰t‰ nodea siirret‰‰n

chosenmodule2	rs.l	1	* TODO: what is this
hippoonbox	rs.b	1	* ~0: shownames p‰ivitt‰‰ koko n‰ytˆn
dontmark	rs.b	1	* ei merkata nime‰ listassa

clickmodule	rs.l	1	* doubleklikattumodule
clicksecs	rs.l	1	* aika CurrentTime()lt‰ DoubleClick()ille
clickmicros	rs.l	1

playerbase	rs.l	1	* soittorutiinin base
playertype	rs	1	* pt_????

tempoflag	rs.b	1	* 0: tempo sallittu, ei-0: tempo ei sallitu
songover	rs.b	1	* kappale soinut loppuun
uusikick	rs.b	1	* ~0 jos kickstart 2.0+
win		rs.b 	1	* ~0: ikkuna auki, 0: EI IKKUNAA, hide!

* Contains gadget address which was selected with RMB, or null if none.
rightButtonSelectedGadget 	rs.l 	1	
* Routine to run after RMB is raised, while still on top of said gadget
rightButtonSelectedGadgetRoutine	rs.l	1
* Tooltip that has been activated and will be shown
activeTooltip				rs.l	1	
* Gadget for which tooltips shall be disabled.
* This is set when a gadget has been pressed by the user
* so that tooltip is not unnecessarily shown.
disableTooltipForGadget  	rs.l 	1
* Tooltip intuition window, if open	
tooltipPopupWindow			rs.l 	1

playing		rs.b	1	* 0: ei soiteta, ei-0: soitetaan
playmode	rs.b	1	* kuinka soitetaan listaa
filterstore	rs.b	1	* filtterin tila

keyfilechecked	rs.b	1	* ~0: keyfile tarkistettu

songnumber	rs	1	* modin sis‰isen kappaleen numero
                    * subsong number, first one is 0
maxsongs	rs	1	* maximi songnumber
minsong  	rs 	1   * min songnumber, used some deliplayers


moduleaddress	rs.l	1	* modin osoite
moduleaddress2	rs.l	1	* modin osoite ladattaessa doublebufferingilla
modulelength	rs.l	1	* modin pituus
modulefilename	rs.l	1	* modin tiedoston nimi
solename	rs.l	1	* osoitin pelkk‰‰n tied.nimeen
kanavatvarattu	rs	1	* 0: ei varattu, ei-0: varattu
moduleAddressLoadSeg rs.l 1  * module if loaded with LoadSeg()

;earlymoduleaddress	rs.l	1	*
;earlymodulelength	rs.l	1	*
;earlytfmxsamples	rs.l	1
;earlytfmxsamlen		rs.l	1
;earlylod_tfmx		rs.b	1
;do_early		rs.b	1



oldst		rs.b	1	* 0: pt modi, ~0: old soundtracker modi
sidflag		rs.b	1	* songnumberin muuttamiseen
* Set to true if the last loaded module is a remote module.
* Path is in "modulefilename" as usual.
lastLoadedModuleWasRemote    rs.b    1

kelausnappi	rs.b	1	* 0: jos ei cia kelausta
kelausvauhti	rs.b	1	* 1: 2x, 2: 4x
do_early	rs.b	1


externalplayers	rs.l	1	* ulkoisen soittorutiininivaskan osoite

external	rs.b	1	* lippu: tarvitaan xplayeri
			rs.b 	1	* pad
xtype		rs.w	1	* ladatun replayerin tyyppi
xplayer		rs.l	1	* osote
xlen		rs.l	1	* pakattupituus

ps3msettingsfile rs.l	1	* ps3m settings filen osoite
;;calibrationaddr	 rs.l	1	* CyberSound 14-bit calibration table

sampleroutines	rs.l	0
aonroutines	rs.l	0
thxroutines	rs.l	0
digiboosterroutines rs.l 0
digiboosterproroutines rs.l 0
hippelcosoroutines rs.l	0
ps3mroutines	rs.l	0
oktaroutines	rs.l	0
bpsmroutines	rs.l	0
fc14routines	rs.l	0
fc10routines	rs.l	0
jamroutines	rs.l	0
p60routines	rs.l	0
pumatrackerroutines 	rs.l 0
gamemusiccreatorroutines rs.l 0
digitalmugicianroutines	rs.l 0
medleyroutines rs.l 0
futureplayerroutines rs.l 0
daveloweroutines	rs.l 	0
bendaglishroutines	rs.l	0
sidmon2routines 	rs.l 	0
deltamusic1routines rs.l 	0
soundfxroutines	rs.l	0
gluemonroutines	rs.l	0
pretrackerroutines rs.l	0
custommaderoutines rs.l 0
startrekkerroutines rs.l 0
voodooroutines	rs.l	0
sonicroutines	rs.l	0
tfmxroutines	rs.l	0
xmaplayroutines rs.l    0
tfmx7routines	rs.l	1	* Soittorutiini purettuna (TFMX 7ch)
player60samples	rs.l	1	* P60A:n samplejen osoite
startrekkerdataaddr rs.l 0
tfmxsamplesaddr	rs.l	1	* TFMX:n samplejen osoite
startrekkerdatalen rs.l 0
tfmxsampleslen	rs.l	1	* TFMX:n samplejen pituus
medrelocced	rs.b	1	* ei-0: Med-modi relocatoitu
medtype		rs.b	1	* 0: 1-4, 1: 5-8, 2: 1-64

ps3m_mname	rs.l	1	* ps3m:n informaation v‰lityst‰ varten
ps3m_numchans	rs.l	1
ps3m_mtype	rs.l	1
ps3m_samples	rs.l	1
ps3m_xm_insts	rs.l	1
ps3m_buff1	rs.l	1
ps3m_buff2	rs.l	1
ps3m_mixingperiod rs.l	1
ps3m_playpos	rs.l	1
ps3m_buffSizeMask rs.l	1
ps3mUnpackedPattern rs.l 1

* Scopes usign PS3M as source data (or faked PS3M)
* modulo. This is always 1 unless PSID+reSID+AHI is active.
ps3m_sampleDataModulo   rs.l    1


ahi_use_new		rs.b	1
ahi_muutpois_new	rs.b	1
ahi_rate_new		rs.l	1
ahi_ratepot_new		rs	1
ahi_mastervol_new	rs	1
ahi_mastervolpot_new	rs	1
ahi_mode_new		rs.l	1
ahi_stereolev_new	rs	1
ahi_stereolevpot_new	rs	1
ahi_name_new		rs.b	44


* file list header, Minimal List Header
moduleListHeader	rs.b	MLH_SIZE	* tiedostolistan headeri
filelistaddr	rs.l	1		* REQToolsin tiedostolistan osoite

loading		rs.b	1		* ~0: lataus meneill‰‰n
loading2	rs.b	1		* ~0: filejen addaus meneill‰‰n
* List of favorite modules
favoriteListHeader	rs.b 	MLH_SIZE
* Flag indicates the list has changed before last save
favoriteListChanged	rs.b	1
windowClosedViaScreenNotify			rs.b	1	

* List for file browser
fileBrowserListHeader	rs.b	MLH_SIZE
* List for search results
searchResultsListHeader rs.b	MLH_SIZE

** InfoWindow kamaa
;infosample	rs.l	1		* samplesoittajan v‰liaikaisalue
swindowbase	rs.l	1
suserport	rs.l	1
srastport	rs.l	1
ssliderold	rs.l	1
sfirstname	rs	1
sfirstname2	rs	1
riviamount	rs	1
oldswinsiz	rs	1
oldsgadsiz	rs	1
skokonaan	rs.b	1
		rs.b	1

******* LoadDatan muuttujia
lod_a			rs.b	0
lod_address		rs.l	1
lod_length		rs.l	1
lod_filename		rs.l	1
lod_memtype		rs.l	1
lod_start		rs.l	1
lod_len			rs.l	1
lod_filehandle		rs.l	1
lod_error		rs	1
lod_xpkerror		rs	1
lod_xfderror		rs	1
lod_archive		rs.b	1	 * 0: ei archive, <>0: archive
lod_tfmx		rs.b	1
lod_pad			rs.b	1
lod_kommentti		rs.b	1	 * 0: ei oteta kommenttia
lod_xpkfile		rs.b	1	 * <>0: tiedosto oli xpk-pakattu
lod_exefile__	rs.b	1	 * <>0: file was an exe		
lod_dirlock		rs.l	1
lod_xpkOutLen   rs.l    1
lod_buf			rs.b	200
lod_b			rs.b	0

newdirectory	rs.b	1
newdirectory2	rs.b	1

prefsdata	rs.b	prefs_size	* Prefs-tiedosto
startup		= prefsdata+prefs_startup
fkeys		= prefsdata+prefs_fkeys
groupname	= prefsdata+prefs_groupname

ahi_rate	= prefsdata+prefs_ahi_rate
ahi_mastervol	= prefsdata+prefs_ahi_mastervol
ahi_stereolev	= prefsdata+prefs_ahi_stereolev
ahi_mode	= prefsdata+prefs_ahi_mode
ahi_name	= prefsdata+prefs_ahi_name
ahi_use		= prefsdata+prefs_ahi_use
ahi_muutpois	= prefsdata+prefs_ahi_muutpois
ahi_use_nyt	rs.b	1
favorites	rs.b	1
tooltips	rs.b  	1
savestate	rs.b    1
altbuttons  rs.b    1
autosort	= prefsdata+prefs_autosort

* Runtime scope settings
quadraScope   rs.b 1
quadraScopeBars   rs.b 1
quadraScopeF   rs.b 1
quadraScopeFBars   rs.b 1
hippoScope   rs.b 1
hippoScopeBars   rs.b 1
patternScope   rs.b 1
patternScopeXL   rs.b 1
spectrumScope   rs.b 1
spectrumScopeBars   rs.b 1
                rs.b    1 * PADDING
                 
* audio homman muuttujat
acou_deviceerr	rs.l	1
iorequest	rs.b	ioa_SIZEOF
audioport	rs.b	MP_SIZE

* input devicen muuttujat
idopen		rs.l	1
iorequest2	rs.b	IO_SIZE
idmsgport	rs.b	MP_SIZE
intstr		rs.b	IS_SIZE
rawkeyinput	rs	1		* rawkoodi

******* Viestiportti
omaviesti0	rs.l	1		* Porttiin saapunut viesti

hippoport	rs.b	HippoPort_SIZEOF

poptofrontr	rs.l	1		* rutiini esiinpullauttamiseksi
newcommand	rs.l	1		* osoitin uuteen komentoon
*******

********* ARexx
rexxport	rs.b	MP_SIZE
rexxmsg		rs.l	1
rexxon		rs.b	1		* ~0: ARexx aktivoitu!
keycheck	rs.b	1		* keyfile checkki. 0=oikea keyfile
rexxresult	rs.l	1		* argstringi

********

wintitl		rs.b	80
wintitl2	rs.b	80

tfmx_L0000DC	rs.l	1		* TFMX:n dataa
tfmx_L0000E0	rs.l	1
tfmx_L0000E4	rs.l	1
tfmx_L0000E8	rs.l	1
tfmx_L0000EC	rs.l	1
sidheader	rs.b	sidh_sizeof

 
moduledir	= prefsdata+prefs_moddir * modulehakemisto
prgdir		= prefsdata+prefs_prgdir * prghakemisto
arcdir		= prefsdata+prefs_arcdir
arclha		= prefsdata+prefs_arclha * pakkerit
arczip		= prefsdata+prefs_arczip
arclzx		= prefsdata+prefs_arclzx
pattern		= prefsdata+prefs_pattern
pubscreen	= prefsdata+prefs_pubscreen  * name for the selected pubscreen
nastyaudio	= prefsdata+prefs_nasty
doublebuf	= prefsdata+prefs_dbf
calibrationfile = prefsdata+prefs_calibrationfile

* Final pubscreen name that is referred to with
; RT_PubScrName (requesters) and WA_PubScreenName (windows)
pubScreenNameTags	rs.b	MAXPUBSCREENNAME+1

tokenizedpattern	rs.b	70*2+2

newpubscreen	rs.b	1   * value of newpubscreen2 on Prefs exit, 
                            * set to null when windows have been moved 
newpubscreen2	rs.b	1   * set in Prefs if pubscreen is selected


deleteflag	rs.b	1	* filen ja dividerin deletointiin

* teksti: "Registered to "
	
;regtext		rs.b	14-1
;	rs.b	1
keycode		rs.b	1		* 33
keyfile		rs.b	64		* keyfile!

INFO_MODULE_NAME_LEN = 128
modulename	rs.b 	INFO_MODULE_NAME_LEN+2 * moduulin nimi
moduletype	rs.b	40		* tyyppi tekstin‰
req_array	rs.b	0		* reqtoolsin muotoiluparametrit
desbuf		rs.b	200		* muotoilupuskuri, temporary buffer
desbuf2		rs.b	200		* muotoilupuskuri prefssille
filename	rs.b	108		* tiedoston nimi (reqtools)
filename2	rs.b	108		* Load/Save program-rutiineille
tempdir		rs.b	200		* ReqToolsin hakemistopolku 
PROBE_BUFFER_LEN = 2048
probebuffer	rs.b	PROBE_BUFFER_LEN * tiedoston tutkimispuskuri
ptsonglist	rs.b	64		* Protrackerin songlisti
xpkerror	rs.b	82		* XPK:n virhe (max. 80 merkki‰)
findpattern	rs.b	30		* find pattern
divider		rs.b	26		* divider

omabitmap	rs.b	bm_SIZEOF-7*4	* 1 bitplanea, ei tilaa muille
bitmapHippoHead	rs.b	bm_SIZEOF-6*4	* 2
omabitmap3	rs.b	bm_SIZEOF-7*4	* 1
omabitmap4	rs.b	bm_SIZEOF-6*4	* 2
omabitmap5	rs.b	bm_SIZEOF-6*4	* 2

							* Semaphore to protect access to the data of the module
							* being played.
moduleDataSemaphore		rs.b	SS_SIZE
							* Semaphore to protect access to the module list
moduleListSemaphore 	rs.b 	SS_SIZE

ARGVSLOTS	=	16		* max. parametrej‰
sv_argvArray	rs.l	ARGVSLOTS	* pointers to zero terminated strings
sv_argvBuffer	rs.b	256			* strings are here

randomValueMask  	rs.l		1 * mask to quickly cull too big random numbers based on modamount
randomtable		rs.l		1 * pointer to random table, allocated when needed

* Indicates which mode the list is in, either normal list 
* or favorites, or file browser
LISTMODE_NORMAL		= 0
LISTMODE_FAVORITES 	= 1
LISTMODE_BROWSER	= 2
LISTMODE_SEARCH     = 3
listMode		rs.b	1

* This is set each time list has been edited by user in some way.
moduleListChanged	rs.b		1

kplbase	rs.b	k_sizeof		* KPlayerin muuttujat (ProTracker)

*** Deli support data
deliData	rs.l    1
* Dynamically allocated:
deliBase	rs.l 	1
* LoadSeg() data 
deliPlayer	rs.l	1
* Type of player which was loaded
deliPlayerType	rs.w	1
* Load file array pointer, contains (addr,len) pairs
* Data loaded with dtg_LoadFile
deliLoadFileArray	rs.l 1
deliLoadFileIoErr	rs.l 1
* Some tag data for faster access
deliStoredInterrupt	rs.l	1
deliStoredSetVolume	rs.l 	1
deliStoredSetVoices rs.l	1
deliStoredNoteStruct rs.l 	1
deliStoredGetPositionNr rs.l 1
deliPath		rs.l	1
deliPathArray		rs.l	1
* Pattern info data returned by EP	
deliPatternInfo		rs.l 	1
* UPS_USER struct info returned by EP
deliUPSStruct			rs.l 	1
deliForceAllocPublicMem rs.w    1

* Path read from auto saved modulelist comment,
* which is the last path used to add files to list
lastStoredFileReqDirectory	rs.l 	1

* Stores the selection indexes so that returning to
* parent can select the correct item.
FILEBROWSER_HISTORY_SIZE = 16
fileBrowserSelectionHistoryIndex rs.w 1
fileBrowserSelectionHistory		 rs.l FILEBROWSER_HISTORY_SIZE
* Lock for currently active dir, so that it can 
* be saved to state if needed.
fileBrowserCurrentDirLock		rs.l	1

* Region used to create a clip region for the list box
listBoxRegion		rs.l	1
* Layers library clip region to keep list box text drawing inside,
* useful for variable sized fonts.	
listBoxClipRegion	rs.l	1
* Same stuff for info box at the top
infoBoxRegion		rs.l	1
infoBoxClipRegion	rs.l	1


* String extend structure to configure custom font to string gadgets on kick2.0+
stringExtendStruct 	rs.b	sex_SIZEOF

* Popup list selector memory remember pointer
listSelectorRememberPtr		rs.l	1

;* UHC aminet mirror path, if this is NULL, there's no UHC
;* installed. Should be freed on exit.
;uhcAminetMirrorPath			rs.l	1
uhcAvailable				rs.b	1	
							rs.b	1

infoBoxOrigTopEdge			rs.w	1
infoBoxOrigHeight			rs.w	1
buttonRow1OrigTopEdge		rs.w	1
buttonRow1OrigHeight		rs.w	1
buttonRow2OrigTopEdge		rs.w	1
buttonRow2OrigHeight		rs.w	1
fileBoxOrigTopEdge			rs.w	1	

infoBoxTopEdge			rs.w	1
infoBoxHeight			rs.w	1
buttonRow1TopEdge		rs.w	1
buttonRow1Height		rs.w	1
buttonRow2TopEdge		rs.w	1
buttonRow2Height		rs.w	1
fileBoxTopEdge			rs.w	1	

* Address of the aget file streamer task if active
streamerTask            rs.l    1
* Pointer to the url to stream
streamerUrl             rs.l    1
* Pointer to streamer error data, aget output 
streamerError           rs.l    1
streamerErrorLength     rs.l    1
* Data returned by RDArgs
streamHeaderRDArgs      rs.l    1
* Set to -1 when starting, set to aget return code when aget exists
* Used to detect if stream has finished in certain cases.
streamReturnCode        rs.w    1
* Pointer to local pipe stream config to be used if not doing aget stream
streamLocalConfig          rs.l    1
* Name of the CLI app last used for local streamin
currentLocalStreamCliName  rs.l    1 
* Data sturcture for ReadArgs, specifies the input
streamRDA                  rs.b    RDA_SIZEOF
* Output parsed data from ReadArgs
streamHeaderArray           rs.l       0
streamHeaderContentLength   rs.l       1
streamHeaderContentType     rs.l       1
streamHeaderIcyName         rs.l       1
streamHeaderIcyDescription  rs.l       1
streamHeaderRest            rs.l       1
disableShowStreamerError    rs.b       1

showPositionSlider_new      rs.b       1
showPositionSlider          = prefsdata+prefs_showPositionSlider


* Remote search popup stores the selected search mode here
* SEARCH_MODLAND etc etc
selectedSearch = prefsdata+prefs_selectedSearch

mhiEnable      = prefsdata+prefs_mhiEnable
mhiLib         = prefsdata+prefs_mhiLib
* 0 = not used, 1 = normal mode, 2 = interpolated mode
ps3mamigus     = prefsdata+prefs_ps3mamigus

* Flags to indicate the bottom search layout state
* Tested with .w!
searchLayoutActive      rs.b    1
localSearchLayoutActive rs.b    1

* This is used to adjust so that the search layout ui gadgets
* fit at the bottom of the window. Normal value is 0.
BOTTOM_MARGIN   rs.w  1

* Keep track of chosen items in different lists so it can
* be rechosen when coming back to the view
normalModeChosenModule      rs.l    1
favoritesModeChosenModule   rs.l    1
fileBrowserChosenModule     rs.l    1
searchResultsChosenModule   rs.l    1

* Store here the status of the last recent playlists search.
* This can be used to not force refresh the recent playlist contents
* if there are no results
recentPlaylistsLastSearchFailed  rs.b    1
                                 rs.b    1 * pad

* HVSC STIL and Songlengths support
stilIndexPtr         rs.l    1 * Index
slIndexPtr           rs.l    1 * Index and data for everything
sidSongLengthData    rs.l    1 * Data for the current song
slLoadAttempted      rs.b    1 * Used to prevent failing many times
slEndDetect          rs.b    1 * End detected based on SL data

* VGM TNT
tntPSG1Core		rs.l	1
vgmDataStart    rs.l    1
vgmDataCurrent	rs.l	1
vgmDataEnd      rs.l    1
vgmSampleCount  rs.l    1
vgmTime         rs.l    1 * VGM time in 44100 Hz ticks
vgmPlayTime     rs.l    1 * Host playback time in 44100 Hz ticks

* SID wave scope
sid_followPositions rs.w    4
sid_followFractions rs.w    4

* Audacious-UADE songlength data, metadata
uslMD5          rs.b      6   * Loaded module 48-bit MD5 sum
uslIndexPtr     rs.l      1   * Pointer to songlength DB index
uslDataPtr      rs.l      1   * Pointer to current DB block
uslSongLengthData rs.w    16  * SL data for the current module, max 16 songs
umeIndexPtr     rs.l      1   * Pointer to metadata DB index
umeDataPtr      rs.l      1   * Pointer to current DB block
umeMetaDataPtr  rs.l      1   * Ptr to metadata strings

* Info text scroller
infoScrollPos       rs.w      1 
infoScrollWaitTicks rs.w      1 * ticks to wait before scrolling
infoScrollMoveTicks rs.w      1
infoScrollLineHeight rs.w     1
infoScrollLength    rs.w      1 * pixels, height
infoScrollBitplane  rs.l      1
infoScrollBitplaneW rs.w      1
infoScrollBitplaneH rs.w      1
infoScrollEnabled   rs.b      1
infoScrollSmall     rs.b      1 * set if all text fits 
infoScrollBitMap    rs.b      bm_SIZEOF-7*4 * for 1 bpl

 if DEBUG
debugDesBuf		rs.b	1000
 endif

* Size of global variables data. Must be even.
size_var	rs.b	0

	ifne	size_var&1
	fail
	endc


*********************************************************************************
*
* Playerbasen rakenne
*
	rsreset
p_init		rs.l	1
p_ciaroutine	rs.l	0
p_play		rs.l	1
p_vblankroutine	rs.l	1
p_end		rs.l	1
p_stop		rs.l	1
p_cont		rs.l	1
p_volume	rs.l	1
p_song		rs.l	1
p_eteen		rs.l	1
p_taakse	rs.l	1
p_ahiupdate	rs.l	1
p_id  		rs.l 	1
p_author	rs.l 	1
p_type 		rs.w    1
p_liput		rs	1	* ominaisuudet
p_name		rs.l	1

p_NOP macro 
	dc.l	$4e754e75
	endm

 if pt_prot<>33 
   fail This must be 33
 endc 
 if pt_multi<>49
   fail This must be 49
 endc 

* player group version
xpl_versio	=	33


*********************************************************************************
*
* Tiedostolistan yhden yksikˆn rakenne
* Mudule list node element
*

	rsreset
		rs.b	MLN_SIZE	* Minimal node 
l_nameaddr	rs.l	1		* osoitin pelkk‰‰n tied.nimeen
					* address to filename without path
l_favorite	rs.b 	1		* 0: not favorite, non-zero: favorite
l_divider	rs.b	1		* this is a divider, ie. a path
                            * 00: not divider
                            * f0: stealthy divider
                            * ff: ordinary divider
                            * 7f: "parent folder" in file browser
l_remote	rs.b    1       * 0: local file, non-zero: remote
l_favSong   rs.b    1       * 0 or song number when node was favorited
l_separateName rs.b 1       * set if l_nameaddr points to "#name=<name>""
l_filename	rs.b	0		* tied.nimi ja polku alkaa t‰st‰
					* full path to filename begins at this point
					* element size is dynamically calculated based on path length.
l_size		rs.b	0


*********************************************************************************
*
* Soittomoodit
*

* Repeat list 
pm_repeat	=	1
* Play list once
pm_through	=	2
* Repeat module
pm_repeatmodule	=	3
* Play module once
pm_module	=	4
* Random play 
pm_random	=	5
pm_max		=	5


*********************************************************************************
*
* Soittorutiinin ominaisuusliput
*

pb_cont		=	0
pb_stop		=	1
pb_song		=	2
pb_kelauseteen	=	3
pb_kelaustaakse =	4
pb_volume	=	5
pb_ciakelaus	=	6		* 2x = lmb, 4x = rmb
pb_ciakelaus2	=	7		* pattern = lmb, 2x = rmb
pb_end		=	14
pb_poslen	=	15
pb_scope	=	13	; Replayer supports patternscope or quadscope
pb_ahi		=	12
pb_quadscopePoke =      11      ; Normal quadscope or EP poke interface
pb_quadscopeUps	=  	10	; EP UPS interface
pb_slidePos =   9    ; Position slider support
pf_cont		=	1<<pb_cont
pf_stop		=	1<<pb_stop
pf_song		=	1<<pb_song
pf_kelauseteen	=	1<<pb_kelauseteen
pf_kelaustaakse	=	1<<pb_kelaustaakse
pf_kelaus	=	pf_kelauseteen!pf_kelaustaakse
pf_volume	=	1<<pb_volume
pf_ciakelaus	=	1<<pb_ciakelaus!1<<pb_kelauseteen
pf_ciakelaus2	=	1<<pb_ciakelaus2!1<<pb_kelauseteen
pf_end		=	1<<pb_end
pf_poslen	=	1<<pb_poslen
pf_scope	=	1<<pb_scope
pf_ahi		=	1<<pb_ahi
pf_quadscopeUps	=	1<<pb_quadscopeUps
pf_quadscopePoke =	1<<pb_quadscopePoke
pf_slidePos =   1<<pb_slidePos

*********************************************************************************
*
* PS3M:n moodit
*

sm_surround	=	1
sm_stereo	=	2
sm_mono		=	3
sm_real		=	4
sm_stereo14	=	5


*********************************************************************************
*
* P‰‰- ja prefsikkunan liput
*

wflags set WFLG_ACTIVATE!WFLG_DRAGBAR!WFLG_CLOSEGADGET!WFLG_DEPTHGADGET
wflags set wflags!WFLG_SMART_REFRESH!WFLG_RMBTRAP!WFLG_REPORTMOUSE
idcmpflags set IDCMP_GADGETUP!IDCMP_MOUSEBUTTONS!IDCMP_CLOSEWINDOW
idcmpflags set idcmpflags!IDCMP_MOUSEMOVE!IDCMP_RAWKEY
idcmpflags set idcmpflags!IDCMP_ACTIVEWINDOW!IDCMP_INACTIVEWINDOW
idcmpflags set idcmpflags!IDCMP_NEWSIZE


wflags2	set WFLG_ACTIVATE!WFLG_DRAGBAR!WFLG_CLOSEGADGET!WFLG_DEPTHGADGET
wflags2 set wflags2!WFLG_SMART_REFRESH!WFLG_RMBTRAP
idcmpflags2 set IDCMP_GADGETUP!IDCMP_CLOSEWINDOW!IDCMP_MOUSEMOVE
idcmpflags2 set idcmpflags2!IDCMP_MOUSEBUTTONS!IDCMP_RAWKEY

*********************************************************************************
*
* Debug macros
*

* Print to debug console
DEBU	macro
	ifne	DEBUG
	pea	\1
	jsr	PRINTOUT
	endc
	endm

* Print to debug console, very clever.
* Param 1: string
* d0-d6:    formatting parameters, d7 is reserved
DPRINT macro
	ifne DEBUG
	jsr	desmsgDebugAndPrint
  dc.b 	\1,10,0
  even
	endc
	endm


* delay
DDELAY macro
	ifne DEBUG
	pushm	all
	move.l	#\1*50,d1
	lore	Dos,Delay
	popm	all
	endc
	endm


; Macro to check the gadget GFLG_DISABLED flag
; GLFG_DISABLED = $0100
skipIfGadgetDisabled macro
	btst	#0,gg_Flags+\1
	beq.b	*+4
	rts
	endm

*********************************************************************************
*
* Start up from CLI or Workbench
* - Handles command line parameters,
* - setting up a new process (detachment),
* - Workbench message,
* - Passing parameters to already existing hippo instance.
* - Can't be used when running from AsmOne.
*

 ifeq asm

	section	detach,code_p

progstart
	lea	var_b,a5
	move.l	a0,d6
	move.l	d0,d7

	move.l	4.w,a6
	move.l	a6,(a5)
	lea	dosname,a1
	lob	OldOpenLibrary
	move.l	d0,a4
	move.l	d0,_DosBase(a5)

	sub.l	a1,a1
	lob	FindTask
	move.l	d0,a3

	moveq	#0,d5
	tst.l	pr_CLI(a3)	* ajettiinko WB:st‰
	bne.b	.nowb
	lea	pr_MsgPort(a3),a0
	lob	WaitPort
	lea	pr_MsgPort(a3),a0
	lob	GetMsg
	move.l	d0,d5
	move.l	d0,a0
	move.l  sm_NumArgs(a0),d4
	* Get WBArg array:
	move.l	sm_ArgList(a0),d0	* nykyisen hakemiston lukko
	beq.b	.waswb			* workbenchilt‰
	move.l	d0,a1
	move.l	wa_Lock(a1),lockhere(a5)
	DPRINT	"Start from WB"
	bsr	.buildWbStartParams
	bra.b	.waswb
.nowb	
	move.l	pr_CurrentDir(a3),lockhere(a5) * nykyinen hakemisto CLI:lt‰
	DPRINT	"Start from CLI"

	push	a3
	bsr	CLIparms
	pop	a3
.waswb	


	* a3 = current task

	bsr	.getDirInfo
	lea	portname,a1		* joko oli yksi HiP??
	lore	Exec,FindPort
	tst.l	d0
	bne	.poptofront

	* There was no hip already running, launch a new one

    * Or not, if there happens to be QUIT given
    move.l  sv_argvArray+4(a5),d0
    beq     .noParms
    move.l  d0,a0
    jsr     kirjainta4
    cmp.l   #"QUIT",d0
    beq     .eien
.noParms

	move.l	a4,a6			* hankitaan kopio lukosta
	move.l	lockhere(a5),d1
	lob	DupLock
	move.l	d0,lockhere(a5)

	move.l	#procname,d1
	moveq	#0,d2			* prioriteetti
	lea	progstart-4(pc),a0
	move.l	(a0),d3
	move.l	d3,segment(a5)		* seuraavan hunkin pointteri
	clr.l	(a0)
;	move.l	#4000,d4		* stacksize
	move.l	#5000,d4		* stacksize
	move.l	a4,a6
	lob	CreateProc	

.eien	

	* if new HiP was NOT launched close the debug window
 if DEBUG
	tst.l	segment(a5)
	bne.b	.launched
	move.l	output(a5),d1
	beq.b	.out
	move.l	_DosBase(a5),a6
	move.l	#3*50,d1
	lob	Delay
	move.l	output(a5),d1
	beq.b	.out
	lob 	Close
.out
 endif

.launched

	move.l	(a5),a6			* vastataan WB:n viestiin
	tst.l	d5
	beq.b	.nomsg
	lob	Forbid
	move.l	d5,a1
	lob	ReplyMsg
.nomsg
	moveq	#0,d0
	rts

* Get parameters received by launching with project icons
* where the tool is defined to be HiP. Multiple projects
* can be opened simultaneously.
*
* This builds the command line argument array based
* on WBArgs. The CLI arg processing will then handle
* these as if they were entered from CLI.
*
* In:
*   d4 = WBArg parameter count
*   a1 = WBArg array
.buildWbStartParams
	pushm	all

 if DEBUG
 	move.l	d4,d0
 	DPRINT	"sm_NumArgs=%ld"
 endif

	* Pointers to strings
	lea	sv_argvArray(a5),a2
	* Strings
	lea	sv_argvBuffer(a5),a4
	* Temporary buffer:
	lea	ptheader,a3
.wbArgLoop
	* Null term it for safety
	clr.b	(a3)
	move.l	wa_Name(a1),d0
	move.l	wa_Lock(a1),d1
 if DEBUG
	DPRINT	"wa_Name=%s wa_Lock=%lx"
	tst.l	d1
 endif
	beq.b	.nullLock
	move.l	a3,d2
	move.l	#200,d3
	jsr	getNameFromLock
	tst.l	d0
	* Skip if errors
	beq.b	.stop
.nullLock
	* Store string ptr
	move.l	a4,(a2)+
	* Copy path based on lock
	move.l	a3,a0
	tst.b	(a0)
	beq.b	.emptyPath
.copyPath1
	move.b	(a0)+,(a4)+
	bne.b	.copyPath1
	subq	#1,a4
	cmp.b	#':',-1(a4)
	beq.b	.noSep
	move.b	#'/',(a4)+
.emptyPath
.noSep
	* Copy filename
	move.l	wa_Name(a1),a0
.copyName1
	move.b	(a0)+,(a4)+
	bne.b	.copyName1

 if DEBUG
	move.l	-4(a2),d0
	DPRINT	"-->%s"
 endif
	addq	#wa_SIZEOF,a1
	subq	#1,d4
	bne.b	.wbArgLoop
.stop
	popm	all
	rts

* in:
*  a3 = current task
*  a6 = exec
.getDirInfo 
	cmp	#36,LIB_VERSION(a6)
	blo.b	.noo	
	move.l 	pr_HomeDir(a3),d1
	beq.b	.noo
	lore	Dos,DupLock
	move.l	d0,homelock(a5)
.noo

 if DEBUG
	move.l 	lockhere(a5),d1
	move.l	#ptheader,d2
	moveq	#100,d3 
	jsr	getNameFromLock
	move.l	#ptheader,d0
	DPRINT	"Current dir: %s"
	move.l 	homelock(a5),d1
	beq.b	.ooold
	move.l	#ptheader,d2
	moveq	#100,d3 
	jsr	getNameFromLock
	move.l	#ptheader,d0
	DPRINT	"Home dir: %s"
.ooold
 endif 
	rts

.poptofront
	tst.l	sv_argvArray+4(a5)	* oliko parametrej‰?
	bne.b	.huh			* jos ei, pullautetaan hip!

	move.l	d0,a0
	move.l	poptofrontr-hippoport(a0),a0	* pullautusrutiini
	jsr	(a0)								* what is this evil magic?
	bra	.eien

* Oli! L‰hetet‰‰n hipille!
.huh
	* Let us send a message to an already existing hippo with command line marguments passed
	* here.

	move.l	d0,a3			* p‰‰ll‰olevan hipin portti

	sub.l	a1,a1
	lore	Exec,FindTask
	move.l	d0,owntask(a5)

	jsr	createport0		* luodaan oma portti!

	* Use this buffer to construct a Message structure
	lea	desbuf(a5),a0		* portti desbufiin
	NEWLIST	a0

	move.l	a3,a0			* kohdeportti
	lea	desbuf(a5),a1		* viesti

	;pushpea	sv_argvArray(a5),MN_LENGTH(a1) * uudet parametrit viestiin
	;move.l	#"K-P!",MN_LENGTH+4(a1) * tunnistin!

	bsr.b	.preparePaths

 if DEBUG
	push	a0
	lea	sv_argvArray(a5),a0
	moveq	#0,d0
.bob
	tst.l	(a0)
	beq.b	.bob2
	move.l	(a0)+,d1
	DPRINT	"%ld: %s"
	addq	#1,d0
	bra.b	.bob
.bob2
	pop 	a0
 endif

	move.l	#MESSAGE_MAGIC_ID,HM_Identifier(a1) 			* magic identifier
	pushpea	sv_argvArray(a5),HM_Arguments(a1) 		  * cmdline parameter array
	* MN_SIZE is left unset
	pushpea	hippoport(a5),MN_REPLYPORT(a1)	* t‰h‰n porttiin vastaus
	lob	PutMsg

	lea	hippoport(a5),a0	* odotellaan vastausta
	lob	WaitPort

	jsr	deleteport0

	bra	.eien

* This checks the command line parameters and adds a fully qualified path 
* to filenames if possible. Uses V36 DOS functions as it would be quite
* painful, yet still doable, otherwise.
.preparePaths
	pushm	all
	;move.l	(a5),a0
	;cmp	#34,LIB_VERSION(a0)	
	;ble.b	.done			* Kickstart 1.3 or earlier? GETOUTTAHERE
	
	* Grab the prepared arguments array
	lea	sv_argvArray(a5),a3
	* Construct any new path strings here, plenty of space
	lea	probebuffer(a5),a4
.loop
	* Take one and see if it was the last one
	move.l	(a3),d3
	beq.b	.done

	* See if it was one of the four letter commands
	move.l	d3,a0 
	jsr		kirjainta4
* skip commands
	cmp.l	#MESSAGE_COMMAND_HIDE,d0
	beq.b	.wasCommand 
	cmp.l	#MESSAGE_COMMAND_QUIT,d0
	beq.b	.wasCommand 
	cmp.l	#MESSAGE_COMMAND_PRG,d0
	beq.b	.wasCommand 
    cmp.l   #"HTTP",d0
    beq     .wasRemote

* consider this a file. let's try to get a lock on it.
	move.l 	d3,d1
	moveq	#ACCESS_READ,d2
	lore  	Dos,Lock
	move.l	d0,d4
	beq.b	.noLock

	* DOS will now provide us with a full path from the lock, conveniently.
	move.l	d4,d1
 	pushpea tempdir(a5),d2  		* this space can be used
 	move.l	#200,d3 
 	jsr	getNameFromLock
	* store return status for a little while so we can UnLock first
	move.l	d0,d3

	move.l	d4,d1
	lob    	UnLock

 	* If something went wrong, skip
 	tst.l	d3
 	beq.b	.error

	* Copy the path to the destination buffer
 	lea	tempdir(a5),a0 
 	move.l	a4,a1
.copy
 	move.b	(a0)+,(a1)+
 	bne.b	.copy
 	* Overwrite arg slot with the new fully qualified path + filename entry
 	move.l	a4,(a3)
 	* Temp buffer position to hold the next possible path+filename
 	move.l	a1,a4

.wasRemote
.wasCommand
.noLock
.error
	* go to next argv slot
	addq.l	#4,a3
	bra.b	.loop
.done 
	popm	all
	rts

CLIparms
;=======================================================================
;====== CLI Startup Code ===============================================
;=======================================================================
;       d0  process CLI BPTR (passed in), then temporary
;       d2  dos command length (passed in)
;       d3  argument count
;       a0  temporary
;       a1  argv buffer
;       a2  dos command buffer (passed in)
;       a3  argv array
*       a4  Task (passed in)
*       a5  SVar structure if not QARG (passed in)
*       a6  AbsExecBase (passed in)
*       sp  WBenchMsg (still 0), sVar or 0, then RetAddr (passed in)
*       sp  argc, argv, WBenchMsg, sVar or 0,RetAddr (at bra domain)

	move.l	172(a3),d0			* pr_CLI
	move.l	d7,d2
	move.l	d6,a2

        ;------ find command name
                lsl.l   #2,d0           ; pr_CLI bcpl pointer conversion
                move.l  d0,a0
                move.l  cli_CommandName(a0),d0
                lsl.l   #2,d0           ; bcpl pointer conversion

                ;-- start argv array
                lea     sv_argvBuffer(a5),a1
                lea     sv_argvArray(a5),a3

                ;-- copy command name
                move.l  d0,a0
                moveq.l #0,d0
                move.b  (a0)+,d0        ; size of command name
                clr.b   0(a0,d0.l)      ; terminate the command name
                move.l  a0,(a3)+
                moveq   #1,d3           ; start counting arguments

        ;------ null terminate the arguments, eat trailing control characters
                lea     0(a2,d2.l),a0
stripjunk:
                cmp.b   #' ',-(a0)
                dbhi    d2,stripjunk

                clr.b   1(a0)

        ;------ start gathering arguments into buffer
newarg:
                ;-- skip spaces
                move.b  (a2)+,d1
                beq.s   parmExit
                cmp.b   #' ',d1
                beq.s   newarg
                cmp.b   #9,d1           ; tab
                beq.s   newarg

                ;-- check for argument count verflow
                cmp.w   #ARGVSLOTS-1,d3
                beq.s   parmExit

                ;-- push address of the next parameter
                move.l  a1,(a3)+
                addq.w  #1,d3

                ;-- process quotes
                cmp.b   #'"',d1
                beq.s   doquote

                ;-- copy the parameter in
                move.b  d1,(a1)+

nextchar:
                ;------ null termination check
                move.b  (a2)+,d1
                beq.s   parmExit
                cmp.b   #' ',d1
                beq.s   endarg

                move.b  d1,(a1)+
                bra.s   nextchar

endarg:
                clr.b   (a1)+
                bra.s   newarg

doquote:
        ;------ process quoted strings
                move.b  (a2)+,d1
                beq.s   parmExit
                cmp.b   #'"',d1
                beq.s   endarg

                ;-- '*' is the BCPL escape character
                cmp.b   #'*',d1
                bne.s   addquotechar

                move.b  (a2)+,d1
                move.b  d1,d2
                and.b   #$df,d2         ;d2 is temp toupper'd d1

                cmp.b   #'N',d2         ;check for dos newline char
                bne.s   checkEscape

                ;--     got a *N -- turn into a newline
                moveq   #10,d1
                bra.s   addquotechar

checkEscape:
                cmp.b   #'E',d2
                bne.s   addquotechar

                ;--     got a *E -- turn into a escape
                moveq   #27,d1

addquotechar:
                move.b  d1,(a1)+
                bra.s   doquote

parmExit:
        ;------ all done -- null terminate the arguments
                clr.b   (a1)
                clr.l   (a3)

	rts



 endc
 

*********************************************************************************
*
* Main program section
*

	section	refridgerator,code

* Correctly aligned fake segments for new processes. 
* Addresses must be divisible by 4.
* These are user for CreateProc() calls.

main0	jmp	main(pc)

	cnop 0,4
	dc.l	16
filereq_segment
	dc.l	0
	jmp	filereq_code(pc)

	cnop 0,4
	dc.l	16
prefs_segment
	dc.l	0
	jmp	prefs_code(pc)

	cnop 0,4
	dc.l	16
info_segment
	dc.l	0
	jmp	info_code

	dc	0 * pad


;	dc.l	16
;quad_segment
;	dc.l	0
;	jmp	quad_code

;	dc	0	* pad


 ifne DEBUG
PRINTOUT_DEBUGBUFFER
	pea	debugDesBuf+var_b 
	bsr.b PRINTOUT
	rts

PRINTOUT
	pushm	d0-d3/a0/a1/a5/a6
	lea	var_b,a5
	move.l	output(a5),d1
	bne.b	.open

	* try tall window firsr
	move.l	#.bmb,d1
	move.l	#MODE_NEWFILE,d2
	lore	Dos,Open
	move.l	d0,output(a5)
	bne.b	.open
	* smaller next
	move.l	#.bmbSmall,d1
	move.l	#MODE_NEWFILE,d2
	lob	Open
	move.l	d0,output(a5)
	bne.b	.open
	* still not open! exit
	bra.b	.x

.bmb	dc.b	"CON:0/0/350/500/HiP debug",0
.bmbSmall
	dc.b	"CON:0/0/350/200/HiP debug",0
    even
.open
	move.l	32+4(sp),a0

	moveq	#0,d3
	move.l	a0,d2
.p	addq	#1,d3
	tst.b	(a0)+
	bne.b	.p
 	lore	Dos,Write
.x	popm	d0-d3/a0/a1/a5/a6
	move.l	(sp)+,(sp)
	rts
 endc

 ifne DEBUG
getmemCount 	dc.l	0
freememCount	dc.l	0
getmemTotal		dc.l	0
 endc


intuiname	dc.b	"intuition.library",0
gfxname		dc.b	"graphics.library",0
dosname		dc.b	"dos.library",0
reqname		dc.b	"reqtools.library",0
wbname		dc.b	"workbench.library",0
diskfontname	dc.b	"diskfont.library",0
rexxname	dc.b	"rexxsyslib.library",0
scrnotifyname	dc.b	"screennotify.library",0
idname		dc.b	"input.device",0
nilname		dc.b	"NIL:",0
portname	dc.b	"HiP-Port",0
fileprocname	dc.b	"HiP-Filereq",0
prefsprocname	dc.b	"HiP-Prefs",0
infoprocname	dc.b	"HiP-Info",0
layersName	dc.b	"layers.library",0
expansionName dc.b	"expansion.library",0
tntName     dc.b    "trinity.library",0
cianame	dc.b	"ciaa.resource",0
timerDeviceName dc.b	"timer.device",0

CHECKSTART
CHECKSUM	=	43647

procname	
reqtitle
windowname1
	dc.b	"HippoPlayer",0

about_tt
 
 dc.b "This program is registered to          ",10,3
 dc.b "%39s",10,3
 dc.b "≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠",10,3
 dc.b " List has %5ld files,  %5ld dividers ",10,3
 dc.b 0


;scrtit	dc.b	"HippoPlayer - Copyright © 1994-2021 K-P Koljonen",0
scrtit	dc.b	"HippoPlayer"
	dc.b	" by K-P in 1994-2000, 2021-2025",0
	dc.b	"$VER: "
banner_t
	dc.b	"HippoPlayer "
versionStringStart
	ver
versionStringEnd
	dc.b	10,"Programmed by K-P Koljonen",0

regtext_t dc.b	"Registered to",0
no_one	 dc.b	"   no-one",0


about_t
 dc.b "≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠",10,3
 dc.b "≠≠≠  HippoPlayer "
 ver
 dc.b "  " ; padding
 dc.b " ≠≠≠",10,3
 dc.b "≠≠          by K-P Koljonen          ≠≠",10,3
 dc.b "≠≠≠       Hippopotamus Design       ≠≠≠",10,3
 dc.b "≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠",10,3

about_t1
 dc.b "    This program is not registered!    ",10,3
 dc.b "You should register to support quality ",10,3
 dc.b "    software and to reward the poor    ",10,3
 dc.b "       author from his hard work.      ",10,3
  
 dc.b "≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠",10,3
 dc.b " HippoPlayer can be freely distributed",10,3
 dc.b " as long as all the files are included",10,3
 dc.b "   unaltered. Not for commercial use",10,3
 dc.b " without a permission from the author.",10,3
 dc.b " Copyright © 1994-2025 by K-P Koljonen",10,3
 dc.b "           *** FREEWARE ***",10,3
 dc.b "≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠",10,3
 dc.b "E-mail:     kpk@iki.fi",10,3
 dc.b "≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠",10,3
 dc.b "    Hippopothamos the river-horse",10,3
 dc.b "    Hippopotamus  amphibius:   a  large",10,3
 dc.b "herbivorous   mammal,  having  a  thick",10,3
 dc.b "hairless  body, short legs, and a large",10,3
 dc.b "head and muzzle.",10,3
 dc.b "    Hippopotami  live in the rivers and",10,3
 dc.b "lakes  of  Africa.  A hippo weighs 2500",10,3
 dc.b "kilos, is 140-160 cm high and 4 m long.",10,3
 dc.b "Hippos  form  herds  of 30 individuals.",10,3
 dc.b "They  are  good swimmers and divers and",10,3
 dc.b "can  stay  under water for six minutes.",10,3
 dc.b "In  the  daytime they lie on the shores",10,3
 dc.b "of  small  islands  or rest in water so",10,3
 dc.b "that  only  their eyes and nostrils can",10,3
 dc.b "be  seen.   With  the  fall of darkness",10,3
 dc.b "they get up from the water and graze on",10,3
 dc.b "the   riverside   walking   along  well",10,3
 dc.b "trampled  paths.   On  a single night a",10,3
 dc.b "hippo   eats   60   kilos   of   grass,",10,3
 dc.b "waterplants and fruit.",10,3
 dc.b 0
 dc.b $ff
 even


 ifne asm
flash	
.p	move	$dff006,$dff180
	btst	#6,$bfe001
	bne.b	.p
	rts
 endc

*
* Main program entry point
*
main:
	* Global variables are in a5
	lea	var_b,a5
	move.l	4.w,a6
	* Exec is accessed a lot so it's shortest to get it from offset 0.
	move.l	a6,(a5)
	* Copy of exec for use in level1 software interrupt
	move.l	a6,exeksi

    clr     BOTTOM_MARGIN(a5)   
    
	sub.l	a1,a1
	lob	FindTask
	move.l	d0,owntask(a5)

	* Prepare a semaphore for module data access
	lea	moduleDataSemaphore(a5),a0
	lob	InitSemaphore

	* Prepare a semaphore for module list access, which is a linked list
	lea	moduleListSemaphore(a5),a0
	lob	InitSemaphore

	not.l	idopen(a5)		* -1 = input.devide ei avattu

;	move	#0,pen_0+2(a5)		* kick2.0+ v‰rit
	clr	pen_0+2(a5)
	move	#1,pen_1+2(a5)
	move	#2,pen_2+2(a5)
	move	#3,pen_3+2(a5)
	move.b	#33,keycode(a5)		* keycode

	pushpea	poptofront(pc),poptofrontr(a5)

	move	#264,WINSIZX(a5)
	* This includes 8 lines of 8-pixel height rows
	move	#136,WINSIZY(a5)
	move	WINSIZX(a5),wsizex
	move	WINSIZY(a5),wsizey


	cmp	#34,LIB_VERSION(a6)		* v‰rit kickstartin mukaan
	ble.b	.vanha
	st	uusikick(a5)		* Uusi kickstart

	* Set homedir for this task, kick2.0+
	* Assume hat pr_HomeDir gets unlocked by os.
 ifeq asm	
	move.l	owntask(a5),a3 
	tst.l 	pr_HomeDir(a3) 
	bne.b 	.hasHome 
	move.l	homelock(a5),d1 
	lore	Dos,DupLock
	move.l	d0,pr_HomeDir(a3)
.hasHome
 endif

	; Set nw_DetailPen and nw_BlockPen
	; nw_DetailPen: prop gadget background, title bar background
	; nw_BlockPen: prop gadget border color, title bar color

	basereg	winstruc,a2
	lea	winstruc,a2
	move	#$0301,d0
;	moveq	#$0001,d0
	move	d0,colors(a2)			* Ikkunoiden v‰rit sen mukaan
	move	d0,colors2(a2)
	move	d0,colors3(a2)

	* Ikkunat avautuu publiscreeneille
	;lea	winstruc,a0	
	move.l	a2,a0
	bsr.b	.boob
	lea	winstruc2(a2),a0
	bsr.b	.boob
	lea	winstruc3(a2),a0
	bsr.b	.boob
	lea	winlistsel(a2),a0
	bsr.b	.boob
	lea	swinstruc(a2),a0
	bsr.b	.boob
	bra.b	.ohib

.boob	move	#PUBLICSCREEN,nw_Type(a0)
	or.l	#WFLG_NW_EXTENDED,nw_Flags(a0)
	rts

.ohib
	* Zipped window width
	move	WINSIZX(a5),windowZippedSize(a5)	* Pienen koko ZipWindowille
	* zipped window height
	move	#11,windowZippedSize+2(a5)

	* Request events for kick2.0+
	* Catch zip window and window resize events
	or.l	#IDCMP_CHANGEWINDOW,idcmpmw(a2)	
.vanha	
	; Above stuff for kick2.0+
	endb	a2

	* Dos has been opened in the startup code
	
 ifeq asm				* uusi nykyinen hakemisto
	move.l	lockhere(a5),d1
	lore	Dos,CurrentDir
 endc

	* In asm mode startup code is skipped
 ifne asm
	lea	dosname(pc),a1
	lore	Exec,OldOpenLibrary
	move.l	d0,_DosBase(a5)
 endc

	lea	intuiname(pc),a1
	lore	Exec,OldOpenLibrary
	move.l	d0,_IntuiBase(a5)

	* The first debug print should be after opening
	* intuition since it may use the alert box.	

	DPRINT	"Hippo is alive"

	tst.b	uusikick(a5)
	beq.b	.olld
	lea	wbname(pc),a1
	lob	OldOpenLibrary
	move.l	d0,_WBBase(a5)
	lea	scrnotifyname(pc),a1
	lob	OldOpenLibrary
	move.l	d0,_ScrNotifyBase(a5)
.olld
	lea	diskfontname(pc),a1
	lob	OldOpenLibrary
	move.l	d0,_DiskFontBase(a5)


	lea 	gfxname(pc),a1		
	lob	OldOpenLibrary
	move.l	d0,_GFXBase(a5)

	lea 	layersName(pc),a1		
	lob	OldOpenLibrary
	move.l	d0,_LayersBase(a5)

	lea 	expansionName(pc),a1		
	lob	OldOpenLibrary
	move.l	d0,_ExpansionBase(a5)

	pushpea	nilname(pc),d1
	move.l	#MODE_OLDFILE,d2
	lore	Dos,Open
	move.l	d0,nilfile(a5)

	lea	cianame(pc),a1
	push	a1
	move.b	#'a',3(a1)
	moveq	#0,d0
	lore	Exec,OpenResource
	move.l	d0,ciabasea(a5)
	pop	a1
	move.b	#'b',3(a1)
	moveq	#0,d0
	lob	OpenResource
	move.l	d0,ciabaseb(a5)

 if DEBUG
	jsr	openTimer
 endif

	* Get the default font for fallback cases, topaz.8
	lea	topaz_text_attr,a0
	move.l	a0,a3
	basereg	topaz_text_attr,a3
	lore	GFX,OpenFont
	move.l	d0,topazbase(a5)	

	pushm	all
	bsr	loadprefs
	bsr	loadps3msettings
	;;bsr	loadcybersoundcalibration
	popm	all



	tst	boxsize(a5)		* jos alkukoko 0 niin laitetaan zoomiks
	bne.b	.nzo			* 8
	move	#8,boxsizez(a5)	
.nzo

* Open fonts


.poh

	* text_attr is now according to loaded prefs
	lea	text_attr(a3),a0	* nyt jo muutettu prefssien mukaan
	tst.l	_DiskFontBase(a5)	* onko libbi‰?
	beq.b	.fontProblem1
	
 if DEBUG
	move.l	ta_Name(a0),d0 
	DPRINT	"Opening main font %s"
 endif 
	lore	DiskFont,OpenDiskFont
	move.l	d0,fontbase(a5)
	bne.b	.mainFontOk
	
.fontProblem1
	; Revert main font to topaz
	DPRINT	"main topaz revert"
	lea	text_attr(a3),a0	
	pushpea	topaz(a3),(a0)+
	move	#8,(a0)+
	clr	(a0)
	lea	topaz_text_attr(a3),a0
	lore	GFX,OpenFont
	move.l	d0,fontbase(a5)

.mainFontOk
	move.l	fontbase(a5),stringExtendStruct+sex_Font(a5)

	* list_text_attr is now according to loaded prefs
	lea	list_text_attr(a3),a0	* nyt jo muutettu prefssien mukaan
	tst.l	_DiskFontBase(a5)	* onko libbi‰?
	beq.b	.fontProblem2
	
 if DEBUG
	move.l	ta_Name(a0),d0 
	DPRINT	"Opening list font %s"
 endif 
	lore	DiskFont,OpenDiskFont
	move.l	d0,listfontbase(a5)
	bne.b	.listFontOk
	
.fontProblem2
	; Revert main font to topaz
	DPRINT	"list topaz revert"

	lea	list_text_attr(a3),a0	
	pushpea	topaz(a3),(a0)+
	move	#8,(a0)+
	clr	(a0)
	lea	topaz_text_attr(a3),a0
	lore	GFX,OpenFont
	move.l	d0,listfontbase(a5)
	DPRINT	"revert topaz"

.listFontOk
	endb	a3
	move.l	listfontbase(a5),a0
	bsr	setListFont

	* Fonts set, some other stuff next

	bsr	createport0
	bsr	createrexxport


	bsr	getsignal
	move.b	d0,songHasEndedSignal(a5)
	bsr	getsignal
	move.b	d0,ownsignal2(a5)
	bsr	getsignal
	move.b	d0,uiRefreshSignal(a5)
	bsr	getsignal
	move.b	d0,posUpdateSignal(a5)
	bsr	getsignal
	move.b	d0,audioPortSignal(a5)
	bsr	getsignal
	move.b	d0,fileReqSignal(a5)
	bsr	getsignal
	move.b	d0,rawKeySignal(a5)
	bsr	getsignal
	move.b	d0,tooltipSignal(a5)

	* Do all kinds of adjustments to gadgets

	lea	sivu0,a0		* Kaikkia pageja 3pix ylˆsp‰in!
	basereg	sivu0,a0

	* Add the "Favorites" prefs button to the end of the
	* list of first page of prefs gadgets
	;move.l	#prefsFavorites,bUu22
	pushpea	prefsFavorites(a0),bUu22(a0)
	* Add "Button tooltips" prefs button to the page 2
	;move.l	#prefsTooltips,eskimO
	pushpea	prefsTooltips(a0),eskimO(a0)
    ; Add sid mode button after the "MED rate" button
    pushpea prefsPlaySidMode(a0),nAMISKA5(a0)
	endb	a0

;	lea	sivu0,a0		* Kaikkia pageja 3pix ylˆsp‰in!
	bsr.b	.hum
	lea	sivu1-sivu0(a0),a0
	bsr.b	.hum
	lea	sivu2-sivu1(a0),a0
	bsr.b	.hum
	lea	sivu3-sivu2(a0),a0
	bsr.b	.hum
	lea	sivu4-sivu3(a0),a0
	bsr.b	.hum
	lea	sivu5-sivu4(a0),a0
	bsr.b	.hum
	lea	sivu6-sivu5(a0),a0
	bsr.b	.hum
	bra.b	.him
.hum
	move.l	a0,a1
.lop0	subq	#3,gg_TopEdge(a1)
	tst.l	(a1)
	beq.b	.e0
	move.l	(a1),a1
	bra.b	.lop0
.e0	rts

.him
	
	; Build the sex struct, font will be set
	; when it is loaded, set pens here.
	lea	stringExtendStruct(a5),a1
	move.b	#1,sex_Pens+0(a1)
	; already zeroes
	;move.b	#0,sex_Pens+1(a1)
	move.b	#1,sex_ActivePens+0(a1)
	;move.b	#0,sex_ActivePens+1(a1)

	; Make space for list mode change button
    ; NOTE: this is recalculated in avaa_ikkuna and
    ; layoutGadgetsVertical
	lea	gadgetFileSlider,a0
	add	#14,gg_TopEdge(a0)
	sub	#18,gg_Height(a0)

	; The last main window button is "gadgetSortButton",
	; add another button as the new last one
	basereg	gadgetFileSlider,a0
	pushpea	gadgetListModeChangeButton(a0),gadgetSortButton+gg_NextGadget(a0)
	endb	a0
	
	move.l	_IntuiBase(a5),a6

	* Give each gadget a gg_GadgetID,
	* set proper text attr for ones which have text.
	moveq	#1,d0
	basereg	gadgets,a3
	lea		gadgets,a3
	lea		gadgets(a3),a1
	bsr.b	.num

** Prefs
	moveq	#1,d0
	lea		gadgets2(a3),a1
	bsr.b	.num
	moveq	#20,d0
	lea		sivu0(a3),a1
	bsr.b	.num
	moveq	#20,d0
	lea		sivu1(a3),a1
	bsr.b	.num
	moveq	#20,d0
	lea		sivu2(a3),a1
	bsr.b	.num
	moveq	#20,d0
	lea		sivu3(a3),a1
	bsr.b	.num
	moveq	#20,d0
	lea		sivu4(a3),a1
	bsr.b	.num
	moveq	#20,d0
	lea		sivu5(a3),a1
	bsr.b	.num
	moveq	#20,d0
	lea		sivu6(a3),a1
	bsr.b	.num
	endb	a3
	bra		.eer2

.num
* Numeroidaan gadgetit
	move.l	a1,a0

.er	bsr.b	.gadu
	move.l	(a0),d1
	beq.b	.eer
	move.l	d1,a0
	addq	#1,d0
	bra.b	.er
.eer	rts

* Gives a gadget an id number
* Adjust text gadget font
* Adjust prop gadget 
.gadu
	move	d0,gg_GadgetID(a0)
	move.l 	gg_SpecialInfo(a0),a2
	
	cmp	#GTYP_PROPGADGET,gg_GadgetType(a0)
	bne.b	.noProp
	* Proportional gadget setup!
	* Enable complement highlight
	* GFLG_GADGHCOMP = 0
	and		#~GFLG_GADGHNONE,gg_Flags(a0)
	* Adjust layout 
	addq	#1,gg_TopEdge(a0)
	subq	#3,gg_Height(a0)
	subq	#1,gg_Width(a0)
	* kick2.0+: newlook borderless
	or		#PROPNEWLOOK!PROPBORDERLESS,pi_Flags(a2)	
	and		#~AUTOKNOB,pi_Flags(a2)
.noProp

	cmp		#GTYP_STRGADGET,gg_GadgetType(a0)
	bne.b	.noStr
	tst.b	uusikick(a5)
	beq.b	.noStr
	* Kick2.0 only
	* Make string gadgets tab cyclable and set font with string extend
	or		#GFLG_TABCYCLE!GFLG_STRINGEXTEND,gg_Flags(a0)
	pushpea	stringExtendStruct(a5),si_Extension(a2)

.noStr
	* If contains text, set font
	tst.l	gg_GadgetText(a0)
	beq.b	.noTxt
	move.l	gg_GadgetText(a0),a2	* IntuiText
	move.l	#text_attr,it_ITextFont(a2)	* fontti
	tst.l	it_NextText(a2)
	beq.b	.noTxt
	move.l	it_NextText(a2),a2
	move.l	#text_attr,it_ITextFont(a2)	* fontti
.noTxt	

	rts

.eer2
	* Adjust file slider a bit
	lea		slider4,a0
	basereg	slider4,a0
	addq	#1,slider4+gg_Height(a0)
	addq	#1,slider4+gg_LeftEdge(a0)
	addq	#1,slider4+gg_Width(a0)
	move.l	#slimage,slider4+gg_GadgetRender(a0)	* filebox-slideriin image

	* Nudge this a bit!
	addq	#1,gg_TopEdge+juust0(a0) 		* ps3m stereo level

	* Info window slider
	moveq	#0,d0
	lea		gAD1(a0),a0
	endb	a0
	bsr		.gadu
	addq	#3,gg_Height(a0)
	addq	#1,gg_Width(a0)
	move.l	#slimage2,gg_GadgetRender(a0) 	* moduleinfo-slideriin image

    * Remove position slider from the list by default, at this point
    * it will have the correct gg_GadgetID by the init loop above.
    clr.l   gg_NextGadget+gadgetResize
	
	* Gadget stuff done.

	move.l	#PLAYING_MODULE_NONE,chosenmodule2(a5)

	bset	#1,$bfe001
	sne	filterstore(a5)			* filtterin tila talteen
	st	modulefilterstate(a5)

	lea	moduleListHeader(a5),a0		* Uusi lista
	NEWLIST	a0
	lea	favoriteListHeader(a5),a0
	NEWLIST a0
	lea	fileBrowserListHeader(a5),a0
	NEWLIST a0
	lea	searchResultsListHeader(a5),a0
	NEWLIST a0

	lea	.startingMsg(pc),a0
	bsr	printbox
	bra.b	.startingMsg2
.startingMsg dc.b "Starting...",0
 even
.startingMsg2



	jsr	loadkeyfile		* ladataan key-file


******* Vanha kick: otsikkopalkin ja WB-nayton koko
	tst.b	uusikick(a5)
	bne	.newkick

	; Copy alternative horiz prop gadget gfx for kick13
	lea	horizPropGadgetGfxNormal,a0
	moveq	#horizPropGadgetGfxNormal_kick13-horizPropGadgetGfxNormal,d0
	lea	(a0,d0),a1
	move.l	a1,a2
.cp13	move	(a1)+,(a0)+
	cmp.l	a0,a2
	bne.b	.cp13
;
;	lea	horizPropGadgetGfxDouble,a0
;	moveq	#horizPropGadgetGfxDouble_kick13-horizPropGadgetGfxDouble,d0
;	lea	(a0,d0),a1
;	move.l	a1,a2
;.cp14	move	(a1)+,(a0)+
;	cmp.l	a0,a2
;	bne.b	.cp14
 


** 3 pixeli‰ korkeempi infowindowin slideri
;	addq	#3,gg_Height+gAD1

* kick1.3 v‰rit
;	move	#0,pen_0+2(a5)	
	clr	pen_0+2(a5)
	move	#1,pen_1+2(a5)
	move	#2,pen_2+2(a5)
	move	#3,pen_3+2(a5)


** Poistetaan reqtoolsrequesterien pubscreentagit
	lea	otag1(pc),a0
	clr.l	(a0)
	clr.l	otag2-otag1(a0)
	clr.l	otag3-otag1(a0)
	clr.l	otag4-otag1(a0)
	clr.l	otag5-otag1(a0)
;	clr.l	otag6-otag1(a0)
;	clr.l	otag7-otag1(a0)
	clr.l	otag8-otag1(a0)
;	clr.l	otag9-otag1(a0)
;	clr.l	otag10-otag1(a0)
;	clr.l	otag11-otag1(a0)
;	clr.l	otag12-otag1(a0)
;	clr.l	otag13-otag1(a0)
	clr.l	otag14-otag1(a0)
	clr.l	otag15-otag1(a0)
	clr.l	otag16-otag1(a0)
	clr.l	otag17-otag1(a0)
	
	* Opens a 1x1 pixel sized window to fetch some Workbench attributes
	* Then immediately closes it!

	lea	winstruc,a0
	move.l	#$00010001,wsizex-winstruc(a0)	* koko 1x1
	lore	Intui,OpenWindow
	tst.l	d0
	bne.b	.go2
	move.b	#i_nowindow,startuperror(a5)
	bra	exit
.go2	
	move.l	d0,a0
	move.l	wd_WScreen(a0),a1		* WB screen addr
	move	sc_Width(a1),wbleveys(a5)	* WB:n leveys
	move	sc_Height(a1),wbkorkeus(a5)	* WB:n korkeus
	move.b	sc_BarHeight(a1),windowtop+1(a5) * palkin korkeus
	lob	CloseWindow
	move	WINSIZX(a5),wsizex
	move	WINSIZY(a5),wsizey
	sub	#10,windowtop(a5)
.newkick

	bsr	inithippo
	bsr	initkorva
	bsr	initkorva2
	jsr	initializeButtonRowLayout

	st	reghippo(a5)


	move.l	(a5),a0
	moveq	#0,d1
	move.b	PowerSupplyFrequency(a0),d1	
	move.l	#3546895,d0
	cmp	#50,d1
	beq.b	.pal
;	move.l	#3579545,d0
	move	#$9E99,d0
.pal	move.l	d0,clockconstant(a5)

	bsr	divu_32
	move.l	d0,colordiv(a5)		* 50Hz tai 60Hz n‰ytˆlle

	move	#15600,horizfreq(a5)
	move	#50,vertfreq(a5)
	
	bsr	srand			* randomgeneratorin seed!



	lea	sv_argvArray+4(a5),a3	* ei ekaa
	tst.l	(a3)
	beq.b	.nohide
	move.l	(a3),a0
	bsr	kirjainta4
	cmp.l	#MESSAGE_COMMAND_HIDE,d0		* oliko komento 'HIDE'??
	bne.b	.nohide
	clr.b	win(a5)
	bra.b	.hid
.nohide
	bsr	get_rt

	st	win(a5)
	bsr	avaa_ikkuna		* palauttaa d4:ss‰ keycheckin~
	beq.b	.go3
	clr.b	win(a5)
	move.b	#i_nowindow,startuperror(a5)
	bra	exit
.go3


* ikkuna avattu.. katotaan pit‰‰ko olla pieni
	tst.b	prefsdata+prefs_kokolippu(a5)
	beq.b	.hid
	bsr	zipMainWindow
.hid

	jsr	inforivit_clear
	jsr	importFavoriteModulesFromDisk
	jsr	initializeUHC

	DPRINT	"Loading group"

	tst.b	groupmode(a5)			* ladataanko playergrouppi?
	bne.b	.purr
	jsr	loadplayergroup
	move.l	d0,externalplayers(a5)
;	bne.b	.purr
;	lea	grouperror_t,a1		* ei valiteta vaikka ei lˆydykk‰‰n
;	bsr	request


* ladataan playerlibitkin samantien
* these were previously loaded at start up. not a very good idea,
* slows down and uses extra mem for nothing.
	;jsr	get_sid
	;jsr	get_med1
	;jsr	get_med2
	;jsr	get_med3
	;jsr	get_mline

.purr


	pushpea	scopeData+scope_ch1(a5),hippoport+hip_PTch1(a5)
	pushpea	scopeData+scope_ch2(a5),hippoport+hip_PTch2(a5)
	pushpea	scopeData+scope_ch3(a5),hippoport+hip_PTch3(a5)
	pushpea	scopeData+scope_ch4(a5),hippoport+hip_PTch4(a5)
	pushpea	kplbase(a5),hippoport+hip_kplbase(a5)
	pushpea	moduleListHeader(a5),hippoport+hip_moduleListHeader(a5)

	move.l	colordiv(a5),hip_colordiv+hippoport(a5)


	moveq	#INTB_VERTB,d0
	lea	intserver,a1
	lore	Exec,AddIntServer
	st	ciasaatu(a5)
	st	vbsaatu(a5)

	bsr	init_inputhandler
	bsr	init_screennotify
    tst.b   win(a5)
    beq     .noScopes
	jsr	startAndStopScopeTasks
.noScopes

	tst.b	infoon(a5)
	beq.b	.qq
;	st	oli_infoa(a5)
	DPRINT	"Starting info"
	jsr	rbutton10b
.qq

	jsr	inforivit_clear

	tst	boxsize(a5)
	beq.b	.oohi

	lea	banner_t(pc),a0			* registered to..
	moveq	#11+WINX,d0
	;moveq	#18+WINY,d1
	move	infoBoxTopEdge(a5),d1
	jsr		infoBoxPrint
	
	; ei annoytekstia vaikkei rekisteroity
	cmp.b	#' ',keyfile(a5)
	beq.b	.oohi

	lea	regtext_t(pc),a0
	moveq	#0,d1
	bsr.b	.rount

	lea	keyfile(a5),a0
	moveq	#8,d1
	bsr.b	.rount
	bra.b	.oohi

.rount
	moveq	#34+WINX,d0
	move	boxsize(a5),d3
	bsr		getFileboxYStartToD2
	add		d2,d1
    tst.w     searchLayoutActive(a5)   
    beq.b   .lm1
    subq    #SEARCH_BOXSIZE_DELTA,d2
.lm1

	mulu	listFontHeight(a5),d3
	lsr		#1,d3
	add		d3,d1
	bra		print
.oohi

    tst.b   win(a5)
    beq     .uc
    * Get metadata at startup
    jsr     initializeUslUme
.uc


 ifne EFEKTI
	jsr	efekti
 endc
    * Are there any command line parameters from shell?
    * Also Workbench icon clicks get placed her as arguments.
	tst.l	sv_argvArray+4(a5)
	bne.b	.komento0
    * No, check for startup module.
	tst.b	startuponoff(a5)
	beq.b	.komento0
	tst.b	startup(a5)
	beq.b	.komento0
	pushpea	startup(a5),sv_argvArray+4(a5) * Parametriksi startupmoduuli
	clr.l	sv_argvArray+8(a5)
    bsr     komentojono
    bra     .startupModHandled
.komento0
    * No startup module.
    * Restore the saved state list next.
	bsr		lockMainWindow
	jsr	importSavedStateModulesFromDisk
	bsr		unlockMainWindow
.startupModHandled

    * Finally, append any modules from command line/workbench
	tst.l	sv_argvArray+4(a5)
    beq     .noCliParms
    bsr     komentojono
.noCliParms

*********************************************************************************
*
* P‰‰silmukka
*	

	DPRINT	"Entering message loop"

;	jsr	startQuadraScopeTask

	bra.b	msgloop
returnmsg
	bsr	flush_messages
msgloop	
	tst.b	exitmainprogram(a5)
	bne	exit

	cmp.b	#1,do_alarm(a5)
	bne.b	.noal				* her‰tys!
	addq.b	#1,do_alarm(a5)
	lea	startup(a5),a0
	tst.b	(a0)
	beq.b	.noal				* onko moduulia??
	move.l	a0,sv_argvArray+4(a5)		* Parametriksi startupmoduuli
	clr.l	sv_argvArray+8(a5)
	bsr	komentojono
	bra.b	returnmsg
.noal

	moveq	#0,d0
	move.b	songHasEndedSignal(a5),d1
	bset	d1,d0
	move.b	ownsignal2(a5),d1
	bset	d1,d0
	move.b	uiRefreshSignal(a5),d1
	bset	d1,d0
	move.b	posUpdateSignal(a5),d1
	bset	d1,d0
	move.b	audioPortSignal(a5),d1
	bset	d1,d0
	move.b	fileReqSignal(a5),d1
	bset	d1,d0
	move.b	rawKeySignal(a5),d1
	bset	d1,d0
	move.b	tooltipSignal(a5),d1
	bset	d1,d0
	move.b	hippoport+MP_SIGBIT(a5),d1 * oman viestiportin bitti
	bset	d1,d0

	tst.b	win(a5)
	beq.b	.nw
	move.l	userport(a5),a0
	move.b	MP_SIGBIT(a0),d1		* ikkunan IDCMP:n sigbit
	bset	d1,d0
.nw
	tst.b	rexxon(a5)
	beq.b	.nre
	move.b	rexxport+MP_SIGBIT(a5),d1	* ARexx-portin signalibitti
	bset	d1,d0
.nre
	* We get signal?
	lore	Exec,Wait		* Odotellaan...
	* Active signals in D0

	tst.b	rexxon(a5)
	beq.b	.nrexm
	move.b	rexxport+MP_SIGBIT(a5),d3	* Tuliko ARexx viesti?
	btst	d3,d0
	beq.b	.nrexm
	jsr	rexxmessage
	bra		returnmsg

.nrexm
* Tuliko viesti‰ porttiin?
	move.b	hippoport+MP_SIGBIT(a5),d3
	btst	d3,d0
	beq.b	.ow
	push	d0
	bsr	omaviesti
	pop	d0
.ow

* Tuliko omia signaaleja??
	move.b	songHasEndedSignal(a5),d3
	btst	d3,d0
	beq.b	.nowo
	pushm	all
	bsr	signalreceived
	popm	all


*** Poistuttiinko preffsist‰?
* Prefs window was just closed? Do stuff!
* Probably this bit handles things like:
* - move windows to a newly set public screen
* - update filebox size according to prefs changes
* - update titlebar information
* - quite ugly!
.nowo	move.b	ownsignal2(a5),d3	* p‰ivitet‰‰n positionia
	btst	d3,d0
	beq.b	.noSignal2
	push	d0  * save signal mask
	bsr	handleSignal2
	move.l	d0,d1
	; d0 = -1 -> window error, exit
	; d0 =  1 -> window reopened, skip rest of the event loop
	; d0 =  0 -> continue
	pop	d0
	tst.l	d1
	bmi	exit
	bne	returnmsg
.noSignal2

	move.b	uiRefreshSignal(a5),d3	* p‰ivitet‰‰n...
	btst	d3,d0
	beq.b	.wow
	bsr		handleUiRefreshSignal
.wow


*** poistuttiin filerequesterista

	push	d0
	move.b	fileReqSignal(a5),d3
	btst	d3,d0
	beq.b	.nwww

* this signal is set when the filerequester for adding files is ready

	tst.b	autosort(a5)		* automaattinen sorttaus?
	beq.b	.nas
	bsr	rsort
.nas

	jsr	listChanged
	bsr	forceRefreshList


	move.b	haluttiinuusimodi(a5),d1
	clr.b	haluttiinuusimodi(a5)

	move.b	new(a5),d0
	clr.b	new(a5)
	tst.b	d0
;	beq.b	.nwww		* ??
	beq.b	.whm		* ??
	bpl.b	.nwww	

.whm	;tst.b	haluttiinuusimodi(a5)
	tst.b	d1
	beq.b	.nwww
	;clr.b	haluttiinuusimodi(a5)


* T‰nne tullaan sillon, kun on painettu playt‰ eik‰ ollut modeja,
* filereq-prosessin signaalista. Eli aletaan soittaa ekaa valittua modia.

	tst.l	modamount(a5)		* Ei modeja edelleenk‰‰n
	beq.b	.nwww

	movem.l	d0-a6,-(sp)
	clr.l	firstname(a5)		* valitaan eka
	clr.l	chosenmodule(a5)
	tst.l	playingmodule(a5)
	bmi.b	.ee
	move.l	#PLAYING_MODULE_REMOVED,playingmodule(a5)
.ee	
	cmp.b	#pm_random,playmode(a5)
	bne.b	.noRand
	bsr	soitamodi_random
	bra.b	.wasRand
.noRand
	bsr	rbutton1
.wasRand
	movem.l	(sp)+,d0-a6
	
.nwww	pop	d0

	bsr	areMainWindowGadgetsFrozen
	bne	.nwwwq

	move.b	rawKeySignal(a5),d3	* rawkey inputhandlerilta
	btst	d3,d0
	beq	.nwwwq
	DPRINT	"rawkey from input handler"
	moveq	#0,d4
	move	rawkeyinput(a5),d3
	cmp	#$25,d3			* oliko 'h'?
	beq.b	.hide
	cmp	#$01,d3			* '1'? -> iconify
	bne.b	.nico
	moveq	#0,d3			* muutetaan -> ~`
	bsr	nappuloita
	bra	returnmsg
.nico

	tst	d3
	beq.b  .noKeys
	bsr nappuloita
	bra	returnmsg
.noKeys

	tst.b	win(a5)
	bne.b	.obh
.open	
	bsr	openw
	bne	exit
	bra	returnmsg

.obh	
* painettiinko zip windowi ei-ikkunassa? pullautetaan..
	tst.b	kokolippu(a5)
	beq.b	.op
	bsr	front
	bra.b	.nwwwq
.op	bsr	sulje_ikkuna
	clr.b	win(a5)
	bra.b	.open


.hide
	tst.b	win(a5)
	beq.b	.open
	bsr	sulje_ikkuna
	clr.b	win(a5)
	bra	returnmsg


.nwwwq

	move.b	posUpdateSignal(a5),d3
	btst	d3,d0
	beq.b	.noSig4
	bsr		handlePosUpdateSignal
.noSig4
	
	* Tooltip display signal check
	move.b	tooltipSignal(a5),d3 
	btst	d3,d0 
	beq.b	.noTooltipSignal
	bsr	tooltipDisplayHandler
.noTooltipSignal

* Vastataan IDCMP:n viestiin

	
;getmoremsg
	tst.b	win(a5)
	beq	msgloop

	* Ignore any ui actions if window is frozen
	* Flush any remaining messages 
	bsr	areMainWindowGadgetsFrozen
	bne	returnmsg		

* Process IDCMP messages if any
	clr.b	ignoreMouseMoveMessage(a5)
.idcmpLoop
	move.l	userport(a5),a4
	move.l	a4,a0
	lore Exec,GetMsg
	* Go back to mainloop if no more messages left
	tst.l	d0
	beq	msgloop

	move.l	d0,a1
	move.l	im_Class(a1),d2		* luokka	
	move	im_Code(a1),d3		* koodi
	move	im_Qualifier(a1),d4	* RAWKEY: IEQUALIFIER_?
	move.l	im_IAddress(a1),a2 	* gadgetin tai olion osoite
	move	im_MouseX(a1),mousex(a5)
	move	im_MouseY(a1),mousey(a5)

	lob	ReplyMsg

	cmp.l	#IDCMP_CHANGEWINDOW,d2
	bne.b	.noChangeWindow
	; Window resize events go into IDCMP_CHANGEWINDOW
	; on kick 2.0+.
	bsr	zipwindow
	bsr	mainWindowSizeChanged
	bra.b	.idcmpLoop

.noChangeWindow
	cmp.l	#IDCMP_NEWSIZE,d2
	bne.b	.noNewSize
	tst.b	uusikick(a5)
	bne.b	.idcmpLoop
	; Use this event on kick1.3, as CHANGEWINDOW is not reported there.
	bsr	mainWindowSizeChanged
	bra.b	.idcmpLoop
.noNewSize

	cmp.l	#IDCMP_RAWKEY,d2
	bne.b	.noRawKey
	clr	userIdleTick(a5)	
	bsr	nappuloita
	bra.b	.idcmpLoop
.noRawKey	
	* There will be a lot of mousemove messages.
	* To keep the load light only take the first one and filter out the
	* rest during this message loop.
	* Prop gadgets and tooltips will work with fewer events, too.
	cmp.l	#IDCMP_MOUSEMOVE,d2
	bne.b	.noMouseMove
	clr	userIdleTick(a5)		* clear user idle counter, user is moving mouse
	tst.b	ignoreMouseMoveMessage(a5) 
	bne  	.idcmpLoop
	st	ignoreMouseMoveMessage(a5)
	bsr	mousemoving
	bra	.idcmpLoop

.noMouseMove
	cmp.l	#IDCMP_GADGETUP,d2
	bne.b	.noGadgetUp
	clr	userIdleTick(a5)	
	bsr	gadgetsup
	bra	.idcmpLoop
.noGadgetUp
	cmp.l	#IDCMP_MOUSEBUTTONS,d2
	bne.b	.noMouseButtons
	clr	userIdleTick(a5)	
	bsr	buttonspressed
	bra	.idcmpLoop
.noMouseButtons	
	cmp.l	#IDCMP_CLOSEWINDOW,d2
	bne.b	.noClose
	bra.b	exit
.noClose
	; When activating or inactivating the window
	; frame will be redrawn on top of the resize gadget,
	; so redraw it to ensure correct visual.
	cmp.l	#IDCMP_ACTIVEWINDOW,d2
	bne.b	.noActive
	bsr	refreshResizeGadget
	bra	.idcmpLoop
.noActive
	cmp.l	#IDCMP_INACTIVEWINDOW,d2
	bne.b	.noInactive
	bsr	refreshResizeGadget
.noInactive

	* All messages checked
	bra	.idcmpLoop
	
exit	
	lea	var_b,a5

	DPRINT "Hippo is exiting"
	bsr	setMainWindowWaitPointer	

	lea	.exmsg(pc),a0
	bsr	printbox
	bra.b	.exmsg2
.exmsg dc.b	"Exiting...",0
 even
.exmsg2
	jsr	exportFavoriteModulesToDisk
	jsr	exportSavedStateModulesToDisk
	jsr	deinitUHC
* poistetaan loput prosessit...


* onko prosessien k‰ynnistys kesken?
;	cmp	#1,prefs_prosessi(a5)
;	beq.b	.er2	
;	cmp	#1,quad_prosessi(a5)
;	beq.b	.er2	
;	cmp	#1,filereq_prosessi(a5)
;	beq.b	.er2	

	bsr	sulje_prefs
	;jsr	sulje_quad
	jsr	stopScopeTasks
	jsr	sulje_info

	tst.b	hippoport+hip_opencount(a5)	* onko portilla
	beq.b	.joer				* k‰ytt‰ji‰?

** k‰sket‰‰n niit‰ sammumaan.
	st	hippoport+hip_quit(a5)


	moveq	#3*25-1,d7		* odotetaan max 2 sekkaa
.jorl	tst.b	hippoport+hip_opencount(a5)
	beq.b	.joer
	bsr	dela
	dbf	d7,.jorl
	bra.b	.er
	clr.b	hippoport+hip_quit(a5)	* ei en‰‰ quittia jos ei onnistunu.

.joer

* n‰it‰ ei voida niin vaan poistaakaan.
	tst	filereq_prosessi(a5)
	beq.b	.ex

.er	lea	.clo(pc),a1
.req	jsr	request
	clr.b	exitmainprogram(a5)	* ei en‰‰ exitti‰.	
	bra	msgloop
.clo	dc.b	"Close all requesters & external programs and try again!",0
 even

.ex
	bsr	rbutton4b		* eject /wo fade
	bsr	freelist		* vapautetaan lista
	jsr	rem_ciaint

	jsr	freeFavoriteList
	jsr	freeFileBrowserList
	jsr	freeSearchList

	tst.b	vbsaatu(a5)
	beq.b	.nbv
	moveq	#INTB_VERTB,d0
	lea	intserver,a1
	lore	Exec,RemIntServer
.nbv



	tst.b	filterstore(a5)
	bne.b	.ee
	bclr	#1,$bfe001
.ee
	jsr	vapauta_kanavat
	bsr	rem_inputhandler
	bsr	rem_screennotify

	move.l	externalplayers(a5),a0		* vapautetaan playerit
	bsr	freemem

	move.l	xplayer(a5),a0
	bsr	freemem
	move.l	ps3msettingsfile(a5),a0		* vapautetaan ps3masetustied.
	bsr	freemem
;	move.l	calibrationaddr(a5),a0
;	bsr	freemem
	move.l	randomtable(a5),a0
	bsr 	freemem
	move.l	lastStoredFileReqDirectory(a5),a0 
	bsr	freemem

	jsr	closeTooltipPopup
	bsr	flush_messages
	bsr	sulje_ikkuna

	move.b	songHasEndedSignal(a5),d0
	bsr	freesignal
	move.b	ownsignal2(a5),d0
	bsr	freesignal
	move.b	uiRefreshSignal(a5),d0
	bsr	freesignal
	move.b	posUpdateSignal(a5),d0
	bsr	freesignal
	move.b	audioPortSignal(a5),d0
	bsr	freesignal
	move.b	fileReqSignal(a5),d0
	bsr	freesignal
	move.b	rawKeySignal(a5),d0
	bsr	freesignal
	move.b	tooltipSignal(a5),d0
	bsr	freesignal

	move.l	fontbase(a5),d0
	beq.b	.uh22
	move.l	d0,a1
	lore	GFX,CloseFont
.uh22

	move.l	minifontbase(a5),d0
	beq.b	.uh3
	move.l	d0,a1
	lore	GFX,CloseFont
.uh3
	move.l	listfontbase(a5),d0
	beq.b	.uh4
	move.l	d0,a1
	lore	GFX,CloseFont
.uh4
	move.l	topazbase(a5),a1
	lore	GFX,CloseFont

	move.l	req_file(a5),d0
	beq.b	.whoop
	move.l	d0,a1
	lore	Req,rtFreeRequest
.whoop

	tst.b	rexxon(a5)
	beq.b	.nor2
	bsr	deleterexxport
.nor2	bsr	deleteport0

	move.l	nilfile(a5),d1
	lore	Dos,Close
 
 if DEBUG
	jsr	closeTimer
 endif
    jsr     freeStreamHeaderArgs
    jsr     freeStreamerError
    jsr     freeStreamerUrl
    jsr     freeSTILData
    jsr     freeSLData
    jsr     uslFreeIndex
    jsr     uslFreeData
    jsr     umeFreeIndex
    jsr     umeFreeData
    jsr     infoScrollFree

	move.l	_SIDBase(a5),d0		* poistetaan sidplayer
	beq.b	.nahf			
	jsr	rem_sidpatch		* patchi kanssa
	move.l	_SIDBase(a5),a1
	lore	Exec,CloseLibrary
.nahf	
	move.l	_MedPlayerBase1(a5),d0
	bsr	closel
	move.l	_MedPlayerBase2(a5),d0
	bsr	closel
	move.l	_MedPlayerBase3(a5),d0
	bsr	closel
	move.l	_MlineBase(a5),d0
	bsr	closel

	move.l	_PPBase(a5),d0
	bsr	closel
	move.l	_XPKBase(a5),d0
	bsr	closel
	move.l	_XFDBase(a5),d0
	bsr	closel
	move.l	_ScrNotifyBase(a5),d0
	bsr	closel
	move.l	_RexxBase(a5),d0
	bsr	closel
	move.l	_DiskFontBase(a5),d0
	bsr	closel
	move.l	_WBBase(a5),d0
	bsr	closel
	move.l	_GFXBase(a5),d0
	bsr	closel
	move.l	_ReqBase(a5),d0
	bsr	closel
	move.l	_FFPBase(a5),d0
	bsr	closel
	move.l	_MTBase(a5),d0
	bsr	closel
	move.l	_LayersBase(a5),d0
	bsr	closel
	move.l	_ExpansionBase(a5),d0
	bsr	closel
	move.l	_TntBase(a5),d0
	bsr	closel

	bsr	tulostavirhe
	move.l	_IntuiBase(a5),d0
	bsr	closel

	move.l	fileBrowserCurrentDirLock(a5),d1
	beq.b	._1
	lore	Dos,UnLock
._1


 ifne DEBUG
	move.l	getmemCount(pc),d0
	DPRINT "Getmem count: %ld"
	move.l	freememCount(pc),d1
	DPRINT "Freememcount: %ld"
	move.l	getmemTotal(pc),d0 
	lsr.l	#8,d0 
	lsr.l	#2,d0 
	DPRINT "Getmem total: %ld kilobytes"
	move.l	getmemTotal(pc),d0
	move.l	getmemCount(pc),d1
	bne.b	.nz
	moveq	#1,d1
.nz
	bsr		divu_32
	DPRINT "Getmem avg: %ld bytes"

	move.l	#(1)*50,d1
	lore	Dos,Delay

 	move.l	output(a5),d1
 	beq.b	.xef
	lob	Close
.xef
 endc ; DEBUG

	* free any locks
	move.l	_DosBase(a5),a6
	move.l	lockhere(a5),d1
	beq.b	.noLock
	lob		UnLock
.noLock
	move.l	homelock(a5),d1
	beq.b	.noHome
	lob     UnLock
.noHome

	lore	Exec,Forbid			* forbid multitasking 

	move.l	_DosBase(a5),d0		* last library to be closed
	bsr.b	closel
	; safely assume DOS is still available after this

 ifeq asm
	; detached process exit
	bsr	vastomaviesti		* reply to any message we may have received

	* Free program segments. After this the following code lines may become
	* unavailable.
	move.l	segment(a5),d1
	move.l  _DosBase(a5),a6
	jmp 	_LVOUnLoadSeg(a6)   * end of transmission
 else
	; asm-one exit
	moveq	#0,d0				* end of transmission
	rts
 endif 

closel:
	beq.b	.notopen
	move.l	d0,a1
	lore	Exec,CloseLibrary
.notopen
	rts

freesignal
	tst.b	d0
	bmi.b	.e
	lore	Exec,FreeSignal
.e	rts

getsignal
	moveq	#-1,d0
	move.l	(a5),a6
	jmp	_LVOAllocSignal(a6)

smallDelay:
dela:	pushm	all		* pienenpieni delay
	moveq	#1,d1
	lore	Dos,Delay
	popm	all
	rts

*** Avaa ReqToolssin

get_rt:
	lea	var_b,a5
	tst.l	_ReqBase(a5)
	bne.b	.o
	pushm	d0/d1/a0/a1/a6
	lea 	reqname(pc),a1		
	moveq	#38,d0
	lore	Exec,OpenLibrary
	move.l	d0,_ReqBase(a5)
	bne.b	.ok

	move.b	#1,startuperror(a5)
	bsr.b	tulostavirhe
;	move.l	#$7fffffff,d1
	moveq	#-2,d1
	ror.l	#1,d1

	lore	Dos,Delay
.ok
	popm	d0/d1/a0/a1/a6
.o	move.l	_ReqBase(a5),a6
	rts


;se_noreq
;	move.b	#i_noreq,startuperror(a5)
;	bsr.b	tulostavirhe
;	bra.b	exit2

tulostavirhe
	tst.b	startuperror(a5)
	bne.b	.ee
	rts
.ee	pushm	all

	move.b	startuperror(a5),d0
	lea	.r1(pc),a0
	subq.b	#1,d0
	beq.b	.r
	lea	.r2(pc),a0
	subq.b	#1,d0
	beq.b	.r
	lea	.r3(pc),a0
	subq.b	#1,d0
	bne.b	.x
.r	
	moveq	#0,d0		* recovery
	moveq	#19,d1		* korkeus
	lore	Intui,DisplayAlert
	
.x	popm	all
	rts

.r1	;dc	(640-((.r1e-.r1-2)*8))/2
	;dc	208
	dc	176
	dc.b	11
	dc.b	"HiP frozen: no reqtools.library V38+!",0,0
.r1e
 even
.r2	
	;dc	(640-((.r2e-.r2-2)*8))/2
	dc	212
	dc.b	11
	dc.b	"HiP: no CIA interrupts!",0,0
.r2e
 even
.r3	
	;dc	(640-((.r3e-.r3-2)*8))/2
	dc	248
	dc.b	11
 	dc.b	"HiP: no window!",0,0
.r3e
  even
 
i_noreq		=	1
i_nocia		=	2
i_nowindow	=	3


*******
* Flush main window messages
*******
flush_messages
	bsr.b	.fl
	move.l	windowbase(a5),a0 
	jmp		flushWindowMessages

* Flush port messages too
* Hippoportin messaget pois
.fl	tst.b	hippoporton(a5)
	beq.b	.exit
	move.l	(a5),a6
	lea	hippoport(a5),a0
	lob	GetMsg
	tst.l	d0
	beq.b	.exit
	move.l	d0,a1
	lob	ReplyMsg
	bra.b	.fl
.exit 	rts
		


createrexxport	pushm	all
        st      rexxon(a5)
		lea	.p(pc),a4
		lea	rexxport(a5),a2
		bra.b	createport1

.p	dc.b	"HIPPOPLAYER",0
 even
	
createport0	pushm	all
		lea	portname(pc),a4
		lea	hippoport(a5),a2
		st	hippoporton(a5)
createport1	moveq	#-1,d0
		lore	Exec,AllocSignal	* varataan signaalibitti
		move.b	d0,MP_SIGBIT(a2)	* asetetaan signaali porttiin
		move.l	owntask(a5),MP_SIGTASK(a2) * asetataan osoite porttiin
		move.b	#NT_MSGPORT,LN_TYPE(a2)	* noden tyyppi = MSGPORT
		clr.b	MP_FLAGS(a2)		* nollataan liput
		move.l	a4,LN_NAME(a2)
		move.l	a2,a1
		lob	AddPort
		popm	all
		rts

deleterexxport	pushm	all
		lea	rexxport(a5),a2
		bra.b	deleteport1

deleteport0	
		tst.b	hippoporton(a5)
		bne.b	.n
		rts

.n		clr.b	hippoporton(a5)
		pushm	all
		lea	hippoport(a5),a2
deleteport1	move.l	a2,a1
		lore	Exec,RemPort
		moveq	#0,d0
		move.b	MP_SIGBIT(a2),d0	* signaalin numero
		lob	FreeSignal
		popm	all
		rts


******************************************************************************
* Screennotify
*****************************************************************************

init_screennotify
	tst.b	uusikick(a5)
	beq.b	.x
	move.l	_ScrNotifyBase(a5),d0
	beq.b	.x
	move.l	d0,a6
	moveq	#0,d0			* priority
	lea	hippoport(a5),a0
	lob	AddWorkbenchClient
	move.l	d0,notifyhandle(a5)
.x	rts

rem_screennotify
	move.l	notifyhandle(a5),d0
	beq.b	.x
	move.l	d0,a0
	lore	ScrNotify,RemWorkbenchClient
.x	rts


******************************************************************************
* Inputhandler
*****************************************************************************

init_inputhandler
	lea	idname(pc),a0
	moveq	#0,d0			* unit
	lea	iorequest2(a5),a1
	moveq	#0,d1			* flags
	lore	Exec,OpenDevice
	move.l	d0,idopen(a5)
	bne	iderror	

	lea	idmsgport(a5),a2
	move.b	#NT_MSGPORT,LN_TYPE(a2)
	clr.b	MP_FLAGS(a2)
	clr.l	LN_NAME(a2)		* name

	moveq	#-1,d0			* get signal bit
	lob	AllocSignal
	move.b	d0,MP_SIGBIT(a2)
;	bmi.b	iderror

	move.l	owntask(a5),MP_SIGTASK(a2)
	lea	MP_MSGLIST(a2),a0
	NEWLIST	a0
	lea	iorequest2(a5),a1
	move.l	a2,MN_REPLYPORT(a1)

	lea	intstr(a5),a4
	move.b	#NT_INTERRUPT,LN_TYPE(a4)
	move.b	#60,LN_PRI(a4)
	lea	inputhandler(pc),a2
	move.l	a2,IS_CODE(a4)
	move.l	a5,IS_DATA(a4)		* IS_DATA = var_b

	lea	iorequest2(a5),a1
	move	#IND_ADDHANDLER,IO_COMMAND(a1)
	move.l	a4,IO_DATA(a1)
	lob	DoIO


*** Registration check.
	tst.b	keycheck(a5)
	beq.b	.rite
	lea	no_one(pc),a0
	lea	keyfile(a5),a1
.jaffa	move.b	(a0)+,(a1)+
	bne.b	.jaffa
.rite
****

	tst.l	d0
	bne.b	iderror
	moveq	#0,d0
	rts

 
rem_inputhandler
iderror
	tst.l	idopen(a5)
	bne.b	.nope

	lea	iorequest2(a5),a1
	move	#IND_REMHANDLER,IO_COMMAND(a1)
	lea	intstr(a5),a0
	move.l	a0,IO_DATA(a1)
	lore	Exec,DoIO

	move.l	idopen(a5),d0
	lea	iorequest2(a5),a1
	lob	CloseDevice

.nope	
	moveq	#0,d0
	move.b	idmsgport+MP_SIGBIT(a5),d0
	bmi.b	.nope2
	beq.b	.nope2
	lore	Exec,FreeSignal
.nope2

	moveq	#0,d0
	rts


* a0 = start of the event list
* a1 = user data pointer (var_b)
inputhandler
	tst.b	hotkey(a1)
	beq.b	.quit
	push	a0
.handlerloop
	cmp.b	#IECLASS_RAWKEY,ie_Class(a0)
	bne.b	.cont

    tst.b   hotkey(a1)
    bmi.b   .normal

    * Special mode active! This can be used to cancel
    * network download.
    cmp.w   #$45,ie_Code(a0)
    bne     .cont
    * Esc pressed, qualifier ignored
    * Eat the event
    move.w  ie_Code(a0),rawkeyinput(a1)
    clr.b   ie_Class(a0)
    bra     .cont

.normal
	move	ie_Qualifier(a0),d0
	and	#IEQUALIFIER_LSHIFT!IEQUALIFIER_CONTROL!IEQUALIFIER_LCOMMAND,d0
	cmp	#IEQUALIFIER_LSHIFT!IEQUALIFIER_CONTROL!IEQUALIFIER_LCOMMAND,d0
	bne.b	.cont
	move	ie_Code(a0),d0			* rawkoodi
	tst.b	d0
	bmi.b	.cont				* vain jos nappula alhaalla
	clr.b	ie_Class(a0)			* ieclass_null (syodaan pois)
	move	d0,rawkeyinput(a1)		* a1 = var_b
	pushm	d1/a6
	move.b	rawKeySignal(a1),d1
	jsr	signalit
	popm	d1/a6
	bra.b	.exhand
	
.cont	
	move.l	ie_NextEvent(a0),d0		* seuraava
	move.l	d0,a0
	bne.b	.handlerloop
.exhand	
	pop	a0
.quit	move.l	a0,d0
	rts



*******
* Printti rutiini
* Text printing. Variants for different target windows.
* Supports line changes.
*******

* sPrint = Info-ikkunaan
sprint  pushm	all
	add	windowleft(a5),d0
	add	windowtop(a5),d1	* suhteutetaan palkin fonttiin
	move.l	srastport(a5),a4
	bra.b	doPrint	


* Print3 = Prefs-ikkunaan
print3	pushm	all
	add	windowleft(a5),d0
	add	windowtop(a5),d1	* suhteutetaan palkin fonttiin
	move.l	rastport2(a5),a4
	bra.b	doPrint	

* Print to mainwindow with bold font style.
printBold
	pushm	d0-d2/a0-a2/a6
	move.l	rastport(a5),a1
	moveq	#FSF_BOLD,d0	* enable bold bit
	moveq	#FSF_BOLD,d1	* mask of bits to change
	lore	GFX,SetSoftStyle
	popm	d0-d2/a0-a2/a6
	bsr.b	print
	move.l	rastport(a5),a1
	moveq	#0,d0		* disable bold bit
	moveq	#FSF_BOLD,d1	* mask of bits to change
	lore	GFX,SetSoftStyle
	 
	rts

* P‰‰ikkunaan
* d0/d1 = x,y
* a0 = teksti
print:
	add	windowleft(a5),d0
	add	windowtop(a5),d1	* suhteutetaan palkin fonttiin
	tst.b	win(a5)		* onko ikkunaa?
	beq.b	.r
	tst.b	kokolippu(a5)	* ei tulosteta, jos ikkuna pienen‰
	bne.b	.e
.r	rts
.e
	pushm	all
	move.l	rastport(a5),a4
;uup
doPrint:

	move.l	_GFXBase(a5),a6
	move.l	a0,a2

	move	d0,d4
	move	d1,d5
.luup	
	move	d4,d0
	move	d5,d1

	move.l	a4,a1
	lob	Move			* move drawing point
	move.l	a4,a1
	move.l	a2,a0

	moveq	#0,d7
	moveq	#0,d0
.plah	addq	#1,d0	* find out number of chars to output
	tst.b	(a2)
	beq.b	.pog
	cmp.b	#10,(a2)+	* check for line changes
	bne.b	.plah
	moveq	#1,d7
.pog
	subq	#1,d0
	lob	Text

	tst	d7
	beq.b	.x
;	addq	#8,d5		* next vertical line
	move.l	rp_Font(a4),a0
	add	tf_YSize(a0),d5
	bra.b	.luup		

.x	popm	all
	rts

*** A0:sta 4 ascii-kirjainta D0:aan 
kirjainta4:
	move.b	(a0)+,d0
	beq.b	.x
	lsl.l	#8,d0
	move.b	(a0)+,d0
	beq.b	.x
	lsl.l	#8,d0
	move.b	(a0)+,d0
	beq.b	.x
	lsl.l	#8,d0
	move.b	(a0),d0
.x	and.l	#$dfdfdfdf,d0		* muunnetaan isoiksi
	rts



******************************************************************************
* Avaa ikkunan ja pikkasen alustaakin
*******

handleUiRefreshSignal
	addq	#1,userIdleTick(a5)
	push	d0
	jsr	lootaan_aika
	jsr	lootaan_kello
;	bsr	lootaan_muisti
	jsr	lootaan_nimi
    jsr     refreshPositionSlider
    bsr     periodicEndCheck
    jsr     drawInfoScroller 

	; No need to call this every refresh signal, it is handled via RMB 
	; and IDCMP-event handlers anyway:
	;bsr	zipwindow

	* Try to save favorite modules when user has been idle for a while
	moveq	#0,d0 
	move	userIdleTick(a5),d0 
	cmp	#7,d0
	blo.b	.notIdleEnough
	jsr	exportFavoriteModulesWithMessage
.notIdleEnough

	pop	d0
	rts

* See if song ended base on the song length data
periodicEndCheck:
    tst.b   playing(a5)
    beq     .3

    * PSID?
    cmp.w   #pt_sid,playertype(a5)
    bne     .1
    jmp     sidEndCheck
.1
    * Others, if they do not provide the end check otherwise
	move.l	playerbase(a5),a0
	move	#pf_end,d2
	and	    p_liput(a0),d2
    bne     .3
    * Do we have length data?
    tst.w   uslSongLengthData(a5)
    beq     .3
    
    move.l	aika2(a5),d0
	sub.l	aika1(a5),d0            * can be negative
    move.w  kokonaisaika(a5),d1     * mins
    mulu    #60,d1
    add.w   kokonaisaika+2(a5),d1   * secs
    cmp.l   d0,d1
    bge     .3
    st      songover(a5)
    DPRINT  "periodicEndCheck! %ld %ld"
.3
    rts


handlePosUpdateSignal
	* Update title bar with position information
    jsr     refreshPositionSlider
	jmp	lootaan_pos

handleSignal2
	DPRINT	"Signal 2"

	
	* see if prefs window was just closed
	tst.b	prefsexit(a5)
	beq.b	.noe
	clr.b	prefsexit(a5)

	* Do this to update favorite status if settings changed
	jsr	handleFavoriteModuleConfigChange
    jsr setPlayModeChangeButtonIcon

	* Check if boxsize in prefs was changed
	move	boxsize(a5),d0		* onko boxin koko vaihtunut??
	cmp	boxsize0(a5),d0
	bne.b	.noe
	* Do a content refresh is box size not changed. Not sure why
	jsr	forceRefreshList
.noe
	* Prefs exit check done

	* Check if window width changed
	move.l	windowbase(a5),a0

	move	wd_Width(a0),d0
	cmp	previousWindowWidth(a5),d0
	beq.b	.sameWidth
	* Store as the new width
	;move	d0,wsizex
	move	d0,WINSIZX(a5)
	move	d0,previousWindowWidth(a5)
	* Force reopen window
	move	#-1,boxsize0(a5)
 if DEBUG
	ext.l	d0
	DPRINT	"width changed to %ld"
 endif
.sameWidth

** ei saa r‰mp‰t‰ ikkunaa jos se ei oo oikeassa koossaan!!

	moveq	#0,d7
	move	boxsize(a5),d0		* onko boxin koko vaihtunut??
	cmp	boxsize0(a5),d0
	beq.b	.boxSizeNotChanged
	
 if DEBUG
 	ext.l	d0
 	moveq	#0,d1
 	move	boxsize0(a5),d1
	DPRINT	"Boxsize changed to %ld from %ld"
 endif
 
	move	d0,boxsize0(a5)
	bsr	setboxy
	moveq	#1,d7

	push	d7
	bsr	.closeAndReopenWindow
	pop	d7
	tst.l	d0
	bne	.error
	move	boxsize(a5),boxsize0(a5)
	bra.b	.boxSizeChanged

.boxSizeNotChanged
	* Ensures the refresh gadget looks correct
	* after user releases it and window is not reopened
	bsr	refreshResizeGadget

	* Check if height changed
	move	wd_Height(a0),d0
	cmp	previousWindowHeight(a5),d0
	beq.b	.sameHeight
	* Change the window size back
	moveq	#0,d0 ; deltaX
	move	previousWindowHeight(a5),d1
	sub	wd_Height(a0),d1 ; deltaY
	bmi.b	.neg
	* ensure negative change to not go over screen,
	* kick1.3 does not do sanity checks
	sub	listFontHeight(a5),d1
.neg	
	DPRINT	"restore height"
	lore	Intui,SizeWindow
.sameHeight
.boxSizeChanged

** ei saa r‰mp‰t‰ ikkunaa jos se ei oo oikeassa koossaan!!

	tst.b	newpubscreen(a5)	* Valittiinko prefsista uusi
	beq.b	.noewp			* pubscreeni?
	clr.b	newpubscreen(a5)	* siirret‰‰n ikkunat sinne

	bsr.b	.closeAndReopenWindow
	bne.b	.error

	; Also move scope windows to the new screen
	jsr	stopScopeTasks
	jsr	startAndStopScopeTasks

	; And the info window
	tst	info_prosessi(a5)
	beq.b	.return
	jsr	sulje_info
	move.b	oli_infoa(a5),d0
	st	oli_infoa(a5)
	push	d0
	jsr	start_info
	pop	d0
	move.b	d0,oli_infoa(a5)
.return
	moveq	#1,d0
	rts
;;	bra	returnmsg

.noewp	
	move.l	d7,d0
	rts

.closeAndReopenWindow
	* Is a window open? If not, just open
	tst.b	win(a5)
	beq.b	.av2
	* Window was open. Small or big?
	tst.b	kokolippu(a5)
	bne.b	.iso2
	* Small, close
	bsr	sulje_ikkuna
	clr.b	win(a5)
.av2	
	* Just open, a different method?
	bsr.b	openw
	bne.b	.error
	rts
.iso2
	* This closes and reopens the window
	bsr	avaa_ikkuna2
	bne.b	.error
.bar2

	rts

.error
	moveq	#-1,d0
	rts


openw:
	tst.b	win(a5)
	bne.b	.x
	st	win(a5)
	clr.b	kokolippu(a5)		* pieni -> iso
	bsr	avaa_ikkuna
	bne.b	.x
	jsr	whatgadgets2
	moveq	#0,d0
.x	rts


plx1	equr	d4
ply1	equr	d5
plx2	equr	d6
ply2	equr	d7

*** Painettiin Zoom-gadgettia

*** P‰ivitet‰‰n ikkunan sis‰ltˆ

zipwindow:
	DPRINT	"ZipWindow refresh"
	tst.b	win(a5)
	bne.b	.onw	
	rts
.onw
	pushm	all
	move.l	windowbase(a5),a0
	move	wd_Height(a0),d0
 if DEBUG
 	ext.l	d0
 	moveq	#0,d1
 	move	windowZippedSize+2(a5),d1
	DPRINT	"height=%ld zipped=%ld"
 endif
	cmp	windowZippedSize+2(a5),d0
	bne.b	.biggified

	* Zipped to small size
	tst.b	kokolippu(a5)
	beq.b	.x * Safety: already small?
	clr.b	kokolippu(a5)
	* Store zipped position 
	move.l	4(a0),windowZippedPos(a5)
** pieni ikkuna!
	;move.l	windowbase(a5),a0
	lea	gadgets,a1
	moveq	#-1,d0
	moveq	#-1,d1
	sub.l	a2,a2
	lore	Intui,RemoveGList
    
    jsr     switchToNormalLayoutNoRefresh
	DPRINT	"small"
	bra.b	.x

.biggified
	tst.b	kokolippu(a5)
	bne.b	.x * Already big?
	st	kokolippu(a5)
	DPRINT	"big"
	* Store window position
	move.l	4(a0),windowpos(a5)
	bsr	wrender

.x	popm	all
	rts


* Close and reopen window
avaa_ikkuna2:
	bsr	sulje_ikkuna
	not.b	kokolippu(a5)
	
* Open window
avaa_ikkuna:
	DPRINT	"Open window"
	bsr	getscreeninfo
	bne	.opener

	tst		infoBoxOrigTopEdge(a5)
	bne.b	.1
	* Store original dimensions 
	move	gadgetPlayButton+gg_TopEdge,buttonRow1TopEdge(a5)
	move	#10,buttonRow1Height(a5)
	move	gadgetPrefsButton+gg_TopEdge,buttonRow2TopEdge(a5)
	move	#10,buttonRow2Height(a5)
	move	#11+WINY,infoBoxOrigTopEdge(a5)
	move	#28-11,infoBoxOrigHeight(a5)
	;move	#8+63+WINY,fileBoxOrigTopEdge(a5)
	move	#63+WINY,fileBoxOrigTopEdge(a5)

	* Original WINSIZY: 136
	* Added to this to get total height:
	* - windowtop
	* - boxy
	* Boxy is calculated in setboxy(), in loadprefs()
	* or in setListFont().


	move	infoBoxOrigTopEdge(a5),infoBoxTopEdge(a5)
	move	infoBoxOrigHeight(a5),infoBoxHeight(a5)
	move	fileBoxOrigTopEdge(a5),fileBoxTopEdge(a5)
.1
	jsr	layoutGadgetsVertical
    * Ensure list mode toggle button has the correct icon 
    jsr setListModeChangeButtonIconNoRefresh    
    jsr setPlayModeChangeButtonIconNoRefresh
	
	; Update into window structure
	lea	winstruc,a0
	basereg	winstruc,a0

	move	WINSIZX(a5),wsizex(a0)
	move	WINSIZY(a5),wsizey(a0)
	tst	winstruc+nw_MaxWidth(a0)
	bne.b	.set
	move	#264,d0		* default width
	move	d0,winstruc+nw_MinWidth(a0)
    * set maxwidth to 4x original
    lsl     #2,d0
	move	d0,winstruc+nw_MaxWidth(a0)
.set
	endb	a0

	move.l	_IntuiBase(a5),a6

	move.l	windowZippedPos(a5),(a0)	* Pienen paikka ja koko
	moveq	#11,d0
	tst.b	uusikick(a5)
	bne.b	.new1
	moveq	#10,d0				* kick1.3
.new1	add	windowtop(a5),d0
	move	d0,wsizey-winstruc(a0)
	bsr	.leve

	* What is this?
	not.b	kokolippu(a5)
	beq 	.small

	move	#7,slimheight	* slideri pieneks, jotta ei tuu sotkuja

    *
    *
    * Next up we try to open a window. If it won't fit, make it smaller.
    *
    *
    
.windowOpenLoop
	lea	winstruc,a0

    * Calculate window height proposal
	move	WINSIZY(a5),d0

	; Adjust
	add     fileBoxTopEdge(a5),d0
	sub     #63+WINY,d0
	;add    #10,d0

    add	    boxy(a5),d0
	add	    windowtop(a5),d0
	move    d0,nw_Height(a0)



    * Calculate left edge so that window fits
    * Set nw_LeftEdge, nw_TopEdge
    move.l  windowpos(a5),nw_LeftEdge(a0)
	bsr   .leve


 if DEBUG
    pushm   d0-d3
    moveq   #0,d0
    moveq   #0,d1
    moveq   #0,d2
    moveq   #0,d3
    move    nw_Width(a0),d0
    move    nw_Height(a0),d1
    move    nw_LeftEdge(a0),d2
    move    nw_TopEdge(a0),d3
    DPRINT  "Trying to open %ldx%ld at %ld,%ld"
    popm    d0-d3
 endif

    lob     OpenWindow
    tst.l   d0
    bne     .gotWindow

    DPRINT  "Window open failed! Retry smaller."
    * If at 3, move the window to the top and hope for the best.
    cmp     #3,boxsize(a5)
    bne     .smaller
    * Reset stored window y-coordinate to zero
    clr     windowpos+2(a5)
    bra     .windowOpenLoop

.smaller
	subq	#1,boxsize(a5)		* Pienennet‰‰n fileboksia..
	subq	#1,boxsize0(a5)
	bsr	setboxy
    bra     .windowOpenLoop


.small	
	lob	OpenWindow
.gotWindow
	move.l	d0,windowbase(a5)
	bne.b	.ok
	bsr	unlockscreen

.opener	moveq	#-1,d0			* Ei auennut!
	rts

.leve	
    move	wbleveys(a5),d0     * WB:n leveys
	move	nw_LeftEdge(a0),d1  * Ikkunan x-paikka
	add	    nw_Width(a0),d1     * Ikkunan oikea laita
	cmp	d0,d1
	bls.b	.okk
	sub	nw_Width(a0),d0	        * Jos ei mahdu ruudulle, laitetaan
	move	d0,nw_LeftEdge(a0)  * mahdollisimman oikealle
.okk	rts

.ok
	move.l	d0,a0
	move.l	wd_RPort(a0),rastport(a5)
	move.l	wd_UserPort(a0),userport(a5)
	;move	wd_Height(a0),wkork(a5)

 if DEBUG
	moveq	#0,d0
	moveq	#0,d1
	moveq	#0,d2
	moveq	#0,d3
	move	wd_LeftEdge(a0),d0
	move	wd_TopEdge(a0),d1
	move	wd_Width(a0),d2
	move	wd_Height(a0),d3
	DPRINT	"Open window pos=%ldx%ld size=%ldx%ld"
 endif
	move.l	rastport(a5),a1
	move.l	fontbase(a5),a0
	lore	GFX,SetFont	

	tst.b	uusikick(a5)	* jos kickstart 2.0+, pistet‰‰n ikkuna
	beq.b	.elderly	* appwindowiksi.

	moveq	#0,d0		* ID
	move.l	#"AppW",d1	* userdata
	move.l	windowbase(a5),a0
	lea	hippoport(a5),a1 * msgport
	sub.l	a2,a2		* null
	lore	WB,AddAppWindowA
	move.l	d0,appwindow(a5)
.elderly
	jsr	createlistBoxRegion
	jsr	createInfoBoxRegion

	; Store this for detecting height changes after window opened
	move	winstruc+nw_Height,previousWindowHeight(a5)

    ; Do some gadget hacking

	lea	slider4,a3		* fileboxin slideri
	moveq	#gadgetFileSliderInitialHeight,d3	* y-koko
	add	boxy(a5),d3
    sub     BOTTOM_MARGIN(a5),d3
	move	d3,gg_Height(a3)
	subq	#3,gg_Height(a3)

    tst.b   altbuttons(a5)
    beq     .noAlt1
    subq    #7,gg_Height(a3)
.noAlt1
 
;    Old (weird) piece of code:
;
;    lea     slider4,a3              * fileboxin slideri
;    moveq   #gadgetFileSliderInitialHeight,d3       * y-koko
;    and     #~$80,gg_TopEdge(a3)
;    add     boxy(a5),d3
;    bpl.b   .r
;    or      #$80,gg_TopEdge(a3)
;    clr     d3
;.r  move    d3,gg_Height(a3)

	basereg	slider4,a3

	* Remove the fileslider from the gadget list
	* if it is not visible. On kick13 there may be
	* some gfx trash otherwise.
	* Normal chain:
	;move.l	#slider4,slider1+gg_NextGadget(a3)
	move.l	a3,slider1+gg_NextGadget(a3)
	tst	boxsize(a5)
	bne.b	.isBox
	* Skip over slider4
	;move.l	#button12,slider1+gg_NextGadget(a3)
	pushpea	button12(a3),slider1+gg_NextGadget(a3)
.isBox
	endb	a3

	jsr		layoutGadgetsHorizontal

	bsr	wrender
	moveq	#0,d0
	rts





getscreeninfo
	st	gotscreeninfo(a5)

*** Selvitet‰‰n ikkunan n‰ytˆn ominaisuudet
*** Uusi kick 
	tst.b	uusikick(a5)
	beq	.olde

    lea     -150(sp),sp     * MAXPUBSCREENNAME = 139
	lea	pubscreen(a5),a0    
    cmp.l   #"Fron",(a0)    * Check for "Front screen"
    bne     .nF
    move.l  sp,a0
    bsr     findFrontPublicScreenName
    lea     pubscreen(a5),a0    
    tst.l   d0
    beq     .nFF     * got null, go for default
    move.l  d0,a0
.nF
    move.l  a0,a3               * name in a3
	lore	Intui,LockPubScreen
.nFF
	move.l	d0,screenlock(a5)
	bne.b	.ok1
    DPRINT  "Using default pubscreen"
	sub.l	a0,a0           * Workbench fallback, should always work
	lob	LockPubScreen
    lea     aseta_vakiot\.wb(pc),a3
	move.l	d0,screenlock(a5)
.ok1
 if DEBUG
    push    d0
    move.l  a3,d0
    DPRINT  "using pubscreen=%s"
    pop     d0
 endif
    * Copy to where windows and requesters can find it
    lea     pubScreenNameTags(a5),a2
.cp move.b  (a3)+,(a2)+
    bne     .cp
    lea     150(sp),sp  * release stack where the name may be

	move.l	d0,a0

	move.l	d0,screenaddr(a5)
	move	sc_Width(a0),wbleveys(a5)	* N‰ytˆn leveys
	move	sc_Height(a0),wbkorkeus(a5)	* N‰ytˆn korkeus
	clr	windowtop(a5)
	clr	windowtopb(a5)
	clr	windowbottom(a5)
	clr	windowleft(a5)
	clr	windowright(a5)
	move.b	sc_BarHeight(a0),windowtop+1(a5) * Palkin korkeus
	move.b	sc_WBorBottom(a0),windowbottom+1(a5)
	move.b	sc_WBorTop(a0),windowtopb+1(a5)
	move.b	sc_WBorLeft(a0),windowleft+1(a5)
	move.b	sc_WBorRight(a0),windowright+1(a5)

	move.l 	sc_Font(a0),a1  * TextAttr, screen font
	moveq	#0,d3
	move	ta_YSize(a1),d3

 if DEBUG
	moveq	#0,d0
	move.b	sc_BarHeight(a0),d0
	moveq	#0,d1
	move.b	sc_BarVBorder(a0),d1
	move.l	d3,d2
	DPRINT	"sc_BarHeight=%ld sc_BarVBorder=%ld fontY=%ld"
	moveq	#0,d0
	move.b	sc_WBorTop(a0),d0
	moveq	#0,d1
	move.b	sc_WBorBottom(a0),d1
	DPRINT	"sc_WBorTop=%ld sc_WBorBottom=%ld"
 endif

	* It seems that the total height of the window
	* border must be calculated using the screen font height
	* and adding some safety margin.
	* Screen bar height can't be used to calculate window
	* title bar height since that can configured separately.
	addq	#2,d3
	move	d3,windowtop(a5)
 

* Screen Border = 0 + Window Border = 0, font 13
* - sc_BarHeight= 15
* - sc_WBorTop = 2
* - ta_YSize = 13

* Screen Border = 0 + Window Border = 0, font 8
* - sc_BarHeight= 10
* - sc_WBorTop = 2
* - ta_YSize = 8

* Screen Border = 0 + Window Border = 0 + font 24
* - sc_BarHeight= 26
* - sc_WBorTop = 2
* - ta_YSize = 24

* Screen Border = 8 + Window Border = 0 + font 13
* - sc_BarHeight= 23
* - sc_WBorTop = 2
* - ta_YSize = 13

* Screen Border = 8 + Window Border = 0 + font 8
* - sc_BarHeight= 18
* - sc_WBorTop = 2
* - ta_YSize = 8

* Screen Border = 0 + Window Border = 8 + font 13
* - sc_BarHeight= 15
* - sc_WBorTop = 10
* - ta_YSize = 13


	move	windowtopb(a5),d0
	add	d0,windowtop(a5)

	subq	#4,windowleft(a5)		* saattaa menn‰ negatiiviseksi
	subq	#4,windowright(a5)
	subq	#2,windowtop(a5)
	subq	#2,windowbottom(a5)

;	subq	#4,windowleft(a5)
;	subq	#4,windowright(a5)
;	subq	#2,windowbottom(a5)


** Tutkaillaan n‰ytˆn tyyppi‰!
* Talteen oikea hz scopeja varten


	lea	sc_ViewPort(a0),a2
	move.l	a2,a0
	lore	GFX,GetVPModeID
	and.l	#$40000000,d0		* onko native amiga screeni?
	beq.b	.nogfxcard
	st	gfxcard(a5)
	bra	.ba	
.nogfxcard


;	lea	sc_ViewPort(a0),a0	* viewport
	move.l	a2,a0
	move.l	vp_ColorMap(a0),a0	* colormap
	move.l	cm_VPModeID(a0),d0	* handle

	lob	FindDisplayInfo
	move.l	d0,d4
	beq.b	.ba

	lea	-40(sp),sp
	move.l	sp,a4

	moveq	#0,d5
	moveq	#0,d6
	moveq	#0,d7

	move.l	#DTAG_DISP,d1
	bsr.b	.pa
	move	dis_PixelSpeed(a4),d5

	move.l	#DTAG_MNTR,d1
	bsr.b	.pa
	move	mtr_TotalRows(a4),d6	
	move	mtr_TotalColorClocks(a4),d7

	lea	40(sp),sp

	move.l	#1000000000,d0
;	divu.l	d5,d0		* pixelclock in Hz
	move.l	d5,d1
	bsr	divu_32
	
	move.l	#280,d1
	divu	d5,d1		* pixelclocks/280ns colorclock
	mulu	d7,d1		* pixelclocks per line
	
;	divu.l	d1,d0		* linefrequency in Hz
	bsr	divu_32

	move.l	d0,d1
	divu	d6,d1		* vertical frequency

	move	d0,horizfreq(a5)
	move	d1,vertfreq(a5)

	move.l	clockconstant(a5),d0
	ext.l	d1
	bsr	divu_32
	move.l	d0,colordiv(a5)
	bra.b	.ba

.pa	move.l	d4,a0
	moveq	#0,d2
	move.l	a4,a1
	moveq	#40,d0		* buf size
	jmp	_LVOGetDisplayInfoData(a6)
;	rts

.ba


;******************************* Piirtokynien selvitys

;	move.l	(a5),a1
;	cmp	#39,LIB_VERSION(a1)
;	blo	.kick2

;	move.l	screenaddr(a5),a0
;	lea	sc_ViewPort(a0),a3
;	move.l	vp_ColorMap(a3),a3	* ColorMappi

;	move.l	#$a0000000,d1
;	move.l	d1,d2
;	move.l	d1,d3
;	move.l	a3,a0
;	lea	.tags(pc),a1
;	lore	GFX,ObtainBestPenA
;	move.l	d0,pen_0(a5)

;	moveq	#0,d1
;	moveq	#0,d2
;	moveq	#0,d3
;	move.l	a3,a0
;	lea	.tags(pc),a1
;	lob	ObtainBestPenA
;	move.l	d0,pen_1(a5)

;	moveq	#0,d1
;	moveq	#0,d2
;	moveq	#0,d3
;	move.l	a3,a0
;	lea	.tags(pc),a1
;	lob	ObtainBestPenA
;	move.l	d0,pen_1(a5)

;	move.l	#$f0000000,d1
;	move.l	d1,d2
;	move.l	d1,d3
;	move.l	a3,a0
;	lea	.tags(pc),a1
;	lob	ObtainBestPenA
;	move.l	d0,pen_2(a5)

;	move.l	#$60000000,d1
;	move.l	#$80000000,d2
;	move.l	#$B0000000,d3
;	move.l	a3,a0
;	lea	.tags(pc),a1
;	lob	ObtainBestPenA
;	move.l	d0,pen_3(a5)

;	bra.b	.kick2

;.tags
;	dc.l	OBP_Precision,PRECISION_GUI
;	dc.l	TAG_END

;.kick2


	sub	#10,windowtop(a5)
	;bpl.b	.olde
	;clr	windowtop(a5)
	
*** S‰‰det‰‰n ikkunat ja gadgetit otsikkopalkin koon mukaan

.olde
	; This does some magic that is needed for the layout.
	; Otherwise after zip window layout will start to break
	move	windowtop(a5),d0
	move	windowtop2(a5),d1
	move	d0,windowtop2(a5)
	sub	d1,d0			* ERO!

* nw_TopEdge = 2
* nw_Width   = 4
* nw_Height  = 6

	lea	winstruc,a0
	basereg	winstruc,a0

	add	d0,winstruc+nw_Height(a0)		* suhteutetaan koot fonttiin
	add	d0,winstruc2+nw_Height(a0)
	add	d0,winstruc3+nw_Height(a0)
	add	d0,swinstruc+nw_Height(a0)
	add	d0,windowZippedSize+2(a5)	* pienen ikkunan zip-koko

	move	windowleft(a5),d1
	move	windowleft2(a5),d2
	move	d1,windowleft2(a5)
	sub	d2,d1
	add	d1,winstruc+nw_Width(a0)
	add	d1,winstruc2+nw_Width(a0)
	add	d1,winstruc3+nw_Width(a0)
	add	d1,swinstruc+nw_Width(a0)

	add	d1,WINSIZX(a5)

	move	windowbottom(a5),d3
	move	windowbottom2(a5),d4
	move	d3,windowbottom2(a5)
	sub	d4,d3
	add	d3,WINSIZY(a5)
	add	d3,prefssiz+2(a0)
	add	d3,quadsiz+2(a0)
	add	d3,swinsiz+2(a0)

	tst	quadWindowHeightOriginal(a5)
	bne.b	.setAlready
	move	quadsiz+2,quadWindowHeightOriginal(a5)
	sub	#SCOPE_DRAW_AREA_HEIGHT_DEFAULT,quadWindowHeightOriginal(a5)
.setAlready

	* Store new window size
	move	WINSIZX(a5),wsizex(a0)
	move	WINSIZY(a5),wsizey(a0)
	move	WINSIZX(a5),previousWindowWidth(a5)

	endb	a0

	* Move gadgets down by d0,
	* right by d1

	lea	gadgets,a0
	bsr.b	.hum
	lea	gadgets2-gadgets(a0),a0
	bsr.b	.hum
    * NOTE: this moves gadgetResizeInfoWindow
	lea	gAD1-gadgets2(a0),a0    
	bsr.b	.hum
	lea	sivu0-gAD1(a0),a0
	bsr.b	.hum
	lea	sivu1-sivu0(a0),a0
	bsr.b	.hum
	lea	sivu2-sivu1(a0),a0
	bsr.b	.hum
	lea	sivu3-sivu2(a0),a0
	bsr.b	.hum
	lea	sivu4-sivu3(a0),a0
	bsr.b	.hum
	lea	sivu5-sivu4(a0),a0
	bsr.b	.hum
	lea	sivu6-sivu5(a0),a0
	bsr.b	.hum




	bsr	unlockscreen
	moveq	#0,d0
	rts
.opener	moveq	#-1,d0
	rts

* Nudge gadget edges in a0 by d0,d1
.hum
    * Resize gadgets are bottom relative, don't touch them

	move.l	a0,a1
.lop0	
    cmp.l   #gadgetResizeInfoWindow,a1
    beq     .e00
    cmp.l   #gadgetResize,a1
    beq     .e00

    add	d0,gg_TopEdge(a1)
	add	d1,gg_LeftEdge(a1)
.e00
	tst.l	(a1)
	beq.b	.e0
	move.l	(a1),a1
	bra.b	.lop0
.e0	rts
	

* In:
*   a0 = Buffer to store the public screen name
* Out:
*   d0 = Passed buffer or NULL if front screen is Workbench or not a public screen
findFrontPublicScreenName:
    DPRINT  "findFrontPublicScreenName"
    move.l  a0,a4       * target buffer
    clr.b   (a4)
    moveq   #0,d4       * result
	lore	Intui,LockPubScreenList
    move.l  d0,a1
	move.l	ib_FirstScreen(a6),a0
    move.l  sc_Title(a0),d0
    moveq   #WBENCHSCREEN,d0
    and     sc_Flags(a0),d0
    bne     .non
    moveq   #PUBLICSCREEN,d0
    and     sc_Flags(a0),d0
    beq     .non

    * a1 = List of PubScreenNode structures
    bra     .goLoop
.loop
    cmp.l   psn_Screen(a1),a0   * Is this the front screen?
    beq     .found    
.goLoop
	TSTNODE	a1,a1
	bne     .loop
    bra     .non
.found
    * Copy public name into buffer
    move.l  LN_NAME(a1),a0
    move.l  a4,a1
.cp move.b  (a0)+,(a1)+
    bne     .cp
    move.l  a4,d4
.non
    lob     UnlockPubScreenList
    move.l  d4,d0
    rts


****** Piirret‰‰n ikkunan kamat

wrender:
	
	move.l	pen_0(a5),d0
	move.l	rastport(a5),a1
	lore	GFX,SetBPen

	lea	gadgets,a4

	tst.b	kokolippu(a5)
	beq	.pienehko


	move.l	rastport(a5),a2
	moveq	#4,d0
	moveq	#11,d1
;	move	#259,d2
	move	WINSIZX(a5),d2
	subq	#6,d2
	;move	WINSIZY(a5),d3
	;subq	#3,d3
	;add	boxy(a5),d3
	move.l	windowbase(a5),a3
	move	wd_Height(a3),d3	
	sub		windowbottom(a5),d3
	subq    #3,d3 * magic constant
    sub     windowtop(a5),d3
	bsr	drawtexture


* tyhjennet‰‰n...
* laatikoitten alueet

;	lea	gadgets,a3
;	move.l	a3,a4
	move.l	a4,a3
.clrloop
	move.l	(a3),d7
	movem	4(a3),d0/d1/d4/d5	* putsataan gadgetin alue..
	bsr.b	.cler
	move.l	d7,a3
	tst.l	d7
	bne.b	.clrloop

    lea     gadgetPlayModeChangeButton,a3
    movem.w 4(a3),d0/d1/d4/d5
    bsr     .cler

	bra.b	.oru

.cler	
	; This one is invisible, skip it, though
	; its not in the list at this point anyway?
	cmp.l	#gadgetResize,a3
	beq 	.skipClear

	tst	boxsize(a5)
	bne 	.clef
	* Box is minimized, skipped gadgets:
	cmp.l	#gadgetListModeChangeButton,a3
	beq 	.skipClear
	cmp.l	#slider4,a3		* fileslider
	bne 	.clef
.skipClear
	rts	
.clef
	move.l	rastport(a5),a0
	move.l	a0,a1
	move	d0,d2
	move	d1,d3
	moveq	#$0a,d6
	move.l	_GFXBase(a5),a6
	jmp	_LVOClipBlit(a6)
.oru
;.vanaha

	* Insert an invisible size gadget last
	bsr	configResizeGadget

* sitten isket‰‰n gadgetit ikkunaan..
	move.l	windowbase(a5),a0
	move.l	a4,a1
	moveq	#-1,d0
	moveq	#-1,d1
	sub.l	a2,a2
	lore	Intui,AddGList

    ; Position slider handling:

    lea     gadgetPositionSlider,a1
    move.l	windowbase(a5),a0
	lob     RemoveGadget
    lea     gadgetPlayModeChangeButton,a1
    move.l	windowbase(a5),a0
	lob     RemoveGadget

    tst.b   showPositionSlider(a5)
    beq     .noPos
    lea     gadgetPositionSlider,a1
    move.l	windowbase(a5),a0
    moveq   #-1,d0  * add as last
    lob     AddGadget
    lea     gadgetPlayModeChangeButton,a1
    move.l	windowbase(a5),a0
    moveq   #-1,d0  * add as last
    lob     AddGadget
.noPos


	move.l	a4,a0
	move.l	windowbase(a5),a1
	sub.l	a2,a2
	lore    Intui,RefreshGadgets



	tst.b	uusikick(a5)
	bne.b	.newK
	; Seems an extra refresh is needed here to get bg correct
	lea	slider1,a0
	bsr	refreshGadgetInA0
.newK

**** paksunnetaan gadujen reunat

* Draw button highlights

	lea	(a4),a3
.loloop
	move.l	(a3),d3

	tst	boxsize(a5)
	bne.b	.visibleBox
	* Skip this one if it is not properly visible
	cmp.l	#gadgetListModeChangeButton,a3
	beq.b	.nel
.visibleBox
	jsr	drawButtonFrameMainWindow
.nel
	move.l	d3,a3
	tst.l	d3
	bne.b	.loloop

* Draw slider highlights

;	tst.b	uusikick(a5)
;	beq.b	.nelq

	tst	boxsize(a5)
	beq.b	.nofs
    bsr     drawFileSlider
.nofs
	movem	slider1+4,plx1/ply1/plx2/ply2	* volumeslider
	add	plx1,plx2
	add	ply1,ply2
	subq	#2,plx1
	addq	#1,plx2
	subq	#2,ply1
	addq	#1,ply2
	move.l	rastport(a5),a1
	bsr	sliderlaatikko


    ; ---------------------------------
    ; Position slider
    tst.b   showPositionSlider(a5)
    beq     .noPosSl
;    lea     gadgetPositionSlider,a0
;    move    gg_LeftEdge(a0),plx1
;    move    gg_TopEdge(a0),ply1
;    move.l  plx1,plx2
;    move.l  ply1,ply2
;    add     gg_Width(a0),plx2
;    add     gg_Height(a0),ply2

    move    buttonRow1TopEdge(a5),ply1
    sub     #12+2,ply1
    move    ply1,ply2
    add     #10+2,ply2

	moveq	#5+WINX,plx1
	move	WINSIZX(a5),plx2
	subq	#8,plx2

    subq    #2,plx2
    sub     gadgetPlayModeChangeButton+gg_Width,plx2

	move.l	rastport(a5),a1
	jsr 	sliderlaatikko
.noPosSl
    ; ---------------------------------

;.nelq

*** Piirret‰‰n korvat
	pushm	all
	lea	button7,a0		* Add
	bsr	printkorva
	lea	lilb1-button7(a0),a0	* M
	bsr	printkorva
	lea	lilb2-lilb1(a0),a0	* S
	bsr	printkorva
	lea	kela2-lilb2(a0),a0	* >, forward
	bsr	printkorva
	lea	plg-kela2(a0),a0	* Prg
	bsr	printkorva
	lea	button8-plg(a0),a0	* Del
	bsr	printkorva
	lea	button2-button8(a0),a0	* i
	bsr	printkorva
	lea	button11-button2(a0),a0	* new
	bsr	printkorva
	lea	button20-button11(a0),a0 * pr
	bsr	printkorva
	lea	button1-button20(a0),a0 * play
	bsr	printkorva
    tst boxsize(a5)
    beq .sk
	lea	gadgetListModeChangeButton-button1(a0),a0
    bsr	printkorva
	lea	gadgetPlayModeChangeButton-gadgetListModeChangeButton(a0),a0
    bsr	printkorva
.sk

 ifd abda

*** Piirret‰‰n 'underlinet'


	move.l	pen_1(a5),d0
	move.l	rastport(a5),a1
	lore	GFX,SetAPen

	lea	button11+4,a3

	movem	(a3),d0/d1
	bsr.b	.dru

	movem	button7-button11(a3),d0/d1
	bsr.b	.dru

	movem	button8-button11(a3),d0/d1
	bsr.b	.dru

	movem	plg-button11(a3),d0/d1
	bsr.b	.dru

	movem	lilb1-button11(a3),d0/d1
	subq	#1,d0
	bsr.b	.dru

	movem	lilb2-button11(a3),d0/d1
	subq	#1,d0
	bsr.b	.dru

	movem	button20-button11(a3),d0/d1
	addq	#6,d0
	bsr.b	.dru
	bra.b	.dru0

.dru
	addq	#4,d0
	add	#11,d1

	movem	d0/d1,-(sp)
	move.l	rastport(a5),a1
	lore	GFX,Move
	movem	(sp)+,d0/d1
	addq	#6,d0
	move.l	rastport(a5),a1
	jmp	_LVODraw(a6)

.dru0
 endc



	popm	all


	jsr	inforivit_clear

    bsr     drawFileBoxFrame

	moveq	#5+WINX,plx1		* infobox
	;move	#254+WINX,plx2
	move	WINSIZX(a5),plx2
	subq	#8,plx2

	;moveq	#10+WINY,ply1
	;moveq	#29+WINY,ply2
	move	infoBoxTopEdge(a5),ply1
	subq	#1,ply1
	;move	infoBoxTopEdge(a5),ply2
	move	ply1,ply2
	;add		#29-10,ply2
	add		infoBoxHeight(a5),ply2
	addq	#2,ply2

	add	windowleft(a5),plx1
	add	windowleft(a5),plx2
	add	windowtop(a5),ply1
	add	windowtop(a5),ply2
	move.l	rastport(a5),a1
	bsr	laatikko2



	tst.l	playingmodule(a5)
	bmi.b	.npl
	jsr	inforivit_play

	tst.b	playing(a5)
	bne.b	.npl
	jsr	inforivit_pause

.npl	st	hippoonbox(a5)
	bsr	shownames


.pienehko
	st	lootassa(a5)        * force refresh titlebar
	clr.b	wintitl2(a5)
	jsr	lootaa
	bsr	reslider

    jsr switchToSearchLayoutIfNeeded
	DPRINT	"wrender done"

	move.l	windowbase(a5),a0
	bsr	setscrtitle
	move.l	keycheckroutine(a5),-(sp)
	rts

drawFileBoxFrame:
	tst	boxsize(a5)		* filebox
	beq.b	.b
	moveq	#28+WINX,plx1
;	move	#253+WINX,plx2
	move	WINSIZX(a5),plx2
	subq	#8,plx2

	;moveq	#61+WINY,ply1
	move	fileBoxTopEdge(a5),ply1
	sub		#2,ply1 * magic offset
	;move	#128+WINY,ply2
	move	fileBoxTopEdge(a5),ply2
	add		#128-61-2,ply2 * magic offset

	add	windowleft(a5),plx1
	add	windowleft(a5),plx2
	add	boxy(a5),ply2
    sub BOTTOM_MARGIN(a5),ply2
	add	windowtop(a5),ply1
	add	windowtop(a5),ply2
	move.l	rastport(a5),a1
	bsr	laatikko1
.b  rts

drawFileSlider:
	movem	slider4+4,plx1/ply1/plx2/ply2	* fileslider
	add	plx1,plx2
	add	ply1,ply2
	subq	#2,plx1
	addq	#1,plx2
	subq	#2,ply1
	addq	#1,ply2
	move.l	rastport(a5),a1
	bra	sliderlaatikko
    
refreshFileSlider:
    lea     gadgetFileSlider,a0
    bra	    refreshGadgetInA0

drawTextureBottomMargin:
    tst     BOTTOM_MARGIN(a5)
    beq     .x
    bsr     getBottomMarginParams
	bsr 	drawtexture
.x  rts

* Common parms for above and bottom routins
getBottomMarginParams:
	move.l	rastport(a5),a2
	moveq	#4,d0
	moveq	#11,d1
	move	WINSIZX(a5),d2
	subq	#6,d2
	move.l	windowbase(a5),a3
	move	wd_Height(a3),d3	
	sub		windowbottom(a5),d3
	subq    #3,d3 * magic constant
    sub     windowtop(a5),d3
    move    d3,d1
    sub     BOTTOM_MARGIN(a5),d1
    subq    #2,d1 * more magic
    * d0 = x start
    * d1 = y start
    * d2 = x end
    * d3 = y end
    rts

* Same as above but clear and clear one top row more,
* also clear only inside the filebox aread
clearBottomMargin:
    tst     BOTTOM_MARGIN(a5)
    beq     .x
    bsr     getBottomMarginParams
    subq    #1,d1

    moveq	#30+WINX,d0
	move    WINSIZX(a5),d2
    sub     #10,d2

	bsr 	tyhjays
.x  rts


* Calculate y-offset related to boxsize value
* Used in placing gfx into the main window.
setboxy:
	move	boxsize(a5),d0

	* original "default" size was 8, so it is relative to that.
	subq	#8,d0
	;muls	#8,d0
	muls	listFontHeight(a5),d0

	* All y-calculations assume that boxy(a5) includes 
	* in it 8 rows of list box lines with 8-pixel tall font.
	* Need to adjust accordingly here.
	move	listFontHeight(a5),d1
	subq	#8,d1	* difference to reference font height 8
	asl	#3,d1
	add	d1,d0

	tst	boxsize(a5)
	bne.b	.x
	subq	#6,d0

.x	move	d0,boxy(a5)
 if DEBUG
 	ext.l	d0
 	moveq	#0,d1
 	move	boxsize(a5),d1
 	moveq	#0,d2
 	move	listFontHeight(a5),d2
 	DPRINT	"boxy=%ld boxsize=%ld fontheight=%ld"
 endif
	rts

* Set font to be used for the list. Also 
* calculates the y-offset magic for gfx placement
* which is relative to the font.
* in:
*   a0 = font to set for the list
setListFont:
	move.l	a0,listfontbase(a5)
    move.l  a0,gadgetSearchStringStringInfo\.extension+sex_Font

	; Dig height for this since it is used widely
	move	tf_YSize(a0),listFontHeight(a5)	
	bra.b	setboxy


front	pushm	all
	move.l	windowbase(a5),d7
	beq.b	.q
.a	move.l	d7,a0
	lore	Intui,WindowToFront
	move.l	d7,a0
	lob	ActivateWindow
	move.l	d7,a0
	bsr	get_rt
	move.l	wd_WScreen(a0),a0
	lob	rtScreenToFrontSafely
.qq	popm	all
	rts

.q	bsr	avaa_ikkuna2	
	move.l	windowbase(a5),d7
	bne.b	.a
	bra.b	.qq

unlockscreen:
	tst.b	uusikick(a5)
	beq.b	.q
	move.l	screenlock(a5),a1
	sub.l	a0,a0
	lore	Intui,UnlockPubScreen
.q	rts


* Called upon IDCMP_NEWSIZE after the user dragged the
* window size gadget. Filebox size is set accoring to window height.
mainWindowSizeChanged
	move.l	windowbase(a5),a0
	tst.b	kokolippu(a5)
	bne.b	.z
	* Store zipped position so it will be saved with prefs
	movem	4(a0),d0/d1
	DPRINT	"zipped move to %ldx%ld"
	movem	d0/d1,windowZippedPos(a5)
.z
	tst.b	win(a5)
	bne.b	.y
.x 	DPRINT	"bail out"
	rts
.y
 if DEBUG
	movem	wd_Width(a0),d0/d1
	movem	winstruc+nw_Width,d2/d3
	DPRINT	"size change to %ldx%ld (orig %ldx%ld)"
 endif
	bsr	getFileboxYStartToD2
	move	wd_Height(a0),d0

	* account for bottom border
	subq	#6,d0
	sub	windowbottom(a5),d0

	sub	d2,d0
	bmi.b	.x
	* Divide to font height pixel rows
	;lsr	#3,d0
	ext.l	d0
	divu	listFontHeight(a5),d0

	* Store new box size
	move	d0,boxsize(a5)
	
 if DEBUG
 	ext.l	d0
	DPRINT	"boxsize=%ld"
 endif

	* Set new boxsize into prefs gadget
	bsr	setprefsbox

	* Signal to make changes happen
	move.b	ownsignal2(a5),d1
	jsr	signalit	
	* Also update prefs window box size value.
	* This doesn't actually update the propgadget position, 
	* ah well.
	bra	updateprefs

* Disables the low right bottom resize gadget by making it 0 pixel wide
disableResizeGadget
	* Hide and disable
	lea	gadgetResize,a1
	clr	gg_Width(a1)
	or	#GFLG_DISABLED,gg_Flags(a1)
	rts


* Enables or disables the resize gadget
configResizeGadget
	bsr.b	disableResizeGadget
	* Check if box is visible?
	tst	boxsize(a5)
	beq.b	enableResizeGadget\.small

* Enables the low right bottom resize gadget
enableResizeGadget
	lea	gadgetResize,a1
	move.l	windowbase(a5),a0

	* Enable and unhide
	and	#~GFLG_DISABLED,gg_Flags(a1)
	move	#6,gg_Width(a1)

	* Set wd_MinSize to correspond to 3 rows
	bsr.b	getFileboxYStartToD2
;	add	#3*8+6,d2
    * NOTE: raise minsize to 5 due to extra space required
    * for search controls and/or list mode buttons
	moveq	#3+2,d0
	mulu	listFontHeight(a5),d0
	* some additional adjustment: bottom border?
	addq	#6+1,d0
	add	windowbottom(a5),d0

	add	d0,d2
	move	d2,wd_MinHeight(a0)

	* Max size too, 47 lines down, total 50
	moveq	#50-3,d0
	mulu	listFontHeight(a5),d0
	add	d0,d2

	move	d2,wd_MaxHeight(a0)


 if DEBUG
	moveq	#0,d0
	move	wd_MinHeight(a0),d0
	moveq	#0,d1
	move	wd_MaxHeight(a0),d1
	DPRINT	"wd_MinHeight=%ld wd_MaxHeight=%ld"
 endif

.old
.small
	rts

* Refresh the resize gadget if possible
refreshResizeGadget:
	tst.b	uusikick(a5)
	beq.b	.x
    * Do if large window
    tst.b   kokolippu(a5)
    beq.b   .x
	push	a0
	lea	gadgetResize,a0
	bsr	refreshGadgetInA0
	pop	a0
.x	rts

* Calculate the start y-position of the filebox 
getFileboxYStartToD2:
	move	fileBoxTopEdge(a5),d2
	subq	#1,d2 * magic constant
;	moveq	#62+WINY,d2

	add	windowtop(a5),d2
	rts
	
*******************************************************************************
* Asettaa ikkunan screentitlen
* a0 = windowbase
setscrtitle
	pushm	d0/d1/a0/a1/a6
	lea	-1.w,a1
	lea	scrtit(pc),a2
	lore	Intui,SetWindowTitles
	popm	d0/d1/a0/a1/a6
	rts



*******************************************************************************
* Sulkee ikkunan
*******
sulje_ikkuna:
	tst.b	win(a5)
	bne.b	.x
.uh	rts
.x	
	bsr	flush_messages
	
	move.l	appwindow(a5),d0
	beq.b	.noapp
	move.l	d0,a0
	lore	WB,RemoveAppWindow
	clr.l	appwindow(a5)
.noapp

	move.l	_IntuiBase(a5),a6		
	move.l	windowbase(a5),d0
	beq.b	.uh
	move.l	d0,a0

	tst.b	kokolippu(a5)
	bne.b	.big
	move.l	4(a0),windowZippedPos(a5)	* Pienen ikkunan koordinaatit
 if DEBUG
 	movem	4(a0),d0/d1
	DPRINT	"Close small window %ldx%ld"
 endif
	bra.b	.small

.big	move.l	4(a0),windowpos(a5)	* Ison ikkunan koordinaatit
 if DEBUG
 	movem	4(a0),d0/d1
	DPRINT	"Close big window %ldx%ld"
 endif

.small
    jsr switchToNormalLayoutNoRefresh
  	jsr	disposeListBoxRegion
	jsr	disposeInfoBoxRegion

	move.l	46(a0),a1		* WB screen addr
	move	14(a1),wbkorkeus(a5)	* WB:n korkeus
	clr.l	windowbase(a5)
	jmp	_LVOCloseWindow(a6)



;freepens
;	move.l	(a5),a0
;	cmp	#39,LIB_VERSION(a0)
;	blo.b	.q
;	move.l	screenlock(a5),a3
;	lea	sc_ViewPort(a3),a3
;	move.l	vp_ColorMap(a3),a3	* ColorMappi
;	move.l	pen_0(a5),d0
;	bsr.b	.burb
;	move.l	pen_1(a5),d0
;	bsr.b	.burb
;	move.l	pen_2(a5),d0
;	bsr.b	.burb
;	move.l	pen_3(a5),d0
;	bsr.b	.burb
;.q	rts
;.burb	move.l	a3,a0
;	lore	GFX,ReleasePen
;	rts



******************************************************************************
* WaitPointer
**************

* TODO: Could use rtLockWindow to replace freezegads and set wait pointer

pon1
setMainWindowWaitPointer:
	pushm	all
	move.l	windowbase(a5),d0
	bra.b	pon0

pon2	pushm	all
	move.l	windowbase2(a5),d0

pon0	beq.b	.q
	move.l	d0,a0
	bsr	get_rt
	lob	rtSetWaitPointer
.q	popm	all
	rts

clearMainWindowWaitPointer:
poff1
	pushm	all
	move.l	windowbase(a5),d0
	bra.b	poff0

poff2	pushm	all
	move.l	windowbase2(a5),d0

poff0	beq.b	.q
	move.l	d0,a0
	lore	Intui,ClearPointer
.q	popm	all
	rts

freezeMainWindowGadgets
	addq.b	#1,freezegads(a5)		* gadgetit jumiin!
	rts

unfreezeMainWindowGadgets
	subq.b	#1,freezegads(a5)
	bpl.b 	.ok
	clr.b   freezegads(a5)
.ok	rts

areMainWindowGadgetsFrozen
	tst.b	freezegads(a5)
	rts

******************************************************************************
* Sanity functions
**************

* Semaphore functions preserve all registers except maybe A0

obtainModuleList
	pushm	a0/a6
	lea 	moduleListSemaphore(a5),a0
	lore    Exec,ObtainSemaphore
	popm	a0/a6
	rts

releaseModuleList
	pushm	a0/a6
	lea 	moduleListSemaphore(a5),a0
	lore    Exec,ReleaseSemaphore
	popm	a0/a6
	rts

obtainModuleData:
	pushm	a0/a6
	lea 	moduleDataSemaphore(a5),a0
	lore    Exec,ObtainSemaphore
	popm	a0/a6
	rts

releaseModuleData:
	pushm	a0/a6
	lea 	moduleDataSemaphore(a5),a0
	lore    Exec,ReleaseSemaphore
	popm	a0/a6
	rts

showOutOfMemoryError
	push	a1
	lea	memerror_t,a1
	jsr	request
	pop 	a1 
	rts

lockMainWindow:
	tst.l	windowbase(a5)
	beq.b	.x
	tst.l	mainWindowLock(a5)
	beq.b	.y
	DPRINT	"Locking window again!",0
	rts
.y	pushm	all
	bsr	get_rt
	move.l	windowbase(a5),a0
	lob    	rtLockWindow
	move.l	d0,mainWindowLock(a5)
	popm	all
.x	rts
	

unlockMainWindow:
	tst.l	mainWindowLock(a5)
	beq.b	.x 
	pushm	all
	bsr	get_rt
	move.l	windowbase(a5),a0
	move.l	mainWindowLock(a5),a1
	lob 	rtUnlockWindow
	clr.l	mainWindowLock(a5)
	popm	all
.x	rts



******************************************************************************
* Grafiikkaa *
**************
* Hipon tulostaminen

HIPPOHEAD_WIDTH = 96
HIPPOHEAD_HEIGHT = 66

inithippo
*** Lasketaan checksummi infoikkunan no-onelle ja unregistered-tekstille.

	check	1

	tst.b	uusikick(a5)
	bne.b	.new

	* Re-map colors to be more kick13 compatible
	* Switch colors 1 and 2
	* %00 = %00
	* %01 = %10
	* %10 = %01
	* %11 = %11
	lea	hippohead,a0
	lea	792(a0),a1
	move	#96*66/8-1,d7
.bytes
	moveq	#$1,d2
.bits
	move.b	(a0),d0
	and	d2,d0
	move.b	(a1),d1
	and	d2,d1
	add 	d1,d0
	cmp	d2,d0
	bne.b	.z
	eor.b	d2,(a0)
	eor.b	d2,(a1)
.z
	add.b   d2,d2
	bne.b	.bits

	addq	#1,a0
	addq	#1,a1
	dbf	d7,.bytes

.new

	lea	bitmapHippoHead(a5),a2
	move.l	a2,a0
	moveq	#2,d0
	moveq	#HIPPOHEAD_WIDTH,d1
	moveq	#HIPPOHEAD_HEIGHT,d2
	lore	GFX,InitBitMap
	move.l	#hippohead,bm_Planes(a2)
	move.l	#hippohead+792,bm_Planes+4(a2)
	rts

 ifeq zoom
* tavallinen hipon p‰‰
printhippo1:
;	DPRINT	"Print hippo"

	tst	boxsize(a5)
	beq.b	.q
	tst.b	win(a5)
	bne.b	.yep
.q	rts
.yep
	pushm	d0-d7/a0-a2/a6
	move.b	reghippo(a5),d7
	clr.b	reghippo(a5)

	* no registered name? 
	tst.b	keyfile(a5)
	beq.b	.noreg
	cmp.b	#' ',keyfile(a5)
	bne.b	.az
.noreg	moveq	#0,d7
.az


	moveq	#0,d0		* l‰hde x,y
	moveq	#0,d1
	moveq	#HIPPOHEAD_HEIGHT,d5		* y-koko

	; Calc y-position
	move	fileBoxTopEdge(a5),d3

	move	boxsize(a5),d6
    tst.w   searchLayoutActive(a5)   
    beq.b   .lm1
    subq    #SEARCH_BOXSIZE_DELTA,d6
.lm1

	mulu	listFontHeight(a5),d6
	sub	d5,d6
	bmi.b	.r	; will it fit?
	lsr	#1,d6	; center it 
	add	d6,d3	

	;moveq	#92,d2		* kohde x
	move	WINSIZX(a5),d2
	lsr	#1,d2
	sub	#HIPPOHEAD_WIDTH/2-8,d2

	tst.b	d7
	beq.b	.e
	move	#150,d2		* position when registered
.e


	lea	bitmapHippoHead(a5),a0
	move.l	rastport(a5),a1		* main
	add	windowleft(a5),d2
	add	windowtop(a5),d3
;	move	#$ee,d6		* minterm, kopio a or d ->d
	move	#$c0,d6		* minterm, suora kopio
	moveq	#HIPPOHEAD_WIDTH,d4		* x-koko
	lore	GFX,BltBitMapRastPort
.r	popm	d0-d7/a0-a2/a6
	rts
 else

printhippo1
* zoomaava hipon p‰‰
	tst.b	win(a5)
	bne.b	.yep
	;beq.b	.q
	;tst.b	uusikick(a5)
	;bne.b	.yep
.q	;rts
.yep
	pushm	all
	move.b	reghippo(a5),d7
	clr.b	reghippo(a5)

	lea	-(bm_SIZEOF+bsa_SIZEOF)(sp),sp
	move.l	sp,a4
	lea	bm_SIZEOF(a4),a3

	move.l	sp,a0
	moveq	#(bm_SIZEOF+bsa_SIZEOF)/2-1,d0
.cl	clr	(a0)+
	dbf	d0,.cl

	tst	boxsize(a5)
	beq	.r

	move.l	#224,d0
	move.l	#400*2,d1		* 2 planea
	lore	GFX,AllocRaster
	tst.l	d0
	beq	.r
	move.l	d0,a2

	move.l	a4,a0
	moveq	#2,d0
	move	#220,d1		* leveys 220
	move	#400,d2		* korkeus 400
	lob	InitBitMap
	move.l	a2,bm_Planes(a4)
	lea	(224/8)*400(a2),a0
	move.l	a0,bm_Planes+4(a4)


* alkup. x: 96, y: 66
* max  x: 220, y: 400

	moveq	#HIPPOHEAD_WIDTH,d0
	moveq	#HIPPOHEAD_HEIGHT,d1

	move	d0,bsa_SrcWidth(a3)
	move	d1,bsa_SrcHeight(a3)
	move	d0,bsa_XSrcFactor(a3)
	move	d1,bsa_YSrcFactor(a3)
	move	d0,bsa_XDestFactor(a3)
	move	d1,bsa_YDestFactor(a3)

	move.l	a4,bsa_DestBitMap(a3)
	pushpea	bitmapHippoHead(a5),bsa_SrcBitMap(a3)


	move.l	windowbase(a5),a0
	move	wd_Height(a0),d0
	sub	#88,d0

	move	d0,bsa_YDestFactor(a3)

	move	d0,d1
	add	#30,d1

	move	#220,d2
	tst.b	d7
	beq.b	.ne0
	moveq	#94,d2
.ne0

	cmp	d2,d1
	blo.b	.e
	move	d2,d1
.e
	move	d1,bsa_XDestFactor(a3)

	move.l	a3,a0
	lob	BitMapScale


	moveq	#0,d0		* l‰hde x
	moveq	#0,d1		* y
	moveq	#79+1,d3	* y
	move	bsa_DestWidth(a3),d4
	move	bsa_DestHeight(a3),d5


	move	#32+220/2+3,d2	* kohde x
	move	d4,d6
	lsr	#1,d6
	sub	d6,d2

	tst.b	d7
	beq.b	.ne
	move	#160,d2
.ne


	move.l	a4,a0
	move.l	rastport(a5),a1		* main
	add	windowleft(a5),d2
	add	windowtop(a5),d3
	move	#$ee,d6		* minterm, kopio a or d ->d
	lob	BltBitMapRastPort

	move.l	a2,d0
	beq.b	.r
	move.l	a2,a0
	move.l	#224,d0
	move.l	#400*2,d1		* 2 planea
	lob	FreeRaster

.r	
	
	lea	(bm_SIZEOF+bsa_SIZEOF)(sp),sp
	
	popm	all
	rts
 endc
	

** Print into scope window
printHippoScopeWindow
	;tst.b	uusikick(a5)
	;bne.b	.yep
	;rts
;.yep	
	pushm	d0-d6/a0-a2/a6
	lea	bitmapHippoHead(a5),a0
	move.l	s_rastport3(a4),a1		* quad
	moveq	#0,d0	
	moveq	#0,d1


	* Center hippohead into scope window
	move.l	s_scopeWindowBase(a4),a2 
	move	wd_Width(a2),d2
	lsr	#1,d2
	sub	#HIPPOHEAD_WIDTH/2,d2

	move	#14,d3
	move	s_scopeDrawAreaHeight(a4),d4
	sub	#SCOPE_DRAW_AREA_HEIGHT_DEFAULT,d4
	asr	#1,d4
	add	d4,d3

	moveq	#HIPPOHEAD_WIDTH,d4	
	moveq	#HIPPOHEAD_HEIGHT,d5
	add	windowleft(a5),d2
	add	windowtop(a5),d3
	move	#$c0,d6			* suora kopio
	lore	GFX,BltBitMapRastPort
	popm	d0-d6/a0-a2/a6
	rts


*********

initkorva
	lea	omabitmap4(a5),a2
	move.l	a2,a0
	moveq	#2,d0
	moveq	#16,d1
	moveq	#4,d2
	lore	GFX,InitBitMap
	move.l	#korvadata,bm_Planes(a2)
	move.l	#korvadata+8,bm_Planes+4(a2)
	rts

initkorva2
	lea	omabitmap5(a5),a2
	move.l	a2,a0
	moveq	#2,d0
	moveq	#16,d1
	moveq	#4,d2
	lore	GFX,InitBitMap
	move.l	#korvadata2,bm_Planes(a2)
	move.l	#korvadata2+8,bm_Planes+4(a2)
	rts

* d2 = x
* d3 = y

* a0 = Gadget
printkorva2
	pushm	d0-d7/a0-a2/a6
	move.l	rastport2(a5),a1	* prefs
	lea	omabitmap4(a5),a2
	bra.b	pkor

* Draw the RMB ear symbol 
* a0 = Gadget
printkorva
	tst.b	win(a5)
	bne.b	.q
	rts
.q
	pushm	d0-d7/a0-a2/a6
	move.l	rastport(a5),a1		* main
	lea	omabitmap5(a5),a2
	tst.b	uusikick(a5)
	bne.b	pkor
	lea	omabitmap4(a5),a2	* kick13: korva ilman tausta patternia

pkor
	movem	gg_LeftEdge(a0),d2/d3
	add	gg_Width(a0),d2
	subq	#4,d2

	moveq	#0,d0		* l‰hde x,y
	moveq	#0,d1
	moveq	#5,d4		* x-koko
	moveq	#4,d5		* y-koko

	move	#$c0,d6		* minterm, suora kopio a->d
	move.l	a2,a0
	lore	GFX,BltBitMapRastPort
.r	popm	d0-d7/a0-a2/a6
	rts


******** Tick-merkki

inittick
	lea	omabitmap3(a5),a2
	move.l	a2,a0
	moveq	#1,d0			* planes
	moveq	#16,d1			* lev
	moveq	#7,d2			* kork
	lore	GFX,InitBitMap
	move.l	#tickdata,bm_Planes(a2)
	rts

* d0 = <>0: aseta merkki, muutoin tyhjenn‰ alue
* d2/d3 = kohde x,y
* a0 = gadget

tickaa:	pushm	d0-d6/a0-a2/a6
    move    #GFLG_DISABLED,d6
    and.w   gg_Flags(a0),d6
    bne     .x
    
	move	#$c0,d6			* suora kopio
;	move	#$ee,d6			* D: A or D
	tst.b	d0
	bne.b	.set
	moveq	#$0a,d6		* clear
.set

	movem	gg_LeftEdge(a0),d2/d3
	addq	#7,d2
	addq	#2+1,d3
	
	lea	omabitmap3(a5),a0
	move.l	rastport2(a5),a1		* prefs
	moveq	#0,d0				* l‰hde x,y
	moveq	#0,d1
	moveq	#16,d4				* koko x,y
	moveq	#7,d5
;	add	windowleft(a5),d2
;	add	windowtop(a5),d3
	lore	GFX,BltBitMapRastPort
.x
	popm	d0-d6/a0-a2/a6
	rts




*******************************************************************************
* Merkkijonon muotoilu
*******
desmsg:
	movem.l	d0-d7/a0-a3/a6,-(sp)
	lea	desbuf(a5),a3	;puskuri
ulppa	move.l	sp,a1		* parametrit ovat t‰‰ll‰!
pulppa	lea	putc(pc),a2	;merkkien siirto
	move.l	(a5),a6
	lob	RawDoFmt
	movem.l	(sp)+,d0-d7/a0-a3/a6
	rts
putc	move.b	d0,(a3)+	
	rts


desmsg2:
	movem.l	d0-d7/a0-a3/a6,-(sp)
	lea	desbuf2(a5),a3
	bra.b	ulppa

* a3 = desbuf
desmsg3:
	movem.l	d0-d7/a0-a3/a6,-(sp)
	bra.b	ulppa


* a3 = desbuf

 if DEBUG 


desmsgDebugAndPrint:
	* sp contains the return address, which is
	* the string to print
	movem.l	d0-d7/a0-a3/a6,-(sp)
	* get string
	move.l	4*(8+4+1)(sp),a0
	* find end of string
	move.l	a0,a1
.e	tst.b	(a1)+
	bne.b	.e
	move.l	a1,d7
	btst	#0,d7
	beq.b	.even
	addq.l	#1,d7
.even
	* overwrite return address 
	* for RTS to be just after the string
	move.l	d7,4*(8+4+1)(sp)

	lea	debugDesBuf+var_b,a3
	move.l	sp,a1	
 ifne SERIALDEBUG
    lea     putCharSerial(pc),a2
    move.b	#"H",d0
    bsr     putCharSerial
    move.b	#"i",d0
    bsr     putCharSerial
    move.b	#"P",d0
    bsr     putCharSerial
    move.b	#":",d0
    bsr     putCharSerial
 else
	lea	putc(pc),a2	
 endif
	move.l	4.w,a6
	lob	RawDoFmt
	movem.l	(sp)+,d0-d7/a0-a3/a6
 ifeq SERIALDEBUG
	bsr	PRINTOUT_DEBUGBUFFER
 endif
	rts	* teleport!

putCharSerial
    ;_LVORawPutChar
    ; output char in d0 to serial
    move.l  4.w,a6
    jsr     -516(a6)
    rts

 endif

*******************************************************************************
* Laatikoiden piirto
*******

* Taalla bugaa joku, kun kaatuu P96 ja MCP

* d0 = x1
* d1 = y1
* d2 = x2
* d3 = y2



** bevelboksit, reunat kaks pixeli‰

laatikko1:
	move.l	pen_2(a5),d3
	move.l	pen_1(a5),d2
	bra.b	laatikko0

laatikko2:
	move.l	pen_1(a5),d3
	move.l	pen_2(a5),d2

;	bra.b	laatikko0


* In:
*   d2 = pen 1
*   d3 = pen 2
*   d4 = x1
*   d5 = y1
*   d6 = x2
*   d7 = y2
*   a1 = rastport 
laatikko0:
	tst.b	uusikick(a5)
	bne.b	.new
	exg	d2,d3
.new

	move.l	a1,a3
	move	d2,a4
	move	d3,a2

** valkoset reunat

	move	a2,d0
	move.l	a3,a1
	lore	GFX,SetAPen

	move	plx2,d0		* x1
	subq	#1,d0		
	move	ply1,d1		* y1
	move	plx1,d2		* x2
	move	ply1,d3		* y2
	bsr	drawli

	move	plx1,d0		* x1
	move	ply1,d1		* y1
	move	plx1,d2
	addq	#1,d2
	move	ply2,d3
	bsr	drawli
	
** mustat reunat

	move	a4,d0
	move.l	a3,a1
	lob	SetAPen

	move	plx1,d0
	addq	#1,d0
	move	ply2,d1
	move	plx2,d2
	move	ply2,d3
	bsr.b	drawli

	move	plx2,d0
	move	ply2,d1
	move	plx2,d2
	move	ply1,d3
	bsr.b	drawli

	move	plx2,d0
	subq	#1,d0
	move	ply1,d1
	addq	#1,d1
	move	plx2,d2
	subq	#1,d2
	move	ply2,d3
	bsr.b	drawli

looex	move.l	pen_1(a5),d0
	move.l	a3,a1
	jmp	_LVOSetAPen(a6)
	
** bevelboksi, reunat 1 pix

laatikko3

	move.l	a1,a3
	move.l	pen_2(a5),a2
	move.l	pen_1(a5),a4

	tst.b	uusikick(a5)
	bne.b	.new
	exg	a2,a4
.new

	move	a4,d0
	move.l	a3,a1
	lore	GFX,SetAPen

	move	plx1,d0
	move	ply2,d1
	move	plx1,d2
	move	ply1,d3
	bsr.b	drawli

	move	plx1,d0
	move	ply1,d1
	move	plx2,d2
	move	ply1,d3
	bsr.b	drawli

	move	a2,d0
	move.l	a3,a1
	lob	SetAPen

	move	plx2,d0
	move	ply1,d1
	addq	#1,d1
	move	plx2,d2
	move	ply2,d3
	bsr.b	drawli

	move	plx2,d0
	move	ply2,d1
	move	plx1,d2
	addq	#1,d2
	move	ply2,d3
	bsr.b	drawli

	bra.b	looex



drawli	cmp	d0,d2
	bhi.b	.e
	exg	d0,d2
.e	cmp	d1,d3
	bhi.b	.x
	exg	d1,d3
.x	move.l	a3,a1
	move.l	_GFXBase(a5),a6
	jmp	_LVORectFill(a6)


** muikea sliderkehys



sliderlaatikko:
;	rts
	
	move.l	a1,a3
	move.l	pen_1(a5),a2
	move.l	pen_2(a5),a4

	tst.b	uusikick(a5)
	bne.b	.new
	exg	a2,a4
.new

** valkoset reunat

	move	a4,d0
	move.l	a3,a1
	lore	GFX,SetAPen

	move	plx2,d0
	move	ply1,d1
	move	plx1,d2
	move	ply1,d3
	bsr.b	drawli

	move	plx1,d0
	move	ply1,d1
	move	plx1,d2
	move	ply2,d3
	bsr.b	drawli

	move	plx1,d0
	addq	#2,d0
	move	ply2,d1
	subq	#1,d1
	move	plx2,d2
	subq	#1,d2
	move	ply2,d3
	subq	#1,d3
	bsr.b	drawli

	move	plx2,d0
	subq	#1,d0
	move	ply2,d1
	subq	#1,d1
	move	plx2,d2
	subq	#1,d2
	move	ply1,d3
	addq	#2,d3
	bsr.b	drawli

** mustat

	move	a2,d0
	move.l	a3,a1
	lob	SetAPen

	move	plx2,d0
	move	ply1,d1
	addq	#1,d1
	move	plx2,d2
	move	ply2,d3
	bsr 	drawli

	move	plx2,d0
	move	ply2,d1
	move	plx1,d2
	addq	#1,d2
	move	ply2,d3
	bsr	drawli

	move	plx1,d0
	addq	#1,d0
	move	ply2,d1
	move	plx1,d2
	addq	#1,d2
	move	ply1,d3
	addq	#1,d3
	bsr	drawli

	move	plx1,d0
	addq	#1,d0
	move	ply1,d1
	addq	#1,d1
	move	plx2,d2
	subq	#1,d2
	move	ply1,d3
	addq	#1,d3
	bsr	drawli

	bra	looex


*******************************************************************************
* Tyhjent‰‰ alueen ikkunasta
*******
* d0 = x1
* d1 = y1
* d2 = x2
* d3 = y2
tyhjays:
	tst.b	win(a5)
	beq.b	.q
	movem.l	d0-a6,-(sp)
	sub	d0,d2
	sub	d1,d3
	move	d2,d4
	move	d3,d5
	addq	#1,d4
	addq	#1,d5
 	move.l	rastport(a5),a0
	move.l	a0,a1
	add	windowleft(a5),d0
	add	windowtop(a5),d1
	move	d0,d2
	move	d1,d3
	moveq	#$0a,d6
	lore	GFX,ClipBlit
	movem.l	(sp)+,d0-a6
.q	rts


*******************************************************************************
* Pullautetaan ikkuna p‰‰limm‰iseksi
*******
poptofront
	movem.l	d0-a6,-(sp)
	lea	var_b,a5
	move	#$25,rawkeyinput(a5)
	tst.b	win(a5)
	beq.b	.now
	clr	rawkeyinput(a5)
.now	move.b	rawKeySignal(a5),d1
	jsr	signalit
	movem.l	(sp)+,d0-a6
	rts


*******************************************************************************
* Muistin k‰sittely‰
*******

* d0=koko
* d1=tyyppi
getmem:
	movem.l	d1/d3/a0/a1/a6,-(sp)
 ifne DEBUG
	add.l	d0,getmemTotal
	addq.l	#1,getmemCount
 endc
	addq.l	#4,d0
	move.l	d0,d3
	move.l	4.w,a6
	lob	AllocMem
	tst.l	d0
	beq.b	.err
	move.l	d0,a0
	move.l	d3,(a0)+
	move.l	a0,d0
.err	movem.l	(sp)+,d1/d3/a0/a1/a6
	rts

* a0=osoite
freemem:
	movem.l	d0/d1/a0/a1/a6,-(sp)
 ifne DEBUG
	addq.l	#1,freememCount
 endc
	move.l	a0,d0
	beq.b	.n
	move.l	-(a0),d0
	move.l	a0,a1
	move.l	4.w,a6
	lob	FreeMem
.n	movem.l	(sp)+,d0/d1/a0/a1/a6
	rts


;freeearly
;	pushm	all

;	move.l	(a5),a6
;	move.l	earlymoduleaddress(a5),d0
;	beq.b	.ee
;	move.l	d0,a1
;	move.l	earlymodulelength(a5),d0
;	beq.b	.ee

;	lob	FreeMem
;	clr.l	earlymoduleaddress(a5)
;	clr.l	earlymodulelength(a5)

;.ee	
;	move.l	earlytfmxsamples(a5),d0
;	beq.b	.eee
;	tst.b	earlylod_tfmx(a5)
;	bne.b	.cl
;	move.l	d0,a1
;	move.l	earlytfmxsamlen(a5),d0
;	lob	FreeMem
;.cl	clr.l	earlytfmxsamples(a5)
;	clr.l	earlytfmxsamlen(a5)
;	clr.b	earlylod_tfmx(a5)
;.eee	
;	popm	all
;	rts




freemodule:
	movem.l	d0-a6,-(sp)

	DPRINT	"freemodule obtain data"
	bsr	obtainModuleData

	* Need to clear playertype(a5) to avoid
    * following freemodules to maybe mistakenly thing
    * that UnLoadSeg() is needed.

	clr	playertype(a5)
	clr.b	modulename(a5)
	clr.b	moduletype(a5)
	clr.b	kelausnappi(a5)
	clr.b	do_early(a5)
	clr.b	oldst(a5)
	clr.b	sidflag(a5)
	clr	ps3minitcount
	clr.b	ahi_use_nyt(a5)

	clr	pos_maksimi(a5)
	clr	pos_nykyinen(a5)
;	st	positionmuutos(a5)
	clr	positionmuutos(a5)
	clr	songnumber(a5)
	clr 	maxsongs(a5)
	clr 	minsong(a5)
    clr.l   kokonaisaika(a5)     
	* For non-EP players supporting patterninfo
	clr.l	deliPatternInfo(a5) 
	jsr	clearScopeData
    jsr     uslClearSongData
    jsr     uslUmeClear
	
;	bsr	lootaa
	bsr	inforivit_clear

	* free replay code, this label here is silly
	* all of them are in the same address
	* with different labels
	lea	ps3mroutines(a5),a0		* vapautetaan replayeri
	jsr	freereplayer
	jsr	freeDeliPlayer


    move.l  moduleAddressLoadSeg(a5),d1
    beq     .noSegs
    clr.l   moduleAddressLoadSeg(a5)
	lore	Dos,UnLoadSeg
	DPRINT	"UnLoadSeg!"
.noSegs

    bsr     justFreeModuleData

;	tst.l	keyfile+44(a5)	* datan v‰lilt‰ 38-50 pit‰‰ olla nollia
;	beq.b	.zz
;	move.l	tempexec(a5),a0
;	addq.l	#1,IVVERTB+IV_DATA(a0)
;.zz

	jsr	sulje_foo	

.ee	

	* See if there are TFMX samples that can be freed
	move.l	tfmxsamplesaddr(a5),d0
	beq.b	.noTFMX
	DPRINT	"Free extra data 0x%lx"
	move.l	d0,a1
	move.l	tfmxsampleslen(a5),d0
	lob	FreeMem
.noTFMX
	clr.l	tfmxsamplesaddr(a5)
	clr.l	tfmxsampleslen(a5)
	clr.b	lod_tfmx(a5)
	DPRINT	"freemodule release data"
	bsr	releaseModuleData

	movem.l	(sp)+,d0-a6
	rts

justFreeModuleData:
    move.l	(a5),a6
	move.l	moduleaddress(a5),d0
	beq.b	.ee
	move.l	d0,a1
	move.l	modulelength(a5),d0
	beq.b	.ee
	lob	FreeMem
.ee
	clr.l	moduleaddress(a5)
	clr.l	modulelength(a5)
    rts


*******************************************************************************
* Volumen feidaus
********
fadevolumedown
	movem.l	d1-a6,-(sp)
	move	mainvolume(a5),d7
	move	d7,d6

	tst.b	fade(a5)
	beq.b	.nop
	tst.l	playingmodule(a5)
	bmi.b	.nop
	tst.b	playing(a5)
	beq.b	.nop
	move.l	playerbase(a5),a0
	moveq	#pf_volume,d0
	and	p_liput(a0),d0
	beq.b	.nop

	cmp	#pt_multi,playertype(a5)	* onko ps3m?
	bne.b	.loop
	move.l	priority(a5),d5
	move.b	#10,priority+3(a5)
	bsr	mainpriority
.loop
	moveq	#1,d1
	lore	Dos,Delay

	move	d6,mainvolume(a5)
	move.l	playerbase(a5),a0
	jsr	p_volume(a0)
	subq	#1,d6
	cmp	#-1,d6
	bne.b	.loop

	cmp	#pt_multi,playertype(a5)	* onko ps3m?
	bne.b	.nop
	move.l	d5,priority(a5)
	bsr.b	mainpriority

.nop	

	

	move	d7,d0
	movem.l	(sp)+,d1-a6
	rts


fadevolumeup
	movem.l	d1-a6,-(sp)
	move	mainvolume(a5),d7
	addq	#1,d7
	moveq	#0,d6

	tst.b	fade(a5)
	beq.b	.nop
	tst.l	playingmodule(a5)
	bmi.b	.nop
	tst.b	playing(a5)
	beq.b	.nop
	move.l	playerbase(a5),a0
	moveq	#pf_volume,d0
	and	p_liput(a0),d0
	beq.b	.nop

	cmp	#pt_multi,playertype(a5)	* onko ps3m?
	bne.b	.loop
	move.l	priority(a5),d5
	move.b	#10,priority+3(a5)
	bsr.b	mainpriority
.loop
	moveq	#1,d1
	lore	Dos,Delay

	move	d6,mainvolume(a5)
	move.l	playerbase(a5),a0
	jsr	p_volume(a0)
	addq	#1,d6
	cmp	d6,d7
	bne.b	.loop

	cmp	#pt_multi,playertype(a5)	* onko ps3m?
	bne.b	.nop
	move.l	d5,priority(a5)
	bsr.b	mainpriority

.nop	
	movem.l	(sp)+,d1-a6
	rts


*******************************************************************************
* Asettaa p‰‰ohjelman prioriteetin
******** 

mainpriority
	pushm	d0/d1/a0/a1/a6
	move.l	owntask(a5),a1		* asetetaan p‰‰ohjelman prioriteetin
	move.l	priority(a5),d0
	lore	Exec,SetTaskPri
	popm	d0/d1/a0/a1/a6
	rts




******************************************************************************
* Hiiren nappeja painettiin
* Mouse button handler
*******
* in:
*   d3=im_Code

* SELECTDOWN: left button down
* SELECTUP: left button up
* MENUDOWN: right button down
* MENUUP: right button up

buttonspressed:
	tst.b	win(a5)			* onko ikkuna auki?
	beq	.nowindow

	* Any button activity should first close any active tooltip
	jsr	closeTooltipPopup

	cmp	#SELECTDOWN,d3		* left button down
	bne.b	.test1
	bsr	.leftButtonDownAction

    * Get rid of the find bar if possible
    jmp     switchToNormalLayoutIfPossible

.test1
	cmp	#MENUUP,d3
	bne.b	.test2
	bra	.rightButtonUpAction		* right button up 

.test2	cmp	#MENUDOWN,d3			* right button down
	bne.b 	.exit
	bsr.b	.rightButtonDownAction
.exit 
	rts
	
.rightButtonDownAction

* Oikeata nappulaa painettu. Tutkitaan oliko rmbfunktio-nappuloiden p‰‰ll‰

	tst.b	kokolippu(a5)		* onko pienen‰?
	beq.b	.nowindow

** onko lootan p‰‰ll‰
** on top of the filebox?
	move	mousex(a5),d0
	move	mousey(a5),d1
	sub	windowleft(a5),d0
	sub	windowtop(a5),d1	* suhteutus fonttiin

	cmp	#7+WINX,d0
	blo.b	.y
	cmp	#70+WINX,d0	* 247
	bhi.b	.y
	cmp	#10+WINY,d1
	blo.b	.y
	cmp	#30+WINY,d1
	bhi.b	.y

** toggle scope with rmb when on top of suitable place
	jsr	toggleScopes

.handled
	rts
.y

** check buttons with RMB functions defined and trigger those

	DPRINT	"RMB DOWN check"

	lea	rightButtonActionsList,a2
.actionLoop
	move.l	a2,a0
	add	(a2)+,a0
	move.l	(a2)+,a1
	bsr 	.rightButtonDownCheck
	beq.b	.handled
	tst.w	(a2) 
	bne.b	.actionLoop

	* no RMB actions found
	* try line marking
	jsr	marklineRightMouseButton
	beq.b	.nothingMarked
	rts

.nothingMarked
	* Last RMB action,
	* Zip Window 
.nowindow

	tst.b	uusikick(a5)
	bne.b	.new
	bsr	sulje_ikkuna		* Vaihdetaan ikkunan kokoa (kick1.3)
	bra	avaa_ikkuna

.new	
	DPRINT	"ZipWindow Intuition"
	move.l	windowbase(a5),a0	* Kick2.0+
	lore	Intui,ZipWindow
	rts

.leftButtonDownAction

* jos oli lootan p‰‰ll‰ niin avataan info ikkuna!
	move	mousex(a5),d0
	move	mousey(a5),d1
	sub	windowleft(a5),d0
	sub	windowtop(a5),d1	* suhteutus fonttiin

	cmp	#7+WINX,d0
	blo.b	.x
	cmp	#70+WINX,d0	* 247
	bhi.b	.x
	cmp	#10+WINY,d1
	blo.b	.x
	cmp	#30+WINY,d1
	blo.b	.yea

	* mouse not on top of info box, try marking files

.x	jmp	markline		* merkit‰‰n modulenimi

.yea

** modinfon infon avaus
	bra	modinfoaaa

* in:
*   a0=gadget
*   a1=gadget function to run
* out:
*  Z-flag set: event handled
.rightButtonDownCheck
	bsr	checkMouseOnGadget
	bne.b	.mouseNotOn
    * RMB on a disabled gadget eats the event
    move.w  gg_Flags(a0),d0     
    and.w   #GFLG_DISABLED,d0
    bne     .rmbHandled
	move.l	a0,rightButtonSelectedGadget(a5)
	move.l	a1,rightButtonSelectedGadgetRoutine(a5)
	bsr	forceSelectGadget
.rmbHandled
	moveq	#0,d0
.mouseNotOn
	rts

* Right button has been released.
* Check if there was a right button activation on a gadget.
* If the pointer is still on that gadget, run the routine.
.rightButtonUpAction
	move.l	rightButtonSelectedGadget(a5),d2
	beq.b	.noGadget

	DPRINT	"RMB UP"

	* In any case RMB selected gadgets should be deselected when now.
	*
	* The display memory gets XORred and acts as internal state
	* even if select flag is cleared and gadget is refreshed.
	* Toggling select and deselect again results in a neutral
	* toggle button look.
	move.l	d2,a0
	bsr	forceDeselectGadget
	move.l	d2,a0
	bsr	forceSelectGadget
	move.l	d2,a0
	bsr	forceDeselectGadget
	
	move.l	d2,a0
	bsr 	checkMouseOnGadget
	bne.b	.xy	

	* Pointer was on top, run the routine
	move.l	rightButtonSelectedGadgetRoutine(a5),d0
	beq.b	.xy
	move.l	d0,a0
	DPRINT	"Execute routine"
	jsr	(a0)
.xy
	clr.l	rightButtonSelectedGadget(a5)
	clr.l	rightButtonSelectedGadgetRoutine(a5)
.noGadget
	rts


*** Zoomataan fileboxi pois tai takasin
*** Switch filebox size
zoomfilebox
	DPRINT	"Zoom filebox"
    tst.w   searchLayoutActive(a5)      
    beq .1
    * Disable this for search mode, there are extra controls at the bottom
    rts
.1
	move	boxsize(a5),d0
	beq.b	.z
	clr	boxsize(a5)
	move	d0,boxsizez(a5)
	bsr	disableResizeGadget
	bra.b	.x
.z
	move	boxsizez(a5),boxsize(a5)
	bsr	enableResizeGadget
.x
	bsr	setprefsbox
	move.b	ownsignal2(a5),d1
	jmp	signalit		* prefsp‰ivitys-signaali
	

*** Open module info window
modinfoaaa
	DPRINT	"modinfo"
	* flag: display mod info
	clr.b	infolag(a5)
	tst	info_prosessi(a5)
	beq.b	.zz	
	move.l	infotaz(a5),a0		* jos oli jo modinfo niin suljetaan
	cmp.l	#about_t,a0
	beq	.start
    jmp	sulje_info
.start
    jmp start_info

.zz	
    jmp	rbutton10b

* Forces a boolean gadget to show the selected status
* in:
*   a0=gadget
forceSelectGadget
	move.l	a0,d2
	move.l	windowbase(a5),a0
	move.l	d2,a1 
	lore	Intui,RemoveGadget

	move.l	d2,a1
	or	#GFLG_SELECTED,gg_Flags(a1)

	move.l	windowbase(a5),a0
	moveq	#-1,d0 
	lob	AddGadget
	move.l	d2,a0	
	bra.b	refreshGadget

* Forces a boolean gadget to show the deselected status
* in:
*   a0=gadget
forceDeselectGadget

	move.l	a0,d2
	move.l	windowbase(a5),a0
	move.l	d2,a1 
	lore	Intui,RemoveGadget

	move.l	d2,a1
	and	#~GFLG_SELECTED,gg_Flags(a1)

	move.l	windowbase(a5),a0
	moveq	#-1,d0 
	lob	AddGadget

	move.l	d2,a0	
	;bra.b	refreshGadget

* Redraws gadget
* in:
*   a0=gadget
refreshGadget:
refreshGadgetInA0:
	move.l	windowbase(a5),a1
	sub.l	a2,a2
	moveq	#1,d0	
	lore	Intui,RefreshGList
	rts


* Checks if mouse pointer is within given gadget in main window
* in: 
*   a0=gadget
* destroys:
*   d0-d3, d6, d7
* out:
*   d0 = 0  was inside
*   d0 = -1 was not inside
checkMouseOnGadget
    * Special case: skip search layout gadgets if not active
    tst.w   searchLayoutActive(a5)
    bne     .srch
    cmp.l   #gadgetSearchString,a0
    beq     .xx
    cmp.l   #gadgetSearchSource,a0
    beq     .xx
.srch

	movem	gg_LeftEdge(a0),d0-d3
	move	mousex(a5),d6
	move	mousey(a5),d7
	subq	#1,d3
	add	d0,d2
	add	d1,d3
	cmp	d0,d6
	blo.b	.xx
	cmp	d2,d6
	bhi.b	.xx
	cmp	d1,d7
	blo.b	.xx
	cmp	d3,d7
	bhi.b	.xx
	moveq	#0,d0			* kelpaa
	rts
.xx	moveq	#-1,d0
	rts


******************************************************************************
* Tooltip handling
*******

 STRUCTURE TooltipListEntry,0
    	UWORD ttle_gadget
    	UWORD ttle_tooltip
 LABEL  ttle_SIZEOF

 STRUCTURE ToolTip,0
    	UBYTE tt_width
	UBYTE tt_height
	APTR  tt_text
 LABEL  tt_SIZEOF

* Tooltip handler
* Called when a mouse move event is received.
* It will close any existing tooltip and set up a new one if needed.
tooltipHandler
	;DPRINT	"tooltiphandler"

	* First, inactivate incoming tooltip
	bsr	deactivateTooltip
	
	* Close any tooltip that may be showing since mouse was moving.
	jsr	closeTooltipPopup

	* Check if window is zipped to toolbar size
	tst.b	kokolippu(a5)
	beq.b	.exit

	* If some lengthy operation is going on lets not
	* try to display tooltips.
	bsr	areMainWindowGadgetsFrozen
	bne.b	.exit

	* Skip further checks if mouse is not over the main button area
	move	mousey(a5),d1

	* Check if above "Play" button
	;lea	gadgetPlayButton,a0
	lea	gadgetPositionSlider,a0
	move	gg_TopEdge(a0),d2
	cmp	d1,d2
	blo.b	.under
	* Mouse is above the "Play" button, exit	
	rts
.under		
;	* Check if below the "New" button
;	;lea	gadgetNewButton,a0
;	lea	gadgetListModeChangeButton,a0
;	move	gg_TopEdge(a0),d2
;	add	gg_Height(a0),d2
;	cmp	d1,d2
;	bhi.b	.below
;	* Mouse is below the "New" button, exit
;	rts
;.below

	* Then check if pointer is on top of some gadget
	lea tooltipList,a3
.loop 
	lea	ttle_gadget(a3),a0
	add	(a0),a0

	* Check if gadget is disabled, no tooltips for those
	move	gg_Flags(a0),d0
	and	#GFLG_DISABLED,d0
	bne.b	.disabled

	bsr  	checkMouseOnGadget
	bne 	.no
	* Yes it was.
	* Check if this gadget was not allowed to have tooltips for now
	cmp.l  disableTooltipForGadget(a5),a0
	beq.b	.disabled
	* Store tooltip to be displayed and activate
	lea	ttle_tooltip(a3),a0
	add	(a0),a0
	move.l	a0,activeTooltip(a5)
	* Count down this many ticks before attempting to show tooltip
	move	#1*50+25,tooltipTick(a5) * about 1.5 seconds	
	rts
.disabled
	;DPRINT	"was disabled"
.no 
	addq.l	#ttle_SIZEOF,a3
	tst.w	(a3)
	bne.b	.loop
.exit	rts

* Displays tooltip if needed
tooltipDisplayHandler	
	pushm	all 
	move.l	activeTooltip(a5),d0 
	beq.b	.exit 
	clr.l	activeTooltip(a5)
	clr.l	disableTooltipForGadget(a5)
	* skip display if not enabled in prefs
	tst.b	tooltips(a5)
	beq.b	.exit
	move.l	d0,a0 
	jsr	showTooltipPopup
.exit
	popm all
	rts

* Clears any previous tooltip activation so it will not be shown
* after the timeout
deactivateTooltip
	clr	tooltipTick(a5)
	clr.l	activeTooltip(a5)
	rts


*******************************************************************************
* Omaan viestiporttiin tuli viesti
******
omaviesti
	pushm	all
	lea	hippoport(a5),a0
	lore	Exec,GetMsg
	tst.l	d0
	beq	.huh
	move.l	d0,a1
	move.l	a1,omaviesti0(a5)

	;cmp.l	#"KILL",MN_LENGTH+2(a1)	* ????????
	;beq	.killeri

	* What kind of a message is this?

	* Sent by another hippo?
	cmp.l	#MESSAGE_MAGIC_ID,HM_Identifier(a1)
	beq	.oma

	* App window message?
	* This is likely kick2.0 feature, dropping icons
	* on top of windows.
	cmp.l	#'AppW',am_UserData(a1)		* Onko AppWindow-viesti?
	beq.b	.appw

	* Screen notify message?
	movem.l	snm_Type(a1),d3/d4
	cmp.l	#SCREENNOTIFY_TYPE_WORKBENCH,d3
	bne	.huh
    ; snm_Value = FALSE: WB will be closed
    ; snm_Value = TRUE: WB is open
	tst.l	d4
	bne.b	.open

	tst.b	win(a5)			* HIDE!
	beq	.huh
    bset  #0,windowClosedViaScreenNotify(a5)
	bsr	sulje_ikkuna
	clr.b	win(a5)
	bsr	sulje_prefs
	jsr	stopScopeTasks
	jsr	sulje_info
	bra	.huh

.open	
	tst.b	win(a5)
	bne	.huh
    * Reopen if closed earlier via screen notify
    bclr #0,windowClosedViaScreenNotify(a5)
    beq .huh
	bsr	openw
	bra	.huh

*********************************************
* App window drag'n'drop handler
*********************************************
.appw
** AppWindow-viesti!!
	move.l	am_NumArgs(a1),d7	* argsien m‰‰r‰
	beq		.huh
	bsr	tokenizepattern
	jsr		engageNormalMode
	bsr		obtainModuleList
 if DEBUG
	move.l	d7,d0
	DPRINT	"AppWindow drag'n'drop num=%ld"
 endif
	subq	#1,d7
	move.l	am_ArgList(a1),a3	* WBArg array
	lea	-200(sp),sp
	move.l	sp,a2
.addfiles
	move.l	wa_Lock(a3),d1
	move.l	sp,d2
	move.l	#150,d3			* max pituus
	jsr		getNameFromLock
	tst.l	d0
	beq		.error

	move.l	sp,a2
.fe	tst.b	(a2)+
	bne.b	.fe
	subq	#1,a2
	cmp.b	#':',-1(a2)
	beq.b	.na
	move.b	#'/',(a2)+
.na	clr.b	(a2)

	* If this is empty, a dir was dropped
	move.l	wa_Name(a3),a0
	tst.b	(a0)
	bne.b	.file
	DPRINT	"Directory scan"
	move.l	sp,a0
.1	tst.b	(a0)+
	bne.b	.1
	subq	#2,a0	* skip null and the 1st dir separator
	move.l	sp,a1
	bsr		nimenalku
	* a0 = dir name
	bsr	adddivider
	* d2 = path
	move.l	sp,d2
	* d3 = path len + l_size
	move.l	a2,d3
	sub.l	sp,d3
	add.l	#l_size,d3

	pushm	all
	bsr		lockMainWindow
	bsr		filereq_code\.scanni
	bsr		unlockMainWindow
	popm	all
	bra.b	.continue
.file
.cp	move.b	(a0)+,(a2)+
	bne.b	.cp

 if DEBUG
	move.l		sp,d0
	DPRINT	"->%s"
 endif
	pushpea	tokenizedpattern(a5),d1
	move.l	sp,d2
	lore	Dos,MatchPatternNoCase
	* 0 = did not match, skip this file if so
	tst.l	d0
	beq.b	.continue

	move.l	sp,a0
	bsr		createListNodeAndAdd

.continue
.error
	addq	#wa_SIZEOF,a3
	dbf		d7,.addfiles
.lop	
	lea		200(sp),sp
	bsr		releaseModuleList
	jsr	listChanged
	bsr	forceRefreshList
	bra.b	.huh


* oma viesti saapui!
.oma
	* Copy commandline arguments from the message to local buffer
	move.l	HM_Arguments(a1),a0
	lea	sv_argvArray(a5),a2
.c	move.l	(a0)+,(a2)+
	bne.b	.c

	* Check out the first parameter 
	move.l	sv_argvArray+4(a5),a0
	bsr	kirjainta4
	cmp.l	#MESSAGE_COMMAND_QUIT,d0
	bne.b	.app
	st	exitmainprogram(a5)
	bra.b	.huh

.app
	bsr	komentojono		* tutkitaan uudet komennot
.huh	bsr.b	vastomaviesti


.he	popm	all
	rts

.killeri
	st	exitmainprogram(a5)
	bra	.he



vastomaviesti
	pushm	d0/d1/a0/a1/a6
	move.l	omaviesti0(a5),d0
	beq.b	.x
	clr.l	omaviesti0(a5)
	move.l	d0,a1
	lore	Exec,ReplyMsg
.x	popm	d0/d1/a0/a1/a6
	rts


*******************************************************************************
* Oman signaalin vastaanotto (moduuli soitettu, jatkotoimenpiteet)
*******
signalreceived
	DPRINT	"Song end signal"

	moveq	#1,d7			* menn‰‰n listassa eteenp‰in
					* step forward in the list

	cmp.b	#pm_random,playmode(a5)	* Arvotaanko j‰rjestys?
	bne.b	.norand

* Previously when a song end was detected in random play mode,
* the next subsong was played if there were any subsongs.
* Better would be to randomize a new module instead.

** Onko subsongeja soiteltavaks?
** Are there any subsongs to play next?
;	move.l	playerbase(a5),a0
;	move	p_liput(a0),d0
;	* See if this replayer supports subsongs
;	btst	#pb_song,d0
; 	beq.b	.ran
;	move	songnumber(a5),d0
;	cmp	maxsongs(a5),d0
;	bne	actionNextSong		* next song!
;.ran	
	* no subsongs, randomize next one
	bra	.karumeininki

.norand
	* Play mode is not random. 

	cmp.b	#pm_repeatmodule,playmode(a5) 	* Jatketaanko soittoa?
	beq	.reet			* If module repeat on, just exit
	
	cmp.l	#1,modamount(a5) * Jos vain yksi modi,
	bne.b	.notone		* jatketaan soittoa keskeytyksett‰.
	cmp.l	#PLAYING_MODULE_REMOVED,playingmodule(a5) * Listassa yksi modi, joka on uusi.
	bne.b	.oon			* Soitetaan se.
	moveq	#0,d7			* ei lis‰t‰ eik‰ v‰hennet‰
					* no stepping in the list
	bra.b	.notone
.oon

	cmp.b	#pm_repeat,playmode(a5)
	bne.b	.notone

** Onko subsongeja soiteltavaks?
	move.l	playerbase(a5),a0
	move	p_liput(a0),d0
	btst	#pb_song,d0
 	beq	.reet
    * Special case: VGM task has already stopped, 
    * can't change to another song at this point.
    cmp.w   #pt_vgm,p_type(a0)
    beq     .reet
	move	songnumber(a5),d0
	cmp	maxsongs(a5),d0
	bne	rbutton13		* next song!
	bra	.reet

.notone

	tst.l	playingmodule(a5)	* soitettiinko edes mit‰‰n
	bmi	.err

	cmp.b	#pm_module,playmode(a5)	* Play mode was "module", stop after playing 
	beq	.stop

** Onko subsongeja soiteltavaks?
* Check for subsongs
	move.l	playerbase(a5),a0
	move	p_liput(a0),d0
	btst	#pb_song,d0
 	beq.b	.eipa
    * Special case: VGM task has already stopped, 
    * can't change to another song at this point.
    cmp.w   #pt_vgm,p_type(a0)
    beq     .eipa
	move	songnumber(a5),d0
	cmp	maxsongs(a5),d0
	bne	rbutton13		* next song!
	

.eipa
	DPRINT	"Replay end"

	* Stopping playback 
    push    d7              * save step index
	bsr	obtainModuleData
	clr.b	playing(a5)		* soitto seis
	move.l	playerbase(a5),a0	* stop module
	jsr 	p_end(a0)
	bsr	releaseModuleData

	bsr	freemodule
    pop     d7

	tst.l	modamount(a5)		* onko modeja?
	beq	.err

	cmp.l	#PLAYING_MODULE_REMOVED,playingmodule(a5) * Lista tyhj‰tty? Soitetaan eka modi.
	bne.b	.eekk
	moveq	#0,d7				* no stepping in the list
	clr.l	chosenmodule(a5)
.eekk
	* select next module 
	ext.l	d7 
	move.l	chosenmodule(a5),d0 
	add.l	d7,d0
	bpl.b	.wasPositive			
	* negative index, wrap to the last module
	move.l	modamount(a5),chosenmodule(a5)
	subq.l	#1,chosenmodule(a5)
	bra.b	.repea
.wasPositive
	move.l	d0,chosenmodule(a5)
	* Note that upper bound check is not here, it's done below when
	* traversing the list nodes.
.repea

	move.l	chosenmodule(a5),playingmodule(a5)
	move.l	playingmodule(a5),d0

	bsr	forceRefreshList

	DPRINT	"signalreceived getListNode"
	bsr	getListNode
	beq	.erer 
	move.l	a0,a3

	tst.b	l_divider(a3)
	beq.b	.wasfile
	tst	d7			* pit‰‰ olla jotain ett‰ ei j‰‰ 
	bne.b	.eekk		* jummaamaan dividerin kohdalle,
	moveq	#1,d7	* step forward
	bra.b	.eekk
.wasfile

	lea	l_filename(a3),a0	* ladataan
	moveq	#0,d0			* no double buffering
    push    a3
	jsr	loadmodule
    pop     a3
	tst.l	d0
	bne.b	.loader

    moveq   #0,d0
    move.b  l_favSong(a3),d0
    move    d0,songnumber(a5)
    DPRINT  "--- fav song: %ld"

	DPRINT	"--- Replay init"
	move.l	playerbase(a5),a0	* soitto p‰‰lle
	jsr	p_init(a0)
	tst.l	d0
	bne.b	.mododo

	bsr	settimestart
    jsr uslGetSongLength
.reet0	st	playing(a5)
	bsr	inforivit_play
	jsr	start_info
.reet
	rts

.loader	
	* load error, no module to play
	move.l	#PLAYING_MODULE_NONE,playingmodule(a5)	* latausvirhe
	bra 	.reet

.mododo	
	* init error, no module to play

	DPRINT	"ERROR, deallocate resources!"
	jsr	rem_ciaint
	jsr	vapauta_kanavat

	move.l	#PLAYING_MODULE_NONE,playingmodule(a5)	* initti virhe
	jsr	init_error
	bra.b	.reet

.err	
	move.l	#PLAYING_MODULE_NONE,playingmodule(a5)	* ei modeja mit‰ soittaa
	move.l	#PLAYING_MODULE_NONE,chosenmodule(a5)
	rts

.stop  	bsr	actionStopButton		* stop!
	bra.b	.reet

* modit loppui, mit‰ tehd‰‰n?
* No modules left to play
.erer	move.l	#PLAYING_MODULE_NONE,playingmodule(a5)

	cmp.b	#pm_through,playmode(a5)
	bne.b	.hm
	* select last module
	move.l	modamount(a5),chosenmodule(a5)
	subq.l	#1,chosenmodule(a5)
	bsr	resh
	bra	.reet

.hm	
	* In "pm_through" mode start over from the first module
 	clr.l	playingmodule(a5)	* Alotetaan alusta
	* select first module
	clr.l	chosenmodule(a5)

	* SANITY CHECK: in the case where it's all dividers,
	* stop instead of trying to find something to play.
	jsr	calculateDividersInList
	cmp.l	modamount(a5),d0
	beq.b	.err
	bra	.repea

* Shuffle-soitto
.karumeininki
	move.l	modamount(a5),d0
	beq	.reet		* jos ei yht‰‰n, jatketaan entisen soittoa
	cmp.l	#1,d0		* Jos vain yksi, jatketaan soittoa
	beq	.reet
	bra	soitamodi2


******************************************************************************
*
* Random stuff
*
****************

* Randomize a module
* out:
*    chosenmodule(a5) will get the index of the randomized module
satunnaismodi
	move.l	modamount(a5),d0
	* Low bound check
	cmp.l	#1,d0
	bhi.b	.nof
	clr.l	chosenmodule(a5)
	rts
.nof
	* High bound check
	cmp.l	#MAX_MODULES,d0		* jos liikaa, ei yll‰pidet‰ listaa
	bhi.b	.onviela
	subq.l	#1,d0			* for dbf

	* Loop as much as we have modules and test if the random table 
	* has free slots left.

.h	bsr	testRandomTableEntry
	beq.b	.onviela
	;dbf	d0,.h
	subq.l	#1,d0 
	bpl.b	.h

	DPRINT 	"all random table slots taken"

	* All slots taken, clear it and start over.
	* This means all modules have randomly played.
	bsr.b	clear_random
	bra.b	satunnaismodi

.onviela
	* There are free slots left in the random table.
	* Next get a random value in the range [0, number of modules-1].
	move.l	modamount(a5),d3
	subq.l	#1,d3
.a	bsr	getRandomValue
	* Function returns 0..MAX_RANDOM_MASK,
	* which may be larger than modamount(a5). 
	* Accept only random values in range.
	cmp.l	d3,d1
	bhi.b	.a

	* Got a random value in proper range in d1
	* Test if a slot is free. Try again if not.
	move.l	d1,d0
	bsr.b	testRandomTableEntry
	bne.b	.a
	* Was free. Take it.
	bsr	setRandomTableEntry

	* I choose you, module in index d1
	move.l	d1,chosenmodule(a5)
.reet	rts


* Clear random table and do force refresh of list
* if in random mode.
clear_random:
	bsr.b	clearRandomTable
	cmp.b	#pm_random,playmode(a5)
	bne.b	.x
	* Request refresh to clear out random play indicators.
	* This may update list in surprising situations.
	* For example, when selecting parent item in filebrowser,
	* before the parent contents are refreshed into view.
	st	hippoonbox(a5)
	pushm	all
	;bsr	shownames
	bsr	showNamesNoCentering
	popm	all
.x
	rts

* Clear random table
clearRandomTable
	pushm	d0/a0
	DPRINT  "clearRandomTable"
	bsr	 obtainModuleList
	clr.l	randomValueMask(a5)
	tst.l	randomtable(a5)
	beq.b	.noList
	move.l	randomtable(a5),a0 
	bsr 	freemem 
	move.l	randomtable(a5),d0
	clr.l	randomtable(a5)
.noList
	bsr	releaseModuleList
	popm	d0/a0
	rts

* Test if index given in d0 is taken in the random table
* in:
*      d0 = module index to test
* out:
*      Z is set if index is taken
testRandomTableEntry:
	push	a0
	bsr.b	getRandomValueTableEntry
	beq.b	.error
	btst	d0,(a0)
.error
	pop     a0
	rts


* Each index maps into one bit in the randomtable. 
* It is created here if not available.
* It's much faster to use a bit table for this instead of doing list traversal.
* in:
*      d0 = module index to test
* out:
*      a0 = index in the ranom table that should be tested 
getRandomValueTableEntry:
	push 	d1
	tst.l	randomtable(a5) 
	bne.b	.yesTable

	* Each byte can hold a slot for 8 modules.
	* A bit silly dynamic allocation as probably
	* the amount is a very few bytes.
	push	d0
	move.l	modamount(a5),d0 
	DPRINT	"New randomtable for %ld"

	lsr.l	#3,d0
	addq.l	#1,d0
	move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
	bsr	getmem
	
	move.l	d0,randomtable(a5)
	bne.b	.ok
	bsr	showOutOfMemoryError
.ok
	pop     d0
		
	tst.l	randomtable(a5)
	beq.b	.problem
.yesTable
	move.l	randomtable(a5),a0
	move.l	d0,d1
	lsr.l	#3,d1 
	add.l	d1,a0
	* Restoring d1 with pop (which is a move.l (sp)+) alters the Z-flag.
	* movem.l (sp)+,d1 would not do this,
	* for fun clear the Z-flag manually!
	pop 	d1
	and.b	#~(1<<2),ccr
.problem
	rts

* Sets the random table entry as taken for given module index.
* in:
*   d0 = module index
setRandomTableEntry
	pushm	all
	DPRINT  "setRandomTableEntry %ld"
	
	* Set it in the table
	bsr	getRandomValueTableEntry
	beq.b	.error
	bset	d0,(a0)
.error

	cmp.b	#pm_random,playmode(a5)
	bne.b	.x

	* This requests refresh of list contents. Possibly not reasonable.
	st	hippoonbox(a5)
.x
	popm	all
	rts

* Get seed for random generator
srand   
	move.l	4.w,a6
	moveq	#MEMF_PUBLIC,d1
	lob	AvailMem
	add.l	ThisTask(a6),d0

	lea	$dff000,a1
	add.l	4(a1),d0      ; Initialize random generator.. Call once
        add.l   2(a1),d0
	lea	$dc0000,a0
	add.l	(a0)+,d0
	add.l	(a0)+,d0
	add.l	(a0)+,d0
	add.l	(a0),d0

	moveq	#0,d1
	move.b	$bfec01,d1
;	add.l	d1,d0
	rol.l	d1,d0

	move	$a(a1),d1	* joy0dat
	add	d1,d0
	move	$c(a1),d1	* joy1dat
	add	d1,d0
	move	$1a(a1),d1	* dskbytr
	add	d1,d0
	move	$18(a1),d1	* serdatr
	add	d1,d0

        move.l  d0,seed(a5)
        rts

* Returns a pseudo random number
* out:
*    d1 = random number, range 0..MAX_RANDOM_MASK
getRandomValue
	push	d0
	move.l  seed(a5),d0     ; Returns random number (result: d0 = 0-32767)
        move.l  #$41c64e6d,d1
        bsr.b	mulu_32
        add.l   #$3039,d0
        move.l  d0,seed(a5)
        moveq   #$10,d1
        lsr.l   d1,d0
		
	move.l	d0,d1 
	bsr	getRandomValueMask
	and.l	d0,d1

	pop	d0
        rts



* mulu_32 --- d0 = d0*d1
mulu_32	movem.l	d2/d3,-(sp)
	move.l	d0,d2
	move.l	d1,d3
	swap	d2
	swap	d3
	mulu	d1,d2
	mulu	d0,d3
	mulu	d1,d0
	add	d3,d2
	swap	d2
	clr	d2
	add.l	d2,d0
	movem.l	(sp)+,d2/d3
	rts	

* divu_32 --- d0 = d0/d1, d1=remainder
divu_32	move.l	d3,-(a7)
	swap	d1
	tst	d1
	bne.b	.lb_5f8c
	swap	d1
	move.l	d1,d3
	swap	d0
	move	d0,d3
	beq.b	.lb_5f7c
	divu	d1,d3
	move	d3,d0
.lb_5f7c	swap	d0
	move	d0,d3
	divu	d1,d3
	move	d3,d0
	swap	d3
	move	d3,d1
	move.l	(a7)+,d3
	rts	

.lb_5f8c	swap	d1
	move	d2,-(a7)
	moveq	#16-1,d3
	move	d3,d2
	move.l	d1,d3
	move.l	d0,d1
	clr	d1
	swap	d1
	swap	d0
	clr	d0
.lb_5fa0	add.l	d0,d0
	addx.l	d1,d1
	cmp.l	d1,d3
	bhi.b	.lb_5fac
	sub.l	d3,d1
	addq	#1,d0
.lb_5fac	dbf	d2,.lb_5fa0
	move	(a7)+,d2
	move.l	(a7)+,d3
	rts	

;umult64 - mulu.l d0,d0:d1
;by Meynaf/English Amiga Board
mulu_64
     move.l d2,-(a7)
     move.w d0,d2
     mulu d1,d2
     move.l d2,-(a7)
     move.l d1,d2
     swap d2
     move.w d2,-(a7)
     mulu d0,d2
     swap d0
     mulu d0,d1
     mulu (a7)+,d0
     add.l d2,d1
     moveq #0,d2
     addx.w d2,d2
     swap d2
     swap d1
     move.w d1,d2
     clr.w d1
     add.l (a7)+,d1
     addx.l d2,d0
     move.l (a7)+,d2
 	rts

; udivmod64 - divu.l d2,d0:d1
; by Meynaf/English Amiga Board
divu_64
	move.l d3,-(a7)
 	moveq #31,d3
.loop
	 add.l d1,d1
	 addx.l d0,d0
 	bcs.s .over
 	cmp.l d2,d0
 	bcs.s .sui
 	sub.l d2,d0
.re
 	addq.b #1,d1
.sui
 	dbf d3,.loop
 	move.l (a7)+,d3	; v=0
 	rts
.over
 	sub.l d2,d0
 	bcs.s .re
 	move.l (a7)+,d3
 	or.b #4,ccr		; v=1
 	rts



* To discard too big random values quickly, "and" the value with a 
* suitable mask, based on amount of modules. Calculate the mask here.
getRandomValueMask
	move.l	randomValueMask(a5),d0 
	bne.b	.x
	move.l 	modamount(a5),d0 
	bsr.b	findHighestBit 
	add.l	d0,d0
	subq.l 	#1,d0
	move.l	d0,randomValueMask(a5)
.x	rts

* Find highest bit set in value
*
* in: 
*   d0 = value to check
* out: 
*   d0 = highest bit in value set
* example: 0x7f -> 0x40

findHighestBit
	push	d1
	move.l	d0,d1
	lsr.l	#1,d1
	or.l	d1,d0

	move.l	d0,d1
	lsr.l	#2,d1
	or.l	d1,d0

	move.l	d0,d1
	lsr.l	#4,d1
	or.l	d1,d0

	move.l	d0,d1
	lsr.l	#8,d1
	or.l	d1,d0

	move.l	d0,d1
	clr	d1
	swap	d1
	or.l	d1,d0

	move.l	d0,d1
	lsr.l	#1,d1
	sub.l	d1,d0
	pop	d1
	rts	



******************************************************************************
* Soitamoduuli 
* Play a module
* in:
*    d7 = step to move in the list, -1 to play previous, +1 to play next. 
****************

soitamodi_random:
	moveq	#1,d5 		* 1: force random
	moveq	#0,d6		* 0: allow volume fade down before startig to play new module
	bra.b	umph

* Called from "signalreceived". That is, when a module playback has ended.
soitamodi2:
	moveq	#-1,d6		* ~0: disable volume fade down before starting to play new module
	moveq	#0,d5		* 0: no forced random
	bra.b	umph

* Called based on user input
soitamodi:
	DPRINT  "Soitamodi"
	moveq	#0,d6		* 0: allow volume fade down
	moveq	#0,d5		* 0: no forced random
umph	
;	cmp.b	#$7f,do_early(a5)	* early load p‰‰ll‰? disable!
;	beq	.ags

 if DEBUG
	move.l	chosenmodule(a5),d0
	DPRINT	"play mod, chosen=%ld"
 endif

	tst	d5
	bne.b 	.raaps

	cmp.b	#pm_random,playmode(a5)	* onko satunnaissoitto?
	bne.b	.bere
.raaps	
	* randomize a module in chosenmodule(a5)
	bsr	satunnaismodi
	* set step to zero
	moveq	#0,d7
.bere
	* Calculate in long words to avoid possible word overflow.
	move.l	modamount(a5),d1
    bne     .is
    DPRINT  "empty list"
    rts
.is 

	* Calculate candidate for the next module
	move.l	chosenmodule(a5),d0
	add.l	d7,d0
	bpl.b	.e					* meni yli listan alkup‰‰st‰?
	* Result is negative. Wrap to the end of the list.
.getLast
	move.l	d1,d0
	subq.l	#1,d0
	bra.b	.ee
.e
	cmp.l	d1,d0
	blt.b	.ee
	* Result is higher than the amount of modules. Wrap to the beginning,
	* or end, depending on the movement direction.
	tst.l	d7
	bmi.b	.getLast
.getFirst
	moveq	#0,d0
.ee
	* Valid chosenmodule index found
	move.l	d0,chosenmodule(a5)
	DPRINT "->chosenmodule %ld"
	* Take a slot in the random table as well
	move.l	d0,d2					* store copy for later
	bsr	setRandomTableEntry		* Merkataan listaan..

;	st	hippoonbox(a5)
	bsr	resh

* etsit‰‰n listasta vastaava tiedosto
* find the corresponding file from the list

	DPRINT	"soitamodi getListNode"
	bsr	getListNode
	beq	.erer
	move.l	a0,a3

	* This might be a list divider. Try again in that case.
	;isListDivider l_filename(a3)	* onko divideri?
	tst.b	l_divider(a3)
	beq.b	.noDiv		* kokeillaan edellist‰/seuraavaa/rnd

	* try next one until at end of the list
	TSTNODE	a3,a0
	bne	umph
	bra	.erer
.noDiv

	cmp.l	playingmodule(a5),d2	* onko sama kuin juuri soitettava??
	bne 	.new

	* It was the same one which already was playing.
	* Restart it from beginning.

* on!
	DPRINT	"Replay end"
	bsr	obtainModuleData
	bsr	halt			* soitetaan vaan alusta
	move.l	playerbase(a5),a0
    push    a3
	jsr 	p_end(a0)
    pop     a3

    moveq   #0,d0
    move.b  l_favSong(a3),d0
    move    d0,songnumber(a5)
    DPRINT  "+++ fav song: %ld"

	DPRINT	"+++ Replay init"
	move.l	playerbase(a5),a0
	jsr	p_init(a0)
	bsr	releaseModuleData

	tst.l	d0
	bne	.inierr

	st	playing(a5)		* Ei varmaan tuu initerroria
	bsr	inforivit_play
	bsr	settimestart
    jsr uslGetSongLength
	bra	start_info
	
.new
	DPRINT	"New mod"

	* New module to be played.

	moveq	#0,d7			* flag for double buffering (0: no db)
	tst.l	playingmodule(a5)	* Oliko soitettavana mit‰‰n?
							* Was something being played?							
	bmi.b	.nomod

	* Yes. Stop and free it.

	tst	d6			* ei fadea jos signalreceivedist‰
	bne.b	.hm1

	move.b	doublebuf(a5),d7	* onko doublebuffering?

    lea     l_filename(a3),a0
    tst.b   l_remote(a3)
    beq.b   .notRem1
    moveq   #0,d7   * disable for remotes!
.notRem1
    tst.b   d7
	bne.b	.nomod

	bsr	fadevolumedown
	move	d0,-(sp)
.hm1
	DPRINT	"Replay end"
    pushm    d6/d7          * preserve double buffering flag
	bsr	obtainModuleData
	bsr	halt			* Vapautetaan se jos on
	move.l	playerbase(a5),a0
	jsr	p_end(a0)
	bsr	releaseModuleData
	bsr	freemodule	
    popm    d6/d7
	tst	d6
	bne.b	.hm2
	move	(sp)+,mainvolume(a5)
.hm2

.nomod
	* Store index of the new module being played
	move.l	d2,playingmodule(a5)	* Uusi numero


	* a3 contains the list elment
	lea	l_filename(a3),a0	* Ladataan
	* load it, d7 contains double buffering flag
	move.b	d7,d0
    tst.b   l_remote(a3)
    beq.b   .notRem
    moveq   #0,d0     * disable for remotes!
    DPRINT  "DISABLE double buffering 2"
.notRem
    push    a3
	jsr	loadmodule
    pop     a3
	tst.l	d0
	bne.b	.loader

    moveq   #0,d0
    move.b  l_favSong(a3),d0
    move    d0,songnumber(a5)
    DPRINT  "=== fav song: %ld"

	DPRINT	"=== Replay init"
	move.l	playerbase(a5),a0
	jsr	p_init(a0)
	tst.l	d0
	bne.b	.inierr

	bsr	settimestart
	st	playing(a5)
	bsr	inforivit_play
    jsr uslGetSongLength
	bsr	start_info

.erer
;	bsr	shownames
	rts

.loader	
	* Load failed.
	* Did not get a module to play successfully.
	move.l	#PLAYING_MODULE_NONE,playingmodule(a5)
	rts


.inierr	
	DPRINT	"Replay init ERROR"

	* Replay init failed.
	* Did not get a module to play successfully.
	move.l	#PLAYING_MODULE_NONE,playingmodule(A5)	* initvirhe
	jmp	init_error


*** Early load

;.early
;	move.b	#$7f,do_early(a5)	* Next/Prev/Play soittavat
					* nyt ladatun piisin

* vanhat talteen
;	move.l	moduleaddress(a5),earlymoduleaddress(a5)
;	move.l	modulelength(a5),earlymodulelength(a5)
;	move.l	tfmxsamplesaddr(a5),earlytfmxsamples(a5)
;	move.l	tfmxsampleslen(a5),earlytfmxsamlen(a5)
;	move.b	lod_tfmx(a5),earlylod_tfmx(a5)


;	lea	l_filename(a3),a0	* Ladataan
;	move.l	l_nameaddr(a3),solename(a5)
;	moveq	#MEMF_CHIP,d0
;	lea	moduleaddress(a5),a1
;	lea	modulelength(a5),a2
;	moveq	#0,d1			* kommentti talteen
;	bsr	loadfile
;	tst.l	d0
;	beq	.ok

;	bsr	freeearly
;	clr.b	do_early(a5)
;	bra	loaderr

;.ok	bsr	inforivit_play
;	rts	


*******************************************************************************
* Asetataan arvot propgadgeteille
*******
nupit

* volume
	lea	slider1,a0
	move	#65535/64,d0		* 65535/max
	bsr	setknob
 ifeq EFEKTI
;	move	#65535*64/64,d0		* 65535*arvo/max
	moveq	#-1,d0
 else
	moveq	#0,d0
 endc
	bsr	setknob2

;	lea	slider4,a0
	lea	slider4-slider1(a0),a0
	move.l	gg_SpecialInfo(a0),a1
	move	#65535/1,pi_VertBody(a1)
;	move	#0,pi_VertPot(a1)
	clr	pi_VertPot(a1)

* mixingrate s3m
;	lea	pslider1,a0
	lea	pslider1-slider4(a0),a0
	moveq	#65535/(580-50),d0	* 65535/max
	bsr	setknob
	move	#65535*50/(580-50),d0	* 65535*arvo/max
	bsr	setknob2

* mixingrate tfmx
;	lea	pslider2,a0
	lea	pslider2-pslider1(a0),a0
	move	#65535/(22-1),d0		* 65535/max
	bsr	setknob
	move	#65535*11/21,d0		* 65535*arvo/max
	bsr	setknob2

* volumeboost s3m
;	lea	juusto,a0
	lea	juusto-pslider2(a0),a0
	;move	#65535/9,d0
	move	#65535/17,d0
	bsr	setknob
;	move	#65535/9*0,d0
	moveq	#0,d0
	bsr	setknob2

* stereoarvo s3m
;	lea	juust0,a0
	lea	juust0-juusto(a0),a0
	move	#65535/64,d0
	bsr	setknob
;	move	#65535/32*0,d0
	moveq	#0,d0
	bsr	setknob2

* boxsize
;	lea	meloni,a0
	lea	meloni-juust0(a0),a0
	move	#65535/(51-3),d0		* 65535/max
	bsr	setknob
	move	#65535*(8-3)/(51-3),d0		* 65535*arvo/max
	bsr	setknob2

* infosize
;	lea	eskimO,a0
	lea	eskimO-meloni(a0),a0
	move	#65535/(50-3),d0		* 65535/max
	bsr.b	setknob
	move	#65535*(16-3)/(50-3),d0		* 65535*arvo/max
	bsr.b	setknob2

* timeout
;	lea	kelloke,a0
	lea	kelloke-eskimO(a0),a0
	move	#65535/1800,d0			* 65535/max
	bsr.b	setknob
;	move	#65535*0/1800,d0		* 65535*arvo/max
	moveq	#0,d0
	bsr.b	setknob2

* alarm
;	lea	kelloke2,a0
	lea	kelloke2-kelloke(a0),a0
	moveq	#65535/1440,d0			* 65535/max
	bsr.b	setknob
;	moveq	#65535*0/1440,d0		* 65535*arvo/max
	moveq	#0,d0
	bsr.b	setknob2

* samplebuffersize
;	lea	sIPULI,a0
	lea	sIPULI-kelloke2(a0),a0
	move	#65535/5,d0		* 65535/max
	bsr.b	setknob
;	move	#65535*0/3,d0		* 65535*arvo/max
	moveq	#0,d0
	bsr.b	setknob2

* sample forced sampling rate
;;	lea	sIPULI2,a0
;	lea	sIPULI2-sIPULI(a0),a0
;	moveq	#65535/600,d0		* 65535/max
;	bsr.b	setknob
;;	move	#65535*0/600,d0		* 65535*arvo/max
;	moveq	#0,d0
;	bsr.b	setknob2



* ahi rate
	lea	ahiG4,a0
;	lea	ahiG4-sIPULI2(a0),a0
	moveq	#65535/(580-50),d0	* 65535/max
	bsr.b	setknob
	move	#65535*50/(580-50),d0	* 65535*arvo/max
	bsr.b	setknob2

* ahi mastervol
;	lea	ahiG5,a0
	lea	ahiG5-ahiG4(a0),a0
	moveq	#65535/1000,d0		* 65535/max
	bsr.b	setknob
	moveq	#65535*1/1000,d0	* 65535*arvo/max
	bsr.b	setknob2

* ahi stereolev
;	lea	ahiG6,a0
	lea	ahiG6-ahiG5(a0),a0
	move	#65535/100,d0		* 65535/max
	bsr.b	setknob
;	move	#65535*00,d0		* 65535*arvo/max
	moveq	#0,d0
	bsr.b	setknob2

* MED rate
	lea	nAMISKA5-ahiG6(a0),a0
	moveq	#65535/(580-50),d0	* 65535/max
	bsr.b	setknob
	move	#65535*50/(580-50),d0	* 65535*arvo/max
	bra.b	setknob2


* Vert.. Horiz..

setknob	move.l	gg_SpecialInfo(a0),a1
	move	d0,pi_HorizBody(a1)
	rts
setknob2
	move.l	gg_SpecialInfo(a0),a1
	move	d0,pi_HorizPot(a1)
	rts



nappilasku
	move.l	gg_SpecialInfo(a2),a0
	mulu	pi_HorizPot(a0),d0
	add.l	#32767,d0
	divu	#65535,d0
	and.l	#$ffff,d0
	rts




*******************************************************************************
* Nappulaa painettu, tehd‰‰n vastaava (gadgetti) toiminto
*******
* d3 = rawkey
* d4 = iequalifier

handleRawKeyInput:
nappuloita:

; The following keys can exist on CDTV, CD32 and "multimedia" keyboards:
.RAWKEY_MEDIA_STOP       = $72
.RAWKEY_MEDIA_PLAY_PAUSE = $73
.RAWKEY_MEDIA_PREV_TRACK = $74
.RAWKEY_MEDIA_NEXT_TRACK = $75
.RAWKEY_MEDIA_SHUFFLE    = $76
.RAWKEY_MEDIA_REPEAT     = $77

  REM
  if DEBUG
   	moveq   #0,d0
    	move.b	d3,d0
	moveq	#0,d1
 	move	d4,d1
  	DPRINT	"Raw key=%lx qual=%lx"
  endc 
  EREM
	and	#$ff,d3
	* mask out non-kb qualifiers
	and	#$ff,d4

	* react only if button is down
	tst.b	d3
	bmi	.exit	* vain jos nappula alhaalla
	movem.l	d0-a6,-(sp)

    ; ---- MODIFIER: control

	cmp	#IEQUALIFIER_CONTROL,d4
	bne.b	.noControl

	cmp.b	#$23,d3		* f + control
	bne.b	.2
	jsr	toggleFavoriteStatusForCurrentModule
	bra	.ee
.2
	cmp.b	#$21,d3	 	* s + control
 	bne.b	.4
    tst     boxsize(a5) * Disable if box hidden
    beq     .ee
	jsr		searchActivate
	bra	.ee
.4
    cmp.b   #$24,d3     * g + control
    bne     .5
    jsr     fetchAndSaveCurrentModule
    bra     .ee
.5
.noControl

    ; ---- MODIFIER: shift 

	and.b	#IEQUALIFIER_LSHIFT!IEQUALIFIER_RSHIFT,d4
	beq.b	.noshifts

	cmp.b	#$37,d3		* m + shift
	bne.b	.1
	bsr	rlistmode
	bra	.ee
.1


	cmp.b	#$17,d3		* i + shift?
	bne.b	.f0
	; window will be opened active:
	or.l	#WFLG_ACTIVATE,sflags
	bsr	rbutton10b
	bra 	.ee
.f0
	cmp.b	#$41,d3		* backspace + shift?
	beq.b	.fid
	cmp.b	#$22,d3		* d + shift?
	bne.b	.fi
.fid	bsr	rbutton8b
	bra.b	.ee
.fi

	cmp.b	#$39,d3		* onko shift + fast forward?
	beq.b	.if
	cmp.b	#$1f,d3
	bne.b	.no1f
.if	bsr	rbutton_kela2_turbo
	bra.b	.ee
.no1f

.noshifts
	cmp.b	#$23,d3		* [F]ind
	bne.b	.not_f
	tst.b	d4
	bne.b	.fi_c
	bsr	find_new
	bra.b	.ee
.fi_c	bsr	find_continue
	bra.b	.ee

.not_f
	cmp.b	#$50,d3		* Oliko funktion‰pp‰imi‰??
	blo.b	.f1
	cmp.b	#$59,d3
	bhi.b	.f1
	bsr	fkeyaction
	bra.b	.ee
.f1


	lea	.nabs(pc),a0	
.checke
	cmp	(a0)+,d3
	beq.b	.jee
	addq.l	#2,a0
	cmp.l	#.nabse,a0
	bne.b	.checke
 if DEBUG
    moveq   #0,d0
    move.b  d3,d0
	DPRINT	"No action for key %lx"
 endif
.ee	movem.l	(sp)+,d0-a6
.sd	
.exit
	rts
.jee	
	move	(a0),d0
	add	d0,a0
	jsr	(a0)
	bra.b	.ee


* $13 r 	prefs

* return $44	play
* *, $2b (returnin vieress‰) play random module
* ylos $4c	lista ylos
* alas $4d	lista alas

* vas $4f	prev song
* oik $4e	next song
* k $27 	prev 
* l $28		next 

* s $10		add divider

* n $36		new

* d $22		delete module
* backspace $41	delete module
* space $40	stop/cont
* esc $45	exit program
* tab $42	eject module
* < $38		prev pattern -
* > $39		next pattern \kelaus
* a $20		add modules

* v $34		volume down
* b $35		volume up


* del $46	delete module
* help $5f	about etc.
* c $33		clear list
* ~` $0		window shrink/expand
* 7 7	show: time - poslen 0	
* 8 8	show: kello/memory 1
* 9 9	show: name 2
* 0 $a 	show: time/duration - poslen
* i $17		moduleinfo
* f1-f10 $50-$59	Funktio-lataussoitto
* w $11		save modprogram
* o $19	 	load modprogram
* h $25		hide!)
* [ $1a		join modprogram

* m $37		move
* t $14		insert
* s $21		sort

* z $31		scope Ltoggle

* f $23		find module

* o $18		comment file

* g $24		play list repeatedly
* h $25		play mods in random order


********
* numeron‰ppis
* [ ] / *
* 7 8 9 -
* 4 5 6 +
* 1 2 3 E
* 000 . E
* 4 - prev song 	$2d
* 6 - next song		$2f
* 8 - select prev	$3e
* 2 - select next	$1e
* 7 - play prev		$3d
* 9 - play next		$3f
* 1 - rewind		$1d
* 3 - fast forward	$1f
* 5 - stop/cont		$2e
* 0 - add mods		$f
* * - random play	$5d
* - - vol down		$4a
* + - vol up		$5e
* enter - return	$43
* . - load program	$3c
* [ - del mod		$5a
* ] - move mod		$5b
* / - insert		$5c


.nabs

	dc	$12
	dr	execuutti


	dc	$13
	dr	rbutton20

	dc	$36
	dr	rbutton11

	dc	$24
	dr	.pm1
	dc	$25
	dr	.pm2	

	dc	$31 * z-key
	dr	.scopetoggle

	dc	$37
	dr	rmove
	dc	$14
	dr	rinsert
	dc	$21
	dr	rsort

	dc	$11
	dr	rsaveprog
	dc	$19
	dr	rloadprog
	dc	$1a
	dr	rloadprog0

	dc	$27
	dr	rbutton6	* prev
	dc	$28
	dr	rbutton5	* next
	dc	$4e
	dr	actionPrevSong	* prev song
	dc	$4f
	dr	actionNextSong	* next song

    dc  .RAWKEY_MEDIA_PREV_TRACK
    dr  prevButtonAction
    dc  .RAWKEY_MEDIA_NEXT_TRACK
    dr  nextButtonAction

	dc	7
	dr	.showtime
	dc	8
	dr	.showclock
	dc	9
	dr	.showname
	dc	$a
	dr	.showtime2

	dc	$45
	dr	.qui

	dc	$44
	dr	rbutton1

	dc	$40
	dr	stopcont

    dc  .RAWKEY_MEDIA_PLAY_PAUSE
    dr  playButtonAction 

	dc	$22
	dr	rbutton8
	dc	$41
	dr	rbutton8
	dc	$46 * DEL
	dr	rbutton8


	dc	$42
	dr	rbutton4    
    
    dc  .RAWKEY_MEDIA_STOP
    dr  ejectButtonAction

	dc	$38
	dr	rbutton_kela1
	dc	$39
	dr	rbutton_kela2

	dc	$4c
	dr	lista_ylos

	dc	$4d
	dr	lista_alas

	dc	$33
	dr	rbutton9

	dc	$20
	dr	rbutton7

	dc	$34
	dr	.voldown
	dc	$35
	dr	.volup

	dc	$5f
	dr	.rbutton10
	dc	$17
	dr	.infoo

	dc	0
	dr	.ocl

	dc	$2b
	dr	.rand

	dc	$10
	dr	add_divider

	dc	$18
	dr	comment_file

*** Numeron‰ppis


	dc	$2f
	dr	actionPrevSong		* prev song
	dc	$2d
	dr	actionNextSong		* next song
	dc	$3e
	dr	lista_ylos	* select prev
	dc	$1e
	dr	lista_alas	* select next
	dc	$3d
	dr	rbutton6	* play prev
	dc	$3f
	dr	rbutton5	* play next
	dc	$1d
	dr	rbutton_kela1	* rewind
	dc	$1f
	dr	rbutton_kela2	* fast forward
	dc	$2e
	dr	stopcont	* stop/cont
	dc	$f
	dr	rbutton7	* add
	dc	$5d
	dr	.rand		* play random mod
	dc	$4a
	dr	.voldown	* volume down
	dc	$5e
	dr	.volup		* volume up
	dc	$43
	dr	rbutton1	* play
	dc	$3c	
	dr	rloadprog	* load program
	dc	$5a
	dr	rbutton8	* del mod
	dc	$5b
	dr	rmove		* move mod
	dc	$5c
	dr	rinsert		* insert mods
.nabse

.rbutton10
	jmp	rbutton10

.rand	bra	soitamodi_random


.qui	st	exitmainprogram(a5)
	rts

.ocl	bra	zipMainWindow



.showtime
	clr	lootamoodi(a5)  ; TITLEBAR_TIME_POSLEN_SONG
	bra	lootaa
.showclock
	move	#TITLEBAR_CLOCK_FREEMEM,lootamoodi(a5)
	bra	lootaa
.showname
	move	#TITLEBAR_NAME,lootamoodi(a5)
	bra	lootaa
.showtime2
	move	#TITLEBAR_TIMEDUR_POSLEN,lootamoodi(a5)
	bra	lootaa


.scopetoggle
	jmp	toggleScopes

.pm1	move.b	#pm_repeat,playmode(a5)	* playmode pikan‰pp‰imet
.pm0	st	hippoonbox(a5)
	bra	shownames
.pm2	move.b	#pm_random,playmode(a5)
	bra.b	.pm0

*** Volume nappuloilla c ja v
.volup
	move	mainvolume(a5),d0
	addq	#1,d0
	cmp	#64,d0
	bls.b	.vol
	moveq	#64,d0
	bra.b	.vol
.voldown
	move	mainvolume(a5),d0
	subq	#1,d0
	bpl.b	.vol
	moveq	#0,d0
.vol
	move	slider1+gg_Flags,d1
	and	#GFLG_DISABLED,d1
	beq.b	.vo1
	rts

.vo1	move	d0,mainvolume(a5)
	bne.b	.ere
	moveq	#1,d0
.ere	bra	volumerefresh


.infoo
** modinfon infon avaus
	DPRINT	"modinfo KEY"
	bra	modinfoaaa
 REM
	tst	info_prosessi(a5)
	beq.b	.zz
	move.l	infotaz(a5),a0		* jos oli jo modinfo niin suljetaan
	cmp.l	#about_t,a0
	beq.b	.rrz
	bsr	sulje_info
	bra.b	.xz
.rrz	bra	start_info
.zz	clr.b	infolag(a5)
	bsr	rbutton10b
.xz	rts
 EREM


** stop/continue

stopcont
	tst.b	playing(a5)
	beq	actionContinue
	bra	actionStopButton


lista_ylos				* shiftin kanssa nopeempi!
	moveq	#1,d0		* lines to skip up
	and	#IEQUALIFIER_LSHIFT!IEQUALIFIER_RSHIFT,d4
	beq.b	.nsh
	tst	boxsize(a5)
	beq.b	.nsh
	move	boxsize(a5),d0
	lsr	#1,d0			* with shift, skip half of the box size
.nsh
	ext.l	d0
	move.l	chosenmodule(a5),d1

	sub.l	d0,d1
	bpl.b	.wasOk
	move.l	modamount(a5),chosenmodule(a5)
	subq.l	#1,chosenmodule(a5)
	bra		resh
.wasOk
	move.l	d1,chosenmodule(a5)
	bra	resh

lista_alas
	moveq	#1,d0		* lines to skip down
	and	#IEQUALIFIER_LSHIFT!IEQUALIFIER_RSHIFT,d4
	beq.b	.nsh
	tst	boxsize(a5)
	beq.b	.nsh
	move	boxsize(a5),d0
	lsr	#1,d0
.nsh
	ext.l	d0
	move.l	chosenmodule(a5),d1
	add.l	d0,d1

	move.l	modamount(a5),d0
	;cmp	chosenmodule(a5),d0
	cmp.l	d1,d0
	bhi.b	.ee
	moveq	#0,d1
	;clr	chosenmodule(a5)
.ee	
	move.l	d1,chosenmodule(a5)
	bra	resh


********* Window zip

zipMainWindow	tst.b	uusikick(a5)
	bne.b	.newo
	bsr	sulje_ikkuna		* Vaihdetaan ikkunan kokoa
	bra	avaa_ikkuna
.newo	move.l	windowbase(a5),a0	* Kick2.0+
	move.l	_IntuiBase(a5),a6
	jmp	_LVOZipWindow(a6)

************************************** Funktion‰pp‰imet!

fkeyaction
	sub.b	#$50,d3
	ext	d3
	mulu	#120,d3
	lea	fkeys(a5),a0
	add.l	d3,a0
	tst.b	(a0)
	bne.b	.oli
	rts

.oli	move.l	a0,sv_argvArray+4(a5)		* Parametri!
	clr.l	sv_argvArray+8(a5)

	bsr	rbutton9		* freelist & shownames
	bsr	rbutton4		* EJECT!

	bra	komentojono			* tutkitaan komentojono.


*******************************************************************************
* Jotain gadgettia painettu, tehd‰‰n vastaava toiminto
* Gadget activated
*******
* in:
*   a2 = intuition gadget

gadgetsup:
	bsr	    areMainWindowGadgetsFrozen
	bne.b 	.exit
  
	movem.l	d0-a6,-(sp)

	* Deactivate tooltips for the gadget that was activated
	* until some other gadget tooltip gets shown.
	move.l	a2,disableTooltipForGadget(a5)
	* Any button activity should first close any active tooltip
	bsr	closeTooltipPopup

	move	gg_GadgetID(a2),d0

   ; ext.l   d0
   ; DPRINT  "gadgetId=%ld"

    cmp     #GADGET_ID_SEARCH_STRING,d0
    bne     .1
    bsr     gadgetSearchStringAction
    bra     .x    
.1 
    cmp     #GADGET_ID_SEARCH_SOURCE,d0
    bne     .2
    bsr     gadgetSearchSourceAction
    bra     .x
.2
    cmp     #GADGET_ID_LOCAL_SEARCH_STRING,d0
    bne     .3
    bsr     gadgetFindAction
    bra     .x
.3
    pushm   all
    ; If user clicks outside of the search terms string
    ; gadget, return to normal layout.
    jsr     switchToNormalLayoutIfPossible
    popm    all

	add	d0,d0
	lea	.gadlist-2(pc,d0),a0
	add	(a0),a0
	jsr	(a0)
.x
	movem.l	(sp)+,d0-a6
.exit 
	rts
	
.gadlist	
	dr	rbutton1	* play
	dr	modinfoaaa	* modinfo toggle
	dr	stopcont	* stop/continue
	dr	rbutton4	* eject
	dr	rbutton5	* next
	dr	rbutton6	* prev
	dr	rbutton7	* add
	dr	rbutton8	* del
	dr	rslider1	* volume
	dr	rslider4	* fileselector
	dr	rbutton13	* Prev Song
	dr	rbutton12	* Next Song
	dr	rbutton11	* New
	dr	rbutton20	* Prefs
	dr	rbutton_kela1	* Taaksekelaus
	dr	rbutton_kela2	* Eteenkelaus
	dr	rloadprog	* ohjelman lataus
	dr	rmove		* move
	dr	rsort       * sort
	dr	rlistmode	* listmode change
    ;dr  rlistmodePop
    dr  .exit       * resize gadget
    dr  .rpositionslider
    dr  .rplaymodechange

.rpositionslider
    jmp     positionSliderMoved
.rplaymodechange
    jmp     togglePlayMode

* Print some text into the filebox
** a0 = teksti
printbox:
	tst.b	win(a5)
	beq.b	.q
	tst	boxsize(a5)
	bne.b	.p
.q	rts
.p	pushm	d0/a0
	bsr	clearbox		* fileboxi tyhj‰ks
	popm	d0/a0

	move.l	a0,a1
    moveq   #-1,d0
.c	cmp.b	#10,(a1)
	beq.b	.cc
	tst.b   (a1)+
.cc	dbeq    d0,.c
 	not.l   d0	* strlen in d0

	pushm	a0/a6
	* d0 = length of text
	* a0 = text
	move.l	rastport(a5),a1
	lore	GFX,TextLength
	popm	a0/a6
	* d0 = text width in pixels
	* center in the window
	move 	previousWindowWidth(a5),d1
	sub		#20,d1
	sub		d0,d1
	addq	#1,d1 * round up, looks nicer
	lsr		#1,d1
	move	d1,d0
	add		#20,d0

;	moveq	#69+WINY,d1	
	move	fileBoxTopEdge(a5),d1
	addq	#6,d1 * magic constant

 	move	boxsize(a5),d2
	lsr	#1,d2
	subq	#1,d2
	mulu	listFontHeight(a5),d2
	add	d2,d1
	bra	print

rlistmode:
    ; No toggling while in Zoomed mode
    tst     boxsize(a5)
    beq     beep
	jmp	    toggleListMode


*******************************************************************************
* Sortti
*******

* This creates an array of
* 4 bytes  = node pointer to the module entry,
* sorts that, and recreates the module list.

SORT_ELEMENT_LENGTH = 8


rsort:
sortButtonAction:
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	bne.b	.1
	DPRINT	"Sort disabled in file browser"
.x	rts
.1
	skipIfGadgetDisabled gadgetSortButton

	jsr	confirmFavoritesModification
	beq.b	.x

	bsr.b	sortModuleList
	bra	forceRefreshList

sortModuleList:
	* Skip force refresh
	* Let's not sort a list with 1 module, that would be silly I guess.
	cmp.l	#2,modamount(a5)
	bhs.b	.so
	rts
.so
	bsr	lockMainWindow

	* Skip info display in these cases
	cmp.l	#100,modamount(a5)
	blo.b	.d
	* Annoying to see the text flashing rapidly
	* when browsing
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	beq.b	.d
	
	lea	.t(pc),a0
	bsr		printbox
	bra.b	.d
.t	dc.b	"Sorting...",0
 even

.d
 if DEBUG
	clr.l	sortSwaps
	clr.l	sortComps
 	jsr		startMeasure
 endif
	move.l	modamount(a5),d0
	moveq	#SORT_ELEMENT_LENGTH,d1		* node address and weight
	bsr	mulu_32		* 
	addq.l	#8,d0			* add some empty space, this is needed when rebuilding the list
							* to check if end is reached.
	move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
	bsr	getmem
	move.l	d0,sortbuf(a5)
	bne.b	.okr
	bsr 	showOutOfMemoryError
	bra	.error
.okr
	move.l	d0,a2

** Lasketaan painot jokaiselle
	DPRINT  "rsort obtain list"
	bsr	obtainModuleList
	bsr	getVisibleModuleListHeader
	move.l	a0,a3

	* sort table in a2
	move.l	(a3),a3		* MLH_HEAD
.ploop
	tst.l	(a3)		* check if last node?
	beq.b	.ep

	* Fill slot with node address
	move.l	a3,(a2)

	* Remove node from list
	move.l	a3,a1		* poistetaan node (a1)
	REMOVE

	* get next node
	SUCC	a3,a3
	* next slot
	addq.l	#SORT_ELEMENT_LENGTH,a2
	bra.b	.ploop
.ep
	* Weights done
	* Now sort in divider sections

	move.l	sortbuf(a5),a3

.ml	moveq	#0,d5		* 1. sortattava node
	moveq	#0,d6		* viimeinen sortattava node

	bsr	.eka
	bne.b	.loph

	move.l	a3,d5

	bsr	.toka

	move.l	a3,d7
	sub.l	d5,d7		* montako nodea sortataan

	* Nodes count
	lsr.l	#3,d7	; /8 - SORT_ELEMENT_LENGTH

;	subq	#1,d7		* 1 pois (listan loppu tai seuraava divideri)
	cmp.l	#2,d7		* v‰h 2 kpl
	blo.b	.ml

	move.l	d5,a2
	bsr	.sort
	* check if ran out of mem
	tst.l	d0
	bne.b	 .ml
	* show error and stop, list will be partially sorted or not at all
	bsr 	showOutOfMemoryError

.loph

	* Start rebuilding the list with sorted nodes
	move.l	sortbuf(a5),a3
	bsr	getVisibleModuleListHeader
	move.l	a0,a2
.er
	tst.l	(a3)
	beq.b	.r			* end reached? this is the extra space mentioned above
	move.l	(a3),a1  	* grab node address

	* Add a1 to a0
	move.l	a2,a0
	ADDTAIL			* lis‰t‰‰n node (a1)
	addq.l	#SORT_ELEMENT_LENGTH,a3
	bra.b	.er
.r

.error

	move.l	sortbuf(a5),a0
	bsr	freemem


 if DEBUG
	jsr		stopMeasure
	divu	#1000,d0
	move.l	d0,d1
	ext.l	d0
	clr		d1
	swap	d1
	DPRINT	"Sort took %lds %ldms"
* Old sort: A500 modsanth-kick13-prg: 10s
* New sort: A500 modsanth-kick13-prg: 73s, sad
* Newer sort: A500 modsanth-kick13-prg: 12s

 endif

		bsr	listChanged
	tst.l	playingmodule(a5)
	bmi.b	.npl
	move.l	#PLAYING_MODULE_REMOVED,playingmodule(a5)
.npl	clr.l	chosenmodule(a5)

 if DEBUG
	move.l	sortSwaps,d1
	move.l	sortComps,d0
	DPRINT	"Compares=%ld swaps=%ld"
 endif

	DPRINT  "rsort release list"
	bsr	releaseModuleList
	bra	unlockMainWindow

* a3 = lista
* Hakee ensimm‰isen nimen, joka ei ole divideri

.eka
.ploop2
	tst.l	(a3)		* Oliko viimeinen
	beq.b	.ep2
	move.l	(a3),a0
	tst.b	l_divider(a0)
	beq.b	.jep1
	* Ignore dividers in browser mode
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	beq.b	.jep1

	addq.l	#SORT_ELEMENT_LENGTH,a3
	bra.b	.ploop2

.ep2	moveq	#-1,d0
	rts
.jep1	moveq	#0,d0
	rts

* Hakee dividerin tai listan lopun a3:een

.toka
.ploop3
	tst.l	(a3)		* Oliko viimeinen
	beq.b	.jep1
	move.l	(a3),a0
	* Ignore dividers in browser mode
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	beq.b	._d
	tst.b	l_divider(a0)
	bne.b	.jep1
._d
	addq.l	#SORT_ELEMENT_LENGTH,a3
	bra.b	.ploop3


*--------------------

.sort
	pushm	d1-a6
 	jsr		combSortNodeArray 
 	popm	d1-a6
	rts


*******************************************************************************
* Move
*******
rmove
moveButtonAction
	skipIfGadgetDisabled gadgetMoveButton

	tst.b	movenode(a5)	* Jos toistamiseen painetaan, menn‰‰n "play"hin
	bne	rbutton1

	cmp.l	#2,modamount(a5)
	blo.b	.qq
	bsr	getcurrent
	beq.b	.q
	jsr	confirmFavoritesModification
	beq.b	.qq

	move.l	a3,nodetomove(a5)
 if DEBUG
	move.l	l_nameaddr(a3),d0
	DPRINT	"moving %s"
 endc
	st	movenode(a5)
	move.l	a3,a1
	lore	Exec,Remove
	subq.l	#1,modamount(a5)
	bsr	listChanged
	tst.l	playingmodule(a5)
	bmi.b	.q
	move.l	#PLAYING_MODULE_REMOVED,playingmodule(a5)
.q	
	bsr	forceRefreshList
.qq	rts



* etsit‰‰n listasta vastaava kohta
;	DPRINT  "getcurrent obtain list"
; 	bsr		obtainModuleList
; 	lea	er(a5),a4
; .luuppo
; 	TSTNODE	a4,a3
; 	beq.b	.q
; 	move.l	a3,a4
; 	;dbf	d0,.luuppo
; 	subq.l	#1,d0 
; 	bpl.b  .luuppo
; 	DPRINT  "getcurrent release list 1"
; 	bsr		releaseModuleList
* a3 = valittu nimi
; 	moveq	#1,d0
; 	rts
; .q	
; 	DPRINT  "getcurrent release list 2"
; ;	bsr		releaseModuleList
; 	moveq	#0,d0
; 	rts



*******************************************************************************
* Comment file
*******

comment_file
	bsr	getcurrent
	beq.b	.x
    * Only local files considered:
    tst.b   l_remote(a3)
    bne     .x

	move.l	a3,a4

** kaapataan vanha kommentti

	moveq	#0,d4
	pushpea	l_filename(a3),d1
	moveq	#ACCESS_READ,d2
	lore	Dos,Lock
	move.l	d0,d4
	beq.b	.ne

	move.l	d4,d1
	pushpea	fileinfoblock(a5),d2
	lob	Examine

	move.l	d4,d1
	beq.b	.ne
	lob	UnLock
.ne

	bsr	get_rt
	lea	-90(sp),sp

** initial string
	lea	fileinfoblock+fib_Comment(a5),a0
	move.l	sp,a1
.c	move.b	(a0)+,(a1)+
	bne.b	.c

	move.l	sp,a1
	moveq	#79,d0		* max chars
	sub.l	a3,a3
	lea	ftags(pc),a0
	lea	.ti(pc),a2
	bsr	setMainWindowWaitPointer
	lob	rtGetStringA
	tst.l	d0
	beq.b	.xx

	pushpea	l_filename(a4),d1
	move.l	sp,d2
	lore	Dos,SetComment
	
.xx	bsr	clearMainWindowWaitPointer
	lea	90(sp),sp
.x	rts

.ti	dc.b	"Enter file comment",0
 even

	

*******************************************************************************
* Find module
*******

* In:
*    a0 = search string
* Out:
*    d0 = true if not too small
beepIfSearchStringIsSmall:
    * Beep display if search term is too small
;    lea     gadgetSearchStringBuffer,a0
    move.l  a0,a1
.len  
    tst.b   (a1)+
    bne     .len
    sub.l   a0,a1

    cmp     #2+1,a1 * strlen=2 or more -> ok
    bhs.b   .1
    cmp     #1,a1   * strlen=0 -> cancel
    beq     .2
    bsr     beep    * strlen=1 -> beep
.2
    moveq   #0,d0
    rts
.1  moveq   #1,d0
    rts

beep:
    move.l  windowbase(a5),a0
    move.l  wd_WScreen(a0),a0
    lore    Intui,DisplayBeep
    rts

gadgetSearchStringAction:
 if DEBUG
    lea     gadgetSearchStringBuffer,a0
    ext.l   d0
    move.l  a0,d1
    DPRINT  "search string action %ld %s"
 endif
    lea     gadgetSearchStringBuffer,a0
    bsr     beepIfSearchStringIsSmall
    bne     .1
    DPRINT  "canceled"
    jmp     switchToNormalLayoutIfPossible

.1
    
    lea     modlandSearch,a0
    basereg modlandSearch,a0
    move.b  selectedSearch(a5),d0
	beq.b	.amigaRemix
	subq.b	#1,d0
	beq.b	.aminet
	subq.b	#1,d0
	beq.b	.hvsc
	subq.b	#1,d0
	beq.b	.modland
	subq.b	#1,d0
	beq.b	.modules
	subq.b	#1,d0
	beq.b	.stations
	subq.b	#1,d0
	beq.b	.rko
	subq.b	#1,d0
	beq.b	.recentPlaylists
	subq.b	#1,d0
	beq.b	.turran
.skip
	rts

.modland
	jmp	modlandSearch(a0)
.aminet
	jmp	aminetSearch(a0)
.modules
	jmp	modulesSearch(a0)
.hvsc
	jmp	hvscSearch(a0)
.amigaRemix
	jmp	amigaRemixSearch(a0)
.rko
    jmp rkoSearch(a0)
.stations
    jmp stationsSearch(a0) 
.recentPlaylists
    jmp recentPlaylistsSearch(a0) 
.turran
    jmp turranSearch(a0) 
    endb    a0



gadgetSearchSourceAction:
	lea		gadgeSearchSourceOptions(pc),a4
	lea		gadgetSearchSource,a0
	move	gg_LeftEdge(a0),d6
	moveq	#20,d7
	add		gg_TopEdge(a0),d7
    moveq   #0,d4   * no callbackkkkk
    moveq   #0,d0
    move.b  selectedSearch(a5),d0
	bsr		listSelectorMainWindowPreselect
	bmi 	.skip
 if DEBUG
    ext.l   d0
    DPRINT  "selected source=%ld"
 endif
    move.b  d0,selectedSearch(a5)
    jsr     refreshGadgetSearchSource
    cmp.b   #SEARCH_RECENT_PLAYLISTS,selectedSearch(a5)
    beq     .1
    jmp     activateSearchStringGadget
.1  
    jmp     recentPlaylistsSearch
.skip
    rts

gadgeSearchSourceOptions:
	* max width, rows
	dc.b	15,9
gadgetSearchSourceOption1:
  dc.b    "AmigaRemix",0        ; 4
  dc.b    "Aminet",0            ; 1
  dc.b    "HVSC",0              ; 3
  dc.b    "Modland",0           ; 0
  dc.b    "Modules.pl",0        ; 2 
  dc.b    "Radio stations",0    ; 6
  dc.b    "Remix.Kwed.org",0    ; 5
  dc.b    "Shared lists",0      ; 7  
  dc.b    "Turran FTP",0        ; 8 
  even

searchActivate:
    DPRINT  "search activate"
    tst.b   uhcAvailable(a5)
    bne     .1
    rts
.1
    tst.w   searchLayoutActive(a5)      
    bne     .x
    * Switch to search view 
    jsr     engageSearchResultsMode
.x
    * Activate popup
    bsr     gadgetSearchSourceAction
    cmp.b   #SEARCH_RECENT_PLAYLISTS,selectedSearch(a5)
    beq     .y
    * Then activate string gadget
    jsr     activateSearchStringGadget
.y
    rts




* in:
*   d3 = index to check
;listSelectorUhcCallback
;	; Disable rows from 2 onwards UHC not available
;	cmp		#3,d3
;	blo.b	.n
;	tst.b	uhcAvailable(a5)
;	bne.b	.n
;	moveq	#0,d0
;	rts
;.n	moveq	#1,d0
;	rts



;enterSearchPattern_t
;	dc.b	"Enter search pattern",0
; even

gadgetFindAction:
    DPRINT  "gadgetFindAction"
    lea     gadgetLocalSearchStringBuffer,a3
    tst.b   (a3)
    bne     .1
    DPRINT  "canceled"
    jmp     switchToNormalLayoutIfPossible
.1
    * Find!
    lea     findpattern(a5),a1
.c  move.b  (a3)+,(a1)+
    bne     .c
    move.l  chosenmodule(a5),-(sp)
    bsr     do_find_continue
    move.l  (sp)+,d0
    cmp.l   chosenmodule(a5),d0
    bne     .found
    bsr     beep
.found

    DPRINT  "restore layout"
    * Return the layout to whatever it was
    cmp.b   #LISTMODE_SEARCH,listMode(a5)
    bne     .norm
    jsr     switchToNormalLayoutNoRefresh
    jsr     switchToSearchLayout
    ; Refresh to update search results
    bra     forceRefreshList
.norm   
    jsr     switchToNormalLayout
    bra     forceRefreshList

find_new:
    tst     boxsize(a5) * Disable if box hidden
    beq     beep
	cmp.l	#3,modamount(a5)
	blo 	beep
    jmp     switchToLocalSearchLayout
    
;	bsr	get_rt
;	lea	findpattern(a5),a1	
;	moveq	#27,d0
;	sub.l	a3,a3
;	lea	ftags(pc),a0
;	lea	enterSearchPattern_t(pc),a2
;	bsr	setMainWindowWaitPointer
;	lob	rtGetStringA
;	bsr	clearMainWindowWaitPointer
;	tst.l	d0
;	bne.b	find_continue	
;	rts
;
ftags
	dc.l	RTGS_Width,262
	dc.l	RT_TextAttr,text_attr
otag15	dc.l	RT_PubScrName,pubScreenNameTags+var_b
	dc.l	TAG_END
	



find_continue:
	cmp.l	#3,modamount(a5)
	bhi.b	.ok
    bra     beep
.ok
    tst.b   findpattern(a5)
    beq     beep

    move.l  chosenmodule(a5),-(sp)
    bsr     do_find_continue
    move.l  (sp)+,d0
    cmp.l   chosenmodule(a5),d0
    beq     .notFound
    DPRINT  "found"
	bra	forceRefreshList
.notFound
    DPRINT  "not found"
    bra     beep
    
do_find_continue
	bsr	setMainWindowWaitPointer
	pea	clearMainWindowWaitPointer(pc)

	; Use chosen module as starting point of seardh

	DPRINT  "find_continue obtain list"
	bsr	obtainModuleList

	bsr	getcurrent		* a0 => chosen module listnode
	tst.l	d0 
	bne.b	.foundCurrent
	* start from beginning
	clr.l	chosenmodule(a5)
	bsr	getcurrent
.foundCurrent

	move.l	a0,a3
	move.l	a3,a4

	move.l	chosenmodule(a5),d7
;	subq	#1,d7

	move	#$df,d2

.luuppo
	addq.l	#1,d7
	TSTNODE	a4,a3
	beq.b	.qq
	move.l	a3,a4
	bsr.b	.find
	bne.b	.luuppo
	bra.b	.q
.qq
* lista l‰pi eik‰ lˆytyny. k‰yd‰‰n alusta l‰htˆkohtaan.

	moveq	#-1,d7
	bsr	getVisibleModuleListHeader
	move.l	a0,a4
.luuppo2
	addq.l	#1,d7
	cmp.l	chosenmodule(a5),d7
	beq.b	.q
	TSTNODE	a4,a3
	beq.b	.q
	move.l	a3,a4
	bsr.b	.find
	bne.b	.luuppo2

.q	
	DPRINT  "find_continue release list"
	bra 	releaseModuleList

* String matchng: convert to uppercase, space equals underscore
.find
	move.l	l_nameaddr(a3),a0

.flop1	lea	findpattern(a5),a1
	move.b	(a1)+,d0
    cmp.b   #"_",d0
    bne.b   .3
    moveq   #" ",d0
.3	and.b	d2,d0

.flop2	move.b	(a0)+,d1
	beq.b	.notfound
    cmp.b   #"_",d1
    bne.b   .1
    moveq   #" ",d1
.1	and.b	d2,d1
	cmp.b	d0,d1
	bne.b	.flop2
	
.flop3	move.b	(a1)+,d0
	beq.b	.found
    cmp.b   #"_",d0
    bne.b   .4
    moveq   #" ",d0
.4	and.b	d2,d0
	move.b	(a0)+,d1
	beq.b	.notfound
    cmp.b   #"_",d1
    bne.b   .2
    moveq   #" ",d1
.2  and.b	d2,d1
	cmp.b	d0,d1
	beq.b	.flop3
	subq	#1,a0
	bra.b	.flop1

.notfound
	moveq	#-1,d0
	rts

.found	
	move.l	d7,chosenmodule(a5)
 if DEBUG
	move.l	d7,d0
	DPRINT	"Found module at %ld"
 endc
	moveq	#0,d0
	rts




*******************************************************************************
* Kelaus
*******
rbutton_kela1
	tst.b	playing(a5)
	beq.b	.e
	tst.l	playingmodule(a5)
	bmi.b	.e
	st	kelattiintaakse(a5)
	move.l	playerbase(a5),a0
	jsr	p_taakse(a0)	
.e	rts

rbutton_kela2_turbo
	move.b	#1,kelausvauhti(a5)
	tst.b	playing(a5)
	beq.b	.e
	tst.l	playingmodule(a5)
	bmi.b	.e
	move.l	playerbase(a5),a0
	move	p_liput(a0),d0
	btst	#pb_ciakelaus2,d0
	beq.b	.nr
	not.b	kelausnappi(a5)
	rts

.nr	move.b	#2,kelausvauhti(a5)
	bra.b	rkelr

.e	rts


rbutton_kela2
	move.b	#1,kelausvauhti(a5)
rkelr

	tst.b	playing(a5)
	beq.b	.e
	tst.l	playingmodule(a5)
	bmi.b	.e
	move.l	playerbase(a5),a0
	move	p_liput(a0),d0
	btst	#pb_ciakelaus,d0
	beq.b	.norm
	not.b	kelausnappi(a5)
	rts

.norm	jmp	p_eteen(a0)	
.e	rts

*******************************************************************************
* New
*******
newButtonAction
rbutton11
	skipIfGadgetDisabled gadgetNewButton
    jsr     confirmFavoritesModification
    bne     .1
    rts
.1
	st	new(a5)
;	bsr	rbutton9		* Clear list
	bra	rbutton1		* Play


*******************************************************************************
* P‰ivitet‰‰n propgadgetteja, kun liikutaan hiirell‰
*******
mousemoving
	movem.l	d0-a6,-(sp)
;	DPRINT	"mousemove"
	lea	slider1,a2
	bsr	rslider1
	lea	slider4,a2
	bsr	rslider4
	bsr	tooltipHandler
	movem.l	(sp)+,d0-a6
	rts


*******************************************************************************
* Next
*******
nextButtonAction:
rbutton5
	moveq	#1,d7		* liikutaan eteenp‰in listassa
	bra	soitamodi

*******************************************************************************
* Prev
*******
prevButtonAction:
rbutton6
	moveq	#-1,d7		* liikutaankin taakkep‰in listassa
	bra	soitamodi


*******************************************************************************
* Song number <
*******
actionNextSong
rbutton12
	moveq	#1,d1		* lis‰t‰‰n songnumberia

songSkip
    DPRINT  "Next/prev song action"

	tst.l	playingmodule(a5)
	bmi.b	.nosong

	clr.b	kelausnappi(a5)

	* this is reversed! TODO: FIX?
	move	songnumber(a5),d0
	sub	d1,d0

	move	minsong(a5),d1 
	move	maxsongs(a5),d2
	bsr	clampWord

	DPRINT	"New song: %ld"
	move	d0,songnumber(a5)

	st	kelattiintaakse(a5)
	clr.b	playing(a5)
	move.l	playerbase(a5),a0
	jsr	p_song(a0)
	st	playing(a5)
	st	kelattiintaakse(a5)
	bsr	settimestart

	bsr	inforivit_play
    jsr uslGetSongLength
.err	
	bsr	lootaan_aika
.nosong
	rts

*******************************************************************************
* Song number >
*******
actionPrevSong
rbutton13
	moveq	#-1,d1			* v‰hennet‰‰n songnumberia
	bra 	songSkip


******************************************************************************
* Stop
*******
actionStopButton
rbutton3
	tst.l	playingmodule(a5)
	bpl.b	.hu
.hehe	rts
.hu	
	DPRINT	"stop"

	clr.b	kelausnappi(a5)

	move.l	playerbase(a5),a0
	moveq	#pf_stop,d0
	and	p_liput(a0),d0
	beq.b	.hehe

	bsr	fadevolumedown
	move	d0,-(sp)

	* The "playing" flags is polled in the interrupts.
	clr.b	playing(a5)
	move.l	playerbase(a5),a0
	jsr	p_stop(a0)
	
	move	(sp)+,mainvolume(a5)    
 if DEBUG
    move.l  moduleaddress(a5),d0
    DPRINT  "module=%lx"
 endif



	bra	inforivit_pause
;.hehe	rts

*******************************************************************************
* Cont
*******
actionContinue
	tst.l	playingmodule(a5)
	bpl.b	.hu
.hehe	rts
.hu	
	DPRINT	"continue"

	clr.b	kelausnappi(a5)

	move.l	playerbase(a5),a0
	moveq	#pf_cont,d0
	and	p_liput(a0),d0
	beq.b	.hehe

	st	playing(a5)
	move.l	playerbase(a5),a0
	jsr	p_cont(a0)

	bsr	fadevolumeup

	bra	inforivit_play
;	rts
	
*******************************************************************************
* Eject
*******
rbutton4b
	moveq	#1,d0		* fade volume: no
	bra.b	rbutton4a

ejectButtonAction
rbutton4
	moveq	#0,d0		* fade volume: allowed
rbutton4a
	DPRINT	"Eject button action"
	clr.b	kelausnappi(a5)

	tst.l	playingmodule(a5)
	bpl.b	.hu
	bra	freemodule
.hu	
	tst	d0
	bne.b	.nofa

	bsr	fadevolumedown

.nofa	move	d0,-(sp)
	DPRINT	"Replay end (eject)"

	lore    Exec,Disable
	bsr	halt
	move.l	#PLAYING_MODULE_NONE,playingmodule(a5)
	lore    Exec,Enable
	move.l	playerbase(a5),d0
	move.l	playerbase(a5),a0
	jsr	p_end(a0)
	
	bsr	freemodule
	move	(sp)+,mainvolume(a5)
	clr.b	movenode(a5)
	rts


*******************************************************************************
* Tyhjennet‰‰n moduulista
*******
rbutton9
	DPRINT	"clearListButtonAction"
	skipIfGadgetDisabled gadgetNewButton
	jsr	confirmFavoritesModification
	bne.b	clearlist
	rts

clearlist
	clr.b	movenode(a5)
	DPRINT  "clearlist"
	bsr	setMainWindowWaitPointer
	cmp.b	#LISTMODE_FAVORITES,listMode(a5)
	beq.b	.isFav
	bsr	freelist
	bra.b	.done 
.isFav
	jsr	freeFavoriteList
.done
	DPRINT "clearlist done"
	bsr	clearMainWindowWaitPointer
	bra	shownames

*******************************************************************************
* Volumegadgetti
*******
rslider1
	move.l	gg_SpecialInfo(a2),a0
	move	pi_HorizPot(a0),d0
	cmp	slider1old(a5),d0
	bne.b	.new
	rts
.new	move	d0,slider1old(a5)
	moveq	#64,d0		* max
	bsr	nappilasku
	move	d0,mainvolume(a5)

	tst.l	playingmodule(a5)
	bmi.b	.ee
	move.l	playerbase(a5),a0
	jsr	p_volume(a0)
.ee	
	rts



*** D0 = volume
*** Uusi volumearvo ja sliderin p‰ivitys
volumerefresh
	cmp	#64,d0
	blo.b	.r
	moveq	#64,d0
.r	move	d0,mainvolume(a5)

	mulu	#65535,d0
	;divu	#64,d0
	lsr.l	#6,d0
	lea	slider1,a0
	move.l	gg_SpecialInfo(a0),a1
	move	d0,d1

	tst.b	win(a5)
	beq.b	.nw

	move	pi_Flags(a1),d0
	move	pi_HorizBody(a1),d3
	moveq	#0,d2
	moveq	#0,d4
	move.l	windowbase(a5),a1
	sub.l	a2,a2
	moveq	#1,d5
	lore	Intui,NewModifyProp
.nw
	tst.b	playing(a5)
	beq.b	.k
	move	mainvolume(a5),d0
	move.l	playerbase(a5),a0
	jsr	p_volume(a0)
.k	rts



*******************************************************************************
* Fileselectorgadgetti
*******
* Calculates the first visible filename based on slider position

rslider4
	move.l	gg_SpecialInfo(a2),a0
	move	pi_VertPot(a0),d0
	cmp	slider4old(a5),d0
	bne.b	.new
.q	rts
.new	move	d0,slider4old(a5)

	* Map VertPot [0..$ffff] to [0..modamount-boxsize].
	* This calculation will not fit into 32 bits if modamount is 0x1ffff.
	* Will be ok if we scale VertPot down one bit.
	* Take scaling into account later below as well.

	and.l	#$ffff,d0
	;DPRINT "slider4 mouse, VertPot=%lx"

	lsr.l	#1,d0		* [0..$7fff]

	move.l	modamount(a5),d1
	moveq	#0,d2
	move	boxsize(a5),d2

    * Adjust accordingly if the bottom search layout is active
    tst.w   searchLayoutActive(a5)     
    beq.b   .lm1
    subq    #SEARCH_BOXSIZE_DELTA,d2
.lm1

	sub.l	d2,d1
	bpl.b	.e
	moveq	#0,d1
.e
	bsr 	mulu_32
	add.l	#32767>>1,d0		* round upwards
	move.l	#65535>>1,d1 
	bsr	divu_32

	cmp.l	firstname(a5),d0
	beq.b	.q
	move.l	d0,firstname(a5)
	bra	showNamesNoCentering

*******************************************************************************
* Suhteutetaan nuppi tiedostojen m‰‰r‰‰n
* Asetetaan valitun nimen kohdalle
*******

forceRefreshList:
	DPRINT	"forceRefreshList"
	st	hippoonbox(a5)


resh:	pushm	all
	bsr	shownames
	bsr.b	reslider
	popm	all
	rts

* Resizes the box slider gadget according to the amount of modules in it
reslider:

	* Calculate pi_vertBody, the vertical size of the prop gadget.
	move.l	modamount(a5),d0
	bne.b	.e
	moveq	#1,d0
.e
	moveq	#0,d1
	move	boxsize(a5),d1
	beq	.eiup

	cmp.l	d1,d0		* v‰h boxsize
	bhs.b	.ok
	move.l	d1,d0
.ok
	lsl.l	#8,d0
	bsr	divu_32
 	
	move.l	d0,d1
	move.l	#65535<<8,d0
	bsr	divu_32
	move.l	d0,d1
	bsr	.ch

 	; VertPot should be in range 0..$ffff

	lea	slider4,a0
	move.l	gg_SpecialInfo(a0),a1
	cmp	pi_VertBody(a1),d0
	sne	d4		* did it change compared to previous?
	lsl	#8,d4
	move	d0,pi_VertBody(a1)

* Below a historical comment line expressing joy:

*** Toimii vihdoinkin!

	* Calculate pi_vertPot, the vertical position of the prop gadget.
	* calculations will not fit into 32-bits if firstname is over 0xffff.
	* scale calculations down with 1 bit.

	* vertpot = (first name index) * 65535 / (modamount-boxsize)
	* modamount: 10000
	* boxsize: 20
	* firstname: 10000-20
	* ->
	* (10000-20)*(65535/2)/((10000/2)-20/2) = 0xffff

	move.l	firstname(a5),d0
	* scale down, +1 is needed to round upwards
	* as the fractions get floored off
	move.l	#65535,d1  * scale 
	;bsr	mulu_32
	bsr	mulu_64
	* d0:d1 now has a 64-bit value 

	move.l	modamount(a5),d2
	moveq	#0,d3
	move	boxsize(a5),d3 
	sub.l	d3,d2
	bgt.b	.positive	* check if over 0
	moveq	#1,d2	 	* avoid zero division
.positive

;	bsr	divu_32  * d0=d0/d1
	bsr	divu_64	 
	* d0:d1 is now d0:d1/d2
	* take the lower 32 bits
	move.l	d1,d0	
	bsr	.ch

	cmp	pi_VertPot(a1),d0
	sne	d4		* did it change compared to previous?
	move	d0,pi_VertPot(a1)

	* Subsequent mousemoves will call rslider4 to update
	* firstname according to VertPot, but that is not needed
	* since we did that already here. There would also be
	* jumps because the VertPot range 0..0xffff is not
	* very accurate for large amount of modules.
	move	d0,slider4old(a5)

	move	gg_Height(a0),d0

	basereg	slider4,a0

	cmp	#8,slimheight(a0)
	blo.b	.fea

	cmp	slider4oldheight(a5),d0
	bne.b	.fea

	tst	d4		* was there a change?
	beq.b	.eiup

.fea	tst.b	win(a5)
	beq.b	.eiup

	move	d0,slider4oldheight(a5)

;	move	gg_Height(a0),d0
	mulu	pi_VertBody(a1),d0	* koko pixelein‰
	divu	#$ffff,d0
	bne.b	.f
	moveq	#8,d0			* onko < 1? minimiksi 8
.f
	cmp	#8,d0
	bhs.b	.zze
	moveq	#8,d0
.zze
	move	d0,slimheight(a0)
	subq	#2+1,d0
	move	d0,d1

	lea	slim,a2
	lea	slim1a(a0),a1
	tst.b	uusikick(a5)
	bne.b	.newz
	* Select alternate gfx
	lea	slim1a_kick13-slim1a(a1),a1
.newz
	move	(a1)+,(a2)+
.filf	move	(a1),(a2)+
	dbf	d0,.filf
	addq	#2,a1
	move	(a1)+,(a2)+

	move	(a1)+,(a2)+
.fil	move	(a1),(a2)+
	dbf	d1,.fil
	move	2(a1),(a2)

.bar

	* Refresh one gadget
	;lea	slider4,a0
	endb	a0
	bsr	refreshGadgetInA0

.eiup
	rts


.ch	cmp.l	#$ffff,d0
	bls.b	.ok3
	move.l	#$ffff,d0
.ok3	rts


;resetslider
;	move.l	a0,-(sp)
;	move.l	slider4+gg_SpecialInfo,a0
;	clr	pi_VertPot(a0)
;	move.l	(sp)+,a0
;	rts




*******************************************************************************
* Play module
*******
* TODO: obtainModuleList
* TODO: most of this is duplicated elsewhere? in signalreceived?

playButtonAction:
rbutton1:
	DPRINT  "playButtonAction"

	tst.b	movenode(a5)
	beq	.nomove

**** Onko move p‰‰ll‰?
	clr.b	movenode(a5)

	bsr	getcurrent
	bne.b	.gotCurrent
	* No selection! Insert to beginning
	bsr	getVisibleModuleListHeader
	move.l	a0,a3
.gotCurrent

 if DEBUG
 	move.l	l_nameaddr(a3),d0
	DPRINT	"move, inserting after %s"
 endc

	DPRINT  "playButtonAction obtain list"
	bsr	obtainModuleList
	;lea	moduleListHeader(a5),a0	* Insertoidaan node...
	bsr	getVisibleModuleListHeader
	move.l	nodetomove(a5),a1
	move.l	a3,a2
	
	lore	Exec,Insert
	addq.l	#1,modamount(a5)
	addq.l	#1,chosenmodule(a5)	* valitaan movetettu node
	DPRINT  "playButtonAction release list"
	bsr	releaseModuleList
	bsr	listChanged
	bra	forceRefreshList

.nomove
	;check	2		* reg check

	tst.b	new(a5)			* onko New?
	bne.b	.newoe

	tst.l	modamount(a5)		* onko modeja
	bne.b	.huh

.newoe	;st	new2(a5)
	st	haluttiinuusimodi(a5)
	bra	rbutton7		* jos ei, ladataan...

.huh	move.l	chosenmodule(a5),d0	* onko valittua nime‰
	bpl.b	.ere
	moveq	#0,d0			* jos ei, otetaan eka
.ere	
	move.l	d0,d2

	DPRINT	"->chosen module %ld"

	;move.b	new2(a5),d1
	;clr.b	new2(a5)

	cmp.b	#pm_random,playmode(a5)
	bne.b	.xa

	move.b	tabularasa(a5),d3
	clr.b	tabularasa(a5)
	tst.b	d3
	bne	soitamodi_random

	;tst.b	d1
	;bne	soitamodi_random * soita randomi, now 'New' ja randomplay
	;bsr	shownames
.xa

	bsr	clear_random		* Tyhj‰x
	bsr	setRandomTableEntry		* merkit‰‰n...

* etsit‰‰n listasta vastaava tiedosto

	DPRINT	"playbutton getListNode"
	bsr	getListNode
	beq	.erer
	move.l 	a0,a3

	* Is it a divider?
;	isListDivider l_filename(a3)
	tst.b	l_divider(a3)
	beq.b	.je

	* In file browser mode, dividers need special attention
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	bne.b	.noBrowser
	jmp	fileBrowserDir
.noBrowser

	* skip over to the next module if this was a divider
	TSTNODE	a3,a3
	beq	.erer			* end of list reached?
							* try the next one
	addq.l	#1,chosenmodule(a5)
	bsr	resh
	bra	.huh
.je
	cmp.l 	playingmodule(a5),d2	* onko sama kuin juuri soitettava??
	bne	.new
	* Special case: some delicustoms, SUNTronic modules,
	* can't handle being started over, to be safe
	* load these modules again before restarting.
	cmp	#pt_delicustom,playertype(a5)
	beq	.new
    * PIPE midi sample? These need a full restart too.
    cmp     #pt_sample,playertype(a5)
    bne    .notSmp
    move.l  modulefilename(a5),a0
    cmp.b   #"P",(a0)+
    bne     .notSmp
    cmp.b   #"I",(a0)+
    bne     .notSmp
    cmp.b   #"P",(a0)+
    bne     .notSmp
    cmp.b   #"E",(a0)
    beq     .new
.notSmp
	* Same with all EaglePlayers to be safe.
	* At least Tim Follin crashes.
	cmp	#pt_eagle_start,playertype(a5)
	bhs	.new
	* Similar case with SonicArranger with built-in
	* replayer code. Data is modified upon init so that
	* subsequent inits with same data will fail as
	* unsupported module.
	cmp	#pt_sonicarranger,playertype(a5)
	bne.b	.notSoar
	* Check for "compact" SA module
	move.l  moduleaddress(a5),a0 
	cmp.l	#'SOAR',(a0)
	bne 	.new
.notSoar
	DPRINT	"Restarting the same module!"
;.early
	bsr	fadevolumedown
	move	d0,-(sp)


	DPRINT	"Replay end"
* Soitetaan vaan alusta
    push    a3
	bsr	halt
	move.l	playerbase(a5),a0
	jsr	p_end(a0)
    pop     a3
	move	(sp)+,mainvolume(a5)

    moveq   #0,d0
    move.b  l_favSong(a3),d0
    move    d0,songnumber(a5)
    DPRINT  "/// fav song: %ld"

	DPRINT	"/// Replay init"
	move.l	playerbase(a5),a0
	jsr	p_init(a0)
	tst.l	d0
	bne	.inierr

	st	playing(a5)		* Ei varmaan tuu initerroria
	bsr	settimestart
	bsr	inforivit_play
    jsr uslGetSongLength
	bra	start_info
	;rts

.new	moveq	#0,d7
	tst.l	playingmodule(a5)	* Onko soitettavana mit‰‰n?
	bmi 	.nomod

	move.b	doublebuf(a5),d7	* Onko doublebufferinki p‰‰ll‰?
    lea     l_filename(a3),a0
    tst.b   l_remote(a3)
    beq.b   .notRem1
    moveq   #0,d7 * disable for remotes!
.notRem1
    tst.b   d7
	bne.b	.nomod

	bsr	fadevolumedown
	move	d0,-(sp)
	DPRINT	"Replay end"
    push    d7          * save this!
	bsr	halt			* Vapautetaan se jos on
	move.l	playerbase(a5),a0
	jsr	p_end(a0)
	bsr	freemodule	
    pop     d7
	move	(sp)+,mainvolume(a5)
.nomod

	move.l	d2,playingmodule(a5)	* Uusi numero

	lea	l_filename(a3),a0	* Ladataan
	move.b	d7,d0 * double buffering flag
    tst.b   l_remote(a3)
    beq.b   .notRem2
    moveq   #0,d7 * disable for remotes!
    DPRINT  "DISABLE double buffering 1"
.notRem2
    push    a3
	jsr	loadmodule
    pop     a3
	tst.l	d0
	bne.b	.loader

    moveq   #0,d0
    move.b  l_favSong(a3),d0
    move    d0,songnumber(a5)
    DPRINT  ":;: fav song: %ld"

	DPRINT	":;: Replay init"
	move.l	playerbase(a5),a0
	jsr	p_init(a0)
	tst.l	d0
	bne.b	.inierr

	bsr	settimestart
    jsr uslGetSongLength
.reet0	st	playing(a5)
	bsr	inforivit_play
	bsr	start_info
.erer
	rts

.loader	
	move.l	#PLAYING_MODULE_NONE,playingmodule(a5)
	rts

.inierr2
	moveq	#ier_unknown,d0

.inierr	
	DPRINT	"Replay init ERROR"
	move.l	#PLAYING_MODULE_NONE,playingmodule(A5)	* initvirhe
	jmp	init_error
;	rts

halt:	clr.b	playing(a5)	
;	clr	songnumber(a5)
	clr	pos_nykyinen(a5)
	clr	positionmuutos(a5)
	rts




*******************************************************************************
* Insertti
*******
insertButtonAction
rinsert
	tst.l	modamount(a5)
	beq	rbutton7
	bsr.b	rinsert2
	bra	rbutton7

rinsert2
	move.l	chosenmodule(a5),d0

* etsit‰‰n listasta vastaava kohta
	DPRINT	"insert getListNode"
	bsr	getListNode
	beq	rbutton7		* go to "add"

* a0 = valittu nimi
	move.l	a0,fileinsert(a5)
	st	filereqmode(a5)
	rts
	



*******************************************************************************
* Add divider
*******
add_divider
	skipIfGadgetDisabled gadgetMoveButton
	
	DPRINT  "add_divider obtain list"
	bsr	obtainModuleList
	tst.l	modamount(a5)
	beq	.x
	move.l	chosenmodule(a5),d0
	bmi	.x
;	subq	#1,d0			* valitun nimen edellinen node

	DPRINT	"addDivider getListNode"
	bsr	getListNode
	beq.b	.x
	move.l	a0,a3

	bsr	get_rt

	push	a3
	lea	divider(a5),a1	
	moveq	#27-1,d0			* Request 27 bytes?
	sub.l	a3,a3
	lea	.tags(pc),a0
	lea	.ti(pc),a2
	bsr	setMainWindowWaitPointer
	lob	rtGetStringA
	bsr	clearMainWindowWaitPointer
	pop	a3
	tst.l	d0
	beq.b	.x

	addq.l	#1,modamount(a5)

	* Divider, reserve 30 bytes for the name. 27 bytes from above, one char from below
	moveq	#l_size+30,d0
	move.l	#MEMF_CLEAR,d1
	bsr	getmem
	beq.b	.x
	move.l	d0,a1

	lea	divider(a5),a0
	lea	l_filename(a1),a2
	move.l	a2,l_nameaddr(a1)
	st	l_divider(a1)
.fe	move.b	(a0)+,(a2)+
	bne.b	.fe
	
* a1 = insertattava nimi
;	lea	moduleListHeader(a5),a0
	bsr	getVisibleModuleListHeader
	move.l	a3,a2
	lore	Exec,Insert
	bsr	listChanged
	bsr	forceRefreshList

.x	
	DPRINT  "add_divider release list"
	bra		releaseModuleList

.ti	dc.b	"Add divider",0
 even

.tags
	dc.l	RTGS_Width,262
	dc.l	RT_TextAttr,text_attr
otag17	dc.l	RT_PubScrName,pubScreenNameTags+var_b
	dc.l	TAG_END




*******************************************************************************
* Add files to list
* Recursive scan (apparently only on kick2.0 (not quite, also works on 1.3))
* Uses a separate process
*******
addButtonAction
rbutton7
	skipIfGadgetDisabled gadgetAddButton

	clr.b	movenode(a5)
	tst	filereq_prosessi(a5)
	beq.b	.ook
.skip
	rts
.ook	
	bsr	confirmFavoritesModification
	beq.b	.skip

	* Another functionality in these list modes:
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	beq		copyCurrentEntryToMainList
	cmp.b	#LISTMODE_SEARCH,listMode(a5)
	beq		copyCurrentEntryToMainList

	move.l	_DosBase(a5),a6

	;bra	filereq_code

	pushpea	fileprocname(pc),d1

	move.l	priority(a5),d2
;	moveq	#0,d2			* pri

	pushpea	filereq_segment(pc),d3
	lsr.l	#2,d3
	* stack size needs to be large.  needed for recursive dir scan,
	* it seems that kick1.3 needs more than kick3.0 for 10 levels of 
	* sub dirs.
	move.l	#7000,d4	
	lob	CreateProc
	tst.l	d0
	beq.b	.error
	addq	#1,filereq_prosessi(a5)
.error	rts

filereq_code
	lea	var_b,a5
	addq	#1,filereq_prosessi(a5)	* Lippu: prosessi p‰‰ll‰
	moveq	#0,d7

	tst.l	modamount(a5)
	sne	tabularasa(a5)		* pistetaan lippu jos aluks 
					* ei moduuleja. tata kaytetaan
					* randomplayn kanssa, eli katotaan
					* otetaanko eka moduuli taysin 
					* randomilla

	bsr.b	.filer

	* Now exiting this process

	lore	Exec,Forbid

	move.b	fileReqSignal(a5),d1	* Send signal, all done
	jsr	signalit
	clr.b	filereqmode(a5)

	clr	filereq_prosessi(a5)	* Lippu: prosessi poistettu
	rts
	
* Varsinainen operaatio alkaa t‰st‰..
.filer
	bsr	tokenizepattern

	bsr	get_rt
	tst.l	req_file(a5)
	bne.b	.onfi
	moveq	#RT_FILEREQ,D0
	sub.l	a0,a0
	lob	rtAllocRequestA
	move.l	d0,req_file(a5)
.onfi

** BUGI?!?

	tst.b	newdirectory(a5)	* Onko uusi hakemisto?
	beq.b	.eimuut
	clr.b	newdirectory(a5)

	* Use either prefs set directory, or one from saved state

	move.l	req_file(a5),a1		* Vaihdetaan hakemistoa...
	lea	newdir_tags(pc),a0
	lea	moduledir(a5),a2
	move.l	a2,4(a0)

	tst.b	savestate(a5)
	beq.b	.noSaveState
	move.l	lastStoredFileReqDirectory(a5),d0 
	beq.b	.noSaveState
	move.l	d0,4(a0)
.noSaveState
 if DEBUG
	move.l	4(a0),d0
	DPRINT	"FileReq to %s"
 endif
	lore	Req,rtChangeReqAttrA

	* When set once, filereq will remember the 
	* last user dir.
	move.l	lastStoredFileReqDirectory(a5),a0 
	bsr		freemem
	clr.l	lastStoredFileReqDirectory(a5)

.eimuut

	move.l	req_file(a5),a1		* Match pattern
	lea	matchp_tags(pc),a0
	lore	Req,rtChangeReqAttrA

	st	loading2(a5)			* checked with loading(a5)

	* launch file requester
	lea	filereqtags(pc),a0		* tags for configuration
	move.l	req_file(a5),a1		* requester structure
	lea	filename(a5),a2			* selected filename (must be 108 bytes)
	lea	filereqtitle(pc),a3		* requester title
	lore	Req,rtFileRequestA	* ReqToolsin tiedostovalikko	
	push	d0					* Result is in d0, 
								* FALSE or a pointer to rtFileList

	* During processing of data lock window and reserve
	* the list structure.

	DPRINT  "filereq_code obtain list"
	bsr		obtainModuleList
	bsr		lockMainWindow
	pop 	d0
	bsr.b	.processResult

	move.l	filelistaddr(a5),d0
	beq.b	.noFileList
	move.l	d0,a0
	* This was never done previously. A memory leak possibly?
	lore	Req,rtFreeFileList
	clr.l	filelistaddr(a5)
.noFileList

	DPRINT  "filereq_code release list"
	bsr		releaseModuleList
	bra		unlockMainWindow

.processResult
	* Test if user selected anything or canceled
	move.l	d0,filelistaddr(a5)
	bne.b	.val

	move.b	#$7f,new(a5)		* new-lippu: cancel
	bra	.fileReqCancelled
.val

	tst.b	new(a5)			* jos 'new', clearataan lista.
	beq.b	.non1
	bsr	clearlist
.non1

 ifne fprog
	bsr	openfilewin
 endc

	bsr	parsereqdir		* Tehd‰‰n hakemistopolku..

* We will now normalize the directory given to us by ReqTools
* This creates consistent paths everytime,
* and allows favorites logic path matching to work.

	pushpea	tempdir(a5),d1
	jsr	normalizeFilePath

	* contains the files from reqtools as per user selection
	move.l	filelistaddr(a5),a4	
	
	* let's calculate how much space is needed to store
	* path in d4.

	moveq	#0,d4			* polun pituus
	lea	tempdir(a5),a0
.f	addq.l	#1,d4
	tst.b	(a0)+
	bne.b	.f
;	subq.l	#1,d4			* -1, nolla pois per‰st‰
;	add.l	#l_size,d4		* listayksikˆn koko
	add.l	#l_size-1,d4
.buildlist

***** K‰sitell‰‰n valitut hakemistot 

	cmp.l	#-1,rtfl_StrLen(a4)	* onko hakemisto?????
	bne	.file				* reqtools-listan file

	move.l	rtfl_Name(a4),a0	* hakemiston nimi
	bsr	adddivider

* rtfl_Name(a4)	= hakemisto 2
* tempdir(a5) = hakemisto 1
* Koko hakemistonpolku = Hakemisto 1/hakemisto 2
	lea	-200(sp),sp
	move.l	sp,a3
	lea	tempdir(a5),a0
.c0	move.b	(a0)+,(a3)+
	bne.b	.c0
	subq.l	#1,a3				* null 
	move.l	rtfl_Name(a4),a0
.c1	move.b	(a0)+,(a3)+
	bne.b	.c1
	subq.l	#1,a3
	move.b	#'/',(a3)+
	clr.b	(a3)

 if DEBUG 
	move.l	sp,d0
	DPRINT	"ReqTools dir: %s"
 endif 

	move.l	a3,d3			* hakemiston pituus
	sub.l	sp,d3
	add.l	#l_size,d3		* listayksikˆn koko

* d3 = dir len + l_size
* sp = dir

	move.l	sp,d2
	pushm	all
	bsr.b	.scanni			* rekursiivinen hakemiston tutkimus
	popm	all
	lea	200(sp),sp

	bsr	.dirdiv
	bra	.skip


* recursively scan directory
* in: 
*  d2 = path to directory to be scanned, with separator
*  d3 = path length + l_size. d3 should not be destroyed
.scanni

 if DEBUG
	move.l	d2,d0
	DPRINT	"Scan: %s"
 endif
	move.l	d2,a4		* hakemisto
	moveq	#0,d6		* lock for dir scan

	* Have a buffer that stores pointers to subdirectory names within this subdirectory.
.MAX_SUBDIRS_TO_SCAN = 250

	* space for counter and path pointers	
	move.l	#.MAX_SUBDIRS_TO_SCAN*4+2,d0	
	move.l	#MEMF_CLEAR!MEMF_PUBLIC,d1
	bsr	getmem
	move.l	d0,d7
	beq	.errd

	* Get a lock on dir.
	* This will succeed even on an empty string, it will then
	* be a lock on SYS:. Add a paranoia check for that.
	tst.b	(a4)
	beq	.errd
	move.l	a4,d1
	moveq	#ACCESS_READ,d2
	lore	Dos,Lock
	move.l	d0,d6			* d6 = hakemiston lukko
  if DEBUG
	bne.b	.lockOk
	DPRINT	"Lock failed!"
	bra 	.errd
  else 
	beq	.errd
  endif
.lockOk
	* Examine it
	move.l	d6,d1
	pushpea	fileinfoblock2(a5),d2
	lob	Examine
	tst.l	d0
	beq	.errd


.loopo	cmp.l	#MAX_MODULES,modamount(a5)	* Ei enemp‰‰ kuin ~16000
	bhs	.errd

	move.l	d6,d1
	pushpea	fileinfoblock2(a5),d2
	lore	Dos,ExNext
	* No more items to check in directory?
	tst.l	d0
	beq	.dodirs	

	* Success! What is it?
	* ST_ROOT=1
	* ST_USERDIR=2
	* ST_SOFTLINK=3
	* ST_LINKDIR=4
	* ST_FILE=-3
	* ST_LINKFILE=-4
	* ST_PIPEFILE=-5

	move.l	fib_DirEntryType+fileinfoblock2(a5),d0
	cmp.l	#ST_FILE,d0
	beq	.filetta
	cmp.l	#ST_LINKFILE,d0
	beq	.filetta
	cmp.l	#ST_USERDIR,d0
	bne	.unsupportedEntry

	* It was a directory. Store it for later, this way
	* files in the directory get placed first in the list,
	* then after that the subdir contents.

	;tst.b	uusikick(a5)		* rekursiivinen vain kick2.0+
	;beq.b	.loopo

* otetaan kyseisen hakemiston nimi talteen myˆhemp‰‰ k‰yttˆ‰ varten
* build a full path for this dir entry
.MAX_PATH_LEN = 200
	move.l	#.MAX_PATH_LEN,d0
	move.l	#MEMF_CLEAR!MEMF_PUBLIC,d1
	bsr	getmem
	move.l	d0,a1
	tst.l	d0
	beq.b	.lc0
	* high bound
	lea	.MAX_PATH_LEN-1(a1),a2

	move.l	a4,a0
.lc	cmp.l   a1,a2
	beq.b	.pathOverflow
	move.b	(a0)+,(a1)+
	bne.b	.lc
	subq	#1,a1
	lea	fib_FileName+fileinfoblock2(a5),a0
.lc2	cmp.l   a1,a2
	beq.b	.pathOverflow
	move.b	(a0)+,(a1)+
	bne.b	.lc2

	* Add path separator
	subq	#1,a1		* NULL
	cmp.b	#':',-1(a1)
	beq.b	.dd
	move.b	#'/',(a1)+
.dd	clr.b	(a1)

	* check if subdir buffer limit is reached
	move.l	d7,a0
	move	(a0),d1

 if DEBUG
	cmp	#.MAX_SUBDIRS_TO_SCAN,d1
	blo.b	.BOB
	DPRINT	"Subdir limit!"
.BOB
 endif

	cmp	#.MAX_SUBDIRS_TO_SCAN,d1
	bhs	.loopo
	* add one path pointer and increment counter
	addq	#1,(a0)+
	lsl	#2,d1
	move.l	d0,(a0,d1)
.lc0
	bra	.loopo

.pathOverflow
	DPRINT	"Path name overflow!"
	bra	.loopo
.unsupportedEntry
	DPRINT	"Unsupported entry: %ld"
	bra	.loopo

**** skannattuamme yhden hakemiston tutkitaan siin‰ olleet muut hakemistot
* Files scanned, now check the subdirs.
.dodirs
	* ExNext failed, then we come here.
	* ERROR_NO_MORE_ENTRIES = 232 should be the normal case.
 if DEBUG
	lore	Dos,IoErr
	cmp.l	#ERROR_NO_MORE_ENTRIES,d0
	beq.b	.io
	DPRINT	"IoErr=%ld"
.io
 endif
	;tst.b	uusikick(a5)		* rekursiivinen vain kick2.0+
	;beq	.errd
	* Allow recursion into directories with kick1.3 too!
	pushm	all

	* sort subdirs to get them in nice order
	move.l 	d7,a0 		
	move	(a0)+,d0
	jsr	sortStringPtrArray

	* the first word in the memory contains the subdir count
	move.l	d7,a3
	move	(a3)+,d5
	beq.b	.errd2
	* some subdirs were stored
	subq	#1,d5

.dodirsLoop
	* subdir path
	move.l	(a3)+,d6

	move.l	d6,a0
.findDirEnd
	tst.b	(a0)+
	bne.b	.findDirEnd
	move.l	a0,d3	* store this for later
	move.l	d6,a1
	subq	#2,a0	* skip last NULL and separator
	bsr	nimenalku
	* a0 = last part of the path

	* Add a named divider from a0
	* Remove separator temporarily
	move.l	d3,a1
	move.b	-2(a1),d0
	clr.b	-2(a1)
	bsr	adddivider	* all regs preserved
	move.b	d0,-2(a1)

	pushm	all
	* path length
	sub.l	d6,d3
	add.l	#l_size,d3
	* path to scan
	move.l	d6,d2
	* scan it
	bsr	.scanni
	; Add end-of-directory divider
	bsr	.dirdiv
	popm	all
	dbf	d5,.dodirsLoop

.errd2	popm	all
	bra.b	.errd

* in: 
*   a4="dir 1/dir 2/",0
*   d3=list element length based on this path
.filetta

** Patternmatchaus
	tst.b	uusikick(a5)
	beq.b	.yas
	pushpea	tokenizedpattern(a5),d1
	pushpea	fib_FileName+fileinfoblock2(a5),d2
	push	a6
	lore	Dos,MatchPatternNoCase
	pop	a6
	tst.l	d0			* kelpaako vaiko eik¯?
	beq	.loopo
.yas

	* allocate memory for list node

	lea	fib_FileName+fileinfoblock2(a5),a0	* filename

	move.l	a0,a1
.fie	tst.b	(a1)+
	bne.b	.fie
	sub.l	a0,a1		* nimen pituus

	move.l	d3,d0		* hakemisto + nimi (pituus)
	add.l	a1,d0
	move.l	d0,d2		* TODO: whats this
	move.l	#MEMF_CLEAR!MEMF_PUBLIC,d1
	bsr	getmem
	bne.b	.gotMem2
	bsr	showOutOfMemoryError
	bra.b	.errd
.gotMem2
	move.l	d0,a3		* a3 = listunit
	
	lea	l_filename(a3),a1
	move.l	a4,a0
.c2	
	move.b	(a0)+,(a1)+	* kopioidaan hakemisto
	bne.b	.c2
	subq.l	#1,a1
	move.l	a1,l_nameaddr(a3)	* ja tiedosto
	lea	fib_FileName+fileinfoblock2(a5),a0
.c3	
	move.b	(a0)+,(a1)+
	bne.b	.c3

	bsr	addfile
	bra	.loopo

.errd	
	move.l	d6,d1
	beq.b	.erde
	lore	Dos,UnLock
.erde	

* vapautetaan lukot hakemiston hakemistoihin
	tst.l	d7
	beq.b	.erde0

	move.l	d7,a3
	move	(a3)+,d3
	beq.b	.erde1
	subq	#1,d3

.erde2	move.l	(a3)+,a0
	bsr	freemem
	dbf	d3,.erde2
.erde1
	move.l	d7,a0		
	bsr	freemem
.erde0
	rts


************* Reqtoollislta saadut tiedostot
* d4=path length
.file
	;DPRINT 	"Adding file at .file"

	cmp.l	#MAX_MODULES,modamount(a5)	* Ei enemp‰‰ kuin 16383
	bhs.b	.overload

	move.l	d4,d0				* listunit,polku,nimi pituus
	add.l	rtfl_StrLen(a4),d0	* incoming string length
	addq.l	#1,d0				* space for terminating zero

	move.l	#MEMF_CLEAR!MEMF_PUBLIC,d1		* varataan muistia
	bsr	getmem
	bne.b	.gotMem
	bsr	showOutOfMemoryError
	bra.b	.whoops2
.gotMem
	move.l	d0,a3

	lea	l_filename(a3),a1
	lea	tempdir(a5),a0
.copy	
	move.b	(a0)+,(a1)+		* kopioidaan polku
	bne.b	.copy
	subq.l	#1,a1			* remove zero
	move.l	a1,l_nameaddr(a3)	* pelk‰n nimen osoite
	movem.l	rtfl_StrLen(a4),d0/a0	* StrLen/Name
	subq	#1,d0
.copy2
	move.b	(a0)+,(a1)+		* kopioidaan tiedoston nimi
	dbf	d0,.copy2
	clr.b	(a1)	

	bsr.b	addfile

.skip
								* Check for next entry in rtFileList
	move.l	rtfl_Next(a4),d0	* Joko loppui?
	beq.b	.whoops3
	move.l	d0,a4
	bra	.buildlist

.whoops2
.whoops	
.whoops3	
.fileReqCancelled

	tst.l	chosenmodule(a5)
	bpl.b	.ee
	clr.l	chosenmodule(a5)	* moduuliksi eka jos ei ennest‰‰n
.ee

	clr.b	loading2(a5)

 ifne fprog
	bsr	closefilewin
 endc
	* all done!?
	rts


.overload
	lea	.t(pc),a1
	bsr	request
	bra.b	.whoops


.dirdiv
	lea	.barf(pc),a0
	bra.b	adddivider

.t	dc.b	"My stomach feels content.",0
	* This must not be changed, content checked in adddivider below.
.barf	dc.b	"/\/\/\/\/\/\/\",0
	even

* addaa/inserttaa listaan a3:ssa olevan noden
* in: 
*   a3 = list node to be added into the list
addfile:
	cmp.l	#MAX_MODULES,modamount(a5)
	bhs.b	.exit

	addq.l	#1,modamount(a5)
	move.l	(a5),a6
	bsr	getVisibleModuleListHeader
	move.l	a3,a1

	tst.b	filereqmode(a5)		* onko add vai insert?
	bne.b	.insert

 	jsr	_LVOAddTail(a6)

	move.l	a3,a0
	jmp	updateFavoriteStatus


.insert	move.l	fileinsert(a5),a2	* mink‰ filen per‰‰n insertataan
	lob	Insert

	move.l	a3,a0
	jsr	updateFavoriteStatus
.exit
	rts



*** Lis‰t‰‰n divideri hakemistolle
* a0 = hakemiston nimi
*      directory name

adddivider:
	pushm	all
	moveq	#0,d7

	* Check configuration flag for automatically added dividers
	tst.b	divdir(a5)
	beq	.meek
	move.l	a0,a2

** testataan onko dirdivideri? jos on, pistet‰‰n sen p‰‰lle
	;lea	moduleListHeader(a5),a3
	bsr	getVisibleModuleListHeader
	move.l	a0,a3
	move.l	MLH_TAILPRED(a3),d0    * this points to the last element of the list
	beq.b	.pehe
	move.l	d0,a3

	move.l	l_nameaddr(a3),d0
	beq.b	.pehe
	move.l	d0,a0

;	isListDivider (a0)    * Magic divider character
;	bne.b	.pehe
	tst.b	l_divider(a3)
	beq.b	.pehe
	cmp.b	#'/',7-1(a0)	 * Another magic divider character
	bne.b	.pehe
	moveq	#1,d7		 * set a magic flag: overwrite existing divider
	bra.b	.hue
.pehe


	; List can display 27 characters per line.
.MAX_WIDTH = 27

	; There is no path information, only the file name on its own.
	; There will be an invisible char first, the divider magic marker.
	; There will be a terminating zero last.
	; Therefore a buffer of 27+1+1 on top of l_size should be ok.

	; Reserve this much chars for the actual name
.MAX_NAME = 21

	moveq	#l_size+30,d0
	move.l	#MEMF_CLEAR,d1
	bsr	getmem
	beq.b	.meek

	move.l	d0,a3
.hue	
	move.l	a2,a0

	lea	l_filename(a3),a2
	move.l	a2,l_nameaddr(a3)

	* first insert divider magic marker
	;move.b	#DIVIDER_MAGIC,(a2)+	* divider merkint‰
	st	l_divider(a3)

	* a0 = directory name

	* find out length of the name,
	* max allowed is 21	
	move.l	a0,a1
.findLength
	tst.b	(a1)+
	bne.b	.findLength
	* discard null termination
	subq	#1,a1
	move.l	a1,d0
	sub.l	a0,d0
	cmp	#.MAX_NAME,d0
	bls.b	.lengthOk
	moveq	#.MAX_NAME,d0
.lengthOk

	* this is the high bound that should not be written to
	lea	.MAX_WIDTH(a2),a1

	* length of name is now in d0.
	* how much is left for padding stars?
	moveq	#.MAX_WIDTH,d1
	sub	d0,d1
	* how about on either side?
	lsr	#1,d1
	* reserve one byte for space on both sides
	subq	#1,d1
	* do left padding
.leftPad
	move.b	#'*',(a2)+
	subq	#1,d1
	bne.b	.leftPad
	move.b	#' ',(a2)+
	* then fill in the name
.copyName
	move.b	(a0)+,(a2)+
	subq	#1,d0
	bne.b	.copyName
	* right pad
	move.b	#' ',(a2)+
	* fill until right bound is reached
.rightPad
	move.b	#'*',(a2)+
	cmp.l	a1,a2
	bne.b	.rightPad

	clr.b	(a2)
	tst.b	d7		* did we overwrite an old one? 
	bne.b	.noAdd
	bsr	addfile		* no, let's add
.noAdd

.meek	popm	all
	rts





** Asetetaan hakemisto requesteriin
newdir_tags
	dc.l	RTFI_Dir
	dc.l	0			* Uuden hakemiston osoite t‰h‰n
	dc.l	TAG_END


matchp_tags
	dc.l	RTFI_MatchPat,var_b+pattern
	dc.l	TAG_END


* Reqtoolsin tagit
filereqtags
	dc.l	RTFI_Flags
	dc.l	FREQF_MULTISELECT!FREQF_PATGAD!FREQF_SELECTDIRS
;	dc.l	RT_TextAttr,text_attr
otag2	dc.l	RT_PubScrName,pubScreenNameTags+var_b
	dc.l	TAG_END
filereqtitle
	dc.b	"Select files & dirs to add",0

 even


* This clones the current entry and appends to the mainlist
* Used when in file browser or search mode and user invokes "Add"
copyCurrentEntryToMainList
	DPRINT	"Copy to main"

	bsr		getcurrent
	beq.b	.nope
	tst.b	l_divider(a3)
	bne.b	.div

	move.l	a3,a0
	jsr		cloneListNode
    * NOTE: d0 status not checked 
	* a4 = cloned node

    * If chosenmodule is the same as the playing one,
    * store subsong metadata.
    move.l  chosenmodule(a5),d0
    cmp.l   playingmodule(a5),d0
    bne     .0
    move    songnumber(a5),d0
    move.b  d0,l_favSong(a4)
 if DEBUG
    and.l   #$ff,d0
    DPRINT  "store song=%ld"
 endif
.0

	move.l	a4,a1
	lea		moduleListHeader(a5),a0
	lore	Exec,AddTail
	bra		.flash
.nope
	DPRINT	"Not found"
	rts
.div
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	bne.b	.addFolder
	* Check if "parent folder", skip those
	tst.b	l_divider(a3)
	bmi.b	.addFolder
	DPRINT	"Not adding parent"
	rts

	* Flash the chosen line a bit for indication
.flash
	bsr		markit
	moveq	#2,d1
	lore	Dos,Delay
	bsr		markit
	moveq	#2,d1
	lore	Dos,Delay
	bsr		markit
	moveq	#2,d1
	lore	Dos,Delay
	bra		markit
	
.addFolder
	lea		l_filename(a3),a0
.1	tst.b	(a0)+
	bne.b	.1
	subq	#2,a0	* skip null and the 1st dir separator
	bsr		nimenalku
	move.l	a0,d0
	* a0 = dir name
	* Create divider into the main list
	move.b	#LISTMODE_NORMAL,listMode(a5)
	bsr		adddivider

	lea		l_filename(a3),a0
 if DEBUG
	move.l	a0,d0
	DPRINT	"folder %s"
 endif

	lea		-200(sp),sp
	move.l	sp,a1
.2	move.b	(a0)+,(a1)+
	bne.b	.2
	cmp.b	#"/",-2(a1)
	beq.b	.3
	move.b	#"/",-1(a1)
	clr.b	(a1)
.3

	move.l	sp,d2
	* Find length to d3
	move.l	sp,a0
    moveq   #-1,d3  ; phx strlen trick
.c	tst.b   (a0)+
	dbeq    d3,.c
 	not.l   d3
	add.l	#l_size,d3

	pushm	all
	bsr		lockMainWindow
	bsr		filereq_code\.scanni
	bsr		unlockMainWindow
	popm	all
	lea		200(sp),sp

	move.b	#LISTMODE_BROWSER,listMode(a5)
	bsr	listChanged
	bra		.flash






 ifne fprog
fail not used 

*********************************
* File add progress indicator

wflags5 = WFLG_SMART_REFRESH!WFLG_BORDERLESS
idcmpflags5 = 0 ;IDCMP_MOUSEBUTTONS!IDCMP_INACTIVEWINDOW

openfilewin
	pushm	all

	move.l	screenaddr(a5),d0
	beq	.x
	move.l	d0,a0

	move	sc_MouseX(a0),d6
	move	sc_MouseY(a0),d7

	lea	winfile,a0		* asetetaan pointterin kohdalle
	move	#125,nw_Width(a0)
	move	#15,nw_Height(a0)

	sub	#125/2,d6
	bpl.b	.b
	moveq	#0,d6
.b	move	d6,nw_LeftEdge(a0)

	sub	#15/2,d7
	bpl.b	.ba
	moveq	#0,d7
.ba	move	d7,nw_TopEdge(a0)



	bsr	tark_mahtu

	lore	Intui,OpenWindow
	move.l	d0,d5
	beq	.x
	move.l	d0,a0
	move.l	wd_RPort(a0),d7		* rastport

	move.l	d5,filewin
	move.l	d7,filerastport

	move.l	d7,a1
	move.l	pen_1(a5),d0
	lore	GFX,SetAPen
	move.l	d7,a1
	move.l	pen_0(a5),d0
	lob	SetBPen

	move.l	d7,a1
	move.l	fontbase(a5),a0
	lob	SetFont	


	move.l	d7,a1
	lea	winfile,a0
	moveq	#0,plx1
	move	nw_Width(a0),plx2
	moveq	#0,ply1
	move	nw_Height(a0),ply2
	subq	#1,ply2
	subq	#1,plx2
	bsr	laatikko2

	move	modamount(a5),fileamount


.x	popm	all
	rts


printfilewin
	pushm	d1/d1/a0/a4

	tst.l	filewin
	beq.b	.x

	move	modamount(a5),d0
	sub	fileamount(pc),d0

	lea	.foo(pc),a0
	bsr	putnumber
	clr.b	(a0)

	lea	.goo(pc),a0
	moveq	#7,d0
	moveq	#10,d1

	move.l	filerastport(pc),a4
	bsr.b	.dd

.x	popm	d0/d1/a0/a4
	rts

.dd	pushm	all
	bra	uup


.goo	dc.b	"Entries: "
.foo	dc.b	"       "
 even

filewin		dc.l	0
filerastport	dc.l	0
fileamount	dc.l	0

closefilewin
	pushm	all
	move.l	filewin(pc),d0
	beq.b	.x
	move.l	d0,a0
	lore	Intui,CloseWindow
.x	popm	all
	rts



winfile
	dc	0,0	* paikka 
	dc	0,0	* koko
	dc.b	0,0	;palkin v‰rit
	dc.l	idcmpflags4
	dc.l	wflags4
	dc.l	0
	dc.l	0	
	dc.l	0	; title
	dc.l	0
	dc.l	0	
	dc	0,0
	dc	0,0
	dc	WBENCHSCREEN
	dc.l	enw_tags
 endc











*******************************************************************************
* Vapautetaan tiedostolista
*******
freelist:
	DPRINT  "freelist obtain list"
	bsr		obtainModuleList
	tst.l		modamount(a5)
	beq.b	.listEmpty
	move.l	#PLAYING_MODULE_NONE,chosenmodule(a5)
	tst.l	playingmodule(a5)
	bmi.b	.ehe
	move.l	#PLAYING_MODULE_REMOVED,playingmodule(a5)
.ehe
	move.l	(a5),a6		* execbase
	lea	moduleListHeader(a5),a2
.freelist_loop
	* a0: list, a1: destroyed, d0: node, or zero
	; TODO: Use MACRO
	move.l	a2,a0
	lob	RemHead
	beq.b	.listFreed
	move.l	d0,a0

	bsr	freemem
	bra.b	.freelist_loop

.listFreed
	* no longer modules in list, at all
	clr.l	modamount(a5) 
	* need to reset random table to nothingness as well
	bsr	clear_random
	bsr	clearCachedNode

	* reset list slider and list box 
	clr.l	firstname(a5)	
	bsr	reslider

.listEmpty
	DPRINT  "freelist release list"
	bra	releaseModuleList


*******************************************************************************
* Parsetaan reqtoolsilta saatu hakemistopolku
*******
parsereqdir
	move.l	req_file(a5),a0
parsereqdir3
	lea	tempdir(a5),a1
parsereqdir2
	move.l	16(a0),a0
	tst.b	(a0)
	bne.b	.dij
	clr	(a1)
	rts
.dij	move.b	(a0)+,(a1)+		* tehd‰‰n hakemisto
	bne.b	.dij
	subq.l	#2,a1
	cmp.b	#':',(a1)
	beq.b	.nfo
	addq.l	#1,a1
	move.b	#'/',(a1)
.nfo	clr.b	1(a1)
	rts



*******************************************************************************
* Ladataan/tallennetaan moduuliohjelma
*******

* ladataan PRG joka on d7:ssa, AREXX
rloadprog2
	bra.b	rloadprogDoIt

* LoadProgram joka AddTailaa vanhan listan per‰‰n.
* Only from keyboard.
rloadprog0		
	st	lprgadd(a5)

* From keys, gadgets
rloadprog
	bsr	confirmFavoritesModification
	bne.b	.go
    rts
.go
	moveq	#0,d7
	skipIfGadgetDisabled gadgetPrgButton

rloadprogDoIt

	bsr 	setMainWindowWaitPointer
	DPRINT  "rloadprog obtain list"
	bsr	obtainModuleList
	bsr.b 	.doLoadProgram
	bsr	 clearMainWindowWaitPointer
	DPRINT  "rloadprog release list"
	bra	releaseModuleList

.doLoadProgram
	tst	filereq_prosessi(a5)
	bne	.kex

	bsr.b	.showLoadingProgram
	bra.b	.dd

.showLoadingProgram
	pushm	all
	lea	.t(pc),a0
	bsr	printbox
	popm	all
	rts
.t	dc.b	"Loading module program...",0
 even

.dd
	clr.b	movenode(a5)

	tst.l	d7
	bne.b	.loe

	bsr	get_rt
	moveq	#RT_FILEREQ,D0
	sub.l	a0,a0
	lob	rtAllocRequestA
	move.l	d0,req_file2(a5)
	beq	.kex

	move.l	d0,a1			* Vaihdetaan hakemistoa...
	lea	newdir_tags(pc),a0
	pushpea	prgdir(a5),4(a0)
	lob	rtChangeReqAttrA

	move.l	req_file2(a5),a1	* pattern match
	lea	matchp_tags(pc),a0	
	lob	rtChangeReqAttrA

	lea	.tags(pc),a0
	move.l	req_file2(a5),a1
	lea	filename(a5),a2		* T‰nne tiedoston polku ja nimi
	clr.b	(a2)

	lea	filereqtitle2(pc),a3
	lob	rtFileRequestA		* ReqToolsin tiedostovalikko
	tst.l	d0
	beq	.kex
	move.l	req_file2(a5),a0
	bsr	parsereqdir3

	lea	tempdir(a5),a0		* kopioidaan polku ja nimi yhdeksi
	lea	filename2(a5),a1
.c	move.b	(a0)+,(a1)+
	bne.b	.c
	subq.l	#1,a1
	lea	filename(a5),a0
.a	move.b	(a0)+,(a1)+
	bne.b	.a


.loe	
	tst.b	lprgadd(a5)		* ei putsata jos addataan
	bne.b	.yad
	bsr	freelist		* putsataan vanha lista
.yad

	lea	filename2(a5),a0
	tst.l	d7
	beq.b	.ewew
	move.l	d7,a0
.ewew
	moveq	#0,d4
.loadp:
	move.b	lprgadd(a5),d7
	clr.b	lprgadd(a5)

***** ladataan proggis

	move.l	a0,.infile

 if DEBUG
	move.l	a0,d0
	moveq	#0,d1
	move.b	d7,d1
	DPRINT	"Infile: %s add: %ld"
 endif		


	move.l	_DosBase(a5),a6
	move.l	a0,d1
	move.l	#1005,d2
	lob	Open
	move.l	d0,d6
	beq	.openerr

	move.l	d6,d1		* selvitet‰‰n filen pituus
	moveq	#0,d2	
	moveq	#1,d3
	lob	Seek
	move.l	d6,d1
	moveq	#0,d2	
	moveq	#1,d3
	lob	Seek
	move.l	d0,d5		* pituus

	move.l	d6,d1
	moveq	#0,d2
	moveq	#-1,d3
	lob	Seek		* alkuun

	move.l	d5,d0		* muistia listalle
	DPRINT	"Allocating %ld for list"
	moveq	#MEMF_PUBLIC,d1
	bsr	getmem
	move.l	d0,a3
	bne.b	.gotMem

	* bail out!
.bailOut
	moveq	#0,d5	* memory address for freemem 
.bailOut2
	bsr	showOutOfMemoryError
	move.l	d6,d1
	lob	Close
	bra	.x2
.gotMem
	* We will need at least another d5 since
	* the list needs to be created.
	push	a6
	moveq	#MEMF_ANY,d1
	lore	Exec,AvailMem
	pop  	a6
	DPRINT	"Mem left   %ld"
	* Arbitrary 100 kB safety margin
	sub.l	#100*1024,d0
	cmp.l	d0,d5
	ble.b	.yesMem
	* address in d5 gets freed later
	move.l	a3,d5
	bra.b	.bailOut2
.yesMem
	
	move.l	d6,d1		* file
	move.l	a3,d2		* destination
	move.l	d5,d3		* pituus
	lob	Read

	move.l	a3,d1
	add.l	d0,d1
	move.l	d1,.loppu

	push	d0

	move.l	d6,d1
	lob	Close

	cmp.l	(sp)+,d5	* read error?
	bne	.x2

** A3:ssa moduulilista
** jos on xpk pakattu, pit‰‰ purkaakkin.

	cmp.l	#"XPKF",(a3)
	bne	.nox

	jsr	get_xpk
	beq	.what

	cmp.l	#"HiPP",16(a3)	* uusi formaatti?
	bne.b	.nu
	cmp	#"rg",20(a3)
	beq.b	.nyy
.nu
	cmp.l	#"HIPP",16(a3)	* tunnistus, vanha formaatti?
	bne	.what
	cmp	#"RO",20(a3)
	bne	.what
.nyy

	move.l	a3,a0
	bsr	freemem

	lea	.tagz(pc),a0
	clr.l	.len-.tagz(a0)
	lore	XPK,XpkUnpack

	tst.l	d0
	beq.b  .xpkOk
	* no freeing later:
	moveq	#0,d5
	lea	xpk_module_program_error(pc),a1
	bsr	request
	bra	.x2
.xpkOk

	move.l	.addr(pc),a3
	move.l	a3,d0
	add.l	.oiklen(pc),d0
	move.l	d0,.loppu

	bra.b	.noxx

.tagz
		dc.l	XPK_InName
.infile		dc.l	0

		dc.l	XPK_GetOutBuf,.addr
		dc.l	XPK_GetOutBufLen,.len
		dc.l	XPK_GetOutLen,.oiklen

		dc.l	XPK_OutMemType,MEMF_PUBLIC
		dc.l	XPK_PassThru,1
;		dc.l	XPK_GetError,xpkerror+var_b	* virheilmoitus
		dc.l	TAG_END

.len	dc.l	0
.addr	dc.l	0
.oiklen	dc.l	0
.loppu	dc.l	0

.noxx

.nox


***************** ALoitetaan k‰sittely



	move.l	a3,d5		* muistialue talteen d5:een

	* read stuff from a3 until a4, into list in a2
	pushm 	d1-a6
	lea		moduleListHeader(a5),a2
	move.l	.loppu(pc),a4 

    ; ---------------------------------
    lea	filename2(a5),a0
    jsr     getFileExtension4
    cmp.l   #".m3u",d0
    bne     .notM3u
    bsr     importModuleProgramM3u
    bra     .wasM3u
.notM3u
	bsr	importModuleProgramFromData
.wasM3u
	DPRINT 	"Imported %ld files"
	popm	d1-a6

	move.l	d0,modamount(a5)

	tst.b	d7
	bne.b	.append
	move.l	d0,modamount(a5)
	bra.b	.noAppend
.append
	add.l	d0,modamount(a5)
.noAppend	


.x2
	tst.l	d5
	beq.b	.xxx

	tst.l	.len
	beq.b	.xx0

	move.l	.len(pc),d0	* xpk puskurin vapautus
	move.l	d5,a1
	lore	Exec,FreeMem
	clr.l	.len
	bra.b	.xxx
.xx0
	
	move.l	d5,a0
	bsr	freemem
.xxx

	sub.l	a4,a4
.x1	
	tst	d4
	bne.b	.ext
	move.l	req_file2(a5),d0
	beq.b	.ex
	move.l	d0,a1
	move.l	_ReqBase(a5),a6
	lob	rtFreeRequest

.ex

	clr.l	chosenmodule(a5)	* moduuliksi eka
.kex	bsr	listChanged
	bra	forceRefreshList

.what
	lea	unknown_module_program_error(pc),a1
	bsr	request
	bra.b	.x2

.openerr
	move	#1,a4			* lippu
	lea	openerror_t,a1
	bsr	request
	bra.b	.x1



.ext
* ladattiin ohjelma komentojonon kautta, soitetaan eka tai satunnainen
* riippuen prefs-s‰‰dˆist‰.
* Jos ohjelmaa ei saatu ladattua, niin pistet‰‰n filerequesteri.

	bsr	vastomaviesti

	cmp	#1,a4	* avausvirhe? -> ei tehd‰ mit‰‰n
	bne.b	.r
	moveq	#lod_openerr,d0
	rts

.r	cmp.b	#pm_random,playmode(a5)
	bne.b	.noran
	move.l	modamount(a5),d0
	cmp.l	#MAX_MODULES,d0
	bhi.b	.noran
	
	subq.l	#1,d0
.b	bsr	getRandomValue
	cmp.l	d0,d1
	bhi.b	.b
		
	move.l	d1,d0
	bsr	setRandomTableEntry

	move.l	d1,chosenmodule(a5)
	bra.b	.eh

.noran	clr.l	chosenmodule(a5)

.eh	
	bsr	forceRefreshList
	bra	rbutton1	* Play

.blob	bsr	.showLoadingProgram
	bra	.loadp


.tags
	dc.l	RTFI_Flags,FREQF_PATGAD
otag1	dc.l	RT_PubScrName,pubScreenNameTags+var_b,0

* UGH! Evil hackery:
;loadprog
;	bra.b	*-22		* bra.b -> bra.b .blob


* To be called instad of "impotModuleProgramFromData"
* if data is an m3u file
importModuleProgramM3u:
    DPRINT  "importModuleProgramM3u"
    * Special: provide an empty line to prepend.
    * This makes it run the filter
    lea     .importFilter(pc),a0
    clr     -(sp)
    move.l  sp,d6   * prepend line addr
    moveq   #0,d4   * prepend line length
    bsr     importModuleProgramFromDataSkipHeader
    addq    #2,sp
    rts

* In:
*   a3 = name to check, ends with 10 or 0
* Out:
*   d0 = true if ok, false otherwise
.importFilter
    * Skip extended m3u lines
    moveq   #0,d0
    cmp.b   #"#",(a3)
    sne     d0
    rts



* in:
*   a0 = module program file name
*   d4 = some magic flag?
*   d7 = some other magic flag?
loadprog:
 if DEBUG
    push    d0
    move.l  a0,d0
	DPRINT	"loadprog %s"
    pop     d0
 endif
	* Ensure correct list mode
	jsr	engageNormalMode
	bra.b	rloadprogDoIt\.blob

* Variant that skips the prg file header,
* and adds extra data in front of every added
* file path.
* in:
*   a2 = list header
*   a3 = data read from file
*   a4 = end address of buffer
*   d4 = line header length
*   d6 = line header address 
*   a0 = filter routine address, for remote url entries
importModuleProgramFromDataSkipHeader:
	pushm	d1-a6
 if DEBUG
	move.l	a3,d0 
	move.l	a4,d1
	DPRINT	"importModuleProgramFromDataSkipHdr %lx %lx"
 endif
	move.l	a0,a6
	moveq	#0,d7 		* count
	move.l	a4,d5		* use this register
	move.l	a2,a4 		* list header here
	bra	importModuleProgramFromData\.r1

* in:
*   a2 = list header
*   a3 = data read from file
*   a4 = end address of buffer
* out:
*   d0 = number of modules  
importModuleProgramFromData:
	pushm	d1-a6
 if DEBUG
	move.l	a3,d0 
	move.l	a4,d1
	DPRINT	"importModuleProgramFromData %lx %lx"
 endif

* Free:
* d3
* d4
* d6

	moveq	#0,d7 		* count
	
	move.l	a3,d0
	beq	.x2

	sub.l	a6,a6		* no filter
	moveq	#0,d4		* no line header
	moveq	#0,d6		* no line header

	move.l	a4,d5		* use this register
	move.l	a2,a4 		* list header here

	;moveq	#0,d6		* 0 = vanha formaatti

	cmp.l	#"HiPP",(a3)
	bne		.what
	cmp	#"rg",4(a3)
	bne		.what
.r2	cmp.b	#10,(a3)+	* skipataan kaks rivinvaihtoa
	bne.b	.r2
	addq	#1,a3
.r1
	
;	lea	moduleListHeader(a5),a4
;	move.l	a5,a4
    ;----------------------------------
.ploop

	* See if additional header should
	* be prepended to the line. This indicates
	* a remote url, it is used to add the base url address.
	tst.l	d6
	beq.b	.accepted
	* A remote it is, run filter if available
	move.l	a6,d3
	beq.b	.accepted
	jsr		(a6)     * FILTER CALLBACK
	tst.l	d0
	bne.b	.accepted
    * Rejected by filter
.skipToNext
	* Skip to next entry
	cmp.l	d5,a3
	bhs	.x2		* upper bound check
	cmp.b	#10,(a3)+
	bne.b	.skipToNext
	bra		.next
.accepted


	* Is this an url?
	moveq	#0,d3	* local
	cmp.b	#"h",(a3)
	bne.b	.local
	cmp.b	#"t",1(a3)
	bne.b	.local
	cmp.b	#"t",2(a3)
	bne.b	.local
	cmp.b	#"p",3(a3)
	bne.b	.local
	moveq	#1,d3	* remote
.local
    
    * Calculate length
	move.l	a3,a0
	moveq	#10,d1
.r23	
	cmp.l	d5,a0
	bhs	.x2		* upper bound check
	;cmp.b	#10,(a0)+
	cmp.b	(a0)+,d1
	bne.b	.r23
	move.l	a0,d0
	sub.l	a3,d0	* pituus

    * Too short? Skip to ignore badly formed paths or urls.
    cmp.l   #5,d0
    bhi     .len1
    
    * Ignore length check for dividers
    push    d0
    bsr     isDividerInA3
    popm    d0  * keep flags
    bne     .len1

    add.l   d0,a3
    bra     .next
.len1
    
	add.l	#1+l_size,d0	* nolla nimen per‰‰n ja listayksikˆn pituus
    add.l	d4,d0	* add extra header space if any

	move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
	bsr	getmem
	bne.b	.gotMem2
	bsr	showOutOfMemoryError
	bra		.x2	
.gotMem2
	move.l	d0,a2

	* Copy filename 
	lea	l_filename(a2),a0
    ; ---------------------------------
    bsr     isDividerInA3
    beq     .notDivider
    * Skip over divider to not copy it
    add     d0,a3
	st	    l_divider(a2)
    tst.b   d1
    beq     .normalDivider
    * Stealthy divider
	move.b  #$f0,l_divider(a2)
.normalDivider
.notDivider

    ; ---------------------------------
	* See if additional header should
	* be prepended to the line. This indicates
	* a remote url, it is used to add the base url address.
	tst.l	d6
	beq.b	.noHdr
	moveq	#1,d3	* remote!
	move.l	d6,a1
    tst.b   (a1)    * null string check
    beq     .noHdr
.copyHdr   
	move.b	(a1)+,(a0)+
	bne.b	.copyHdr
	subq	#1,a0 * to NULL
.noHdr
    ; ---------------------------------
	* Copy chars until line change
	moveq	#10,d1  * LF
    moveq   #13,d0  * CR
    move.w  #"#",a1
    moveq   #0,d2
.le	
	move.b	(a3)+,d2
    * Painfully check for "#song=x"
    cmp.w   a1,d2 
    bne.b   .1
    cmp.b   (a3),d1
    beq     .1
    cmp.b   #"s",(a3)
    bne     .1
    cmp.b   1(a3),d1
    beq     .1
    cmp.b   #"o",1(a3)
    bne     .1
    cmp.b   2(a3),d1
    beq     .1
    cmp.b   #"n",2(a3)
    bne     .1
    cmp.b   3(a3),d1
    beq     .1
    cmp.b   #"g",3(a3)
    bne     .1
    moveq   #$f,d2
    and.b   5(a3),d2
    move.b  d2,l_favSong(a2)
 if DEBUG
    push    d0
    move.l  d2,d0
    DPRINT  "FavSong restored=%ld" 
    pop     d0
 endif
    * Replace with LF to ignore the rest
    move.b  d1,d2
    addq    #7,a3
.1
    cmp.b   d0,d2      * Skip CR
    beq    .le
	move.b	d2,(a0)+   * Copy!
	cmp.b	d1,d2
	bne 	.le
	* Replace LF with NULL
	clr.b	-(a0)
    ; ---------------------------------
	lea	l_filename(a2),a1
	tst.b	l_divider(a2)
	beq.b	.notDiv
	move.l	a1,a0
	bra.b	.wasDiv
.notDiv
	tst.b	d3
	beq.b	.wasLocal
	; Config this node as a remote node
	move.l	a2,a0
	jsr		configRemoteNode
	bra.b	.wasRemote
.wasLocal
	bsr	nimenalku
.wasDiv
	move.l	a0,l_nameaddr(a2)
.wasRemote

	* add node a1 to list a0	
	move.l	a2,a1
	move.l	a4,a0
	push	a6
	lore	Exec,AddTail
	pop		a6
	addq.l	#1,d7

	move.l	a2,a0

	* protect a3, which is killed here
	push	a3
	jsr	updateFavoriteStatus
	pop 	a3

	cmp.l	#MAX_MODULES,d7
	bhs.b	.x2
.next
	* Go until at the end of given buffer
	cmp.l	d5,a3
	blo	.ploop
.x2
	move.l	d7,d0
	popm	d1-a6
	rts

* unknown format
.what
	lea	unknown_module_program_error(pc),a1
	bsr	request
	bra.b  	.x2

unknown_module_program_error  dc.b	"Not a module program!",0
xpk_module_program_error	 dc.b	"Could not load XPK compressed module program!",0
 even

* In:
*  a3 = string
* Out:
*  d0 = 0 if not divider, otherwise divider length, 1 or 2 (UTF8)
*  d1 = 0 normal divider, 1 strealth divider
isDividerInA3:
    * Amiga encoding:
	cmp.b	#DIVIDER_MAGIC,(a3)
	beq 	.1
    * Amiga encoding:
    cmp.b   #DIVIDER_MAGIC_ALT,(a3)
	beq 	.11

* UTF8 encoding for divider magic: $c3b7
    cmp.b   #$c3,(a3)
    bne     .div0
    cmp.b   #$b7,1(a3)
    beq     .2
.div0
    cmp.b   #$c2,(a3)
    bne     .div1
    cmp.b   #$a2,1(a3)
    beq     .22
.div1
    moveq   #0,d0
    rts

.1
    moveq   #0,d1
    moveq   #1,d0
    rts
.11
    moveq   #1,d1
    moveq   #1,d0
    rts
.2
    moveq   #0,d1
    moveq   #2,d0
    rts
.22
    moveq   #1,d1
    moveq   #2,d0
    rts

*** Etsii tiedoston nimest‰ (polku/nimi) pelk‰n tiedoston nimen alun
*** a0 <= loppu
*** a1 <= alku
*** a0 => nimi
nimenalku:
.f	move.b	-(a0),d0		* etsit‰‰n pelk‰n nimen alku
	cmp.b	#'/',d0
	beq.b	.fo
	cmp.b	#':',d0
	beq.b	.fo
	cmp.l	a1,a0
	bne.b	.f
	bra.b	.fof
.fo	addq.l	#1,a0
.fof rts


rsaveprog
	cmp.b 	#LISTMODE_BROWSER,listMode(a5)
	beq.b	.x
	DPRINT  "rsaveprog obtain list"
	bsr 	obtainModuleList
	bsr	 setMainWindowWaitPointer
	bsr.b	.doSaveProg
	bsr 	clearMainWindowWaitPointer
	DPRINT  "rloadprog release list"
	bsr 	releaseModuleList
.x	rts

.doSaveProg
	clr.b	movenode(a5)

	tst	filereq_prosessi(a5)
	bne	.ex

	tst.l	modamount(a5)
	beq	.nomods

	bsr	get_rt
	moveq	#RT_FILEREQ,D0
	sub.l	a0,a0
	lob	rtAllocRequestA
	move.l	d0,req_file2(a5)
	beq	.ex

	move.l	d0,a1			* Vaihdetaan hakemistoa...
	lea	newdir_tags(pc),a0
	pushpea	prgdir(a5),4(a0)
	lob	rtChangeReqAttrA

.eimuut
	move.l	req_file2(a5),a1	* pattern match
	lea	matchp_tags(pc),a0	
	lob	rtChangeReqAttrA


	lea	.t(pc),a0
	bsr	printbox
	bra.b	.d
.t	dc.b	"Saving module program...",0
 even
.d

	lea	.tags(pc),a0
	
	move.l	req_file2(a5),a1
	lea	filename(a5),a2		* T‰nne tiedoston polku ja nimi

	lea	filereqtitle3(pc),a3
	lob	rtFileRequestA		* ReqToolsin tiedostovalikko
	tst.l	d0
	beq.b	.ex
	move.l	req_file2(a5),a0
	bsr	parsereqdir3

	lea	tempdir(a5),a0		* kopioidaan polku ja nimi yhdeksi
	lea	filename2(a5),a1
.c	move.b	(a0)+,(a1)+
	bne.b	.c
	subq.l	#1,a1
	lea	filename(a5),a0
.a	move.b	(a0)+,(a1)+
	bne.b	.a

	lea	tempdir(a5),a0
	lea	prgdir(a5),a1
.cpe2	move.b	(a0)+,(a1)+
	bne.b	.cpe2

	bsr     getVisibleModuleListHeader
    move.l  a0,a1
	lea	filename2(a5),a0
	;lea	moduleListHeader(a5),a1
	bsr.b exportModuleProgramToFile

	move.l	req_file2(a5),d0
	beq.b	.ex
	move.l	d0,a1
	move.l	_ReqBase(a5),a6
	lob	rtFreeRequest
.ex

	bra	forceRefreshList

.nomods	lea	.lerr(pc),a1
	bra	request

.lerr	dc.b	"No program to save!",0
 even


.tags	dc.l	RTFI_Flags,FREQF_PATGAD
otag16	dc.l	RT_PubScrName,pubScreenNameTags+var_b,0


prgheader	dc.b	"HiPPrg",10,10	* headeri
headere


filereqtitle2
	dc.b	"Load module program",0
filereqtitle3
	dc.b	"Save module program",0
 even



exportModuleProgramToFileWithSongMetaData:
    moveq   #1,d7
    bra     doExportModuleProgramToFile

* in:
*  a0 = filename
*  a1 = list
exportModuleProgramToFile:
    moveq   #0,d7
doExportModuleProgramToFile:
 if DEBUG
	move.l	a0,d0
	DPRINT	"Exporting module list to %s"
 endif
	move.l	a1,a4
	move.l	_DosBase(a5),a6
	move.l	#1006,d2
	move.l	a0,d1
	lob	Open

	move.l	d0,d6
	beq		.openError	

	move.l	d6,d1
	lea	prgheader(pc),a0
	move.l	a0,d2
	moveq	#headere-prgheader,d3
	lob	Write

.saveloop
	* Get next and test for end
	TSTNODE	a4,a3
	beq 	.exit
	move.l	a3,a4

    * For very big radio station urls
	lea	-1000(sp),sp
	move.l	sp,a1

	lea	l_filename(a3),a0
	tst.b	l_divider(a3)
	beq.b	.noDiv
	move.b	#DIVIDER_MAGIC,(a1)+
.noDiv


.co	move.b	(a0)+,(a1)+
	bne.b	.co
	subq	#1,a1

    tst.b   l_separateName(a3)
    beq.b   .noAdd
    move.b  #"#",(a1)+
    move.b  #"n",(a1)+
    move.b  #"a",(a1)+
    move.b  #"m",(a1)+
    move.b  #"e",(a1)+
    move.b  #"=",(a1)+
    move.l  l_nameaddr(a3),a0
.c2 move.b  (a0)+,(a1)+
    bne.b   .c2
	subq	#1,a1
.noAdd

    * Output fav song! 
    * d7 is true if saving favorites list

    * Check #1: are we saving the favorites list? Save #song
    tst.b   d7
    bne     .doFav

    * Check #2: not saving favorites. 
    * Store song for this one if it is not a favorite
    tst.b   l_favorite(a3)
    beq     .doFav

    * Is favorite and favsong is empty -> skip
    tst.b   l_favSong(a3)
    beq     .noFavSong

* Existing minor issue:
* - Jogeir's list has tune A with song #3
* - Favs list has tune A with song #3
* -> when saving, can't know where the song
*    came from from favs: or from Jogeir's list

    * This is a favorite song.
    * Compare favorited song and list item song.
    * If they differ, then save.
    pushm   a1-a3
    move.b  l_favSong(a3),d1
    move.l  a3,a0
    jsr     findFavoriteModule
    beq     .favNotFound
    * Compare favorited iten song with playlist item song
    cmp.b   l_favSong(a1),d1
.favNotFound
    popm    a1-a3
    * If they are the same, no need to save since
    * it's already in favorites.
    beq     .noFavSong
.doFav
    move.b  l_favSong(a3),d0
    beq     .noFavSong
    move.b  #"#",(a1)+
    move.b  #"s",(a1)+
    move.b  #"o",(a1)+
    move.b  #"n",(a1)+
    move.b  #"g",(a1)+
    move.b  #"=",(a1)+
    or.b    #$30,d0
    move.b  d0,(a1)+
.noFavSong

	move.b	#10,(a1)+

	move.l	a1,d3
	sub.l	sp,d3
	move.l	sp,d2
	move.l	d6,d1		* tallennetaan nimi
	lob	Write	

	lea	1000(sp),sp

	cmp.l	d3,d0
	bne.b	.writeError
	bra    	.saveloop
	
.exit
	move.l	d6,d1
	beq.b	.x
	lob	Close
.x	
	rts

.writeError
	lea	.err(pc),a1
	bsr	request
	bra.b	.exit

.openError
	lea	openerror_t,a1
	bsr	request
	bra.b	.exit

.err	dc.b	"Error while writing module program!",0
 even


*******************************************************************************
* Komentojono
*******

komentojono:
	DPRINT	"Processing command line parameters"

	tst.l	sv_argvArray+4(a5)
    bne     .something
    DPRINT  "->nothing"
    rts
.something

	* Ensure correct list mode before proceeding
	jsr	engageNormalMode

	lea	sv_argvArray+4(a5),a3	* ei ekaa
	moveq	#ARGVSLOTS-1-1,d7
	move.l	modamount(a5),d6	* vanha m‰‰r‰ talteen

* HIDEst‰ ja QUITista ei v‰litet‰!

*** Silmukka
.alp
	move.l	(a3)+,d5
	beq	.end

 if DEBUG
	move.l	d5,d0
	DPRINT	"->%ls"
 endif

	move.l	d5,a0
	bsr	kirjainta4
	cmp.l	#MESSAGE_COMMAND_HIDE,d0
	beq.b	.skip
	cmp.l	#MESSAGE_COMMAND_QUIT,d0
	beq.b	.skip
	cmp.l	#MESSAGE_COMMAND_PRG,d0
	bne.b	.hmm
	move.l	(a3),a0			* ohjelman nimi
	moveq	#-1,d4			* lippu
	bra	loadprog
.hmm

	move.l	d5,a0
	bsr		createListNodeAndAdd

.skip	dbf	d7,.alp

.end
	bsr	vastomaviesti

	tst.l	modamount(a5)
	beq.b	.x
	move.l	d6,chosenmodule(a5)	* ensimm‰inen uusi moduuli valituksi

	bsr	listChanged
	bsr	forceRefreshList
	bsr	rbutton1		* soitetaan 
.x	rts


* In:
*   a0 = File path
createListNodeAndAdd:
	pushm	all
	move.l	a0,d5
.f	tst.b	(a0)+
	bne.b	.f
	move.l	a0,d0
	sub.l	d5,d0			* pituus

	add.l	#l_size,d0		* listayksikˆn pituus
	move.l	#MEMF_CLEAR,d1
	bsr	getmem
	beq.b	.end
	move.l	d0,a2

	lea	l_filename(a2),a0	* kopioidaan
	move.l	d5,a1
.c	move.b	(a1)+,(a0)+
	bne.b	.c

	lea	l_filename(a2),a1

	cmp.b	#"h",(a1)
	bne.b	.local
	cmp.b	#"t",1(a1)
	bne.b	.local
	cmp.b	#"t",2(a1)
	bne.b	.local
	cmp.b	#"p",3(a1)
	bne.b	.local
    move.l  a2,a0
    jsr     configRemoteNode
    bra     .remote
.local
	bsr	nimenalku
	move.l	a0,l_nameaddr(a2)
.remote
	move.l	a2,a1
	lea	    moduleListHeader(a5),a0
    * Add to the main list
	lore	Exec,AddTail

	* update favorite status for node a0
	move.l	a2,a0
	* destroys a2/a3 (no stack saving for speed there)
	jsr	updateFavoriteStatus

	addq.l	#1,modamount(a5)	* m‰‰r‰++
.end
	popm	all
	rts

*************
* Tokenisoidaan file match patterni

tokenizepattern
	pushm	all
	tst.b	uusikick(a5)
	beq.b	.feff
	lea	tokenizedpattern(a5),a0
	move.l	a0,d2
	lea	70*2+2(a0),a1
.f	clr	(a0)+
	cmp.l	a1,a0
	bne.b	.f

	pushpea	pattern(a5),d1
	move.l	#70*2+2,d3
	lore	Dos,ParsePatternNoCase
.feff	popm	all
	rts



*******************************************************************************
* Ladataan/tallennetaan prefs-tiedosto
***************************

loadprefs
	DPRINT 	"Load prefs"
	pushpea	prefsfilename(pc),d7

;	move.l	(a5),a0			* Kokeillaan ladata preffsi
;	cmp	#36,LIB_VERSION(a0)	* PROGDIR:ist‰
;	blo.b	.nah
;	move.l	#prefsfilename2,d1
;	move.l	d1,d4
;	move.l	#ACCESS_READ,d2
;	lore	Dos,Lock
;	move.l	d0,d1
;	beq.b	.nah
;	lob	UnLock
;	move.l	d4,d7
;.nah


* d7 = tied.nimi
loadprefs2

	push	d7
	move	#200,wbkorkeus(a5)
	move	#640,wbleveys(a5)
	move	#360,windowpos(a5)		* pistet‰‰n ikkunoiden paikat
	move	#23,windowpos+2(a5)
	move	#360,windowZippedPos(a5)
	move	#23,windowZippedPos+2(a5)
	move	#42,windowpos_p(a5)
	move	#18,windowpos_p+2(a5)
	;move	#259,quadpos(a5)
	;move	#157,quadpos+2(a5)
	bsr	aseta_vakiot

	pop	d1

	move.l	_DosBase(a5),a6
	move.l	#1005,d2
	lob	Open
	move.l	d0,d4
	beq	.nope
	lea	prefsdata(a5),a0
	move.l	a0,d2
	move.l	d0,d1
	move.l	#prefs_size,d3
	lob	Read

	cmp.b	#prefsversio,prefsdata(a5)	* Onko oikea versio?
	beq.b	.q

	DPRINT	"Old prefs, set some defaults"

* Vanha prefssi?
* Laitetaan defaultti archivejutut 
	bsr	defarc
* when migrating to a new prefs version I want the tooltips
* to be on by default!
	st	prefs_tooltips+prefsdata(a5)
.q
	cmp.l	#prefs_size,d0
	bhi	.eeee

	DPRINT	"Set values"

* Pistet‰‰n ladatut arvot yms. paikoilleen
	lea	prefsdata(a5),a0
	move.l	prefs_s3mrate(a0),mixirate(a5)
	move.b	prefs_play(a0),playmode(a5)
	move.b	prefs_show(a0),lootamoodi+1(a5)
	move.b	prefs_tempo(a0),tempoflag(a5)
	move.b	prefs_tfmxrate(a0),tfmxmixingrate+1(a5)
	move.b	prefs_s3mmode1(a0),s3mmode1(a5)
	move.b	prefs_s3mmode2(a0),s3mmode2(a5)
	move.b	prefs_s3mmode3(a0),s3mmode3(a5)
	
	;move.b	prefs_quadmode(a0),quadmode(a5)
	move.l	prefs_mainpos1(a0),windowpos(a5)
	move.l	prefs_mainpos2(a0),windowZippedPos(a5)
	move.l	prefs_prefspos(a0),windowpos_p(a5)
	;move.l	prefs_quadpos(a0),quadpos(a5)
	;move.b	prefs_quadon(a0),quadon(a5)
	move.b	prefs_ptmix(a0),ptmix(a5)
	move.b	prefs_xpkid(a0),xpkid(a5)
	move.b	prefs_fade(a0),fade(a5)
	move.b	prefs_pri(a0),d0
	ext	d0
	ext.l	d0
	move.l	d0,priority(a5)
	move.b	prefs_boxsize(a0),boxsize+1(a5)
	move.b	prefs_boxsize(a0),boxsize0+1(a5)
	move.b	prefs_doubleclick(a0),doubleclick(a5)
	move.b	prefs_startuponoff(a0),startuponoff(a5)
	move	prefs_timeout(a0),timeout(a5)
	move.b	prefs_hotkey(a0),hotkey(a5)
	move.b	prefs_cerr(a0),contonerr(a5)
	move.b	prefs_ps3mb(a0),ps3mb(a5)
	move.b	prefs_timeoutmode(a0),timeoutmode(a5)
	move.b	prefs_filter(a0),filterstatus(a5)
	move.b	prefs_vbtimer(a0),vbtimer(a5)
	move.b	prefs_groupmode(a0),groupmode(a5)
	move	prefs_alarm(a0),alarm(a5)
	move.b	prefs_stereofactor(a0),stereofactor(a5)
	move.b	prefs_div(a0),divdir(a5)
	move.b	prefs_prefix(a0),prefixcut(a5)
	move.b	prefs_early(a0),earlyload(a5)
	move.l	prefs_infopos2(a0),infopos2(a5)
	move.b	prefs_xfd(a0),xfd(a5)
	move	prefs_infosize(a0),infosize(a5)
	bne.b	.rr
	move	#16,infosize(a5)
.rr
	move.b	prefs_infoon(a0),infoon(a5)
	move.b	prefs_ps3msettings(a0),ps3msettings(a5)
	move.b	prefs_prefsivu(a0),prefsivu+1(a5)
	move.b	prefs_samplebufsiz(a0),samplebufsiz0(a5)
	;move.b	prefs_cybercalibration(a0),cybercalibration(a5)
	move	prefs_forcerate(a0),sampleforcerate(a5)

	move.b	prefs_samplecyber(a0),samplecyber(a5)
	
	move.b	prefs_mpegaqua(a0),d0
	moveq	#0,d1
	moveq	#2,d2
	bsr	clampByte
	move.b	d0,mpegaqua(a5)
	
	move.b	prefs_mpegadiv(a0),d0 
	bsr	clampByte
	move.b	d0,mpegadiv(a5)

	move.b	prefs_medmode(a0),d0
	moveq	#0,d1
	moveq	#1,d2
	bsr	clampByte
	move.b	d0,medmode(a5)

	move	prefs_medrate(a0),medrate(a5)
	move.b	prefs_sidmode(a0),sidmode(a5)
	move.b	prefs_residmode(a0),residmode(a5)
	move.b	prefs_residfilter(a0),residfilter(a5)
	move.b	prefs_residboost(a0),residboost(a5)
	move.b	prefs_midimode(a0),midimode(a5)
	move.b	prefs_xmaplay(a0),xmaplay(a5)
	move.b	prefs_medfastmemplay(a0),medfastmemplay(a5)
	move.b	prefs_favorites(a0),favorites(a5)
	move.b	prefs_tooltips(a0),tooltips(a5)
	move.b	prefs_savestate(a0),savestate(a5)
	move.b  prefs_altbuttons(a0),altbuttons(a5)
 
	move.l	prefs_textattr(a0),text_attr+4		* ysize jne
	pushpea	prefs_fontname+prefsdata(a5),text_attr
	move.l	prefs_listtextattr(a0),list_text_attr+4		* ysize jne
	pushpea	prefs_listfontname+prefsdata(a5),list_text_attr

	move	prefs_windowWidth+prefsdata(a5),d0
    * Min width check
    cmp     #264,d0
    bhs.b   .wOk
    move    #264,d0
.wOk
	move	d0,previousWindowWidth(a5)
	move	d0,WINSIZX(a5)


	st	newdirectory(a5)		* Lippu: uusi hakemisto

	bsr.b	sliderit
	bsr	setprefsbox
	bsr	mainpriority

.eee	
	move.l	d4,d1
	lob	Close	
.nope
	rts

.eeee	

	lea	prefsdata(a5),a0
	move	#prefs_size/2-1,d0
.zapit	clr	(a0)+
	dbf	d0,.zapit

	bsr.b	.eee
	bsr	aseta_vakiot

	lea	.err(pc),a1
	bra	request


.err	dc.b	"Trouble with the prefs file (wrong version?).",0
 even

* in:
*  d0 = value, can be negative
*  d1 = low bound
*  d2 = high bound
* out:
*  d0 = value within bounds
clampByte
	ext		d0 
	ext		d1 
	ext		d2
clampWord
	ext.l	d0
	ext.l	d1
	ext.l	d2
clamp
	cmp.l	d1,d0
	;blo.b	.low   
	blt.b	.low  
	cmp.l	d2,d0
	bhi.b	.high
	rts
.low	move.l	d1,d0
	rts
.high	move.l	d2,d0
	rts
	

sliderit
* mixingrate s3m

	move.l	mixirate(a5),d0
	sub.l	#5000,d0
	divu	#100,d0
	mulu	#65535,d0
	divu	#580-50,d0

	lea	pslider1,a0
	bsr	setknob2

* mixingrate tfmx
	lea	pslider2-pslider1(a0),a0
	move	tfmxmixingrate(a5),d0
	subq	#1,d0
	mulu	#65535,d0
	divu	#21,d0
	bsr	setknob2

* volumeboost ps3m
	lea	juusto-pslider2(a0),a0
	moveq	#0,d0
	move.b	s3mmode3(a5),d0
	mulu	#65535,d0
	divu	#16,d0
	bsr	setknob2

* stereoarvo ps3m
	lea	juust0-juusto(a0),a0
	moveq	#0,d0
	move.b	stereofactor(a5),d0
	mulu	#65535,d0
	divu	#64,d0
	bsr	setknob2

* timeout
	lea	kelloke-juust0(a0),a0
	move	timeout(a5),d0
	mulu	#65535,d0
	divu	#1800,d0		* 10*60 sekkaa
	bsr	setknob2

* alarm
	lea	kelloke2-kelloke(a0),a0
	move	alarm(a5),d1
	moveq	#0,d0
	move.b	d1,d0
	lsr	#8,d1
	mulu	#60,d1
	add	d1,d0

	mulu	#65535,d0
	divu	#1440,d0
	bsr	setknob2

* moduleinfo
	lea	eskimO-kelloke2(a0),a0
	move	infosize(a5),d0
	subq	#3,d0
	mulu	#65535,d0
	divu	#50-3,d0
	bsr	setknob2


* samplebuffersize
	lea	sIPULI-eskimO(a0),a0
	moveq	#0,d0
	move.b	samplebufsiz0(a5),d0
	mulu	#65535,d0
	divu	#5,d0
	bsr	setknob2

* sampleforcerate
;	lea	sIPULI2-sIPULI(a0),a0
;	moveq	#0,d0
;	move	sampleforcerate(a5),d0
;	mulu	#65535,d0
;	divu	#600-9,d0
;	bsr	setknob2



* ahi rate
	move.l	ahi_rate(a5),d0
	sub.l	#5000,d0
	divu	#100,d0
	mulu	#65535,d0
	divu	#580-50,d0

	lea	ahiG4,a0
	bsr	setknob2

* ahi master volume
	moveq	#0,d0
	move	ahi_mastervol(a5),d0
	mulu	#65535,d0
	divu	#1000,d0

	lea	ahiG5-ahiG4(a0),a0
	bsr	setknob2

* ahi stereo level
	moveq	#0,d0
	move	ahi_stereolev(a5),d0
	mulu	#65535,d0
	divu	#100,d0

	lea	ahiG6-ahiG5(a0),a0
	bsr	setknob2

* mixingrate med

	moveq	#0,d0
	move	medrate(a5),d0
	sub.l	#5000,d0
	divu	#100,d0
	mulu	#65535,d0
	divu	#580-50,d0
	lea	nAMISKA5-ahiG6(a0),a0
	bra	setknob2

* Update box size slider in prefs
setprefsbox
* boxsize
	lea	meloni,a0
	move	boxsize(a5),d0
	beq.b	.x
	subq	#2,d0
.x	mulu	#65535,d0
	divu	#51-3,d0
	bra	setknob2

setPrefsInfoBox
	lea	eskimO,a0
	move	infosize(a5),d0
	subq	#3,d0
	mulu	#65535,d0
	divu	#50-3,d0
	bra		setknob2

saveprefs
	DPRINT	"Prefs save"
	move.l	windowbase(a5),d0
	beq.b	.h
	move.l	d0,a0
	tst.b	kokolippu(a5)
	beq.b	.smal
	move.l	4(a0),windowpos(a5)
	bra.b	.h
.smal	move.l	4(a0),windowZippedPos(a5)

.h	move.l	windowbase2(a5),d0
	beq.b	.g
	move.l	d0,a0
	move.l	4(a0),windowpos_p(a5)
.g	

	tst	info_prosessi(a5)
	sne	prefs_infoon+prefsdata(a5)

	move.l	swindowbase(a5),d0
	beq.b	.gg
	move.l	d0,a0
	move.l	4(a0),infopos2(a5)
.gg


* Arvot yms. prefs-tiedostoon
	lea	prefsdata(a5),a0
	move.b	#prefsversio,(a0)
	move.l	mixirate(a5),prefs_s3mrate(a0)
	move.b	playmode(a5),prefs_play(a0)
	move.b	lootamoodi+1(a5),prefs_show(a0)
	move.b	tempoflag(a5),prefs_tempo(a0)
	move.b	tfmxmixingrate+1(a5),prefs_tfmxrate(a0)
	move.b	s3mmode1(a5),prefs_s3mmode1(a0)
	move.b	s3mmode2(a5),prefs_s3mmode2(a0)
	move.b	s3mmode3(a5),prefs_s3mmode3(a0)
	move.l	windowpos(a5),prefs_mainpos1(a0)
	move.l	windowZippedPos(a5),prefs_mainpos2(a0)
	move.l	windowpos_p(a5),prefs_prefspos(a0)
	move.b	ptmix(a5),prefs_ptmix(a0)
	move.b	xpkid(a5),prefs_xpkid(a0)
	move.b	fade(a5),prefs_fade(a0)
	move.b	priority+3(a5),prefs_pri(a0)
	move.b	boxsize+1(a5),prefs_boxsize(a0)
	move.b	doubleclick(a5),prefs_doubleclick(a0)
	move.b	startuponoff(a5),prefs_startuponoff(a0)
	move	timeout(a5),prefs_timeout(a0)
	move.b	hotkey(a5),prefs_hotkey(a0)
	move.b	contonerr(a5),prefs_cerr(a0)
	move.b	ps3mb(a5),prefs_ps3mb(a0)
	move.b	timeoutmode(a5),prefs_timeoutmode(a0)
	move.b	filterstatus(a5),prefs_filter(a0)
	move.b	vbtimer(a5),prefs_vbtimer(a0)
	move.b	groupmode(a5),prefs_groupmode(a0)
	move	alarm(a5),prefs_alarm(a0)
	move.b	stereofactor(a5),prefs_stereofactor(a0)
	move.b	divdir(a5),prefs_div(a0)
	move.b	prefixcut(a5),prefs_prefix(a0)
	move.b	earlyload(a5),prefs_early(a0)
	move.l	infopos2(a5),prefs_infopos2(a0)
	move.b	xfd(a5),prefs_xfd(a0)
	move	infosize(a5),prefs_infosize(a0)
	move.b	ps3msettings(a5),prefs_ps3msettings(a0)
	move.b	prefsivu+1(a5),prefs_prefsivu(a0)
	move.b	kokolippu(a5),prefs_kokolippu(a0)
	not.b	prefs_kokolippu(a0)
	move.b	samplebufsiz0(a5),prefs_samplebufsiz(a0)
	;move.b	cybercalibration(a5),prefs_cybercalibration(a0)
	move	sampleforcerate(a5),prefs_forcerate(a0)

	move.b	samplecyber(a5),prefs_samplecyber(a0)
	move.b	mpegaqua(a5),prefs_mpegaqua(a0)
	move.b	mpegadiv(a5),prefs_mpegadiv(a0)
	move.b	medmode(a5),prefs_medmode(a0)
	move	medrate(a5),prefs_medrate(a0)
	move.b	sidmode(a5),prefs_sidmode(a0)
	move.b	residmode(a5),prefs_residmode(a0)
	move.b	residfilter(a5),prefs_residfilter(a0)
	move.b	residboost(a5),prefs_residboost(a0)
	move.b	midimode(a5),prefs_midimode(a0)
	move.b	xmaplay(a5),prefs_xmaplay(a0)
	move.b	medfastmemplay(a5),prefs_medfastmemplay(a0)
	move.b	favorites(a5),prefs_favorites(a0)
	move.b	tooltips(a5),prefs_tooltips(a0)
	move.b	savestate(a5),prefs_savestate(a0)
	move.b	altbuttons(a5),prefs_altbuttons(a0)
	move	previousWindowWidth(a5),prefs_windowWidth(a0)

	move.l	text_attr+4,prefs_textattr(a0)
	move.l	text_attr,a1
	lea	prefs_fontname(a0),a2
.cec	move.b	(a1)+,(a2)+
	bne.b	.cec

	move.l	list_text_attr+4,prefs_listtextattr(a0)
	move.l	list_text_attr,a1
	lea	prefs_listfontname(a0),a2
.cec2	move.b	(a1)+,(a2)+
	bne.b	.cec2


.ohi
	move.l	_DosBase(a5),a6
	pushpea	prefsfilename(pc),d1
	move.l	#1006,d2
	lob	Open
	move.l	d0,d4
	beq.b	.nope
	lea	prefsdata(a5),a0
	move.l	a0,d2
	move.l	d0,d1
	move.l	#prefs_size,d3
	lob	Write
	cmp.l	#prefs_size,d0
	bne.b	.eeef
.clc	move.l	d4,d1
	lob	Close
.nope	rts

.eeef	bsr.b	.clc
	lea	.errr(pc),a1
	bra	request

.errr	dc.b	"Couldn't save prefs file!",0

prefsfilename dc.b	"S:HippoPlayer.prefs",0
;prefsfilename2 dc.b	"PROGDIR:HippoPlayer.prefs",0
 even

*******************************************************************************
* Asetetaan vakioarvot yms.

defarc
	lea	.lha(pc),a0
	lea	arclha(a5),a1
	bsr	copyb

	lea	.zip(pc),a0
	lea	arczip(a5),a1
	bsr	copyb

	lea	.lzx(pc),a0
	lea	arclzx(a5),a1
	bsr	copyb

	lea	.arc(pc),a0
	lea	arcdir(a5),a1
	bra	copyb
;	rts

.arc	dc.b	"RAM:",0

.lha	dc.b	'c:lha >nil: x -IqmMNQw "%s"',0
* m	no messages for query
* q	be quiet
* M	no autoshow files
* N	no progress indicator
* I	ignore LHAOPTS variable
* Qw	disable wildcards


.lzx	dc.b 'c:lzx >nil: -m -q x "%s"',0

.zip
zipDecompressCommand
	dc.b	'c:unzip >nil: -jo "%s"',0
* j: do not create folders
* o: overwrite without asking
* qq	be very quiet

* decompress %s to stdout and redirect to current dir data file
gzipDecompressCommand
	dc.b	'gzip -d -c "%s" >gzData',0	

 even
	

aseta_vakiot
	DPRINT	"Set defaults"
	bsr	nupit
	move	#64,mainvolume(a5)
	move.l	#PLAYING_MODULE_NONE,playingmodule(a5)
	move.l	#PLAYING_MODULE_NONE,chosenmodule(a5)
	move	#12,tfmxmixingrate(a5)
	move.b	#pm_repeat,playmode(a5)		* lippu: toistetaan
	move.l	#10000,mixirate(a5)
	move	#CHECKSUM,textchecksum(a5)
	move	#12,tfmxmixingrate(a5)
	move.b	#2,s3mmode1(a5)
	move.b	#sm_surround,s3mmode2(a5)
	clr.b	s3mmode3(a5)
	move	#8,boxsize(a5)
	move	#8,boxsize0(a5)
	move.b	#2,ps3mb(a5)	* 4,8,16,32,64
	move.b	#32,stereofactor(a5)
	move	#16,infosize(a5)

	move	#8,text_attr+4

	lea	check_keyfile,a2

	lea	defgroup(pc),a0
	lea	groupname(a5),a1
	bsr	copyb
	
	st	newdirectory(a5)
	lea	.defdir1(pc),a0
	lea	moduledir(a5),a1
	bsr	copyb

	lea	.defdir1(pc),a0
	lea	prgdir(a5),a1
	bsr	copyb

	lea	.defdir2(pc),a0
	lea	arcdir(a5),a1
	bsr	copyb

	lea	.defdir1(pc),a0
	lea	mhiLib(a5),a1
	bsr	copyb

	lea	.wb(pc),a0
	lea	pubscreen(a5),a1
	bsr	copyb

	lea	.pat(pc),a0
	lea	pattern(a5),a1
	bsr	copyb

	move.l	a2,keycheckroutine(a5)

	bra	defarc
;	rts

.defdir1 dc.b	"SYS:",0
.defdir2 dc.b	"RAM:",0
.wb	dc.b	"Workbench",0
.pat	dc.b	"~(#?.info|smpl.#?|#?.ins|#?.nt|#?.as|#?.instr|#?.ss)",0
defgroup dc.b	"S:"	
hipGroupFileName
	dc.b	"HippoPlayer.Group",0
 even

bcopy
copyb	move.b	(a0)+,(a1)+
	bne.b	copyb
	rts



******************************************************************************
* Lataa PS3M asetustiedoston

loadps3msettings

	move.l	_DosBase(a5),a6

; ifeq asm
;	tst.b	uusikick(a5)
;	beq.b	.old
;	lea	.n2(pc),a0
;	move.b	#"R",.n1-.n2(a0)
;	move.l	a0,d1
;	move.l	#1005,d2
;	lob	Open
;	move.l	d0,d4
;	bne.b	.ok
;.old
; endc

	lea	.n1(pc),a0
;	move.b	#'S',(a0)
	move.l	a0,d1
	move.l	#1005,d2
	lob	Open
	move.l	d0,d4
	beq.b	.xx
.ok
	move.l	d4,d1		* selvitet‰‰n filen pituus
	moveq	#0,d2	
	moveq	#1,d3
	lob	Seek
	move.l	d4,d1
	moveq	#0,d2	
	moveq	#1,d3
	lob	Seek
	move.l	d0,d5

	move.l	d4,d1		* alkuun
	moveq	#0,d2
	moveq	#-1,d3
	lob	Seek

	move.l	d5,d0
	moveq	#MEMF_PUBLIC,d1
	bsr	getmem
	move.l	d0,d7
	beq.b	.x

	move.l	d4,d1
	move.l	d7,d2
	move.l	d5,d3
	lob	Read
	cmp.l	d5,d0
	bne.b	.er

	move.l	d7,ps3msettingsfile(a5)
	bra.b	.x
.er
	move.l	d7,a0
	bsr	freemem

.x	move.l	d4,d1
	beq.b	.xx
	lob	Close	

.xx	rts


;.n2	dc.b	"PROGDI"
;.n1	dc.b	"R:HippoPlayer.PS3M",0
.n1	dc.b	"S:HippoPlayer.PS3M",0
 even


*********************************************************************
* Ladataan CyberSound 14-bit kalibraatiotiedosto

 REM
loadcybersoundcalibration
	tst.b	cybercalibration(a5)
	beq.b	.xx
	tst.l	calibrationaddr(a5)
	bne.b	.xx

	moveq	#0,d7


	move.l	_DosBase(a5),a6
	pushpea	calibrationfile(a5),d1
	move.l	#1005,d2
	lob	Open
	move.l	d0,d4
	bne.b	.ok

.err	lea	.er1(pc),a1
	bsr	request
	bra.b	.x
.ok

	move.l	#256,d0
	moveq	#MEMF_PUBLIC,d1
	bsr	getmem
	move.l	d0,d7
	beq.b	.err

	move.l	d4,d1
	move.l	d7,d2
	move.l	#256,d3
	lob	Read
	cmp.l	#256,d0
	bne.b	.err

	move.l	d7,calibrationaddr(a5)
	bra.b	.kos

.x
	tst.l	d7
	beq.b	.kos
	move.l	d7,a0
	bsr	freemem
.kos
	move.l	d4,d1
	beq.b	.xx
	lob	Close	
.xx	rts

.er1	dc.b	"Unable to load calibration file!",0
 even
 EREM

******************************************************************************
* Piirt‰‰ tekstuurin ikkunaan

* in: 
*   d0 = xmin
*   d1 = ymin
*   d2 = xmax
*   d3 = ymax

drawtexture:
	movem.l	d0-a6,-(sp)
	movem.l	d0-d3,-(sp)

	move.l	rp_AreaPtrn(a2),d6
	move.b	rp_AreaPtSz(a2),d7

	lea	.texture(pc),a0
	move.l	a0,rp_AreaPtrn(a2)
	move.b	#1,rp_AreaPtSz(a2)

	move.l	a2,a1
	move.l	pen_0(a5),d0
	lore	GFX,SetAPen
	move.l	a2,a1

	move.l	pen_3(a5),d0
	tst.b	uusikick(a5)
	bne.b	.n
	move.l	pen_1(a5),d0 * kick1.3: different color
.n
	lob	SetBPen

	movem.l	(sp)+,d0-d3
	move.l	a2,a1
	add	windowleft(a5),d0
	add	windowtop(a5),d1
	add	windowleft(a5),d2
	tst.b	uusikick(a5)
	bne.b	.nn
	addq	#2,d2 * kick1.3: more wider
.nn
	add	windowtop(a5),d3
	lob	RectFill

	move.l	a2,a1
	move.l	pen_1(a5),d0
	lob	SetAPen
	move.l	a2,a1
	move.l	pen_0(a5),d0
	lob	SetBPen

	move.l	d6,rp_AreaPtrn(a2)
	move.b	d7,rp_AreaPtSz(a2)
	
	movem.l	(sp)+,d0-a6
	rts

.texture dc	$5555,$aaaa



*******************************************************************************
*** SECTION *******************************************************************
*
* Preferences section
* - Prefs UI
*
*******************************************************************************


*******************************************************************************
* Preferences
* Luodaan erillinen prosessi
*******

* This will signal the prefs window to update itself.
updateprefs:
	; Called from scope, no logging
	;DPRINT	"Update prefs"
	pushm	all
	tst	prefs_prosessi(a5)
	beq.b	.x
	move.l	prefs_task(a5),d0
	beq.b	.x
	move.l	d0,a1
	moveq	#0,d0
	move.b	prefs_updateContentsSignal(a5),d1
	bset	d1,d0
	lore	Exec,Signal
.x	popm	all
	rts

* T‰m‰ aiheutti enforcer-hitin jos ei ollut prefs-taskia!

sulje_prefs
	tst	prefs_prosessi(a5)
	beq.b	.ww
	tst.l	prefs_task(a5)
	beq.b	.ww
	move.l	a6,-(sp)
	moveq	#0,d0			* signaali prefssille lopettamisesta
	move.b	prefs_closeSignal(a5),d1
	bset	d1,d0
	move.l	prefs_task(a5),a1
	lore	Exec,Signal
	move.l	(sp)+,a6
.w	tst	prefs_prosessi(a5)	* odotellaan..
	beq.b	.ww
	bsr	dela
	bra.b	.w
.ww	rts

rbutton20
;	bra.b	prefs_code

	tst	prefs_prosessi(a5)	* sammutus jos oli p‰‰ll‰
	bne.b	sulje_prefs

.ook	
	movem.l	d0-a6,-(sp)
	move.l	_DosBase(a5),a6
	pushpea	prefsprocname(pc),d1
;	moveq	#0,d2			* pri
	move.l	priority(a5),d2

	pushpea	prefs_segment(pc),d3
	lsr.l	#2,d3
	move.l	#3000,d4
	lob	CreateProc
	tst.l	d0
	beq.b	.error
	addq	#1,prefs_prosessi(a5)
.error	movem.l	(sp)+,d0-a6
	rts


	
prefs_code
	lea	var_b,a5
	addq	#1,prefs_prosessi(a5)	* Lippu: prosessi p‰‰ll‰

	printt	"TODO: refactor prefs data handling"

	clr.b	prefs_exit(a5)		* Lippu

	st	boxsize00(a5)

* Arvot yms. v‰liaikaismuuttujiin
	move.l	mixirate(a5),mixingrate_new(a5)
	move	tfmxmixingrate(a5),tfmxmixingrate_new(a5)
	move	lootamoodi(a5),lootamoodi_new(a5)
	move.b	tempoflag(a5),tempoflag_new(a5)
	move.b	playmode(a5),playmode_new(a5)
	move.b	newdirectory(a5),newdir_new(a5)
	move.b	s3mmode1(a5),s3mmode1_new(a5)
	move.b	s3mmode2(a5),s3mmode2_new(a5)
	move.b	s3mmode3(a5),s3mmode3_new(a5)
	move.b	ptmix(a5),ptmix_new(a5)
	move.b	xpkid(a5),xpkid_new(a5)
	move.b	fade(a5),fade_new(a5)
	move.b	priority+3(a5),pri_new(a5)
	move.b	doubleclick(a5),dclick_new(a5)
	move.b	startuponoff(a5),startuponoff_new(a5)
	move	boxsize(a5),boxsize_new(a5)
	bsr	setprefsbox
	move	timeout(a5),timeout_new(a5)
	move.b	hotkey(a5),hotkey_new(a5)
	move.b	contonerr(a5),cerr_new(a5)
	move.b	doublebuf(a5),dbf_new(a5)
	move.b	nastyaudio(a5),nasty_new(a5)
	move.b	ps3mb(a5),ps3mb_new(a5)
	move.b	timeoutmode(a5),timeoutmode_new(a5)
	move.b	vbtimer(a5),vbtimer_new(a5)
	move.b	groupmode(a5),groupmode_new(a5)
	move	alarm(a5),alarm_new(a5)
	move.b	stereofactor(a5),stereofactor_new(a5)
	move.b	divdir(a5),div_new(a5)
	move.b	prefixcut(a5),prefix_new(a5)
	move.b	earlyload(a5),early_new(a5)
	move.b	xfd(a5),xfd_new(a5)
	move	infosize(a5),infosize_new(a5)
	bsr	setPrefsInfoBox
	move.b	ps3msettings(a5),ps3msettings_new(a5)
	move.b	samplebufsiz0(a5),samplebufsiz_new(a5)
	;move.b	cybercalibration(a5),cybercalibration_new(a5)
	move	sampleforcerate(a5),sampleforcerate_new(a5)

	move.b	samplecyber(a5),samplecyber_new(a5)
	move.b	mpegaqua(a5),mpegaqua_new(a5)
	move.b	mpegadiv(a5),mpegadiv_new(a5)
	move.b	medmode(a5),medmode_new(a5)
	move	medrate(a5),medrate_new(a5)
	move.b	sidmode(a5),sidmode_new(a5)
	move.b	residmode(a5),residmode_new(a5)
	move.b	residfilter(a5),residfilter_new(a5)
	move.b	residboost(a5),residboost_new(a5)
	move.b	midimode(a5),midimode_new(a5)
	move.b	xmaplay(a5),xmaplay_new(a5)
	move.b	medfastmemplay(a5),medfastmemplay_new(a5)
	move.b	favorites(a5),favorites_new(a5)
	move.b	tooltips(a5),tooltips_new(a5)
	move.b	savestate(a5),savestate_new(a5)
	move.b	altbuttons(a5),altbuttons_new(a5)
	move.b	mhiEnable(a5),mhiEnable_new(a5)
	move.b	showPositionSlider(a5),showPositionSlider_new(a5)
    move.b  ps3mamigus(a5),ps3mamigus_new(a5)

	move.l	ahi_rate(a5),ahi_rate_new(a5)
	move	ahi_mastervol(a5),ahi_mastervol_new(a5)
	move.l	ahi_mode(a5),ahi_mode_new(a5)
	move	ahi_stereolev(a5),ahi_stereolev_new(a5)
	move.b	ahi_use(a5),ahi_use_new(a5)
	move.b	ahi_muutpois(a5),ahi_muutpois_new(a5)

	move.b	autosort(a5),autosort_new(a5)


;	move.l	pslider1+gg_SpecialInfo,a0
;	move	pi_HorizPot(a0),s3mmixpot_new(a5)
;	move.l	pslider2+gg_SpecialInfo,a0
;	move	pi_HorizPot(a0),tfmxmixpot_new(a5)
;	move.l	juusto+gg_SpecialInfo,a0
;	move	pi_HorizPot(a0),volumeboostpot_new(a5)
;	move.l	juust0+gg_SpecialInfo,a0
;	move	pi_HorizPot(a0),stereofactorpot_new(a5)
;	move.l	meloni+gg_SpecialInfo,a0
;	move	pi_HorizPot(a0),boxsizepot_new(a5)
;	move.l	kelloke+gg_SpecialInfo,a0
;	move	pi_HorizPot(a0),timeoutpot_new(a5)
;	move.l	kelloke2+gg_SpecialInfo,a0
;	move	pi_HorizPot(a0),alarmpot_new(a5)
;	move.l	eskimO+gg_SpecialInfo,a0
;	move	pi_HorizPot(a0),infosizepot_new(a5)
;	move.l	sIPULI+gg_SpecialInfo,a0
;	move	pi_HorizPot(a0),samplebufsizpot_new(a5)
;	move.l	sIPULI2+gg_SpecialInfo,a0
;	move	pi_HorizPot(a0),sampleforceratepot_new(a5)

	lea	pslider1s+pi_HorizPot,a0
	move	(a0),s3mmixpot_new(a5)
	move	pslider2s-pslider1s(a0),tfmxmixpot_new(a5)
	move	juustos-pslider1s(a0),volumeboostpot_new(a5)
	move	juust0s-pslider1s(a0),stereofactorpot_new(a5)
	move	melonis-pslider1s(a0),boxsizepot_new(a5)
	move	kellokes-pslider1s(a0),timeoutpot_new(a5)
	move	kelloke2s-pslider1s(a0),alarmpot_new(a5)
	move	eskimOs-pslider1s(a0),infosizepot_new(a5)
	move	sIPULIs-pslider1s(a0),samplebufsizpot_new(a5)
	;move	sIPULI2s-pslider1s(a0),sampleforceratepot_new(a5)
	move	ahiG4s-pslider1s(a0),ahi_ratepot_new(a5)
	move	ahiG5s-pslider1s(a0),ahi_mastervolpot_new(a5)
	move	ahiG6s-pslider1s(a0),ahi_stereolevpot_new(a5)
	move	nAMISKA5s-pslider1s(a0),medratepot_new(a5)

	lea	fontname_new(a5),a0
	lea	prefs_fontname+prefsdata(a5),a1
.cc	move.b	(a1)+,(a0)+
	bne.b	.cc

	lea	listfontname_new(a5),a0
	lea	prefs_listfontname+prefsdata(a5),a1
.cc2	
	move.b	(a1)+,(a0)+
	bne.b	.cc2
		
		
	lea	ack2,a3
	lea	arclha(a5),a0
	lea	arclha_new(a5),a1
	bsr	.copy

	lea	ack3-ack2(a3),a3
	lea	arczip(a5),a0
	lea	arczip_new(a5),a1
	bsr	.copy

	lea	ack4-ack3(a3),a3
	lea	arclzx(a5),a0
	lea	arclzx_new(a5),a1
	bsr	.copy

	lea	DuU0-ack4(a3),a3
	lea	pattern(a5),a0
	lea	pattern_new(a5),a1
	bsr	.copy


	lea	pubscreen_new(a5),a1
	lea	pubscreen(a5),a0
.w	move.b	(a0)+,(a1)+
	bne.b	.w

	lea	groupname(a5),a0
	lea	groupname_new(a5),a1
.ww	move.b	(a0)+,(a1)+
	bne.b	.ww

	lea	moduledir(a5),a0
	lea	moduledir_new(a5),a1
.www	move.b	(a0)+,(a1)+
	bne.b	.www

	lea	prgdir(a5),a0
	lea	prgdir_new(a5),a1
.wwww	move.b	(a0)+,(a1)+
	bne.b	.wwww

	lea	arcdir(a5),a0
	lea	arcdir_new(a5),a1
.wwwww	move.b	(a0)+,(a1)+
	bne.b	.wwwww
	

	lea	startup_new(a5),a1
	lea	startup(a5),a0
	moveq	#120-1,d0
	bsr.b	.cp2

	lea	mhiLib_new(a5),a1
	lea	mhiLib(a5),a0
	moveq	#MHILIB_SIZE-1,d0
	bsr.b	.cp2

;	lea	calibrationfile(a5),a0
;	lea	calibrationfile_new(a5),a1
;.ww2	move.b	(a0)+,(a1)+
;	bne.b	.ww2

	lea	ahi_name(a5),a0
	lea	ahi_name_new(a5),a1
.w32	move.b	(a0)+,(a1)+
	bne.b	.w32


	lea	fkeys_new(a5),a1
	lea	fkeys(a5),a0
	move	#10*120-1,d0
	bsr.b	.cp2

	bra.b	.ohi

.copy	
	move.l	gg_SpecialInfo(a3),a2
	move.l	si_Buffer(a2),a2	* Teksipuskuri

.c	move.b	(a0),(a1)+
	move.b	(a0)+,(a2)+
	bne.b	.c
	rts

.cp2	move.b	(a0)+,(a1)+
	dbf	d0,.cp2
	rts

.ohi


	bsr	inittick

	move	#GFLG_DISABLED,d4
    lea     VaL6,a3
    basereg VaL6,a3
	tst.b	uusikick(a5)		* uusi kick?
	bne.b	.uusi
** Disabloidaan screengadgetti!
;	or	d4,gg_Flags+pbutton13
** Disabloidaan ahi-valinta
	or	d4,gg_Flags+VaL6(a3)

    * Disable MHI gadgtes
	;or	d4,gg_Flags+prefsMHIEnable(a3)
	;or	d4,gg_Flags+prefsMHILib(a3)
.uusi
    jsr    checkAmiGUSAvailability
    tst    d0
    bne    .yesGus
    or     d4,gg_Flags+bENDER1(a3)
.yesGus
    endb    a3

	move.l	_IntuiBase(a5),a6
	lea	winstruc2,a0
	move	wbkorkeus(a5),d0	* Onko ikkuna liian suuri?
	cmp	nw_Height(a0),d0	* Kutistetaan 200:aan pixeliin
	bhi.b	.ok
	move	d0,nw_Height(a0)
.ok

	move.l	windowpos_p(a5),(a0)	* Paikka

	bsr	tark_mahtu

	lob	OpenWindow
	move.l	d0,windowbase2(a5)
	beq	exprefs

	move.l	d0,a0
	move.l	wd_RPort(a0),rastport2(a5)
	move.l	wd_UserPort(a0),userport2(a5)

	bsr	setscrtitle


;	tst.b	uusikick(a5)
;	beq.b	.vanaha

	move.l	rastport2(a5),a2
	moveq	#4,d0
	moveq	#11,d1
	move	#452-6,d2
	move	#182-15,d3
	bsr	drawtexture

.ohih

* pagenappulot
	lea	VaL1,a0
	bsr.b	.cler2
	lea	VaL2-VaL1(a0),a0
	bsr.b	.cler2
	lea	VaL3-VaL2(a0),a0
	bsr.b	.cler2
	lea	VaL4-VaL3(a0),a0
	bsr.b	.cler2
	lea	VaL5-VaL4(a0),a0
	bsr.b	.cler2
	lea	VaL6-VaL5(a0),a0
	bsr.b	.cler2
	lea	VaL7-VaL6(a0),a0
	bsr.b	.cler2

* saveusecancel-alue
	lea	pbutton14,a0
	bsr.b	.cler2
	lea	pbutton6-pbutton14(a0),a0
	bsr.b	.cler2
	lea	pbutton7-pbutton6(a0),a0
	bsr.b	.cler2
	bra.b	.oru

.cler2
	movem	4(a0),d0/d1/d4/d5
	sub	windowleft(a5),d0
	sub	windowtop(a5),d1
	bra	pcler
.oru
;.vanaha


	move.l	rastport2(a5),a1
	move.l	fontbase(a5),a0
	lore	GFX,SetFont	




* sitten isket‰‰n gadgetit ikkunaan..
	move.l	windowbase2(a5),a0
	lea	gadgets2,a1
	moveq	#-1,d0
	moveq	#-1,d1
	sub.l	a2,a2
	lore	Intui,AddGList
	lea	gadgets2,a0
	move.l	windowbase2(a5),a1
	sub.l	a2,a2
	lob	RefreshGadgets


	move.l	rastport2(a5),a1
	move.l	pen_1(a5),d0
	lore	GFX,SetAPen
	move.l	pen_0(a5),d0
	move.l	rastport2(a5),a1
	lob	SetBPen


	move.l	(a5),a6
	sub.l	a1,a1
	lob	FindTask
	move.l	d0,prefs_task(a5)

	moveq	#-1,d0
	lob	AllocSignal
	move.b	d0,prefs_closeSignal(a5)
;	bmi	exprefs
	moveq	#-1,d0
	lob	AllocSignal
	move.b	d0,prefs_updateContentsSignal(a5)
;	bmi	exprefs

	bsr	prefsgads


	moveq	#12,d4			* laatikko
	moveq	#31,d5
	move	#439,d6
	move	#146,d7
	add	windowleft(a5),d4
	add	windowleft(a5),d6
	add	windowtop(a5),d5
	add	windowtop(a5),d7
	move.l	rastport2(a5),a1
	bsr	laatikko3


	bra.b	msgloop2
returnmsg2
	bsr	flush_messages2
msgloop2
	tst.b	prefs_exit(a5)
	bne	exprefs

	move.l	(a5),a6
	moveq	#0,d0
	move.l	userport2(a5),a4
	move.b	MP_SIGBIT(a4),d1	* IDCMP signalibitti
	bset	d1,d0
	move.b	prefs_closeSignal(a5),d1	* oma signaali
	bset	d1,d0
	move.b	prefs_updateContentsSignal(a5),d1	* oma signaali ikkunan p‰ivitykseen
	bset	d1,d0
	lob	Wait			* Odotellaan...

	move.b	prefs_closeSignal(a5),d1	* k‰skeekˆ p‰‰ohjelma lopettamaan?
	btst	d1,d0
	bne	exprefs

	move.b	prefs_updateContentsSignal(a5),d1	* p‰ivitys?
	btst	d1,d0
	beq.b	.naa
	* Update window!
	pushm	all
	cmp	#4,prefsivu(a5)
	bne.b	.er
	* Done only for page 4?
	bsr	prefsgads
	bra.b	.er2
.er	bsr	pupdate
.er2	popm	all
.naa

* Vastataan IDCMP:n viestiin

	move.l	userport2(a5),a4
	move.l	a4,a0
	lob	GetMsg
	tst.l	d0
	beq.b	msgloop2

	move.l	d0,a1
	move.l	im_Class(a1),d2		* luokka	
	move	im_Code(a1),d3		* koodi
	move.l	im_IAddress(a1),a2 	* gadgetin tai olion osoite
	move	im_MouseX(a1),d6	* mousen koordinaatit
	move	im_MouseY(a1),d7

	lob	ReplyMsg

	cmp.l	#IDCMP_RAWKEY,d2
	bne.b	.nr
	tst.b	d3
	bmi	returnmsg2
	move	d3,rawkeyinput(a5)
	move.b	rawKeySignal(a5),d1
	bsr	signalit
	bra	returnmsg2
.nr
	cmp.l	#IDCMP_MOUSEMOVE,d2
	beq	mousemoving2
	cmp.l	#IDCMP_GADGETUP,d2
	beq	gadgetsup2
	cmp.l	#IDCMP_MOUSEBUTTONS,d2
	beq	pmousebuttons
	cmp.l	#IDCMP_CLOSEWINDOW,d2
	bne	msgloop2

	bsr	flush_messages2

exprefs	move.l	_IntuiBase(a5),a6		

	move.l	windowbase2(a5),d0
	beq.b	.eek

	move.l	d0,a0
	move.l	prefsivugads(a5),d0
	beq.b	.hh
	move.l	d0,a1
	moveq	#-1,d0
	moveq	#-1,d1
	sub.l	a2,a2
	lob	RemoveGList
	clr.l	prefsivugads(a5)
.hh
	move.l	windowbase2(a5),a0
	move.l	4(a0),windowpos_p(a5)
	lob	CloseWindow
	clr.l	windowbase2(a5)
.eek
	move.l	(a5),a6

	moveq	#0,d0
	move.b	prefs_closeSignal(a5),d0
	bmi.b	.yyk
	lob	FreeSignal
.yyk	
	moveq	#0,d0
	move.b	prefs_updateContentsSignal(a5),d0
	bmi.b	.yyk2
	lob	FreeSignal
.yyk2

	tst.b	prefs_exit(a5)
	beq	.cancelled
	cmp.b	#-1,prefs_exit(a5)	* Cancel
	beq	.cancelled

** USE
	DPRINT	"Prefs use"

	move.l	mixingrate_new(a5),mixirate(a5)
	move	tfmxmixingrate_new(a5),tfmxmixingrate(a5)
	move	lootamoodi_new(a5),lootamoodi(a5)
	move.b	tempoflag_new(a5),tempoflag(a5)
	move.b	playmode_new(a5),playmode(a5)
	move.b	s3mmode1_new(a5),s3mmode1(a5)
	move.b	s3mmode2_new(a5),s3mmode2(a5)
	move.b	s3mmode3_new(a5),s3mmode3(a5)
	move.b	ptmix_new(a5),ptmix(a5)
	move.b	xpkid_new(a5),xpkid(a5)
	move.b	fade_new(a5),fade(a5)
	move.b	pri_new(a5),d0
	ext	d0
	ext.l	d0
	move.l	d0,priority(a5)
	move	boxsize_new(a5),boxsize(a5)
    tst.w   searchLayoutActive(a5)      
    beq     .sla
    cmp     #5,boxsize(a5)
    bhs     .sla
    move    #5,boxsize(a5)
.sla    
	move.b	dclick_new(a5),doubleclick(a5)
	move.b	startuponoff_new(a5),startuponoff(a5)
	move	timeout_new(a5),timeout(a5)
	move.b	hotkey_new(a5),hotkey(a5)
	move.b	cerr_new(a5),contonerr(a5)
	move.b	dbf_new(a5),doublebuf(a5)
	move.b	nasty_new(a5),nastyaudio(a5)
	move.b	ps3mb_new(a5),ps3mb(a5)
	move.b	timeoutmode_new(a5),timeoutmode(a5)
	move.b	vbtimer_new(a5),vbtimer(a5)
	move.b	groupmode_new(a5),groupmode(a5)

	move	alarm_new(a5),alarm(a5)
	move.b	stereofactor_new(a5),stereofactor(a5)
	move.b	div_new(a5),divdir(a5)
	move.b	prefix_new(a5),prefixcut(a5)
	move.b	early_new(a5),earlyload(a5)
	move.b	xfd_new(a5),xfd(a5)
	move.b	ps3msettings_new(a5),ps3msettings(a5)
	move.b	samplebufsiz_new(a5),samplebufsiz0(a5)
	;move.b	cybercalibration_new(a5),cybercalibration(a5)
	move	sampleforcerate_new(a5),sampleforcerate(a5)

	move.b	samplecyber_new(a5),samplecyber(a5)
	move.b	mpegaqua_new(a5),mpegaqua(a5)
	move.b	mpegadiv_new(a5),mpegadiv(a5)
	move.b	medmode_new(a5),medmode(a5)
	move	medrate_new(a5),medrate(a5)
	move.b	sidmode_new(a5),sidmode(a5)
	move.b	residmode_new(a5),residmode(a5)
	move.b	residfilter_new(a5),residfilter(a5)
	move.b	residboost_new(a5),residboost(a5)
	move.b	midimode_new(a5),midimode(a5)
	move.b	xmaplay_new(a5),xmaplay(a5)
	move.b	medfastmemplay_new(a5),medfastmemplay(a5)
    move.b  mhiEnable_new(a5),mhiEnable(a5)
    move.b  ps3mamigus_new(a5),ps3mamigus(a5)

    move.b  showPositionSlider(a5),d0
    move.b  showPositionSlider_new(a5),showPositionSlider(a5)
    cmp.b   showPositionSlider(a5),d0
    beq     .2
	* magic! causes reopening of the main window:
	clr	boxsize00(a5)
.2

	move.l	ahi_rate_new(a5),ahi_rate(a5)
	move	ahi_mastervol_new(a5),ahi_mastervol(a5)
	move.l	ahi_mode_new(a5),ahi_mode(a5)
	move	ahi_stereolev_new(a5),ahi_stereolev(a5)
	move.b	ahi_use_new(a5),ahi_use(a5)
	move.b	ahi_muutpois_new(a5),ahi_muutpois(a5)

	move.b	favorites_new(a5),favorites(a5)
	move.b	tooltips_new(a5),tooltips(a5)
	move.b	savestate_new(a5),savestate(a5)

	move.b	altbuttons(a5),d0
	move.b	altbuttons_new(a5),altbuttons(a5)
	cmp.b	altbuttons(a5),d0
	beq.b	.1
	DPRINT	"Alt buttons changed"
	* magic! causes reopening of the main window:
	clr	boxsize00(a5)
.1

	move.b	autosort_new(a5),autosort(a5)

;	move	infosize_new(a5),infosize(a5)

	move	infosize(a5),d0
	move	infosize_new(a5),infosize(a5)
	cmp	infosize(a5),d0
	beq.b	.eimu
	tst	info_prosessi(a5)
	beq.b	.eimu
** updatetaan infoikkunaa
	bsr	sulje_info
	move.b	oli_infoa(a5),d7
	st	oli_infoa(a5)
	push	d7
	bsr	start_info
	pop	d7
	move.b	d7,oli_infoa(a5)

.eimu

** asetetaan fontti
	tst	boxsize00(a5)
	bne	.enor
	clr	boxsize0(a5)

	;tst.b	uusikick(a5)
	;beq.b	.enor
	tst.l	_DiskFontBase(a5)	* lib?
	beq	.enor

	lore	Exec,Forbid

	lea	text_attr,a4
	basereg	text_attr,a4

	move.l	prefs_textattr+prefsdata(a5),text_attr+4(a4)
	pushpea	prefs_fontname+prefsdata(a5),text_attr(a4)

	move.l	fontbase(a5),a1
	lore	GFX,CloseFont
	lea	text_attr(a4),a0
	lore	DiskFont,OpenDiskFont
	move.l	d0,fontbase(a5)
	move.l	d0,stringExtendStruct+sex_Font(a5)
  	
	move.l	prefs_listtextattr+prefsdata(a5),list_text_attr+4(a4)
	pushpea	prefs_listfontname+prefsdata(a5),list_text_attr(a4)

	move.l	listfontbase(a5),a1
	lore	GFX,CloseFont
	lea	list_text_attr(a4),a0
	lore	DiskFont,OpenDiskFont
	move.l	d0,listfontbase(a5)
	bne.b	.gotFont
	
	lea	list_text_attr(a4),a0	
	pushpea	topaz(a4),(a0)+
	move	#8,(a0)+
	clr	(a0)
	lea	topaz_text_attr(a4),a0
	lore	GFX,OpenFont
	move.l	d0,listfontbase(a5)
	DPRINT	"revert topaz"
.gotFont
	move.l	d0,a0
	bsr	setListFont

	endb	a4

	lore	Exec,Permit

	tst	info_prosessi(a5)
	beq.b	.enor
	bsr	rbutton10b
	bsr	rbutton10b
.enor


	tst.b	newdirectory(a5)
	beq.b	.aaps
	lea	moduledir_new(a5),a0
	lea	moduledir(a5),a1
	bsr	.copy
.aaps
	tst.b	newdirectory2(a5)
	beq.b	.aaps2
	lea	prgdir_new(a5),a0
	lea	prgdir(a5),a1
	bsr	.copy
.aaps2
	lea	arcdir_new(a5),a0
	lea	arcdir(a5),a1
	bsr	.copy

	lea	arclha_new(a5),a0
	lea	arclha(a5),a1
	bsr	.copy
	lea	arczip_new(a5),a0
	lea	arczip(a5),a1
	bsr	.copy
	lea	arclzx_new(a5),a0
	lea	arclzx(a5),a1
	bsr	.copy
	lea	pattern_new(a5),a0
	lea	pattern(a5),a1
	bsr 	.copy

	lea	pubscreen_new(a5),a0
	lea	pubscreen(a5),a1
	bsr 	.copy

	lea	groupname_new(a5),a0
	lea	groupname(a5),a1
	bsr 	.copy

;	lea	calibrationfile_new(a5),a0
;	lea	calibrationfile(a5),a1
;	bsr 	.copy

	lea	ahi_name_new(a5),a0
	lea	ahi_name(a5),a1
	bsr 	.copy

	lea	startup_new(a5),a0
	lea	startup(a5),a1
	moveq	#120-1,d0
	bsr 	.copy2

	lea	mhiLib_new(a5),a0
	lea	mhiLib(a5),a1
	moveq	#MHILIB_SIZE-1,d0
	bsr 	.copy2

	lea	fkeys_new(a5),a0
	lea	fkeys(a5),a1
	move	#10*120-1,d0
	bsr 	.copy2


* ladataan caib fle jos tarpeen

 REM
	tst.b	cybercalibration(a5)
	beq.b	.dw
	tst.l	calibrationaddr(a5)
	beq.b	.dw2
	tst.b	newcalibrationfile(a5)
	beq.b	.dw
	move.l	calibrationaddr(a5),a0
	bsr	freemem
	clr.l	calibrationaddr(a5)
.dw2	bsr	loadcybersoundcalibration
.dw	clr.b	newcalibrationfile(a5)
 EREM


	cmp.b	#2,prefs_exit(a5)	* Tallennetaanko??
	bne	.jee
	bsr	saveprefs
	bra	.jee

.copy	move.b	(a0)+,(a1)+
	bne.b	.copy
	rts
.copy2	move.b	(a0)+,(a1)+
	dbf	d0,.copy2
	rts

.cancelled
	DPRINT	"Prefs cancel"
* Pistet‰‰n vanhat asennot propgadgetteihin
;	move.l	pslider1+gg_SpecialInfo,a0
;	move	s3mmixpot_new(a5),pi_HorizPot(a0)
;	move.l	pslider2+gg_SpecialInfo,a0
;	move	tfmxmixpot_new(a5),pi_HorizPot(a0)
;	move.l	juusto+gg_SpecialInfo,a0
;	move	volumeboostpot_new(a5),pi_HorizPot(a0)
;	move.l	juust0+gg_SpecialInfo,a0
;	move	stereofactorpot_new(a5),pi_HorizPot(a0)
;	move.l	meloni+gg_SpecialInfo,a0
;	move	boxsizepot_new(a5),pi_HorizPot(a0)
;	move.l	eskimO+gg_SpecialInfo,a0
;	move	infosizepot_new(a5),pi_HorizPot(a0)
;	move.l	kelloke+gg_SpecialInfo,a0
;	move	timeoutpot_new(a5),pi_HorizPot(a0)
;	move.l	kelloke2+gg_SpecialInfo,a0
;	move	alarmpot_new(a5),pi_HorizPot(a0)
;	move.l	sIPULI+gg_SpecialInfo,a0
;	move	samplebufsizpot_new(a5),pi_HorizPot(a0)
;	move.l	sIPULI2+gg_SpecialInfo,a0
;	move	sampleforceratepot_new(a5),pi_HorizPot(a0)


	lea	pslider1s+pi_HorizPot,a0
	move	s3mmixpot_new(a5),(a0)
	move	tfmxmixpot_new(a5),pslider2s-pslider1s(a0)
	move	volumeboostpot_new(a5),juustos-pslider1s(a0)
	move	stereofactorpot_new(a5),juust0s-pslider1s(a0)
	move	boxsizepot_new(a5),melonis-pslider1s(a0)
	move	infosizepot_new(a5),eskimOs-pslider1s(a0)
	move	timeoutpot_new(a5),kellokes-pslider1s(a0)		
	move	alarmpot_new(a5),kelloke2s-pslider1s(a0)
	move	samplebufsizpot_new(a5),sIPULIs-pslider1s(a0)	
	;move	sampleforceratepot_new(a5),sIPULI2s-pslider1s(a0)	
	move	ahi_ratepot_new(a5),ahiG4s-pslider1s(a0)
	move	ahi_mastervolpot_new(a5),ahiG5s-pslider1s(a0)
	move	ahi_stereolevpot_new(a5),ahiG6s-pslider1s(a0)
	move	medratepot_new(a5),nAMISKA5s-pslider1s(a0)


	move.b	newdir_new(a5),newdirectory(a5)

	move.l	text_attr+4,prefs_textattr+prefsdata(a5)
	lea	fontname_new(a5),a0
	lea	prefs_fontname+prefsdata(a5),a1
.cec	move.b	(a0)+,(a1)+
	bne.b	.cec

	move.l	list_text_attr+4,prefs_listtextattr+prefsdata(a5)
	lea	listfontname_new(a5),a0
	lea	prefs_listfontname+prefsdata(a5),a1
.cec2
	move.b	(a0)+,(a1)+
	bne.b	.cec2


	move	boxsize(a5),boxsize0(a5)	* ei vaihdettu fonttia..
	

	move.b	s3mmode3(a5),s3mmode3_new(a5)
	bsr	updateps3m
	move.b	stereofactor(a5),stereofactor_new(a5)
	bsr	updateps3m2

	move	ahi_mastervol(a5),ahi_mastervol_new(a5)
	move	ahi_stereolev(a5),ahi_stereolev_new(a5)
	bsr	updateahi

	

	clr.b	newpubscreen2(a5)
.jee	

	lore	Exec,Forbid		* kielletaan muut taskit!

	bsr	mainpriority

	move.b	ownsignal2(a5),d1
	bsr	signalit		* signaali: poistutaan preffsist‰..

	st	prefsexit(a5)

	move.b	newpubscreen2(a5),newpubscreen(a5)
	clr.b	newpubscreen2(a5)
	
	clr.l	prefs_task(a5)
	clr	prefs_prosessi(a5)	* Lippu: prosessi poistettu
	rts

flush_messages2
	move.l	windowbase2(a5),a0 
	bra	flushWindowMessages



* d0,d1: x,y
* d4,d5: x-koko,y-koko

pcler	
	push	a0
	move.l	rastport2(a5),a0
	move.l	a0,a1
	add	windowleft(a5),d0
	add	windowtop(a5),d1
	move	d0,d2
	move	d1,d3
	moveq	#$0a,d6
	lore	GFX,ClipBlit
	pop	a0
	rts



****************************************************************
*** T‰r‰ytet‰‰n ikkunaan oikean sivun gadgetit


prefsgads2
	cmp	prefsivu(a5),d0
	beq.b	.xx
	move	d0,prefsivu(a5)
	bra.b	prefsgads
.xx	rts

prefsgads
** Valinta nappulan 'highlight'

	lea	VaL1,a0
	moveq	#7-1,d0
	moveq	#0,d2
.lup	move.l	pen_1(a5),d1
	cmp	prefsivu(a5),d2
	bne.b	.no
	move.l	pen_2(a5),d1
	tst.b	uusikick(a5)
	bne.b	.no
	move.l	pen_3(a5),d1
.no	move.l	gg_GadgetText(a0),a1
	move.b	d1,it_FrontPen(a1)
	move.l	(a0),a0
	addq	#1,d2
	dbf	d0,.lup
	lea	VaL1,a0
	moveq	#6,d0
	move.l	windowbase2(a5),a1
	sub.l	a2,a2
	lore	Intui,RefreshGList


	moveq	#13,d0		* laatikko
	moveq	#32,d1
	move	#439,d4
	move	#146,d5
	sub	d0,d4
	sub	d1,d5
	bsr	pcler

	move.l	windowbase2(a5),a0
	move.l	prefsivugads(a5),d0
	beq.b	.hh
	move.l	d0,a1
	moveq	#-1,d0
	moveq	#-1,d1
	sub.l	a2,a2
	lore	Intui,RemoveGList
.hh

	lea	sivu0,a1
	move	prefsivu(a5),d0
	beq.b	.yy
	lea	sivu1-sivu0(a1),a1
	subq	#1,d0
	beq.b	.yy
	lea	sivu2-sivu1(a1),a1
	subq	#1,d0
	beq.b	.yy
	lea	sivu3-sivu2(a1),a1
	subq	#1,d0
	beq.b	.yy
	lea	sivu4-sivu3(a1),a1
	subq	#1,d0
	beq.b	.yy
	lea	sivu5-sivu4(a1),a1
	subq	#1,d0
	beq.b	.yy
	lea	sivu6-sivu5(a1),a1
.yy

	move.l	a1,prefsivugads(a5)

	move.l	windowbase2(a5),a0
	moveq	#-1,d0
	moveq	#-1,d1
	sub.l	a2,a2
	lore	Intui,AddGList

    
	lea	gadgets2,a0
	move.l	windowbase2(a5),a1
	sub.l	a2,a2
	lob	RefreshGadgets

    bsr     refreshPrefsGads

	move.l	rastport2(a5),a1
	move.l	pen_1(a5),d0
	lore	GFX,SetAPen
	move.l	pen_0(a5),d0
	move.l	rastport2(a5),a1
	lob	SetBPen


	bra	pupdate
	

refreshPrefsGads:
*** Gadgettien reunojen vahvistus
	lea	gadgets2,a3
.loloop
	move.l	(a3),d3

	move	gg_GadgetType(a3),d7
	subq.b	#GTYP_PROPGADGET,d7
	beq.b	.sli
	subq.b	#GTYP_STRGADGET-GTYP_PROPGADGET,d7
	beq.b	.nel	

	jsr	drawButtonFramePrefsWindow

.nel	move.l	d3,a3
	tst.l	d3
	bne.b	.loloop
	bra.b	.loru

.sli
	;tst.b	uusikick(a5)
	;beq.b	.nel

	movem	4(a3),plx1/ply1/plx2/ply2	* fileslider
	add	plx1,plx2
	add	ply1,ply2
	subq	#2,plx1
	addq	#1,plx2
	subq	#2,ply1
	addq	#1,ply2
	push	d3
	move.l	rastport2(a5),a1
	bsr	sliderlaatikko
	pop	d3

	bra.b	.nel


.loru
    rts


****************** 

mousemoving2			* P‰ivitet‰‰n propgadgetteja
	movem.l	d0-a6,-(sp)

	move	prefsivu(a5),d0
	bne.b	.x	
	bsr	psup4		* timeout
	bsr	purealarm	* alarm
	bra.b	.z
.x
	subq	#1,d0
	bne.b	.2
	bsr	pbox		* box size
	bsr	pinfosize
	bra.b	.z
.2
	subq	#1,d0
	bne.b	.3
	bra.b	.z
.3
	subq	#2,d0
	bne.b	.4
	
	bsr	pupdate7	* ps3m volboost
	bsr	pupdate7b	* ps3m stereo
	bsr	psup1		* ps3m mixingrate
	bra.b	.z

.4
	subq	#1,d0
	bne.b	.5
	
	bsr	pahi4		* ahi mixing rate
	bsr	pahi5		* ahi master volume
	bsr	pahi6		* ahi stereolev
	bra.b	.z

.5
	bsr	psup2		* tfmx mixingrate
	bsr	psup2b		* samplebufsiz
	;bsr	psup2c		* sampleforcerate
	bsr	pupmedrate	* med mixing rate
	

.z	movem.l	(sp)+,d0-a6
	bra	returnmsg2


*** Oikeata nappulaa painettu. Tutkitaan oliko gadgetin p‰‰ll‰ jolla on
*** requesteri.
pmousebuttons
	cmp	#MENUDOWN,d3		* oikea nappula
	bne	returnmsg2

	pushm	all

	move	prefsivu(a5),d0
	bne.b	.1

	lea	pbutton1,a0		* play
	lea	rpbutton2_req(pc),a2
	bsr	.check
	lea	tomaatti,a0		* priority
	lea	rpri_req(pc),a2
	bsr	.check
; Early load has been disabled 
;	lea	bUu3,a0
;	lea	rearly_req(pc),a2
;	bsr	.check
	bra	.xx

.1	subq	#1,d0
	bne.b	.2

	lea	pbutton2,a0		* show
	lea	rpbutton1_req(pc),a2
	bsr	.check
	;lea	pout3,a0		* scope type
	;lea	rquadm_req(pc),a2
	;bsr	.check
	lea	bUu2,a0			* prefix cut
	lea	rprefx_req(pc),a2
	bsr	.check
	bra     .xx

.2	subq	#1,d0
	bne.b	.3

	lea	pout1,a0		* filter control
	lea	rpfilt_req(pc),a2
	bsr 	.check
	lea	laren1,a0		* pt replayer
	lea	rptmix_req(pc),a2
	bsr    	.check
	lea	PoU2,a0
	lea	rpgmode_req(pc),a2
	bsr 	.check
	bra 	.xx

.3	subq	#2,d0
	bne.b	.4

	lea	smode2,a0		* ps3m playmode
	lea	rsmode1_req(pc),a2	
	bsr 	.check
	lea	smode1,a0		* ps3m state
	lea	rsmode2_req(pc),a2
	bsr 	.check
	lea	jommo,a0		* ps3m buffer size
	lea	rps3mb_req(pc),a2
	bsr 	.check
    lea     bENDER1,a0
    lea     rps3mamigus_req(pc),a2
    bsr     .check
	bra 	.xx
	
					* ahi sivun ohi
.4	;nop
	subq	#1,d0
	beq.b	.xx
.5

	lea	nAMISKA2,a0
	lea	rmpegaqua_req(pc),a2	* mpega quality
	bsr.b	.check
	lea	nAMISKA3,a0
	lea	rmpegadiv_req(pc),a2	* mpega freq div
	bsr.b	.check
	lea	nAMISKA4,a0
	lea	rmedmode_req(pc),a2	* med mode
	bsr.b	.check
	lea     prefsPlaySidMode,a0
	lea	    rsidmode_req(pc),a2	    * sid mode
	bsr.b	.check
	lea     prefsResidMode,a0
	lea	    rresidmode_req(pc),a2	   * resid mode
	bsr.b	.check
	lea     prefsResidFilter,a0
	lea	    rresidfilter_req(pc),a2	   * resid mode
	bsr.b	.check
	lea     prefsResidBoost,a0
	lea	    rresidboost_req(pc),a2	   * resid boost
	bsr.b	.check
	lea     prefsMidiMode,a0
	lea	    rmidimode_req(pc),a2	   * resid boost
	bsr.b	.check


.xx	popm	all
	bra	returnmsg2

.check	movem	4(a0),d0-d3
	subq	#1,d3
	add	d0,d2
	add	d1,d3
	cmp	d0,d6
	blo.b	.x
	cmp	d2,d6
	bhi.b	.x
	cmp	d1,d7
	blo.b	.x
	cmp	d3,d7
	bhi.b	.x
	pushm	a0/d6/d7
	jsr	(a2)
	popm	a0/d6/d7
.x	rts
	



* This updates the preds window to match state.
* p-functions handle each gadget.
pupdate:				* Ikkuna p‰ivitys
	pushm	all
	DPRINT	"prefs::pUpdate"

	move	prefsivu(a5),d0
	bne.b	.2

	bsr	pupdate2		* play
	bsr	ppri			* priority
	bsr	pdclick			* doubleclick
	bsr	pstartuponoff		* startup
	bsr	psup4			* timeoutslider
	bsr	phot			* hotkey
	bsr	perr			* cont on err
	bsr	pdiv			* divider dir
	bsr	purealarm		* alarm slider
	bsr	pautosort		* auto sort
	bsr	pfavorites		* favorites
	bsr	psavestate		* savestate
	bra	.x

.2	subq	#1,d0
	bne.b	.3

	;bsr	psup3			* scope mode
	bsr	pbox			* box size
	;bsr	psup0			* scope on/off
	bsr	pinfosize		* info size
	bsr	pupdate1		* show
	bsr	pselscreen		* screen
	;bsr	pscopebar		* scope bars
	bsr	pprefx			* prefix cut
	bsr	pfont			* fontti
	bsr	pscreen			* screen refresh rates
	bsr	ptooltips  	     	* tooltips
	bsr	paltbuttons  	        * alt buttons
	bsr	pQuadraScope
	bsr	pQuadraScopeBars
	bsr	pQuadraScopeF
	bsr	pQuadraScopeFBars
	bsr	pHippoScope
	bsr	pHippoScopeBars
	bsr	pPatternScope
	bsr	pPatternScopeXL
	bsr	pSpectrumScope
	bsr	pSpectrumScopeBars
	bsr	pListFont
	bra	.x

.3	subq	#1,d0
	bne 	.4

	bsr	pipm			* pt replayer
	bsr	pupf			* filter
	bsr	pupdate3		* pt tempo
	bsr	pvbt			* vblank timer
	bsr	pnasty			* nasty audio
	bsr	ppgfile			* pgfilename
	bsr	ppgmode			* pgmode
	bsr	ppgstat			* pgstatus
	bsr	pdbf			* volume fade
    bsr ppositionslider * posiion slider
	bra 	.x

.4	subq	#1,d0
	bne 	.5

	bsr	pux			* xpk id
	bsr	pdbuf			* doublebuffering
	bsr	pdup			* mod/prg/arc dirrit
	bsr	pxfd			* xfdmaster
	bra	.x

.5	subq	#1,d0
	bne.b	.6

	bsr	pupdate5		* ps3m priority
	bsr	pupdate6		* ps3m playmode
	bsr	pupdate7		* ps3m volboost
	bsr	psup1			* ps3m mixingrate
	bsr	pps3mb			* ps3m buffer
	bsr	pupdate7b		* stereo
	bsr	psettings		* settings file
    bsr pps3mamigus     * ps3m amigus mode
;	bsr	pcyber			* cyber calibration
;	bsr	pcybername		* cyber calibration file name
	bra	.x

.6	subq.b	#1,d0
	bne.b	.7
	
	bsr	pahi1			* ahi use
	bsr	pahi2			* ahi disable others
	bsr	pahi3			* ahi select mod
	bsr	pahi4			* ahi mixing rate
	bsr	pahi5			* ahi master volume
	bsr	pahi6			* ahi stereo level
	bra	.x


.7
	bsr	psup2			* tfmx mixingrate
	bsr	psup2b			* samplebufsize
	;bsr	psup2c			* sampleforcerate
	bsr	pupmedrate		* med mixing rate
	bsr	psamplecyber	* sample cyber
	bsr	pmpegaqua		* MPEGA quality
	bsr	pmpegadiv		* MPEGA freq division
	bsr	pmedmode		* med mode
    bsr psidmode        * SID mode
    bsr pxmaplay        * XMAPlay
    bsr presidmode      * reSID mode
    bsr presidfilter    * reSID filter
    bsr presidboost     * reSID boost
    bsr pmhienable      * MHI enable
    bsr pmhilib         * MHI library
    bsr pmedfastmemplay * MED FastMemPlay
    bsr pmidimode       * MIDI mode

.x	popm	all
	rts




***** Tarkistetaan mahtuuko avattava ikkuna ruudulle
* a0 = ikkuna
tark_mahtu
	move	wbleveys(a5),d0		* WB:n leveys
	move	(a0),d1			* Ikkunan x-paikka
	add	4(a0),d1		* Ikkunan oikea laita
	cmp	d0,d1
	bls.b	.ok1
	sub	4(a0),d0	* Jos ei mahdu ruudulle, laitetaan
	move	d0,(a0)		* mahdollisimman oikealle
.ok1	move	wbkorkeus(a5),d0	* WB:n korkeus
	move	2(a0),d1		* Ikkunan y-paikka
	add	6(a0),d1		* Ikkunan oikea laita
	cmp	d0,d1
	bls.b	.ok2
	sub	6(a0),d0	* Jos ei mahdu ruudulle, laitetaan
	move	d0,2(a0)	* mahdollisimman alas
.ok2	rts




**************************
* Tulostaa teksti‰ gadgetin sis‰lle
* a0 = teksti
* a1 = gadgetti

prunt2:
	pushm	all
	moveq	#1,d7		* ei korvaa
	bra.b	pru0

prunt:
	pushm	all
	moveq	#0,d7
pru0
    move    #GFLG_DISABLED,d0
    and.w   gg_Flags(a1),d0
    bne     .nok

	movem.l	a0/a1,-(Sp)			* putsaus
	movem	gg_LeftEdge(a1),d0/d1/d4/d5
	move.l	rastport2(a5),a0
	subq	#3,d4
	subq	#4,d5
	addq	#2,d0
	addq	#2,d1

	move.l	a0,a1
	move	d0,d2
	move	d1,d3
	moveq	#$0a,d6
	lore	GFX,ClipBlit
	popm	a0/a1

	* a1 = gadgetti
	* a0 = teksti
	move.l	a0,a2
.fe	tst.b	(a2)+
	bne.b	.fe
	sub.l	a0,a2
	move	a2,d0
	subq	#1,d0

	lsl	#2,d0
	move	gg_Width(a1),d2
	lsr	#1,d2
	sub	d0,d2

	movem	gg_LeftEdge(a1),d0/d1	* x,y
	add	d2,d0
	bsr.b	.pr

	tst	d7
	bne.b	.nok
	move.l	a1,a0
	bsr	printkorva2
.nok
	popm	all
	rts

.pr	pushm	all
	addq	#8,d1
	move.l	rastport2(a5),a4
	bra	doPrint


** Suoritetaan gadgettia vastaava toiminto
gadgetsup2
	movem.l	d0-a6,-(sp)
	move	gg_GadgetID(a2),d0

 if DEBUG
	ext.l	d0
	DPRINT	"Gadget id=%ld"
 endif

	add	d0,d0
	cmp	#20*2,d0
	bhs.b	.pag
	lea	.gadlist-2(pc,d0),a0
.x	add	(a0),a0
	jsr	(a0)
	movem.l	(sp)+,d0-a6
	bra	returnmsg2

.pag
;	sub	#10*2,d0
	lea	.s0-20*2(pc,d0),a0
	move	prefsivu(a5),d1
	beq.b	.x
	lea	.s1-20*2(pc,d0),a0
	subq	#1,d1
	beq.b	.x
	lea	.s2-20*2(pc,d0),a0
	subq	#1,d1
	beq.b	.x
	lea	.s3-20*2(pc,d0),a0
	subq	#1,d1
	beq.b	.x
	lea	.s4-20*2(pc,d0),a0
	subq	#1,d1
	beq.b	.x
	lea	.s5-20*2(pc,d0),a0
	subq	#1,d1
	beq.b	.x
	lea	.s6-20*2(pc,d0),a0
	bra.b	.x


.gadlist
*** P‰‰gadgetit
	dr	rpbutton14	* save
	dr	rpbutton6	* use
	dr	rpbutton7	* cancel
	dr	rval0		* sivu0
	dr	rval1		* sivu1
	dr	rval2		* sivu2
	dr	rval3		* sivu3
	dr	rval4		* sivu4
	dr	rval5		* sivu5
	dr	rval6		* sivu6

.s0
*** Sivu0
	dr	rpbutton2	* play		* pbutton1
	dr	rtimeoutmode	* timeoutmoodi
	dr	rtimeoutslider	* timeout
	dr	ralarm		* her‰tyskello
	dr	rstartup	* startup
	dr	rstartuponoff	* startup on/off
	dr	rfkeys		* fkeys
	dr	rpri		* prioriteetti
	dr	rhotkey		* hotkey
	dr	rdclick		* doubleclick
	dr	rerr		* continue on error
	dr	rdiv		* divider / dir
	dr	rautosort	* autosort
	dr	rfavorites	* favorites
	dr 	rsavestate	* save state

.s1
*** Sivu1
	dr	rpbutton1	* show		* pbutton2
	dr	rselscreen	* publicscreen
	dr	rbox		* boxsize
	dr	rfont		* font selector
	;dr	rquad		* scope on/off
	;dr	rquadm		* scopen moodi	* pout3
	;dr	rscopebar	* bar mode scopeille
	dr	rprefx		* prefix cut
	dr	rinfosize	* module info size
	dr  	rtooltips     * tooltips
	dr  	raltbuttons * alt buttons
	dr	rQuadraScope
	dr	rQuadraScopeBars
	dr	rQuadraScopeF
	dr	rQuadraScopeFBars
	dr	rHippoScope
	dr	rHippoScopeBars
	dr	rPatternScope
	dr	rPatternScopeXL
	dr	rSpectrumScope
	dr	rSpectrumScopeBars
	dr	rListFont

.s2
*** Sivu2
	dr	rpgfile		* pg file select
	dr	rpgmode		* pg mode
	dr	rpfilt		* filtteri
	dr	rdbf		* fadevolume
	dr	rnasty		* nasty audio
	dr	rvbtimer	* vblank timer
	dr	rptmix		* pt norm/fast/ps3m
	dr	rpbutton3	* pt tempo
    dr  rpositionslider * position slider
;	dr	rpslider2	* tfmx rate
;	dr	rpslider2b	* samplebufsiz
;	dr	rpslider2c	* sampleforcerate

.s3
*** Sivu3
	dr	rpbutton10	* moduledir
	dr	rselprgdir	* prgdir
	dr	rselarcdir	* archive dir
	dr	rarch2		* archiver: lha
	dr	rarch4		* archiver: lzx
	dr	rarch3		* archiver: zip
	dr	rdbuf		* doublebuffering
	dr	rxp		* xpk id on/off
	dr	rxfd		* xfdmaster on/off
	dr	rpattern	* file pattern

.s4
*** Sivu4
	dr	rsmode2		* ps3m playmode
	dr	rsmode1		* ps3m priority
	dr	rps3mb		* ps3m mixbuffersize
	dr	rpslider1	* ps3m mixingrate
	dr	rsmode3		* ps3m volumeboost
	dr	rsmode4		* ps3m stereofactor
	dr	rsettings	* settings file on/off
    dr  rps3mamigus * ps3m amigus mode
;	dr	rcyber		* cyber calibration
;	dr	rcybername	* cyber calibration file name

*** Sivu5
.s5	dr	rahi3		* ahi select mode
	dr	rahi1		* ahi use
	dr	rahi2		* ahi disable others
	dr	rahi4		* ahi mixing rate
	dr	rahi5		* ahi master volume
	dr	rahi6		* ahi stereo level

*** Sivu6
.s6
	dr	rpslider2	* tfmx rate
	dr	rpslider2b	* samplebufsiz
	;dr	rpslider2c	* sampleforcerate
	dr	rsamplecyber	* sample cybercalibration
	dr	rmpegaqua	* mpega quality
	dr	rmpegadiv	* mpega freq division
	dr	rmedmode	* med mode
	dr	rmedrate	* med mixing rate
    dr  rsidmode    * sid mode
    dr  rxmaplay    * xmaplay
    dr  rresidmode  * resid mode
    dr  rresidfilter * resid filter
    dr  rresidboost * resid boost
    dr  rmhienable  * mhi enable
    dr  rmhilib     * mhi lib
    dr  rmedfastmemplay * MED fast mem play
    dr  rmidimode    * MIDI mode

rval0	moveq	#0,d0
	bra	prefsgads2
rval1	moveq	#1,d0
	bra	prefsgads2
rval2	moveq	#2,d0
	bra	prefsgads2
rval3	moveq	#3,d0
	bra	prefsgads2
rval4	moveq	#4,d0
	bra	prefsgads2
rval5	moveq	#5,d0
	bra	prefsgads2
rval6	moveq	#6,d0
	bra	prefsgads2


*** Scope

rQuadraScope:
	DPRINT	"rQuadrascope"
	not.b	prefsdata+prefs_quadraScope(a5)
	bne.b	.start
	bsr	stopQuadraScopeTask
	bra.b 	pQuadraScope
.start	
	bsr	startQuadraScopeTask
	
pQuadraScope:
	move.b	prefsdata+prefs_quadraScope(a5),d0
	lea	prefsQuadraScope,a0
	bra	tickaa

rQuadraScopeBars:
	DPRINT	"rQuadrascopeBars"
	not.b	prefsdata+prefs_quadraScopeBars(a5)
	bsr	restartQuadraScopeTask

pQuadraScopeBars
	move.b	prefsdata+prefs_quadraScopeBars(a5),d0
	lea	prefsQuadraScopeBars,a0
	bra	tickaa

rQuadraScopeF
	DPRINT	"rQuadraScopeF"
	not.b	prefsdata+prefs_quadraScopeF(a5)
	bne.b	.start
	bsr	stopQuadraScopeFTask
	bra.b	pQuadraScopeF
.start	
	bsr	startQuadraScopeFTask

pQuadraScopeF
	move.b	prefsdata+prefs_quadraScopeF(a5),d0
	lea	prefsQuadraScopeF,a0
	bra	tickaa

rQuadraScopeFBars
	DPRINT	"rQuadraScopeFBars"
	not.b	prefsdata+prefs_quadraScopeFBars(a5)
	bsr	restartQuadraScopeFTask
	
pQuadraScopeFBars
	move.b	prefsdata+prefs_quadraScopeFBars(a5),d0
	lea	prefsQuadraScopeFBars,a0
	bra	tickaa

rHippoScope
	DPRINT	"rHippoScope"
	not.b	prefsdata+prefs_hippoScope(a5)
	bne.b	.start
	bsr	stopHippoScopeTask
	bra.b pHippoScope
.start	
	bsr	startHippoScopeTask
	
pHippoScope
	move.b	prefsdata+prefs_hippoScope(a5),d0
	lea	prefsHippoScope,a0
	bra	tickaa


rHippoScopeBars
	DPRINT	"rHippoScopeBars"
	not.b	prefsdata+prefs_hippoScopeBars(a5)
	bsr	restartHippoScopeTask

pHippoScopeBars
	move.b	prefsdata+prefs_hippoScopeBars(a5),d0
	lea	prefsHippoScopeBars,a0
	bra	tickaa

rPatternScope
	DPRINT	"rPatternScope"
	not.b	prefsdata+prefs_patternScope(a5)
	bne.b	.start
	bsr	stopPatternScopeTask
	bra.b 	pPatternScope
.start	
	bsr	startPatternScopeTask

pPatternScope
	move.b	prefsdata+prefs_patternScope(a5),d0
	lea	prefsPatternScope,a0
	bra	tickaa

rPatternScopeXL
	DPRINT	"rPatternScopeXL"
	not.b	prefsdata+prefs_patternScopeXL(a5)
	bsr	restartPatternScopeTask

pPatternScopeXL
	move.b	prefsdata+prefs_patternScopeXL(a5),d0
	lea	prefsPatternScopeXL,a0
	bra	tickaa

rSpectrumScope
	DPRINT	"rSpectrumScope"
	not.b	prefsdata+prefs_spectrumScope(a5)
	bne.b	.start
	bsr	stopSpectrumScopeTask
	bra.b 	pSpectrumScope
.start	
	bsr	startSpectrumScopeTask
	
pSpectrumScope
	move.b	prefsdata+prefs_spectrumScope(a5),d0
	lea	prefsSpectrumScope,a0
	bra	tickaa

rSpectrumScopeBars
	DPRINT	"rSpectrumScopeBars"
	not.b	prefsdata+prefs_spectrumScopeBars(a5)
	bsr	restartSpectrumScopeTask

pSpectrumScopeBars
	move.b	prefsdata+prefs_spectrumScopeBars(a5),d0
	lea	prefsSpectrumScopeBars,a0
	bra	tickaa
	

** Mixingrate S3M
rpslider1
psup1
	lea	pslider1,a2
	move	#580-050,d0		* max
	bsr	nappilasku
	add	#50,d0
	mulu	#100,d0
	move.l	d0,mixingrate_new(a5)

	divu	#1000,d0
	swap	d0
	moveq	#0,d1
	move	d0,d1
	clr	d0
	swap	d0

	lea	info2_t(pC),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0
;	movem	pslider1+4,d0/d1
	movem	4(a2),d0/d1
	sub	#65,d0
	addq	#8,d1
	bra	print3b

info2_t dc.b	"%2.2ld.%1.1ldkHz",0
 even

***** PS3M buffer

rps3mb_req
	lea	.b(pc),a0
	bsr	listselector
	bmi.b	.x
	move.b	d0,ps3mb_new(a5)
	bra.b	pps3mb

.x	rts

.b	dc.b	4,4
	dc.b	"4kB",0
	dc.b	"8kB",0
	dc.b	"16kB",0
	dc.b	"32kB",0


rps3mb
	addq.b	#1,ps3mb_new(a5)
	cmp.b	#3,ps3mb_new(a5)
	bls.b	.ok
	clr.b	ps3mb_new(a5)
.ok

pps3mb
	move.b	ps3mb_new(a5),d1
	moveq	#4,d0
	lsl	d1,d0
	lea	.f(pC),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0
	lea	jommo,a1
	bra	prunt

.f	dc.b	"%ldkB",0
 even


** Mixingrate TFMX
rpslider2
psup2
	lea	pslider2,a2
	moveq	#22-1,d0		* max
	bsr	nappilasku
	addq	#1,d0
	move	d0,tfmxmixingrate_new(a5)
	
	lea	.info3_t(pC),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0
;	movem	pslider2+4,d0/d1
	movem	4(a2),d0/d1
	sub	#48,d0
	addq	#8,d1
	bra	print3b

.info3_t dc.b	"%2.2ldkHz",0
 even



** Samplebuffersize
rpslider2b
psup2b
	lea	sIPULI,a2
	moveq	#5,d0		* max
	bsr	nappilasku
	move.b	d0,samplebufsiz_new(a5)

	move	d0,d1
	moveq	#1,d0
	addq	#2,d1
	lsl	d1,d0

	lea	.t(pC),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0
;	movem	sIPULI+4,d0/d1
	movem	4(a2),d0/d1
	sub	#44,d0
	addq	#8,d1

	bra	print3b

.t 	dc.b	"%3.3ldkB",0
 even

********** force sample rate

 REM
rpslider2c
psup2c
	lea	sIPULI2,a2
	move	#600-9,d0		* max
	bsr	nappilasku
	move	d0,sampleforcerate_new(a5)
	bne.b	.m

	lea	.of(pc),a0
	bra.b	.p
.m
	add	#9,d0
	divu	#10,d0
	move.l	d0,d1
	clr	d1
	swap	d1
	ext.l	d0
	
	lea	.t(pC),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0
.p	
;	movem	sIPULI2+4,d0/d1
	movem	4(a2),d0/d1
	add	#149,d0
	subq	#6,d1

	bra	print3b

.of	dc.b	".....off",0
.t	dc.b	" %2.2ld.%1.1ldkHz",0
	even 
 EREM


** Archivers: tempdir, lha jne..

rpattern
	move.l	DuU0+gg_SpecialInfo,a0
	lea	pattern_new(a5),a1
	bra.b	acopy

rarch2	move.l	ack2+gg_SpecialInfo,a0
	lea	arclha_new(a5),a1
	bra.b	acopy
rarch3	move.l	ack3+gg_SpecialInfo,a0
	lea	arczip_new(a5),a1
	bra.b	acopy
rarch4	move.l	ack4+gg_SpecialInfo,a0
	lea	arclzx_new(a5),a1

acopy	move.l	si_Buffer(a0),a0	* Teksipuskuri
.c	move.b	(a0)+,(a1)+
	bne.b	.c

;	jsr	flash

	rts

** Save
rpbutton14
	move.b	#2,prefs_exit(a5)
	rts
** Exit
rpbutton6
	move.b	#1,prefs_exit(a5)
	rts
** Cancel
rpbutton7
	st	prefs_exit(a5)
	rts




** Show; Mit‰ n‰ytet‰‰n otsikkopalkissa

rpbutton1_req
	lea	ls1(pc),a0
	bsr	listselector
	bmi.b	.x
	move	d0,lootamoodi_new(a5)
	bra.b	pupdate1

.x	rts

rpbutton1
	addq	#1,lootamoodi_new(a5)	* vaihetaan moodia
	cmp	#TITLEBAR_MODE_MAX,lootamoodi_new(a5)
	ble.b	.ook
	clr	lootamoodi_new(a5)
.ook
	
pupdate1
	lea	ls2(pc),a0
	move	lootamoodi_new(a5),d0
	beq.b	.n
	lea	ls3(pc),a0
	subq	#1,d0
	beq.b	.n
	lea	ls4(pc),a0
	subq	#1,d0
	beq.b	.n
	lea	ls44(pc),a0
.n	

	lea	pbutton2,a1
	bra	prunt

ls1	dc.b	22,3	* leveys/korkeus merkkein‰
ls2 	dc.b	"Time, pos/len, song",0
ls3 	dc.b	"Clock, free memory",0
ls4	dc.b	"Module name",0
ls44 	dc.b	"Time/duration, pos/len",0 ; no longer available
 even




** Play; Soittotapa

rpbutton2_req
	lea	ls50(pc),a0
	bsr	listselector
	bmi.b	.x
	addq.b	#1,d0
	move.b	d0,playmode_new(a5)
	bra.b	pupdate2

.x	rts

rpbutton2
	addq.b	#1,playmode_new(a5)
	cmp.b	#pm_max,playmode_new(a5)
	ble.b	pupdate2
	move.b	#1,playmode_new(a5)
	
pupdate2
	move.b	playmode_new(a5),d0
	lea	ls5(pc),a0
	subq.b	#1,d0
	beq.b	.ee
	lea	ls6(pc),a0
	subq.b	#1,d0
	beq.b	.ee
	lea	ls7(pc),a0
	subq.b	#1,d0
	beq.b	.ee
	lea	ls8(pc),a0
	subq.b	#1,d0
	beq.b	.ee
	lea	ls9(pc),a0
.ee	
	lea	pbutton1,a1
	bra	prunt 

togglePlayModePopupOptions:
ls50	dc.b	23,5
ls5 dc.b	"List repeatedly",0
ls6 dc.b	"List once",0
ls7 dc.b	"Module repeatedly",0
ls8 dc.b	"Module once",0
ls9 dc.b	"Modules in random order",0
 even


** Tempomoodi
rpbutton3
	not.b	tempoflag_new(a5)

pupdate3
	tst.b	tempoflag_new(a5)
	seq	d0
	lea	pbutton3,a0
	bra	tickaa

** Position slider
rpositionslider
	not.b	showPositionSlider_new(a5)

ppositionslider
    move.b  showPositionSlider_new(a5),d0
	lea	gadgetEnablePositionSlider,a0
	bra	tickaa



** S3M moodit 1,2,3

rsmode1_req
	lea	ls51(pc),a0
	bsr	listselector
	bmi.b	.x
	move.b	d0,s3mmode1_new(a5)
	bra.b	pupdate5

.x	rts

rsmode1
	addq.b	#1,s3mmode1_new(a5)
	cmp.b	#5,s3mmode1_new(a5)
	bls.b	pupdate5
	clr.b	s3mmode1_new(a5)

pupdate5
	lea	ls52(pc),a0
	move.b	s3mmode1_new(a5),d0
	beq.b	.e
	lea	ls53(pc),a0
	subq.b	#1,d0
	beq.b	.e
	lea	ls531(pc),a0
	subq.b	#1,d0
	beq.b	.e
	lea	ls532(pc),a0
	subq.b	#1,d0
	beq.b	.e
	lea	ls533(pc),a0
	subq.b	#1,d0
	beq.b	.e
	lea	ls54(pc),a0
.e	
	lea	smode2,a1
	bra	prunt

* -10, -3, 0, +3, +10

ls51	dc.b	7,6
ls52	dc.b	"-10",0
ls53	dc.b	"-1",0
ls531	dc.b	"0",0
ls532	dc.b	"+1",0
ls533	dc.b	"+9",0
ls54	dc.b	"Killer",0		* 5
 even


rsmode2_req
	lea	ls10(pc),a0
	bsr	listselector
	bmi.b	.x
	addq.b	#1,d0
	move.b	d0,s3mmode2_new(a5)
	bra.b	pupdate6

.x	rts


rsmode2
	addq.b	#1,s3mmode2_new(a5)
	cmp.b	#5,s3mmode2_new(a5)
	ble.b	pupdate6
	move.b	#1,s3mmode2_new(a5)

pupdate6
	lea	ls11(pc),a0
	move.b	s3mmode2_new(a5),d0
	subq.b	#1,d0
	beq.b	.e
	lea	ls12(pc),a0
	subq.b	#1,d0
	beq.b	.e
	lea	ls13(pc),a0
	subq.b	#1,d0
	beq.b	.e
	lea	ls14(pc),a0
	subq.b	#1,d0
	beq.b	.e
	lea	ls15(pc),a0

.e	
	lea	smode1,a1
	bra	prunt


ls10	dc.b	13,5
ls11	dc.b	"Surround",0
ls12	dc.b	"Stereo",0
ls13	dc.b	"Mono",0
ls14	dc.b	"Real surround",0
ls15	dc.b	"14-bit stereo",0
 even

** Volboost

rsmode3
pupdate7
	lea	juusto,a2
	moveq	#16,d0			* max
	bsr	nappilasku
	move.b	d0,s3mmode3_new(a5)
	bsr	updateps3m

	moveq	#0,d0
	move.b	s3mmode3_new(a5),d0
	lea	.i(pC),a0
	bsr	desmsg2

	lea	desbuf2(a5),a0
;	movem	juusto+4,d0/d1
	movem	4(a2),d0/d1
	sub	#16+8,d0
	addq	#8,d1
	bra	print3b
.i	dc.b	"%2.2ld",0
 even

*** Stereo

rsmode4
pupdate7b
	lea	juust0,a2
	moveq	#64,d0			* max
	bsr	nappilasku
	move.b	d0,stereofactor_new(a5)

	bsr.b	updateps3m2

	mulu	#100,d0
	lsr.l	#6,d0		* x/64
	lea	.i(pC),a0
	bsr	desmsg2


;	movem	juust0+4,d0/d1
	movem	4(a2),d0/d1
	sub	#41+1,d0
	addq	#8,d1
	movem	d0/d1,-(sp)

	lea	.ii(pc),a0
	bsr	print3b

	lea	desbuf2(a5),a0
	movem	(sp)+,d0/d1


	bra	print3b
.i	dc.b	"%3.3ld%%",0
.ii	dc.b	"  ",0
 even

updateps3m2
	tst.b	ahi_use_nyt(a5)
	bne.b	.nd

	lea	var_b,a5
	tst.l	playingmodule(a5)
	bmi.b	.nd
	tst.b	playing(a5)
	beq.b	.nd
	cmp	#pt_multi,playertype(a5)
	bne.b	.nd
	cmp.b	#1,s3mmode2(a5)		* onko surround?
	bne.b	.nd
	moveq	#64,d1
	sub.b	stereofactor_new(a5),d1
	move	d1,$dff0c8
	move	d1,$dff0d8
.nd	rts

updateps3m
	tst.b	ahi_use_nyt(a5)
	bne.b	.nd

	tst.l	playingmodule(a5)
	bmi.b	.nd
	tst.b	playing(a5)
	beq.b	.nd
	cmp	#pt_multi,playertype(a5)
	bne.b	.nd
	pushm	all
	move.b	s3mmode3_new(a5),d0
	jsr	ps3m_boost
	popm	all
.nd
	rts


**** ps3m settings
rsettings
	not.b	ps3msettings_new(a5)
psettings
;	tst.b	ps3msettings_new(a5)
;	sne	d0
	move.b	ps3msettings_new(a5),d0
	lea	Fruit,a0
	bra	tickaa


rps3mamigus_req
	lea	pps3mamigus\.ls0(pc),a0
	bsr	listselector
	bmi.b	.x
	move.b	d0,ps3mamigus_new(a5)
	bra.b	pps3mamigus_update
.x	rts

rps3mamigus
	addq.b	#1,ps3mamigus_new(a5)
	cmp.b	#2,ps3mamigus_new(a5)
	ble.b	.3
	clr.b   ps3mamigus_new(a5)
.3

pps3mamigus_update
    bsr     pps3mamigus
    
    move.b	ps3mamigus_new(a5),d0
    beq     ps3mamigusEnableOthers
    bra     ps3mamigusDisableOthers

pps3mamigus
	lea     .ls1(pc),a0
    move.b	ps3mamigus_new(a5),d0
    beq     .g
	lea     .ls2(pc),a0
    subq.b  #1,d0
    beq     .g
	lea     .ls3(pc),a0
.g
    lea     bENDER1,a1
    bra     prunt
    
.ls0	dc.b	18,3
.ls1	dc.b	"No",0
.ls2	dc.b	"Yes, normal",0
.ls3	dc.b	"Yes, interpolate",0
 even

ps3mamigusDisableOthers:
    lea     smode1,a4
    basereg smode1,a4
    move.l  a4,a3
    bsr     .disable
    lea     smode2(a4),a3
    bsr     .disable
    lea     jommo(a4),a3
    bsr     .disable
    lea     pslider1(a4),a3
    bsr     .disable
    lea     juusto(a4),a3
    bsr     .disable
    lea     juust0(a4),a3
    bsr     .disable
    lea     Fruit(a4),a3
    bsr     .disable
    endb    a4
    rts

.disable
    move.l  a3,a0
	move.l	windowbase2(a5),a1
    sub.l   a2,a2
    lore    Intui,OffGadget
    rts

ps3mamigusEnableOthers:
    lea     smode1,a4
    move    #GFLG_DISABLED,d0
    and     gg_Flags(a4),d0
    beq     .x
    basereg smode1,a4
    move.l  a4,a3
    bsr     .enable
    lea     smode2(a4),a3
    bsr     .enable
    lea     jommo(a4),a3
    bsr     .enable
    lea     pslider1(a4),a3
    bsr     .enable
    lea     juusto(a4),a3
    bsr     .enable
    lea     juust0(a4),a3
    bsr     .enable
    lea     Fruit(a4),a3
    bsr     .enable
    bsr     refreshPrefsGads
    bsr     pupdate
    endb    a4
.x
    rts

.enable
    move.l  a3,a0
	move.l	windowbase2(a5),a1
    sub.l   a2,a2
    lore    Intui,OnGadget
	cmp	#GTYP_PROPGADGET,gg_GadgetType(a3)
    beq     .xx
	movem	4(a3),d0/d1/d4/d5
	move.l	rastport2(a5),a1
    move.l  a1,a0
	move	d0,d2
	move	d1,d3
	moveq	#$0a,d6
	move.l	_GFXBase(a5),a6
	jmp	    _LVOClipBlit(a6)
.xx rts

 REM
***** cyber calibration nappu
rcyber
	not.b	cybercalibration_new(a5)
pcyber
;	tst.b	cybercalibration_new(a5)
;	sne	d0
	move.b	cybercalibration_new(a5),d0
	lea	bENDER1,a0
	bra	tickaa



***** cyber calibration file name
rcybername
	lea	calibrationfile_new(a5),a0
	move.l	a0,a1			* mihin hakemistoon menn‰‰n
	lea	.t(pc),a2
	bsr	pgetfile
	st	newcalibrationfile(a5)
	bra.b	pcybername

.t	dc.b	"Select calibration file",0
 even

pcybername
	lea	calibrationfile_new(a5),a0
	move.l	a0,a2
.f	tst.b	(a2)+
	bne.b	.f
	move.l	sp,a1
	lea	-30(sp),sp
	moveq	#20-1,d0
.c	move.b	-(a2),-(a1)
	cmp.l	a0,a2
	beq.b	.cx
	dbf	d0,.c
.cx	
	move.l	a1,a0
	lea	bENDER2,a1
	bsr	prunt2	
	lea	30(sp),sp
	rts
 EREM





** Filtteri
rpfilt_req
	lea	ls16(pc),a0
	bsr	listselector
	bmi.b	.x
	move.b	d0,filterstatus(a5)
	bra.b	pupf

.x	rts

rpfilt
	addq.b	#1,filterstatus(a5)
	cmp.b	#2,filterstatus(a5)
	ble.b	pupf
	clr.b	filterstatus(a5)

pupf
	lea	ls17(pc),a0
	move.b	filterstatus(a5),d0
	bne.b	.prp

	bset	#1,$bfe001
	tst.b	modulefilterstate(a5)
	bne.b	.pr
	bclr	#1,$bfe001
	bra.b	.pr
.prp
	lea	ls18(pc),a0
	subq.b	#1,d0
	beq.b	.pr
	lea	ls19(pc),a0
.pr	
	lea	pout1,a1
	bra	prunt

ls16	dc.b	6,3
ls17	dc.b	"Module",0
ls18	dc.b	"Off",0
ls19	dc.b	"On",0
 even	

rptmix_req
	lea	ls20(pc),a0
	bsr	listselector
	bmi.b	.x
	move.b	d0,ptmix_new(a5)
	bra.b	pipm

.x	rts

rptmix
	addq.b	#1,ptmix_new(a5)
	cmp.b	#2,ptmix_new(a5)
	bls.b	pipm
	clr.b	ptmix_new(a5)
pipm
	lea	ls21(pc),a0
	move.b	ptmix_new(a5),d0
	beq.b	.n
	lea	ls22(pc),a0
	subq.b	#1,d0
	beq.b	.n
	lea	ls23(pc),a0
.n	
	lea	laren1,a1
	bra	prunt

ls20	dc.b	7,3
ls21	dc.b	"Normal",0
ls22	dc.b	"Fastram",0
ls23	dc.b	"PS3M",0
 even 

** XPKID
rxp	not.b	xpkid_new(a5)

pux	
	tst.b	xpkid_new(a5)
	seq	d0
	lea	makkara,a0
	bra	tickaa

	
**** XFDmaster
rxfd	not.b	xfd_new(a5)
pxfd	;tst.b	xfd_new(a5)
	;sne	d0
	move.b	xfd_new(a5),d0
	lea	nappU2,a0
	bra	tickaa


*** volumefade
rdbf	not.b	fade_new(a5)

pdbf	;tst.b	fade_new(a5)
	;sne	d0
	move.b	fade_new(a5),d0
	lea	kinkku,a0
	bra	tickaa


**** Prioriteetti
rpri_req
	lea	ls200(pc),a0
	bsr	listselector
	bmi.b	.x
	subq.b	#1,d0
	move.b	d0,pri_new(a5)
	bra.b	ppri

.x	rts

rpri
	move.b	pri_new(a5),d0
	addq.b	#2,d0
	cmp.b	#2,d0
	bls.b	.r
	moveq	#0,d0
.r	subq.b	#1,d0
	move.b	d0,pri_new(a5)

ppri
	lea	ls201(pc),a0
	move.b	pri_new(a5),d0
	bmi.b	.0	
	lea	ls202(pc),a0
	beq.b	.0
	lea	ls203(pc),a0

.0	lea	tomaatti,a1
	bra	prunt

ls200	dc.b	2,3
ls201	dc.b	"-1",0
ls202	dc.b	"0",0
ls203	dc.b	"+1",0
 even

** Valitaan hakemisto moddir
rpbutton10
	bsr	dir_req
	bne.b	.ee
	rts
.ee	
	move.l	d7,a0
	lea	moduledir_new(a5),a1
	bsr	parsereqdir2		* Tehd‰‰n hakemistopolku..
	st	newdirectory(a5)

psele	move.l	d7,a1
	lob	rtFreeRequest

* 19 max

pdup
	lea	moduledir_new(a5),a0
	basereg	DuU1,a1
	lea	DuU1,a1
	bsr.b	.o
	lea	prgdir_new(a5),a0
	lea	DuU2(a1),a1
	bsr.b	.o
	lea	arcdir_new(a5),a0		* DISABLED!
	lea	DuU3(a1),a1
	endb	a1
	;bra.b	.o

.o	lea	-32(sp),sp
	lea	30(sp),a2
	clr.b	(a2)

	move.l	a0,a3
.u	tst.b	(a0)+
	bne.b	.u

	cmp.b	#'/',-2(a0)
	bne.b	.cy
	subq	#2,a0
.cy


	moveq	#19-1,d0
.c	cmp.l	a3,a0
	beq.b	.cc
	move.b	-(a0),-(a2)
	dbf	d0,.c
.cc	
	move.l	a2,a0
	bsr	prunt2
	lea	32(sp),sp
	rts


** Valitaan hakemisto prgdir
rselprgdir
	bsr.b	dir_req
	bne.b	.ee
	rts
.ee	
	move.l	d7,a0
	lea	prgdir_new(a5),a1
	bsr	parsereqdir2		* Tehd‰‰n hakemistopolku..
	st	newdirectory2(a5)
	bra.b	psele

** Valitaan hakemisto prgdir
rselarcdir
	bsr.b	dir_req
	bne.b	.ee
	rts
.ee	
	move.l	d7,a0
	lea	arcdir_new(a5),a1
	bsr	parsereqdir2		* Tehd‰‰n hakemistopolku..
	bra	psele



** Hakemisto requesteri
dir_req:
	bsr	get_rt
	moveq	#RT_FILEREQ,D0
	sub.l	a0,a0
	lob	rtAllocRequestA
	move.l	d0,d7
	beq.b	.eek
	bsr	pon2		* waitpointer

	lea	.dirtags(pc),a0
	move.l	d7,a1
	lea	desbuf2(a5),a2		* Kunhan jonnekkin laitetaan..
	lea	.dirreqtitle(pc),a3
	lob	rtFileRequestA		* ReqToolsin tiedostovalikko
	bsr	poff2
	tst.l	d0
.eek	rts

.dirreqtitle dc.b "Select directory",0
 even


.dirtags
	dc.l	RTFI_Flags,FREQF_NOFILES
;	dc.l	RT_TextAttr,text_attr
otag4	dc.l	RT_PubScrName,pubScreenNameTags+var_b
	dc.l	TAG_END





*** Box size

rbox
pbox
	lea	meloni,a2
	moveq	#51-3,d0		* max
	bsr	nappilasku
	beq.b	.fe
	addq	#2,d0

.fe	move	d0,boxsize_new(a5)

	lea	.i(pC),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0

;	movem	meloni+4,d0/d1
	movem	4(a2),d0/d1
	sub	#26,d0
	addq	#8,d1

	bra	print3b

.i dc.b	"%-2.2ld",0
 even

rinfosize
pinfosize
	lea	eskimO,a2
	moveq	#50-3,d0		* max
	bsr	nappilasku
	addq.l	#3,d0
	move	d0,infosize_new(a5)

	lea	.i(pC),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0

;	movem	eskimO+4,d0/d1
	movem	4(a2),d0/d1
	sub	#26,d0
	addq	#8,d1

	bra	print3b

.i dc.b	"%-2.2ld",0
 even


********* Doubleclick
rdclick
	not.b	dclick_new(a5)
pdclick
	;tst.b	dclick_new(a5)
	;sne	d0
	move.b	dclick_new(a5),d0
	lea	eins2,a0
	bra	tickaa

********* Favorite
rfavorites
	not.b	favorites_new(a5)
pfavorites
	move.b	favorites_new(a5),d0
	lea	prefsFavorites,a0
	bra	tickaa

********* Tooltips
rtooltips
	not.b	tooltips_new(a5)
ptooltips
	move.b	tooltips_new(a5),d0
	lea	prefsTooltips,a0
	bra	tickaa

********* Save state
rsavestate
	not.b	savestate_new(a5)
psavestate
	move.b	savestate_new(a5),d0
	lea	prefsSaveState,a0
	bra	tickaa

********* Alt buttons
raltbuttons
	not.b	altbuttons_new(a5)

paltbuttons
	move.b	altbuttons_new(a5),d0
	lea	prefsAltButtons,a0
	bra	tickaa


********* Autosort
rautosort
	not.b	autosort_new(a5)
pautosort
	;tst.b	autosort_new(a5)
	;sne	d0
	move.b	autosort_new(a5),d0
	lea	bUu22,a0
	bra	tickaa



********* Startup on/off
rstartuponoff
	not.b	startuponoff_new(a5)
pstartuponoff
	;tst.b	startuponoff_new(a5)
	;sne	d0
	move.b	startuponoff_new(a5),d0
	lea	salaatti3,a0
	bra	tickaa


********* Startup
* a0 = paikka nimelle (jossa vanha nimi)

rstartup
	lea	startup_new(a5),a0
	move.l	a0,a1			* mihin hakemistoon menn‰‰n
	sub.l	a2,a2

pgetfile
	move.l	a2,d4		 * title
	bsr	get_rt
	move.l	a0,d6
	move.l	a1,d5
	moveq	#RT_FILEREQ,D0
	sub.l	a0,a0
	lob	rtAllocRequestA
	move.l	d0,req_file3(a5)
	bne.b	.joo
	rts
.joo
	move.l	d5,a0
.f0	tst.b	(a0)+
	bne.b	.f0
	move.l	d5,a1
	bsr	nimenalku

	move.l	a0,a2
	lea	desbuf2(a5),a3		* nimi
.c	move.b	(a0)+,(a3)+
	bne.b	.c

	move.b	(a2),d7
	clr.b	(a2)

	move.l	req_file3(a5),a1		* Vaihdetaan hakemistoa...
	lea	newdir_tags(pc),a0
	move.l	d5,4(a0)
	lore	Req,rtChangeReqAttrA

	move.l	req_file3(a5),a1		* Match pattern
	lea	matchp_tags(pc),a0
	lob	rtChangeReqAttrA
	move.b	d7,(a2)


	lea	.tags(pc),a0
	move.l	req_file3(a5),a1
	lea	desbuf2(a5),a2
	lea	.title(pc),a3
	tst.l	d4
	beq.b	.noti
	move.l	d4,a3
.noti

	bsr	pon2		* waitpointer

	lore	Req,rtFileRequestA	* ReqToolsin tiedostovalikko
	bsr	poff2
	tst.l	d0
	beq.b	.eek


	move.l	req_file3(a5),a0
	move.l	d6,a1
	bsr	parsereqdir2

	addq	#1,a1
	lea	desbuf2(a5),a0
.e	move.b	(a0)+,(a1)+
	bne.b	.e

.eek	
	move.l	req_file3(a5),d0
	beq.b	.eek2
	move.l	d0,a1
	lore	Req,rtFreeRequest
.eek2
	rts


.title dc.b "Select module or program",0
 even

.tags
	dc.l	RTFI_Flags,FREQF_PATGAD
otag14	dc.l	RT_PubScrName,pubScreenNameTags+var_b,TAG_END

********* Alarm
ralarm
	rts

purealarm
	lea	kelloke2,a2
	move.l	gg_SpecialInfo(a2),a0
	move	pi_HorizPot(a0),d0
	move	#1440,d0		* max
	bsr	nappilasku

	divu	#60,d0
	moveq	#0,d1
	move.b	d0,d1
	lsl	#8,d1
	swap	d0
	move.b	d0,d1

	move	d1,alarm_new(a5)
	ext.l	d1
	beq.b	.nl

	moveq	#0,d0
	move	d1,d0
	lsr	#8,d0
	and	#$ff,d1

	lea	.t(pC),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0
.r
;	movem	kelloke2+4,d0/d1
	movem	4(a2),d0/d1
	sub	#68,d0
	addq	#8,d1


	bra.b	print3b

.nl
	lea	.nil(pc),a0
	bra.b	.r

.nil	dc.b	".....Off",0
.t	dc.b	"...%02ld:%02ld",0
 even


print3b:
	pushm	all			* Sit‰varten ett‰ windowtop/left
	move.l	rastport2(a5),a4	* arvoja ei lis‰tt‰isi kun
	bra	doPrint			* teksti on jo suhteessa gadgettiin


******* FKeys
rfkeys
	lea	-60(sp),sp
	move.l	sp,a4

	lea	fkeys_new(a5),a0
	moveq	#10-1,d0
.lop	move.l	a0,(a4)+
	lea	120(a0),a0
	dbf	d0,.lop
	clr.l	(a4)

	lea	.form(pc),a1
	lea	(sp),a4
	lea	.gad(pc),a2
	lea	.tags(pc),a0
	sub.l	a3,a3
	bsr	get_rt
	bsr	pon2
	lob	rtEZRequestA
	bsr	poff2
	tst.l	d0
	bne.b	.e
	moveq	#11,d0
.e	subq	#1,d0
	lea	60(sp),sp
	tst.b	d0
	beq.b	.x
	subq	#1,d0		* 0-9

	lea	fkeys_new(a5),a0
	mulu	#120,d0
	add.l	d0,a0
	move.l	a0,a1		* jos ei ole ennest‰‰n tiedostoa,
	tst.b	(a1)		* otetaan hakemistoksi oletusmusahakemisto
	bne.b	.jep
	lea	moduledir(a5),a1	
.jep
	sub.l	a2,a2
	bsr	pgetfile
	bra.b	rfkeys

.x	rts


.gad	dc.b	"_OK|F_1|F_2|F_3|F_4|F_5|F_6|F_7|F_8|F_9|F1_0",0
.title	dc.b	"Function keys",0

.form
	dc.b	"F1:  %-60.60s",10
	dc.b	"F2:  %-60.60s",10
	dc.b	"F3:  %-60.60s",10
	dc.b	"F4:  %-60.60s",10
	dc.b	"F5:  %-60.60s",10
	dc.b	"F6:  %-60.60s",10
	dc.b	"F7:  %-60.60s",10
	dc.b	"F8:  %-60.60s",10
	dc.b	"F9:  %-60.60s",10
	dc.b	"F10: %-60.60s",0

 even

.tags	dc.l	RTEZ_ReqTitle,.title
	dc.l	RT_Underscore,"_"
	dc.l	RT_TextAttr,text_attr
otag5	dc.l	RT_PubScrName,pubScreenNameTags+var_b
	dc.l	TAG_END

*********** Timeout

rtimeoutslider
psup4
	lea	kelloke,a2
	move	#1800,d0		* max
	bsr	nappilasku
	move	d0,timeout_new(a5)
	beq.b	.nl

	divu	#60,d0
	move.l	d0,d1
	swap	d1
	ext.l	d1
	ext.l	d0

	lea	.t(pC),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0
.r	
;	movem	kelloke+4,d0/d1
	movem	4(a2),d0/d1
	sub	#52,d0
	addq	#8,d1


	bra	print3b

.nl
	lea	.nil(pc),a0
	bra.b	.r

.nil	dc.b	"...Off",0
.t	dc.b	" %02ld:%02ld",0
 even


******* timeoutmode
rtimeoutmode
	lea	.gad(pc),a2
	lea	.form(pc),a1
	pea	.1(pc)
	tst.b	timeoutmode_new(a5)
	beq.b	.o
	addq	#4,sp
	pea	.2(pc)
.o	lea	(sp),a4
	bsr.b	pselector2
	seq	timeoutmode_new(a5)
	addq	#4,sp
	rts
.form	dc.b	"Timeout affects %s modules.",0
.gad	dc.b	"_All modules|_Never ending modules",0
.1	dc.b	"all",0
.2	dc.b	"never-ending",0
 even





* Reqtools-valikko
pselector
	sub.l	a4,a4
pselector2
	bsr	get_rt
	lea	.tags(pc),a0
	sub.l	a3,a3
	bsr	pon2
	lob	rtEZRequestA
	bsr	poff2
	tst.l	d0
	rts


.tags	
	dc.l	RTEZ_ReqTitle,reqtitle
	dc.l	RT_Underscore,"_"
	dc.l	RT_TextAttr,text_attr
otag3	dc.l	RT_PubScrName,pubScreenNameTags+var_b
	dc.l	TAG_END

pgad5	dc.b	"_1|_2|_3|_4|_5",0
 even


******* Hotkey
rhotkey
	not.b	hotkey_new(a5)
phot
	;tst.b	hotkey_new(a5)
	;sne	d0
	move.b	hotkey_new(a5),d0
	lea	kaktus,a0
	bra	tickaa

**** Cont on error
rerr
	not.b	cerr_new(a5)
perr
	;tst.b	cerr_new(a5)
	;sne	d0
	move.b	cerr_new(a5),d0
	lea	luuta,a0
	bra	tickaa




**** Select screen

rselscreen
    tst.b	uusikick(a5)
	bne.b	.nk
	rts

.nk
    * new list selector data
    lea     -512(sp),sp
    * 0: width in characters
    * 1: height in lines
    move.l  sp,a3
    move.b  #16,(a3)+    * default width
    move.b  #1,(a3)+     * at least one 

    * Get public screens and put them into the list
	lore	Intui,LockPubScreenList
    move.l  d0,a1
    * a1 = List of PubScreenNode structures
    bra     .goLoop
.loop
    move.l  LN_NAME(a1),a0  * screen name
    bsr     .cp
    addq.b  #1,1(sp)        * increase entry counter
.goLoop
	TSTNODE	a1,a1
	bne     .loop

    lob     UnlockPubScreenList

    * Index 0: Workbench
    * Index 1: ...
    * Index 2: ...
    * Index last: Front

    * Put the last one
    lea     .front(pc),a0
    bsr     .cp

    move.l  sp,a0
	bsr	listselector
    DPRINT  "listselector=%ld"
    tst.b   d0
    bmi     .x

    * What was the name?
    lea     2(sp),a0    
    tst.b   d0
    bra     .goFind
.findName
    tst.b   (a0)+
    bne     .findName
    subq.b  #1,d0
.goFind
    bne     .findName
    * Copy it
    lea     pubscreen_new(a5),a3
    bsr     .cp
.cont
 if DEBUG
    pushpea pubscreen_new(a5),d0
    DPRINT  "Selected pubscreen=%s"
 endif
    st	newpubscreen2(a5)	
	bsr pselscreen
.x	

    lea 512(sp),sp
    rts

.cp
    move.b  (a0)+,(a3)+
    bne     .cp
    rts

.front  dc.b    "Front screen",0
 even


pselscreen
	tst.b	uusikick(a5)
	bne.b	.new
	lea	pubscreen_new(a5),a0
	bra.b	.rpo

.new

	lea	pubscreen_new(a5),a2
	lea	desbuf2(a5),a1
	move.l	a1,a0
	moveq	#18-1,d0
.c	move.b	(a2)+,(a1)+
	dbeq	d0,.c
	clr.b	(a1)

.rpo	lea	pbutton13,a1
	bra	prunt2
	


**** doublebuffering
rdbuf
	not.b	dbf_new(a5)
pdbuf
	;tst.b	dbf_new(a5)
	;sne	d0
	move.b	dbf_new(a5),d0
	lea	nappu1,a0
	bra	tickaa

**** nasty audio
rnasty
	not.b	nasty_new(a5)
pnasty
	;tst.b	nasty_new(a5)
	;sne	d0
	move.b	nasty_new(a5),d0
	lea	nappu2,a0
	bra	tickaa


rvbtimer
	not.b	vbtimer_new(a5)
pvbt
	;tst.b	vbtimer_new(a5)
	;sne	d0
	move.b	vbtimer_new(a5),d0
	lea	nApPu,a0	
	bra	tickaa


****** FontSelector



pfont
	lea	prefs_fontname+prefsdata(a5),a0
	lea	gfonttou,a1

showFontNameInGadget
	lea	-20(sp),sp
	move.l	sp,a2
	moveq	#10-1,d0
.c	cmp.b	#'.',(a0)
	beq.b	.cc
	move.b	(a0)+,(a2)+
	dbeq	d0,.c
.cc	clr.b	(a2)
	move.l	sp,a0
	bsr	prunt2
	lea	20(sp),sp
	rts

rfont
	DPRINT	"rfont"
	tst.l	_DiskFontBase(a5)
	bne.b	.y
	rts
.y
	moveq	#RT_FONTREQ,d0
	lore	Req,rtAllocRequestA
	move.l	d0,d7

	lea	.tit(pc),a3
	lea	fontreqtags(pc),a0

	; Remove pubscreen for old kickstart to prevent crash
	tst.b	uusikick(a5)
	bne.b	.new
	basereg	fontreqtags,a0
	clr.l	fontreqtags\.pubScreenTag(a0)
	endb	a0
.new

	move.l	d7,a1
	bsr	pon2
	lob	rtFontRequestA
	bsr	poff2
	tst.l	d0
	beq.b	.ew

	move.l	d7,a0
	lea	rtfo_Attr(a0),a0	* fontin textattr
	* Open font from TextAttr in A0
	lore	DiskFont,OpenDiskFont	
	tst.l	d0
	beq.b	.ew
	move.l	d0,a3
	
	cmp	#8,tf_XSize(a3)
	sne	d3
	cmp	#8,tf_YSize(a3)
	sne 	d4
	btst	#FPB_PROPORTIONAL,tf_Flags(a3) 
	sne 	d5

	move.l	a3,a1
	lore	GFX,CloseFont
	move.l	a3,a1
	lob	RemFont		* puis muistista

	or.b	d3,d4 
	or.b	d4,d5
	bne.b	.ew

	move.l	d7,a0
	lea	rtfo_Attr(a0),a0
	move.l	4(a0),prefs_textattr+prefsdata(a5) * YSize, Style, Flags talteen
	move.l	(a0),a0				* Fontin nimi
	lea	prefs_fontname+prefsdata(a5),a1
	printt "TOOD: DANGER: the output buffer is just 20 chars long"
	
.cec	move.b	(a0)+,(a1)+
	bne.b	.cec

	clr	boxsize00(a5)		* avataan ja suljetaan p‰‰ikkuna


.ew
	move.l	d7,a1
	lore	Req,rtFreeRequest
	bra	pfont


.tit	dc.b	"Font for other windows",0
 even

fontreqtags
	dc.l	RTFO_Flags,FREQF_NOBUFFER!FREQF_FIXEDWIDTH
	dc.l	RTFO_SampleHeight,12
	dc.l	RTFO_MaxHeight,8
	dc.l	RTFO_MinHeight,8
	dc.l	RTFO_FilterFunc,.fontfilter
	dc.l	RT_TextAttr,text_attr
.pubScreenTag
	dc.l	RT_PubScrName,pubScreenNameTags+var_b
	dc.l	TAG_END

.fontfilter
	ds.b	MLN_SIZE
	dc.l	.hookroutine	* h_Entry
	dc.l	0		* h_SubEntry
	dc.l	0		* h_Data

.hookroutine
* a1 = textattr
	pushm	d1-a6		
	lea	var_b,a5
	moveq	#FALSE,d7
	cmp	#8,ta_YSize(a1)		* 8 pixeli‰ korkee?
	bne.b	.x
	btst	#FPB_PROPORTIONAL,ta_Flags(a1)	* Onko proportional?
	bne.b	.x	

	move.l	a1,a0			* tutkitaan onko leveys 8 pixeli‰
	lore	DiskFont,OpenDiskFont
	tst.l	d0
	beq.b	.x
	move.l	d0,a3
	cmp	#8,tf_XSize(a3)
	bne.b	.no
	moveq	#TRUE,d7
.no	move.l	a3,a1
	lore	GFX,CloseFont
	move.l	a3,a1
	lob	RemFont		* puis muistista
.x	move.l	d7,d0
	popm	d1-a6
	rts


rListFont
	DPRINT	"rListFont"
	tst.l	_DiskFontBase(a5)
	bne.b	.y
	rts
.y
	moveq	#RT_FONTREQ,d0
	lore	Req,rtAllocRequestA
	move.l	d0,d7

	lea	.tit(pc),a3
	lea	listfontreqtags(pc),a0

	; Remove pubscreen for old kickstart to prevent crash
	tst.b	uusikick(a5)
	bne.b	.new
	basereg	listfontreqtags,a0
	clr.l	listfontreqtags\.pubScreenTag(a0)
	endb	a0
.new
	move.l	d7,a1
	bsr	pon2
	lob	rtFontRequestA
	bsr	poff2
	tst.l	d0
	beq.b	.ew

	move.l	d7,a0
	lea	rtfo_Attr(a0),a0
	move.l	4(a0),prefs_listtextattr+prefsdata(a5) * YSize, Style, Flags talteen
	move.l	(a0),a0				* Fontin nimi
	lea	prefs_listfontname+prefsdata(a5),a1
.cec	move.b	(a0)+,(a1)+
	bne.b	.cec

	clr	boxsize00(a5)		* avataan ja suljetaan p‰‰ikkuna

.ew
	move.l	d7,a1
	lore	Req,rtFreeRequest
	bra.b	pListFont


.tit	dc.b	"Font for main window",0
 even

listfontreqtags
	dc.l	RTFO_Flags,FREQF_NOBUFFER
	dc.l	RTFO_SampleHeight,8
	dc.l	RTFO_MaxHeight,20 * Not too large to overflow the button gadgets
	dc.l	RTFO_MinHeight,6
	dc.l	RT_TextAttr,text_attr
.pubScreenTag
	dc.l	RT_PubScrName,pubScreenNameTags+var_b
	dc.l	TAG_END

pListFont
	DPRINT	"pListFont"
	lea	prefs_listfontname+prefsdata(a5),a0
	lea	prefsListFont,a1
	bra	showFontNameInGadget


*** Printataan screen refresh ratetkin

pscreen
	tst.b	gfxcard(a5)
	beq.b	.nop
	lea	.dea(pc),a0
	bra.b	.do

.nop
	moveq	#0,d0
	move	vertfreq(a5),d0

	moveq	#0,d1
	move	horizfreq(a5),d1
	divu	#1000,d1
	ext.l	d1

	lea	.de(pc),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0

.do	moveq	#16,d0
	move	#122+18,d1
	add	windowtop(a5),d1
	bra	print3b


.de
	dc.b	"Screen: %ldHz/%ldkHz",0
.dea	dc.b	"A gfx card detected.",0
 even


***** Playergroup file

rpgfile
	lea	groupname_new(a5),a0
	move.l	a0,a1			* mihin hakemistoon menn‰‰n
	lea	.tit(pc),a2
	bsr	pgetfile
	bra.b	ppgfile

.tit	dc.b	"Select player group file",0
 even

ppgfile
	lea	groupname_new(a5),a0
	move.l	a0,a2
.f	tst.b	(a2)+
	bne.b	.f
	move.l	sp,a1
	lea	-30(sp),sp
	moveq	#23-1,d0
.c	move.b	-(a2),-(a1)
	cmp.l	a0,a2
	beq.b	.cx
	dbf	d0,.c
.cx	
	move.l	a1,a0
	lea	RoU1,a1
	bsr	prunt2	
	lea	30(sp),sp
	rts


******** Playergroup mode

rpgmode_req
	lea	ls300(pc),a0
	bsr	listselector
	bmi.b	.x
	move.b	d0,groupmode_new(a5)
	bra.b	ppgmode
.x	rts


rpgmode
	move.b	groupmode_new(a5),d0
	addq.b	#1,d0
	cmp.b	#3,d0
	bls.b	.r
	moveq	#0,d0
.r	move.b	d0,groupmode_new(a5)

ppgmode
	lea	ls301(pc),a0
	move.b	groupmode_new(a5),d0
	beq.b	.0
	lea	ls302(pc),a0
	subq.b	#1,d0
	beq.b	.0
	lea	ls303(pc),a0
	subq.b	#1,d0
	beq.b	.0
	lea	ls304(pc),a0
	
.0	lea	PoU2,a1
	bra	prunt

ls300	dc.b	14,4
ls301	dc.b	"All on startup",0
ls302	dc.b	"All on demand",0
ls303	dc.b	"Disable",0
ls304	dc.b	"Load single",0
 even


ppgstat
	lea	.2(pc),a0
	tst.l	externalplayers(a5)
	beq.b	.q
	lea	.1(pc),a0
.q

	movem	PoU2+4,d0/d1
	add	#40,d0
	subq	#6,d1
	bra	print3b

.2	dc.b	"not loaded",0
.1 	dc.b	"....loaded",0
 even

*********** Divider / dir

rdiv
	not.b	div_new(a5)
pdiv
	;tst.b	div_new(a5)
	;sne	d0
	move.b	div_new(a5),d0
	lea	bUu1,a0
	bra	tickaa


**** Prefix cut
* Recycled to: Scope priority
rprefx_req
	lea	ls299(pc),a0
	bsr	listselector
	bmi.b	.x
	move.b	d0,prefix_new(a5)
	cmp.b	#4,d0
	blo.b	pprefx
	move.b	#3,prefix_new(a5)
	bra.b	pprefx
.x	rts

rprefx
	move.b	prefix_new(a5),d0
	addq.b	#1,d0
	cmp.b	#3,d0
	bls.b	.r
	moveq	#0,d0
.r	move.b	d0,prefix_new(a5)

pprefx
	moveq	#0,d0
	move.b	prefix_new(a5),d0
	lsl  #2,d0
	lea	ls299+2(pc,d0),a0
	lea	bUu2,a1
	bra	prunt

ls299	dc.b	3,4
	dc.b	"-30",0
	dc.b	"-1 ",0
	dc.b	" 0 ",0
	dc.b	"+1 ",0
 even

**** Early load
* DISABLED!
;rearly_req
;	lea	ls400(pc),a0
;	bsr	listselector
;	bmi.b	.x
;	move.b	d0,early_new(a5)
;	cmp.b	#11,d0
;	blo.b	pearly
;	move.b	#10,early_new(a5)
;	bra.b	pearly
;.x	rts
;
;rearly
;	move.b	early_new(a5),d0
;	addq.b	#1,d0
;	cmp.b	#10,d0
;	bls.b	.r
;	clr.b	d0
;.r	move.b	d0,early_new(a5)
;pearly
;	moveq	#0,d0
;	move.b	early_new(a5),d0
;	add	d0,d0
;	lea	ls400+2(pc,d0),a0
;	lea	bUu3,a1
;	bra	prunt
;
;
;
;
;ls400	dc.b	2,11
;	dc.b	"0",0
;	dc.b	"1",0
;	dc.b	"2",0
;	dc.b	"3",0
;	dc.b	"4",0
;	dc.b	"5",0
;	dc.b	"6",0
;	dc.b	"7",0
;	dc.b	"8",0
;	dc.b	"9",0
;	dc.b	"10",0
; even
;


;samplecyber	rs.b	1
;mpegaqua	rs.b	1
;mpegadiv	rs.b	1
;medmode		rs.b	1
;medrate		rs	1

;samplecyber_new	rs.b	1
;mpegaqua_new	rs.b	1
;mpegadiv_new	rs.b	1
;medmode_new	rs.b	1
;medrate_new	rs	1



*** Sample cybercalibration

rsamplecyber
	not.b	samplecyber_new(a5)
psamplecyber
	move.b	samplecyber_new(a5),d0
	lea	nAMISKA1,a0
	bra	tickaa


** MPEGA quality

rmpegaqua_req
	lea	ls500(pc),a0
	bsr	listselector
	bmi.b	.x
	move.b	d0,mpegaqua_new(a5)
	bra.b	pmpegaqua
.x	rts
rmpegaqua
	addq.b	#1,mpegaqua_new(a5)
	cmp.b	#3,mpegaqua_new(a5)
	bne.b	pmpegaqua
	clr.b	mpegaqua_new(a5)
pmpegaqua
	moveq	#0,d0
	move.b	mpegaqua_new(a5),d0
	lsl	#2,d0
	lea	ls501(pc,d0),a0
	lea	nAMISKA2,a1
	bra	prunt
ls500	dc.b	4,3
ls501	dc.b	"Low",0
ls502	dc.b	"Med",0
ls503	dc.b	"Hi ",0
 even

** MPEGA quality

rmpegadiv_req
	lea	ls600(pc),a0
	bsr	listselector
	bmi.b	.x
	move.b	d0,mpegadiv_new(a5)
	bra.b	pmpegadiv
.x	rts
rmpegadiv
	addq.b	#1,mpegadiv_new(a5)
	cmp.b	#3,mpegadiv_new(a5)
	bne.b	pmpegadiv
	clr.b	mpegadiv_new(a5)
pmpegadiv
	moveq	#0,d0
	move.b	mpegadiv_new(a5),d0
	add	d0,d0
	lea	ls601(pc,d0),a0
	lea	nAMISKA3,a1
	bra	prunt
ls600	dc.b	2,3
ls601	dc.b	"1",0
ls602	dc.b	"2",0
ls603	dc.b	"4",0
 even



** MED mode

rmedmode_req
	lea	ls700(pc),a0
	bsr	listselector
	bmi.b	.x
	move.b	d0,medmode_new(a5)
	bra.b	pmedmode
.x	rts
rmedmode
	addq.b	#1,medmode_new(a5)
	cmp.b	#2,medmode_new(a5)
	bne.b	pmedmode
	clr.b	medmode_new(a5)
pmedmode
	moveq	#0,d0
	move.b	medmode_new(a5),d0
	add	d0,d0
	lea	ls701(pc,d0),a0
	lea	nAMISKA4,a1
	bra	prunt
ls700	dc.b	2,2
ls701	dc.b	"8",0
ls702	dc.b	"14",0
 even




pupmedrate	
rmedrate
	lea	nAMISKA5,a2
	move	#580-050,d0		* max
	bsr	nappilasku
	add	#50,d0
	mulu	#100,d0
	move	d0,medrate_new(a5)

	divu	#1000,d0
	swap	d0
	moveq	#0,d1
	move	d0,d1
	clr	d0
	swap	d0

	lea	info2_t(pC),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0
	movem	4(a2),d0/d1
	;add	#118,d0
	add     #-7*8-2-4,d0
    addq    #6,d1
   ; subq	#6,d1
	bra	print3b


** SID mode

rsidmode_req
	lea	sidmode00(pc),a0

    pushpea sidmode_callback(pc),d4
	bsr 	listSelectorPrefsWindowWithCallback
	bmi.b	.x
	move.b	d0,sidmode_new(a5)
	bra.b	psidmode
.x	rts

    * in:
*   d3 = index to check
sidmode_callback
    tst     d3
    bhi     .2
    moveq   #1,d0
    rts
.2  
    jsr     get_sid
    jmp     isPlaysidReSID

rsidmode
	addq.b	#1,sidmode_new(a5)
	cmp.b	#7,sidmode_new(a5)
	bne.b	.1
	clr.b	sidmode_new(a5)
.1
    jsr     get_sid
    jsr     isPlaysidReSID
    bne     .2
	clr.b	sidmode_new(a5)
.2

psidmode
    lea     sidmode01(pc),a0
	move.b	sidmode_new(a5),d0
    beq.b   .1
    lea     sidmode02(pc),a0
    subq.b  #1,d0
    beq.b   .1
    lea     sidmode03(pc),a0
    subq.b  #1,d0
    beq.b   .1
    lea     sidmode04(pc),a0
    subq.b  #1,d0
    beq.b   .1
    lea     sidmode05(pc),a0
    subq.b  #1,d0
    beq.b   .1
    lea     sidmode06(pc),a0
    subq.b  #1,d0
    beq.b   .1
    lea     sidmode07(pc),a0
.1 
    lea	    prefsPlaySidMode,a1
	bra	prunt



sidmode00	dc.b	11,7
sidmode01	dc.b	"Normal",0
sidmode02	dc.b	"reSID "
t6581       dc.b    "6581",0
sidmode03	dc.b	"reSID "
t8580       dc.b    "8580",0
sidmode04	dc.b	"reSID Auto",0
sidmode05	dc.b	"SIDBlaster",0
sidmode06	dc.b	"ZorroSID",0
sidmode07	dc.b	"USBSID-Pico",0
 even

rresidmode_req
	lea	residmode00(pc),a0

    pushpea sidmode_callback(pc),d4
    bsr     listselector
	bmi.b	.x
	move.b	d0,residmode_new(a5)
	bra.b	presidmode
.x	rts


rresidfilter_req
	lea	residfilter00(pc),a0

    pushpea sidmode_callback(pc),d4
    bsr     listselector
	bmi.b	.x
	move.b	d0,residfilter_new(a5)
	bra 	presidfilter
.x	rts

rresidboost_req
	lea	residboost00(pc),a0

    pushpea sidmode_callback(pc),d4
    bsr     listselector
	bmi.b	.x
	move.b	d0,residboost_new(a5)
	bra 	presidboost
.x	rts


rmidimode_req
	lea	midimode00(pc),a0

    moveq   #0,d4
    bsr     listselector
	bmi.b	.x
	move.b	d0,midimode_new(a5)
	bra 	pmidimode
.x	rts


rresidmode
	addq.b	#1,residmode_new(a5)
	cmp.b	#4,residmode_new(a5)
	bne.b	.1
	clr.b	residmode_new(a5)
.1

presidmode
    lea     residmode01(pc),a0
	move.b	residmode_new(a5),d0
    beq.b   .1
    lea     residmode02(pc),a0
    subq.b  #1,d0
    beq.b   .1
    lea     residmode03(pc),a0
    subq.b  #1,d0
    beq.b   .1
    lea     residmode04(pc),a0
.1 
    lea	    prefsResidMode,a1
	bra	prunt



residmode00	dc.b	13,4
residmode01	dc.b	"Normal",0
residmode02	dc.b	"Oversample 2x",0
residmode03	dc.b	"Oversample 3x",0
residmode04	dc.b	"Oversample 4x",0
 even



rresidfilter
	addq.b	#1,residfilter_new(a5)
	cmp.b	#3,residfilter_new(a5)
	bne.b	.1
	clr.b	residfilter_new(a5)
.1

presidfilter
    lea     residfilter01(pc),a0
	move.b	residfilter_new(a5),d0
    beq.b   .1
    lea     residfilter02(pc),a0
    subq.b  #1,d0
    beq.b   .1
    lea     residfilter03(pc),a0
.1 
    lea	    prefsResidFilter,a1
	bra	prunt



residfilter00	dc.b    12,3
residfilter01	dc.b	"Internal on",0
residfilter02	dc.b	"Internal+Ext",0
residfilter03	dc.b	"All off",0
 even


rresidboost
	addq.b	#1,residboost_new(a5)
	cmp.b	#4,residboost_new(a5)
	bne.b	.1
	clr.b	residboost_new(a5)
.1

presidboost
    lea     residboost01(pc),a0
	move.b	residboost_new(a5),d0
    beq.b   .1
    lea     residboost02(pc),a0
    subq.b  #1,d0
    beq.b   .1
    lea     residboost03(pc),a0
    subq.b  #1,d0
    beq.b   .1
    lea     residboost04(pc),a0
.1 
    lea	    prefsResidBoost,a1
	bra	prunt

residboost00	dc.b    6,4
residboost01	dc.b	"Off",0
residboost02	dc.b	"2x",0
residboost03	dc.b	"3x",0
residboost04	dc.b	"4x",0
 even


rmidimode
	addq.b	#1,midimode_new(a5)
	cmp.b	#3,midimode_new(a5)
	bne.b	.1
	clr.b	midimode_new(a5)
.1

pmidimode
    lea     midimode01(pc),a0
	move.b	midimode_new(a5),d0
    beq.b   .1
    lea     midimode02(pc),a0
    subq.b  #1,d0
    beq.b   .1
    lea     midimode03(pc),a0
.1 
    lea	    prefsMidiMode,a1
	bra	prunt

midimode00	dc.b    12,3
midimode01	dc.b	"Timidity",0
midimode02	dc.b	"GMPlay",0
midimode03	dc.b	"Serial out",0
 even



*** XMAPlay toggle

rxmaplay
	not.b	xmaplay_new(a5)
pxmaplay
	move.b	xmaplay_new(a5),d0
	lea	    prefsEnableXMAPlay,a0
	bra	tickaa

*** MED fastmemplay toggle

rmedfastmemplay
	not.b	medfastmemplay_new(a5)
pmedfastmemplay
	move.b	medfastmemplay_new(a5),d0
	lea	    prefsMedFastRamMode,a0
	bra	tickaa


*** MHI toggle, lib

rmhienable
	not.b	mhiEnable_new(a5)
pmhienable
    move.b	mhiEnable_new(a5),d0
	lea	    prefsMHIEnable,a0
	bra	tickaa
.x  rts

rmhilib
	lea	mhiLib_new(a5),a0
	move.l	a0,a1			* mihin hakemistoon menn‰‰n
	lea	.t(pc),a2
	bsr	pgetfile
	lea	mhiLib_new(a5),a0
    move.l  a0,d0
    DPRINT  "got=%ls"
	bra.b	pmhilib

.t	dc.b	"Select MHI driver",0
 even

pmhilib
    lea     mhiLib_new(a5),a0
    jsr     findFilePart

	lea	-30(sp),sp
    move.l  sp,a1
.c	move.b  (a0)+,d1
    beq     .cc
    cmp.b   #".",d1
    beq     .cc
    move.b  d1,(a1)+
    bra     .c
.cc clr.b   (a1)
	move.l	sp,a0
	lea	prefsMHILib,a1
	bsr	prunt2	
	lea	30(sp),sp
.x
	rts


***************************************
* AHI valinnat

*** use ahi
rahi1	not.b	ahi_use_new(a5)
pahi1	;tst.b	ahi_use_new(a5)
	;sne	d0
	move.b	ahi_use_new(a5),d0
	lea	ahiG2,a0
	bra	tickaa


*** ahi disable muut
rahi2	not.b	ahi_muutpois_new(a5)
pahi2	;tst.b	ahi_muutpois_new(a5)
	;sne	d0
	move.b	ahi_muutpois_new(a5),d0
	lea	ahiG3,a0
	bra	tickaa


*** ahi select mode
rahi3
	OPENAHI	1
	move.l	d0,d7
	beq	rahi3_e
	move.l	d0,a6

	lea	audioreqtags(pc),a0
	jsr	_LVOAHI_AllocAudioRequestA(a6)
	move.l	d0,d6
	beq.b	.gr

	move.l	d6,a0
	lea	audioreqtags2(pc),a1
	move.l	windowbase2(a5),4(a1)	* parent window

	jsr	_LVOAHI_AudioRequestA(a6)
	tst.l	d0
	beq.b	.gr
	move.l	d6,a0
	move.l	ahiam_AudioID(a0),d0
	move.l	d0,ahi_mode_new(a5)

	lea	-50(sp),sp

	lea	ahi_attrtags(pc),a1
	move.l	sp,ahimodenam-ahi_attrtags(a1)
	jsr	_LVOAHI_GetAudioAttrsA(a6)

	move.l	sp,a0
.f	tst.b	(a0)+
	bne.b	.f
	subq	#1,a0
	move.l	a0,d0
	sub.l	sp,d0
	moveq	#42,d1
	sub	d0,d1
	subq	#1,d1
	bmi.b	.h
.r	move.b	#' ',(a0)+
	dbf	d1,.r
	clr.b	(a0)
.h
	lea	ahi_name_new(a5),a1
	move.l	sp,a0
.c	move.b	(a0)+,(a1)+
	bne.b	.c

	lea	50(sp),sp


.gr
	tst.l	d6
	beq.b	.gr2
	move.l	d6,a0
	jsr	_LVOAHI_FreeAudioRequest(a6)
.gr2


	CLOSEAHI

;	bsr	pahi3
;	rts


pahi3	lea	ahi_name_new(a5),a0
	tst.b	(a0)
	bne.b	.y
	lea	.non(pc),a0
.y	movem	ahiG1+4,d0/d1
	add	#10,d0
	addq	#8,d1
	bra	print3b

.non	dc.b	"NONE",0
 even

rahi3_e
	lea	.e(pc),a1
	bra	request
.e	dc.b	"Couldn't open AHI device!",0
 even



audioreqtags2
	dc.l	AHIR_Window,0
	dc.l	AHIR_DoDefaultMode,TRUE
	dc.l	AHIR_SleepWindow,TRUE
	dc.l	AHIR_TitleText,ahirt
	dc.l	AHIR_TextAttr,text_attr
audioreqtags
	dc.l	TAG_END

ahirt	dc.b	"Select audio mode",0
 even

ahi_attrtags
	dc.l	AHIDB_BufferLen,39+4
	dc.l	AHIDB_Name,0
ahimodenam = *-4
	dc.l	TAG_END




*** ahi mixing rate
pahi4
rahi4
	lea	ahiG4,a2
	move	#580-050,d0		* max
	bsr	nappilasku
	add	#50,d0
	mulu	#100,d0
	move.l	d0,ahi_rate_new(a5)

	divu	#1000,d0
	swap	d0
	moveq	#0,d1
	move	d0,d1
	clr	d0
	swap	d0

	lea	info2_t(pC),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0
;	movem	ahiG4+4,d0/d1
	movem	4(a2),d0/d1
	sub	#65,d0
	addq	#8,d1
	bra	print3b

*** master volume
pahi5
rahi5	
	lea	ahiG5,a2
	move	#1000,d0		* max
	bsr	nappilasku
	move	d0,ahi_mastervol_new(a5)

	lea	.i(pC),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0
;	movem	ahiG5+4,d0/d1
	movem	4(a2),d0/d1
	sub	#49,d0
	addq	#8,d1
	bsr	print3b
	bra.b	updateahi

.i	dc.b	".%4.4ld",0
 even

*** stereo level
pahi6
rahi6	
	lea	ahiG6,a2
	moveq	#100,d0		* max
	bsr	nappilasku
	move	d0,ahi_stereolev_new(a5)

	lea	.i(pC),a0
	bsr	desmsg2
	lea	desbuf2(a5),a0
;	movem	ahiG6+4,d0/d1
	movem	4(a2),d0/d1
	sub	#41,d0
	addq	#8,d1
	bsr	print3b
	bra.b	updateahi
	

.i	dc.b	"%3.3ld%%",0
 even



updateahi
	pushm	all

	cmp	#pt_digiboosterpro,playertype(a5)
	beq.b	.d

	tst.b	ahi_use_nyt(a5)
	beq.b	.nd

.d	tst.l	playingmodule(a5)
	bmi.b	.nd
	tst.b	playing(a5)
	beq.b	.nd

	move.l	playerbase(a5),a0
	move	p_liput(a0),d0
	btst	#pb_ahi,d0
	beq.b	.nd

	move	ahi_mastervol_new(a5),d0
	move	ahi_stereolev_new(a5),d1
	jsr	p_ahiupdate(a0)
.nd	popm	all
	rts


 
*********************************
**************** Listselector
********************************

* Mieletˆn.

wflags4 = WFLG_SMART_REFRESH!WFLG_ACTIVATE!WFLG_BORDERLESS!WFLG_RMBTRAP
idcmpflags4 = IDCMP_INACTIVEWINDOW!IDCMP_GADGETUP!IDCMP_MOUSEBUTTONS!IDCMP_RAWKEY

listSelectorMainWindowPreselect:
	pushm	d1-a6	
	move.l	windowbase(a5),a0	
	bra.b	listselector\.do


listSelectorMainWindow:
	pushm	d1-a6	
	move.l	windowbase(a5),a0	
    moveq   #-1,d0
	bra.b	listselector\.do

listSelectorPrefsWindowWithCallback:
	movem.l	d1-a6,-(sp)
	bra.b	listselector\.dop

* in: 
*   d4 = callback to check whether line should be enabled
*   d6 = mouse x
*   d7 = mouse y
*   a0 = data to show
* out: 
*   d0 = selected index, or -1 if cancel
listselector:
.LINE_HEIGHT = 12

	pushm	d1-a6
    moveq   #-1,d0
	moveq	#0,d4
.dop
    moveq   #-1,d0
	move.l	a0,a4
	move.l	windowbase2(a5),a0	* prefs-ikkuna
.do
	add	wd_LeftEdge(a0),d6	* mousepos suhteellinen prefs-ikkunan
	add	wd_TopEdge(a0),d7	* yl‰laitaan

;    move    #-1,.arrowSelection	
    move    d0,.arrowSelection

	lea	winlistsel,a0		* asetetaan pointterin kohdalle

	moveq	#0,d5
	move.b	(a4),d5
	mulu	#8,d5
	add	#16,d5
	move	d5,nw_Width(a0)

	lsr	#1,d5
	sub	d5,d6
	bpl.b	.oe
	moveq	#0,d6
.oe	move	d6,nw_LeftEdge(a0)

	moveq	#0,d5
	move.b	1(a4),d5
	mulu	#.LINE_HEIGHT,d5
	addq	#8,d5
	move	d5,nw_Height(a0)

	lsr	#1,d5
	sub	d5,d7
	bpl.b	.oee
	moveq	#0,d7
.oee	move	d7,nw_TopEdge(a0)

	bsr	tark_mahtu

	lore	Intui,OpenWindow
	move.l	d0,d6
	beq	.x
	move.l	d0,a0
	move.l	wd_RPort(a0),d7		* rastport
	move.l	wd_UserPort(a0),a3	* userport


	pushm	all
	
	moveq	#0,d7
	move.b	(a4)+,d7	* max leveys
	lsl	#3,d7			* x8

	moveq	#0,d5
	move.b	(a4)+,d5	* vaakarivej‰
    move    d5,.lineCount
	subq	#1,d5
	move.l	a4,a0

	moveq	#0,d2   * id counter
	moveq	#4,d3 	* start y
.prl	
	move.l	a0,a1
.fe	tst.b	(a1)+
	bne.b	.fe
	move.l	a1,d1
	sub.l	a0,d1
	subq	#1,d1
	lsl	#3,d1
	move	d7,d0
	sub	d1,d0
	lsr	#1,d0
	;addq	#8,d0	* right margin

	move	d3,d1
	* d0 = x
	* d1 = y
	* a0 = text
	bsr	.print
	add		#.LINE_HEIGHT,d3 * next y
	addq	#1,d2 * id number
	move.l	a1,a0
	dbf	d5,.prl

	movem.l	(sp),d0-a6

	move.l	d7,a1
	lea	winlistsel,a0
	moveq	#0,plx1
	move	nw_Width(a0),plx2
	moveq	#0,ply1
	move	nw_Height(a0),ply2
	subq	#1,ply2
	subq	#1,plx2
	bsr	laatikko1
	popm	all

    * Preselection?
    move    .arrowSelection(pc),d0
    bmi.b   .zzz
    bsr     .doSelect
.zzz

	moveq	#-1,d7		* selection
.msgloop3
	moveq	#0,d0
	move.b	MP_SIGBIT(a3),d1	* IDCMP signalibitti
	bset	d1,d0
	lore	Exec,Wait			* Odotellaan...

	move.l	a3,a0
	lob	GetMsg
	tst.l	d0
	beq.b	.msgloop3

	move.l	d0,a1
	move.l	im_Class(a1),d2		* luokka	
	move	im_Code(a1),d3		* koodi
	move.l	im_IAddress(a1),a2 	* gadgetin tai olion osoite
;	move	im_MouseX(a1),d6	* mousen koordinaatit
;	move	im_MouseY(a1),d7

	lob	ReplyMsg

	cmp.l	#IDCMP_GADGETUP,d2
	bne 	.noGadget
	move	gg_GadgetID(a2),d7
	bra 	.done
.noGadget
	cmp.l	#IDCMP_MOUSEBUTTONS,d2
	bne 	.noButtons
	cmp		#SELECTDOWN,d3
	beq 	.done
	cmp		#MENUDOWN,d3
	beq 	.done
.noButtons
	cmp.l	#IDCMP_RAWKEY,d2
	bne 	.noRawKey
    tst.b   d3
    bmi     .msgloop3
    cmp.b   #$4c,d3
    bne.b   .1
    bsr     .selectUp
    bra     .msgloop3
.1  cmp.b   #$4d,d3
    bne     .2
    bsr     .selectDown
    bra     .msgloop3
.2  cmp.b   #$44,d3
    bne     .done
    * RETURN
    move    .arrowSelection(pc),d7
    bra     .done
.noRawKey  
    cmp.l	#IDCMP_INACTIVEWINDOW,d2
	bne 	.msgloop3
	
.done
	move.l	d6,a0
	bsr	flushWindowMessages

	move.l	d6,d0
	beq.b	.eek
	move.l	d0,a0
	lore	Intui,CloseWindow
.eek
.x
	lea	listSelectorRememberPtr(a5),a0
	moveq	#1,d0 * forget all of it
	lore	Intui,FreeRemember

	move	d7,d0
	popm	d1-a6
	rts

* Makes a bool gadget 
* In:
*   d0 = x
*   d1 = y
*   d2 = id
*   d4 = callback
*   a0 = text
*   d6 = window base
.print
	pushm	all
	
	move.l	a0,a4	* save text
	move	d0,d5
	move	d1,d7
	move	d2,d3

	; Get NewGadget
	lea	listSelectorRememberPtr(a5),a0
	moveq	#gg_SIZEOF,d0
	move.l	#MEMF_CLEAR!MEMF_PUBLIC,d1
	lore	Intui,AllocRemember
	tst.l	d0
	beq		.xx
	move.l	d0,a3
	; Only need to change these fields
	move	#GFLG_GADGHCOMP,gg_Flags(a3)
	move	#GACT_RELVERIFY,gg_Activation(a3)
	move	#GTYP_BOOLGADGET,gg_GadgetType(a3)

	move.l	d6,a0
	move	wd_Width(a0),d0
	sub		#16-4,d0
	move	d0,gg_Width(a3)
	move	#.LINE_HEIGHT,gg_Height(a3)
	move	#8-2,gg_LeftEdge(a3)
	move	d7,gg_TopEdge(a3)
	move	d3,gg_GadgetID(a3)

	* Enable/disable callback
	tst.l	d4
	beq.b	.enabled
	move.l	d4,a0
	jsr		(a0)
	bne.b	.enabled
	or	#GFLG_DISABLED,gg_Flags(a3)
.enabled

	lea	listSelectorRememberPtr(a5),a0
	moveq	#it_SIZEOF,d0
	move.l	#MEMF_CLEAR!MEMF_PUBLIC,d1
	lob		AllocRemember
	tst.l	d0
	beq		.xx
	move.l	d0,a2
	move.l	a2,gg_GadgetText(a3)
	move.b	#1,it_FrontPen(a2)
	move.b	#RP_JAM1,it_DrawMode(a2)
	move.l	a4,it_IText(a2)
	move.l	#text_attr,it_ITextFont(a2)
	addq	#2,d5
	move	d5,it_LeftEdge(a2)	
	move	#2,it_TopEdge(a2)

	move.l	d6,a0
	move.l	a3,a1
	moveq	#-1,d0 * position = last
	lob		AddGadget

	move.l	a3,a0
	move.l	d6,a1 * window
	sub.l	a2,a2 * req
	moveq	#1,d0 * numgad
	lob		RefreshGList

	move.l	d6,a1
	move.l	wd_RPort(a1),a1
	move.l	a3,a3
	jsr		doDrawButtonFrame
.xx
	popm	all
	rts

* d6 = window
.selectDown
    bsr     .deselect

    move    .arrowSelection(pc),d0
    bpl.b   .s1
    moveq   #-1,d0
.s1 addq    #1,d0
    cmp     .lineCount(pc),d0
    bne     .s2
    moveq   #0,d0
.s2 move    d0,.arrowSelection

.doSelect
    move.l  d6,a0
    move.l  wd_FirstGadget(a0),a0
.f  cmp     gg_GadgetID(a0),d0
    beq.b   .f2
    move.l  gg_NextGadget(a0),d1
    beq     .f3
    move.l  d1,a0
    bra     .f
.f2
    * found it
    move.l  gg_GadgetText(a0),a1
    move.b  #2,it_FrontPen(a1)
    tst.b   uusikick(a5)
    bne     .k1
    move.b  #3,it_FrontPen(a1)
.k1

    move.l  d6,a1
    sub.l   a2,a2
    moveq   #1,d0
    lore    Intui,RefreshGList

.f3
    rts 

.selectUp
    bsr     .deselect

    move    .arrowSelection(pc),d0
    bpl.b   .z1
    move    .lineCount(pc),d0
.z1 subq     #1,d0
    bpl     .z2
    move    .lineCount(pc),d0
    subq    #1,d0
.z2 move    d0,.arrowSelection
    bra     .doSelect

.deselect
    push    a3
    move.l  d6,a3
    move.l  wd_FirstGadget(a3),d0
.de1
    beq     .de2
    move.l  d0,a3
    move.l  gg_GadgetText(a3),a0
    cmp.b   #1,it_FrontPen(a0)
    beq     .de3
    move.b  #1,it_FrontPen(a0)
    move.l  a3,a0
    move.l  d6,a1
    sub.l   a2,a2
    moveq   #1,d0
    lore    Intui,RefreshGList
.de3
    move.l  gg_NextGadget(a3),d0
    bra     .de1
.de2
    pop     a3
    rts

.arrowSelection dc.w    -1
.lineCount      dc.w    0

*******************************************************************************
*  End of Prefs section
*******************************************************************************

*******
* Kirjoitetaan n‰kyv‰t tiedoston nimet ikkunaan
* Writes the filenames into the box
*******

* hippoonbox(a5) is a flag that requests the whole list to be redrawn instead
* of some clever partial refresh that is used when scrolling up and down.


showNamesNoCentering
shownames2
	moveq	#1,d4		* flag: do not center
	bra.b	shownames\.doit

* Clears the filebox area
clearbox:
	tst	boxsize(a5)
	beq.b	.x
	tst.b	win(a5)
	bne.b	.r
.x	rts
.r	
    moveq	#30+WINX,d0
	;moveq	#62+WINY,d1
	move	fileBoxTopEdge(a5),d1
	subq	#1,d1
;	move	#251+WINX,d2
	move	WINSIZX(a5),d2
	sub	#10,d2
	;move	#127+WINY,d3
	move	fileBoxTopEdge(a5),d3
	add		#127-62-1,d3 * magic constant

	add	boxy(a5),d3
    sub BOTTOM_MARGIN(a5),d3
	bra	tyhjays

shownames:
	moveq	#0,d4	 	* flag: center
.doit
	tst	boxsize(a5)
	beq.b	.bx
	tst.b	win(a5)		* onko ikkunaa?
	bne.b	.iswin
.bx	rts

.iswin

	pushm	all

	tst.l	modamount(a5)
	bne		.eper

	bsr.b	clearbox

	cmp.b	#LISTMODE_SEARCH,listMode(a5)
	bne.b	.noSrch
	lea		.noSrchResults(pc),a0
    tst.b   uhcAvailable(a5)
    bne.b   .s1
    lea     .noUhc(pc),a0
.s1
	bsr	printbox
	bra 	.wasSrch
.noSrchResults  dc.b	"No search results.",0
.noUhc          dc.b    "Search disabled! UHCTools",10
                dc.b    "missing or too old.",0
	even
.noSrch
	cmp.b 	#LISTMODE_FAVORITES,listMode(a5)
	bne.b	.doHippo
	* What to show when no modules and favorites mode?
	lea	.noFavs(pc),a0
	tst.b	favorites(a5)
	bne.b	.favsOn
	lea	.noFavs2(pc),a0
.favsOn
	bsr	printbox
	bra.b	.wasFav
.noFavs 	dc.b 	"No favorites!",10
		dc.b	"Add with RMB.",0
.noFavs2	dc.b	"Favorites feature disabled!",0
		even
.doHippo
	bsr	printhippo1
.wasFav	
.wasSrch
	st	hippoonbox(a5)		* koko hˆsk‰n tulostus
	bra	.nomods
.eper

	tst	d4		* ei mink‰‰nlaista uudelleensijoitusta
	bne.b	.nob

	moveq	#0,d2
	move	boxsize(a5),d2
    tst.w   searchLayoutActive(a5)      
    beq.b   .lm1
    subq    #SEARCH_BOXSIZE_DELTA,d2
.lm1
	move.l	d2,d3
	lsr	#1,d2		* center chosenmodule in the middle of the box
	
	move.l	chosenmodule(a5),d0
	;DPRINT "Shownames center index %ld"

	sub.l	d2,d0
	bmi.b	.nok
	move.l	modamount(a5),d1
	sub.l	d3,d1
	bmi.b	.nok
	cmp.l	d1,d0
	blo.b	.ok
	move.l	d1,d0
	bra.b	.ok
.nok	
	moveq	#0,d0	
.ok	
	move.l	d0,firstname(a5)
	;DPRINT "->first name %ld"

.nob
	tst.b	hippoonbox(a5)
	beq.b	.eh
	clr.b	hippoonbox(a5)
	bra	.neen
.eh
	move.l	firstname(a5),d0
	move.l	firstname2(a5),d7
	move.l	d0,firstname2(a5)
	cmp.l	d0,d7
	beq	.nomods
	sub.l	d0,d7		* d7 should be in range 0..boxsize
	bmi.b	.alas

.ylos
	moveq	#0,d1 
	move	boxsize(a5),d1
    tst.w   searchLayoutActive(a5)      
    beq.b   .lm9
    subq    #SEARCH_BOXSIZE_DELTA,d1
.lm9
	cmp.l	d1,d7
	bhs	.all

	bsr	.unmark

* siirrytty d7 rivi‰ ylˆsp‰in:
* kopioidaan rivit 0 -> d7 (koko: boxsize-d7 r) kohtaan 0 ja printataan
* kohtaan 0 d7 kpl uusia rivej‰

	move	fileBoxTopEdge(a5),d1		* source y
	move	d7,d3
	;lsl	#3,d3
	mulu	listFontHeight(a5),d3
	add		fileBoxTopEdge(a5),d3		* dest y
	bsr	.copy
	move.l	firstname(a5),d0
	moveq	#0,d1
	move	d7,d2
	bra.b	.rcr


.alas	
	moveq	#0,d1 
	move	boxsize(a5),d1
    tst.w   searchLayoutActive(a5)      
    beq.b   .lm2
    subq    #SEARCH_BOXSIZE_DELTA,d1
.lm2
	neg.l  	d7 
	cmp.l	d1,d7 
	bhs.b	.all

	bsr	.unmark

* siirrytty d7 rivi‰ alasp‰in:
* kopioidaan rivit d7 -> boxsizee (koko: boxsize-d7 r) kohtaan 0 ja printataan
* kohtaan boxsize-d7 d7 kpl uusia rivej‰

	move	d7,d1
	;lsl	#3,d1
	mulu	listFontHeight(a5),d1
	add		fileBoxTopEdge(a5),d1		* source y
	move	fileBoxTopEdge(a5),d3	* dest y
	bsr 	.copy
	moveq	#0,d0 
	move 	boxsize(a5),d0 
    tst.w   searchLayoutActive(a5)   
    beq.b   .lm3
    subq    #SEARCH_BOXSIZE_DELTA,d0
.lm3

	add.l 	firstname(a5),d0
	sub.l	d7,d0
	moveq	#0,d1 
	move	boxsize(a5),d1
    tst.w   searchLayoutActive(a5)   
    beq.b   .lm4
    subq    #SEARCH_BOXSIZE_DELTA,d1
.lm4

	sub.l   d7,d1
	move.l	d7,d2

.rcr	bsr	doPrintNames
	bra.b	.huh2

.nomods	
	bsr 	.unmark
.huh2
.xx
	move.l	#-1,markedline(a5)
	move.l	chosenmodule(a5),d0
	bmi.b	.huh
	sub.l	firstname(a5),d0
	bmi.b	.huh
	move.l	d0,markedline(a5)		* merkit‰‰n valittu nimi
	bsr	markit
.huh
	move.l	chosenmodule(a5),chosenmodule2(a5)
	move.l	firstname(a5),firstname2(a5)
	clr.b	dontmark(a5)

	popm	all
	rts

.all
.neen
	* clear and print all names
	bsr	clearbox

	move.l	firstname(a5),d0
	moveq	#0,d1
	move	boxsize(a5),d2
    tst.w   searchLayoutActive(a5)   
    beq.b   .lm5
    subq    #SEARCH_BOXSIZE_DELTA,d2
.lm5
	bsr.b	doPrintNames
	bra.b	.huh2



.copy	
	move	boxsize(a5),d5	* y size
    tst.w   searchLayoutActive(a5)   
    beq.b   .lm8
    subq    #SEARCH_BOXSIZE_DELTA,d5
.lm8
	sub	d7,d5
	;lsl	#3,d5
	mulu	listFontHeight(a5),d5

	moveq	#32+WINX,d0	* source x
	move	d0,d2		* dest x
	;move	#27*8+1,d4	* x size
	move	WINSIZX(a5),d4
	sub	#264-216-2,d4

	add	windowleft(a5),d0
	add	windowtop(a5),d1
	add	windowleft(a5),d2
	add	windowtop(a5),d3
	move.l	rastport(a5),a0
	move.l	a0,a1
	move.b	#$c0,d6		* minterm: a->d
	move.l	_GFXBase(a5),a6
	jmp	_LVOClipBlit(a6)



.unmark
	tst.b	dontmark(a5)
	bne.b	.huh22

	move.l	chosenmodule2(a5),d0
	bmi.b	.huh22
	sub.l	firstname2(a5),d0
	bmi.b	.huh22
	push	d7
	move.l	chosenmodule(a5),-(sp)
	move.l	chosenmodule2(a5),chosenmodule(a5)
	bsr	unmarkit
	move.l	(sp)+,chosenmodule(a5)
	pop	d7
.huh22	rts

* d0 = alkurivi
* d1 = eka rivi ruudulla
* d2 = printattavien rivien m‰‰r‰
doPrintNames:
;	DPRINT  "shownames obtain list"
	bsr  obtainModuleList
	;lea	moduleListHeader(a5),a4	
	bsr	getVisibleModuleListHeader
	move.l	a0,a4

; if DEBUG
; 	ext.l	d2
;	DPRINT	"doPrintNames first=%ld target=%ld amount=%ld"
; endif
	* d0 = module index
	* d1 = line number to print to
	* d2 = number of lines to print
	* find out the corresponding list entry
	move.l	d0,d3 		* keep track of the module index as well here
	move.l	d1,d4		* move this out of the way
	subq.l	#1,d0
	bmi.b	.baa

	bsr	getListNodeCached
	beq	.lop	* check for z-flag error indication
	tst.l	(a0)
	beq	.lop
	move.l	a0,a3
	move.l	a0,a4
.baa

	move	d2,d5
	subq	#1,d5

	move	d4,d6
	;lsl	#3,d6
	mulu	listFontHeight(a5),d6
	;add	#83+WINY-14,d6		
	* turn line number into a Y-coordinate
	add	fileBoxTopEdge(a5),d6
	add		#83-14-64+1,d6 * magic offset
	move.l	rastport(a5),a1
	move.l	listfontbase(a5),a0
	lore	GFX,SetFont
	
	jsr	setListBoxClip

	* loop to print d5 lines 
.looppo

	* a4=current node
	* a3=next node
	* test if at end
	TSTNODE	a4,a3
	beq	.lop			* joko loppui
	move.l	a3,a4

	move.l	l_nameaddr(a3),a0
	;;bsr	cut_prefix
	move.l	a0,a2		* name is in a2

	moveq	#0,d7		* clear divider flag

	tst.b	l_divider(a3)
	beq.b	.nodi
    * Stealthy divider, no special styles
    cmp.b   #$f0,l_divider(a3)
    beq.b   .nodi
	st	d7	* set flag: divider being handled
	* Set color for list divider
	push	a1
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	beq.b	.1
.3	move.l	pen_2(a5),d0
	move.l	rastport(a5),a1
	lore	GFX,SetBPen
	move.l	pen_3(a5),d0
	move.l	rastport(a5),a1
	lob	SetAPen
	bra.b	.2
.1
	* Filebrowser divider color
	* Special case for parent node:
	tst.b	l_divider(a3)
	bpl.b	.3
	* Filebrowser directory:
	move.l	pen_2(a5),d0
	move.l	rastport(a5),a1
	lore	GFX,SetAPen
.2
	pop	a1
.nodi

	* name to print
	move.l	a2,a0		

	lea	-300(sp),sp
	tst.b	l_remote(a3)
	beq.b	.local
	move.l	a0,d0
	* Remote entries formatting
	move.l	sp,a1
.unescape
	move.b	(a0)+,d0
	cmp.b	#"_",d0
	bne.b	.noU
	move.b	#" ",(a1)+
	bra.b	.unescape
	;move.b	#":",(a1)+
	;move.b	#" ",(a1)+
;	move.b	#" ",(a1)+
;	move.b	#"-",(a1)+
;	move.b	#" ",(a1)+
;	bra.b	.unescape
;.noSlsh
.noU
	move.b	d0,(a1)+
	bne.b	.unescape

	* cleaned up name 
	move.l	sp,a0
.local

	* target x, y
	moveq	#33+WINX,d0
	move.l	d6,d1
	* progress to next vertical line 
	add	listFontHeight(a5),d6

	; Adjust y-position according to baseline,
	; so it will hit the exact spot
	move.l	listfontbase(a5),a1
	add	tf_Baseline(a1),d1
	subq	#6,d1
	push	d1	; save start y

	* Favorites are bolded, skip this if feature disabled
	tst.b	favorites(a5)
	beq.b	.noFav
	isFavoriteModule a3
	beq.b	.noFav
	cmp.b 	#LISTMODE_FAVORITES,listMode(a5)
	beq.b	.noBold
	jsr	printBold
	bra.b	.wasFav
.noFav
.noBold
	jsr	print
.wasFav
	; Clear the line towards the right edge of rastport
	move.l	rastport(a5),a1	
	lore	GFX,ClearEOL

	pop	d1	; restore start y
	
	lea		300(sp),sp * name buffer

	; Display random marker if needed
	tst.b	d7		* divider will not have a random play marker
	bne.b	.noMarker
	cmp.b	#pm_random,playmode(a5)
	bne.b	.noMarker
	* Random play mode magic check: Add a marker to the end to indicate module has been played?
	* Here the module index is needed
	move.l 	d3,d0 
	bsr	testRandomTableEntry ; keeps d1 is safe
	beq.b	.noMarker

	* marker x-pos relative to the right edge
	moveq	#-12,d0
	add	WINSIZX(a5),d0

	* Go back the amount of pixels for the marker
	move.l	rastport(a5),a1
	move.l	rp_Font(a1),a1
	lea	.marker(pc),a0
	
	* See if the marker has a glyph in the font
	move	#"Æ",d2
	cmp.b	tf_HiChar(a1),d2
	bls.b	.yesRmark
	* Use alternative
	moveq	#"*",d2
.yesRmark
	move.b	d2,(a0)

	* How many pixels does it take
	tst.l	tf_CharSpace(a1)
	beq.b	.noCharSpace
	* Check individual char spaces, prop fonts
	sub.b	tf_LoChar(a1),d2
	add	d2,d2
	move.l	tf_CharSpace(a1),a1
	sub	(a1,d2),d0
	bra.b	.hadCharSpace
.noCharSpace
	* Fixed width font
	sub	tf_XSize(a1),d0	

.hadCharSpace
	jsr	print ; print marker to d0, d1
.noMarker

	* Set ordinary colors if divider was previously printed
	tst.b	d7
	beq.b	.nodiv
	move.l	pen_0(a5),d0
	move.l	rastport(a5),a1
	lore	GFX,SetBPen
	move.l	pen_1(a5),d0
	move.l	rastport(a5),a1
	lob	SetAPen
.nodiv

	* loop until all names printed
	addq.l	#1,d3 	 	* next module index
	dbf	d5,.looppo
.lop	
	* Lines printed

	* Restore normal font
	move.l	rastport(a5),a1
	move.l	fontbase(a5),a0
	lore	GFX,SetFont

	jsr	removeListBoxClip

	bra 	releaseModuleList
	
.marker	dc.b	0,0


***** Katkaisee prefixin nimest‰ a0:ssa
 REM
cut_prefix:
;	isListDivider (a0)		* onko divideri?
;	beq.b	.xx

	pushm	d0/a1
	move.b	prefixcut(a5),d0
	beq.b	.x
	move.l	a0,a1
	ext	d0
;	subq	#1,d0
.l	cmp.b	#".",(a0)+
	beq.b	.x
	tst.b	-1(a0)
	beq.b	.h
	dbf	d0,.l
.h	move.l	a1,a0
	
.x	popm	d0/a1
.xx	rts
 EREM

* in:
*   a0 = test pointer with two chars to convert
* out: 
*   d0 = number
;convertHexTextToNumber
;	pushm	d1-d3
;	moveq	#2-1,d2
;	moveq	#4,d1
;	moveq	#0,d0
;.loop
;	moveq	#0,d3
;	move.b	(a0)+,d3
;	cmp.b	#"a",d3
;	bhs.b	.hih 
;	cmp.b	#"A",d3
;	bhs.b	.hi 
;	sub.b	#"0",d3
;	bra.b	.lo
;.hih
;	sub.b	#"a"-10,d3
;	bra.b	.lo
;.hi
;	sub.b	#"A"-10,d3
;.lo
;	lsl	d1,d3
;	or	d3,d0
;	subq	#4,d1
;	dbf	d2,.loop
;	popm	d1-d3
;	rts

*******************************************************************************
* Deletoidaan yksi tiedosto listasta
*******

* right mouse button + Del button
hiiridelete
	skipIfGadgetDisabled gadgetDelButton
	tst.l	chosenmodule(a5)
	bmi.b	.noChosen
	bsr	areyousure_delete
	tst.l	d0
	bne.b	rbutton8b
.noChosen
	rts

rbutton8b
	skipIfGadgetDisabled gadgetDelButton
.l	moveq	#1,d7		* DELETE from DISK!
	bsr.b	delete\.elete
	tst.b	deleteflag(a5)
	bne.b	.l
	bra	resh

rbutton8
deleteButtonAction
delete
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	bne.b	.9
	jmp	fileBrowserGoToParent
.9
	skipIfGadgetDisabled gadgetDelButton
	moveq	#0,d7
	bsr.b	.elete
	bsr	resh
	clr.b	deleteflag(a5)
.skip
	rts
.elete
	bsr	confirmFavoritesModification
	beq.b	.skip

	clr.b	movenode(a5)
	moveq	#PLAYING_MODULE_NONE,d0
	move.l	d0,chosenmodule2(a5)
	st	hippoonbox(a5)
	bsr	listChanged

	move.l	chosenmodule(a5),d0
	bmi	.erer

	tst.l	playingmodule(a5)
	bmi.b	.huh	

	cmp.l	playingmodule(a5),d0	* onko dellattava sama kuin soitettava?
	beq.b	.sama

	subq.l	#1,playingmodule(a5)
	bpl.b	.huh
.sama	move.l	#PLAYING_MODULE_REMOVED,playingmodule(a5)

.huh	tst.l	modamount(a5)
	beq	.erer

	;lea	moduleListHeader(a5),a4
	bsr	getVisibleModuleListHeader
	move.l	a0,a4

	DPRINT	"delete getListNode"
	bsr	getListNode
	beq	.erer
	move.l	a0,a3
	
	tst.l	d7
	beq.b	.nmod

;	isListDivider l_filename(a3)
;	bne.b	.de
	tst.b	l_divider(a3)
	beq.b	.de
	not.b	deleteflag(a5)		 * Deleting a divider! Special action
	beq	.nmodo
	bra.b	.ni
.de
	tst.b	deleteflag(a5)
	bne.b	.ni

	pushm	all
	lea	.del(pc),a0
	bsr	printbox
	popm	all


	moveq	#-2,d5
	moveq	#0,d6
.noa
	lea	l_filename(a3),a0
	tst.b	l_remote(a3)	* can't delete remotes
	bne.b	.nmod
	move.l	a0,d1
	lore	Dos,DeleteFile	
	tst.l	d0
	bne.b	.nmod

* ei onnistunu.
	addq	#1,d5
	beq.b	.ni

	tst	d6
	bne.b	.noa

	pushm	d5/d6
	bsr	rbutton4	* ejektoidaan ja yritet‰‰n uusiks
	popm	d5/d6
	bra.b	.noa

.ni
** onko toisiks viimenen dellattava?
	move.l	modamount(a5),d0
	subq.l	#1,d0
	cmp.l	chosenmodule(a5),d0
	bne.b	.nmod
	clr.b	deleteflag(a5)

.nmod
	move.l	a3,a1
	lore	Exec,Remove
	move.l	a3,a0
 ifne DEBUG
    push    a0
    lea l_filename(a0),a0
    move.l  a0,d0
	DPRINT "Deleting %s"
    pop     a0
 endc


	bsr	freemem

	subq.l	#1,modamount(a5)
	bpl.b	.ak
	bne.b	.ak
	move.l	#PLAYING_MODULE_NONE,chosenmodule(a5)
	bra.b	.ee
.ak	
	move.l	modamount(a5),d0
	cmp.l	chosenmodule(a5),d0
	bne.b	.ee
	subq.l	#1,d0
	move.l	d0,chosenmodule(a5)
.ee
.nmodo
	st	hippoonbox(a5)
	bra	shownames
;	rts

.erer	clr.b	deleteflag(a5)
	rts

.del	dc.b	"-ªª>> Deleting file! <<´´-",0
 even	



***************************************************************************
*
* Execute file
*

execuutti
	lea	-300(sp),sp
	move.l	sp,a4
	clr.b	(a4)

	jsr	get_rt
	moveq	#RT_FILEREQ,D0
	sub.l	a0,a0
	lob	rtAllocRequestA
	move.l	d0,d7
	beq.b	.kex

	tst.b	uusikick(a5)
	beq.b	.ne
	move.l	lockhere(a5),d1
	pushpea	200(sp),d2
	moveq	#100,d3
	jsr	getNameFromLock
	lea	.tagz(pc),a0
	move.l	d7,a1
	pushpea	200(sp),4(a0)
	lore	Req,rtChangeReqAttrA
.ne
	lea	otag15(pc),a0
	move.l	d7,a1
	lea	(a4),a2		* tiedoston nimi

	lea	.title(pc),a3
	lob	rtFileRequestA		* ReqToolsin tiedostovalikko
	tst.l	d0
	beq.b	.kex

	move.l	d7,a0
	lea	100(a4),a1
	move.l	#'run ',(a1)+
	bsr	parsereqdir2
	addq	#1,a1
.c	move.b	(a4)+,(a1)+
	bne.b	.c

* sp+100 = ajettava komento

	pushpea	100(sp),d1
	moveq	#0,d2			* input
	move.l	nilfile(a5),d3		* output
	lore	Dos,Execute


.kex	lea	300(sp),sp
	rts

.tagz	dc.l	RTFI_Dir,0
	dc.l	TAG_END

.title	dc.b	"Select executable",0
 even

*******************************************************************************
* Kahden ylimm‰isen tekstirivin hommat (loota)
*******
* 30 merkki‰ leve‰ alue

inforivit_clear:
	movem.l	d0-d4,-(sp)
	moveq	#7+WINX,d0
	move	infoBoxTopEdge(a5),d1
	move	d1,d3
	add		infoBoxHeight(a5),d3
	move	WINSIZX(a5),d2
	sub		#10,d2	* side margin
	;moveq	#28+WINY,d3
	bsr	tyhjays
	movem.l	(sp)+,d0-d4
	rts

inforivit_clear_2ndrow:
	movem.l	d0-d4/a0,-(sp)
	moveq	#7+WINX,d0
	move	infoBoxTopEdge(a5),d1
  	move	d1,d3
    addq    #1,d1 * magic
	add		infoBoxHeight(a5),d3
	move	WINSIZX(a5),d2
	sub		#10,d2	* side margin

    move    infoBoxHeight(a5),d4
    lsr     #1,d4
    add     d4,d1
    
	bsr	tyhjays
	movem.l	(sp)+,d0-d4/a0
	rts

inforivit_killerps3m
	lea	var_b,a5
inforivit_play:
	bsr.b	inforivit_clear
	tst.l	playingmodule(a5)
	bpl.b	.huh
	bra	bopb
	
.huh

	moveq	#0,d2

* Jos S3M, nime‰ ei tartte siisti‰.

	cmp	#pt_multi,playertype(a5)
	bne	.eer

	move.l	ps3m_mtype(a5),a0
	cmp	#mtMOD,(a0)		* MODeissa ei konvertointia
	seq	d2

	lea	asciitable,a2		* konvertoidaan PC -> Amiga

	move.l	ps3m_mname(a5),a0
	move.l	(a0),a0
	lea	modulename(a5),a1
	move.l	#INFO_MODULE_NAME_LEN-1,d0
	moveq	#0,d1
.copc	move.b	(a0)+,d1

	tst.b	d2
	beq.b	.htht
	move.b	d1,(a1)+
	bra.b	.hth
.htht	
	move.b	(a2,d1),(a1)+
.hth	dbeq	d0,.copc
	clr.b	(a1)

	move.l	ps3m_numchans(a5),a0
	move	(a0),d2

	move.l	ps3m_mtype(a5),a0
	move	(a0),d0
	move	d0,d3

	lea	.1(pc),a0
	subq	#1,d0
	beq.b	.hee 	; s3m
	lea	.2(pc),a0
	subq	#1,d0
	beq.b	.hee2	; Pro/Fasttracker
	lea	.3(pc),a0
	subq	#1,d0
	beq.b	.hee  	; mtm
	lea	.4(pc),a0
	subq	#1,d0
	beq.b	.hee  	; xm
	moveq	#0,d2  	; it: clear channel count for
	lea	 .5(pc),a0
.hee	move.l	a0,d1

	cmp	#mtMOD,d3
	bne	.leer
	pushm	d1/d2
	bsr	siisti_nimi
	popm	d1/d2
	bra	.leer

.hee2
	; ensure zero termination for pt mods?
	lea	modulename(a5),a1
	clr.b	20(a1)
	bra.b	.hee

.1	dc.b	"Screamtracker ]I[",0
.2	dc.b	"Pro/Fasttracker",0
.3	dc.b	"Multitracker",0
.4	dc.b	"Fasttracker ][",0
.5	dc.b	"ImpulseTracker [DP]",0
 even

.eer	bsr	siisti_nimi

	move.l	playerbase(a5),a0
	lea	p_name(a0),a0
	move.l	a0,d1

	tst.b	oldst(a5)
 	beq.b	.leer
	pushpea	.oldst(pc),d1
	bra.b	.leer
.oldst	dc.b	"Old Soundtracker",0
 even
.leer

	lea	modulename(a5),a0
	move.l	a0,d0

    * Display additional "AHI" if running PS3M in AHI mode
    pushpea type_notAhi(pc),d3
    cmp     #pt_multi,playertype(a5)
    bne     .notAhi
    tst.b   ahi_use_nyt(a5)
	bne		.yesAhi
    cmp.b   #sm_stereo14,s3mmode2(a5)
    bne     .not14
    pushpea type_14bit(pc),d3
    bra     .notAhi
.yesAhi
    pushpea type_ahi(pc),d3
	tst.b	ps3mamigus(a5)
	beq		.notAG
    pushpea type_agus(pc),d3	
.notAG
.not14
.notAhi

    * d0 = name; d1 = type; d2 = AHI/not ahi
	lea	tyyppi1_t(pc),a0
	tst	d2			* PS3M channel count
	beq.b	.ic
    * d0 = name; d1 = type; d2 = channel count; d3 = AHI/not ahi
	lea	tyyppi2_t(pc),a0
    bra     .icc
.ic	
    move.l  d3,d2
.icc

    bsr	desmsg

	lea	desbuf(a5),a2		* moduletyyppi talteen
	move.l	a2,a0
	lea	moduletype(a5),a1
.ol	cmp.b	#10,(a2)+
	bne.b	.ol
	addq.l	#6,a2           * skip "Type: "
.cep	move.b	(a2)+,(a1)+
	bne.b	.cep
	clr.b	(a1)

bipb
	;moveq	#18+WINY,d1
	move	infoBoxTopEdge(a5),d1
bipb2	
	;addq	#7,d1 * magic offset
	moveq	#11+WINX,d0
	printt "TODO TODO: length check"
	bsr		infoBoxPrint
    jsr     initInfoScroller
    DPRINT  "infoBoxPrint"
bopb	rts

putinfo:
	bsr	inforivit_clear
	bra.b	bipb

* In:
*   a0 = text
*   d0 = x
*   d1 = y
;printInfoBox:
infoBoxPrint:
    tst.b   win(a5)
    beq     .x
	jsr		setInfoBoxClip
	pushm	d0/d1/a0
	move.l	rastport(a5),a1
	move.l	listfontbase(a5),a0
	lore	GFX,SetFont
	popm	d0/d1/a0
	move.l	listfontbase(a5),a1
	add		tf_Baseline(a1),d1
	addq	#1,d1 * magic constant
	jsr		print
	move.l	rastport(a5),a1
	move.l	fontbase(a5),a0
	lore	GFX,SetFont	
	jsr		removeInfoBoxClip
.x	rts

* 2nd row
putinfo2:
	move	infoBoxTopEdge(a5),d1
	move.l	listfontbase(a5),a1
	add		tf_YSize(a1),d1	* to 2nd row
	bra	bipb2	


putinfo2centered:
    tst.b   win(a5)
    bne.b   .11
    rts
.11
    pushm   d0/a0
    move.l	rastport(a5),a1
	move.l	listfontbase(a5),a0
	lore	GFX,SetFont
    popm    d0/a0
    move.l  a0,a2
    move.l  rastport(a5),a1
    lob     TextLength
    * d0 = pixels


    * Complicated centering logic
	moveq	#7+WINX,d1
    add     windowleft(a5),d1
    move    WINSIZX(a5),d2
    sub     #10,d2
    sub     d1,d2
    sub     d0,d2
    bpl.b   .1
    moveq   #0,d2
.1
    lsr     #1,d2
    move    d2,d0
    add     #11+WINX,d0

    move.l  a2,a0
	move	infoBoxTopEdge(a5),d1
	move.l	listfontbase(a5),a1
	add		tf_YSize(a1),d1	* to 2nd row
    bsr     inforivit_clear_2ndrow
    * Will also set and restore font:
	bra		infoBoxPrint

infolines_loadToChipMemory
	lea	.1(pc),a0
	bra		putinfo
.1	dc.b	"Loading to chip memory...",0
 even

infolines_loadToPublicMemory
	lea	.1(pc),a0
	bra		putinfo
.1	dc.b	"Loading to public memory...",0
 even

 
inforivit_tfmxload
	lea	.1(pc),a0
	bra		putinfo
.1	dc.b	"Loading TFMX samples...",0
 even

inforivit_ppload
	lea	.1(pc),a0
	bra		putinfo2
.1	dc.b	"PowerPacker file",0
 even

inforivit_pause
	lea	.1(pc),a0
    moveq   #.1e-.1,d0
	bra	putinfo2centered
;.1	dc.b	"        *** Paused ***        ",0
.1	dc.b	"-=-=-=-=-=- Paused -=-=-=-=-=-",0
.1e
 even


inforivit_xpkload
	lea	.1(pc),a0
	lea	probebuffer+8(a5),a1
	move.l	a1,d0
	jsr	desmsg
	lea	desbuf(a5),a0
	bra	putinfo2
.1	dc.b	"XPK %4s",0
 even

inforivit_xpkload2
	lea	.1(pc),a0
	bra	putinfo
.1	dc.b	"Identifying XPK file...",0
 even

inforivit_fimpload
	lea	.1(pc),a0
	bra	putinfo2
.1	dc.b	"FImp file",0
 even

inforivit_fimpdecr
	lea	.1(pc),a0
	bra	putinfo
.1	dc.b	"Exploding...",0
 even

inforivit_xfd
	lea	.1(pc),a0
	jsr	desmsg	
	lea	desbuf(a5),a0
	bra	putinfo
.1	dc.b	"XFD decrunching...",10
	dc.b	"%-30s",0
 even


inforivit_errc
	lea	.1(pc),a0
	bra	putinfo
.1	dc.b	"*** ERROR ***",10
	dc.b	"Skipping...",0
 even

inforivit_initerror
	lea	.1(pc),a0
	bra	putinfo
.1	dc.b	"Initialization error!",0
 even

inforivit_warn
	lea	.1(pc),a0
	bra	putinfo
.1	dc.b	"*** Warning! ***",10
	dc.b	"File was loaded in chip ram! ",0
 even

inforivit_group
	lea	.1(pc),a0
	bra	putinfo
.1	dc.b	"Loading player group...",0
 even

inforivit_group2
	lea	.1(pc),a0
	bra	putinfo
.1	dc.b	"Loading replayer...",0
 even

inforivit_extracting
	lea	.1(pc),a0
	tst	d6
	beq.b	.q
	lea	.2(pc),a0
	subq	#1,d6
	beq.b	.q
	lea	.3(pc),a0
.q	bra	putinfo
.1	dc.b	"LhA extracting...",0
.2	dc.b	"UnZipping...",0
.3	dc.b	"LZX extracting...",0
 even

inforivit_downloading
	lea	.1(pc),a0
	bra	putinfo
.1	dc.b	"Downloading...",0
 even
inforivit_connecting
	lea	.1(pc),a0
	bra	putinfo
.1	dc.b	"Connecting...",0
 even


;inforivit_initializing
;	lea	.1(pc),a0
;	bra	putinfo2
;.1	dc.b	"Initializing...",0
; even
;
;inforivit_identifying
;	lea	.1(pc),a0
;	bra	putinfo
;.1	dc.b	"Identifying...",0
; even
;
* Siistit‰‰n moduulin nimi 

siisti_nimi
	lea	modulename-1(a5),a0
	bsr.b	.cap
.loo	addq.l	#1,a0
	tst.b	(a0)
	beq.b	.end
	cmp.b	#' ',(a0)
	beq.b	.jee
	cmp.b	#'-',(a0)
	beq.b	.jee
	cmp.b	#'(',(a0)
	beq.b	.jee
	cmp.b	#')',(a0)
	beq.b	.jee
	cmp.b	#'<',(a0)
	beq.b	.jee
	cmp.b	#'>',(a0)
	beq.b	.jee
	cmp.b	#'_',(a0)
	beq.b	.jee
	bra.b	.loo
.end
	rts


.jee	tst.b	1(a0)
	beq.b	.end
	bsr.b	.cap
	bra.b	.loo

.cap	
	cmp.b	#'a',1(a0)		* Jos mahdollista, muutetaan
	blo.b	.m			* kirjain isoksi.
	cmp.b	#'z',1(a0)
	bhi.b	.m
	and.b	#$df,1(a0)

	cmp.b	#'I',1(a0)
	bne.b	.m
	cmp.b	#'i',2(a0)
	bne.b	.m
	and.b	#$df,2(a0)
	cmp.b	#'i',3(a0)
	bne.b	.m
	and.b	#$df,3(a0)
.m	rts

	printt	"todo: align name and type for extra nicety"

tyyppi1_t	dc.b	"Name: %s",10
tyyppi1b_t  dc.b	"Type: %s%s",0

tyyppi2_t	dc.b	"Name: %s",10
		dc.b	"Type: %s %ldch%s",0
typpi

type_ahi    dc.b    " AHI"
type_notAhi dc.b    0
type_14bit  dc.b    " 14-bit",0
type_agus   dc.b    " AGUS",0
 even



*******************************************************************************
* Loota (otsikkopalkki tiedot)
*******

* Set the start time of the module playback
* Also stores whether the module playback was started in AHI mode
settimestart
	move.b	ahi_use(a5),ahi_use_nyt(a5)	* ahi:n tila talteen

	pushm   all
    bsr     getCurrentTimeInSecs
	move.l	d0,aika1(a5)
	check	3
	popm	all
	rts


* Out:
*   d0 = System time relative to the 1st day of the year 1978 in seconds
getCurrentTimeInSecs:
    lea     -12(sp),sp
    move.l  sp,d1
	lore	Dos,DateStamp
    move.l (sp)+,d0
    * convert days into secs
    move.l  #24*60*60,d1
    bsr     mulu_32
    * convert minutes into secs
    move.l  (sp)+,d1
	mulu	#60,d1
    add.l   d1,d0
    * convert ticks to secs
    move.l  (sp)+,d1
    divu    #50,d1
    ext.l   d1
    add.l   d1,d0
    rts

* 0= 	dc.b	8+4,"Time, pos/len, song",0
* 1= 	dc.b	0,"Time/duration, pos/len",0
* 2= 	dc.b	2*8,"Clock, free memory",0
* 3=		4*8,"Module name",0


lootaa					* p‰ivitet‰‰n kaikki

	bsr	lootaan_kello
;	bsr	lootaan_muisti
	bsr	lootaan_nimi
;	bsr.b	lootaan_aika		
;	rts

lootaan_pos

;lootaan_song
;	moveq	#1,d0

* Does both TITLEBAR_TIME_POSLEN_SONG and TITLEBAR_TIMEDUR_POSLEN	
lootaan_aika
	moveq	#0,d0
	tst	lootamoodi(a5)  * TITLEBAR_TIME_POSLEN_SONG
	beq.b	.ook
	cmp	#TITLEBAR_TIMEDUR_POSLEN,lootamoodi(a5)
	beq.b	.ook
	rts
.ook	
	pushm	all
	clr.b	do_alarm(a5)		* sammutetaan her‰tys

	clr	lootassa(a5)		    * TITLEBAR_TIME_POSLEN_SONG 	

* ajan p‰ivitys (datestamp-magic)

	;tst	d0			* mit‰ t‰‰ tekee?
	;bne.b	.npa

	move.l	aika2(a5),d3
    bsr     getCurrentTimeInSecs
	move.l	d0,aika2(a5)

	cmp	#pt_multi,playertype(a5)
	bne.b	.je
	cmp.b	#5,s3mmode1(a5)		* killer
	beq.b	.not
.je
	tst.b	playing(a5)
	bne.b	.npa

.not

	sub.l	d3,d0
	add.l	d0,aika1(a5)		* erotus samana jos ei soiteta
.npa

	move.l	aika2(a5),d0
	sub.l	aika1(a5),d0

  ;;  DPRINT  "Current time=%ld"
    
	move.l	d0,hippoport+hip_playtime(a5)

    ; ---------------------------------

************* t‰h‰n timeout!
	move	timeout(a5),d1
	beq     .ok0
	;mulu	#50,d1
    ext.l   d1

	cmp.l	d1,d0
	blo    	.ok0

	DPRINT 	"Timeout triggered %ld"

	cmp.l	#1,modamount(a5)	* 0 tai 1 modia -> ei timeouttia
	bls 	.ok0

	tst.b	timeoutmode(a5)		* timeout-moodi
	beq 	.all			* -> kaikille modeille

    * Special case check:
    * Streamed sample with no content length
    * should not be interrupted with a timeout
    cmp     #pt_sample,playertype(a5)
    bne     .notSample
    jsr     streamIsAlive
    beq     .notSample
    jsr     streamGetContentLength
    beq     .ok0
.notSample  

	move.l	playerbase(a5),a0	* vain niille, joilla ei ole
	move	p_liput(a0),d1		* end-detectia.
	btst	#pb_end,d1		* onko end-detect?
	bne.b	.ok0			* -> on
	btst	#pb_poslen,d1		* poslenist‰ voidaan p‰‰tell‰ end-detect
	bne.b	.ok0

.all	push	d0			* painetaan 'next'i‰ :)

	move	#$28,rawkeyinput(a5)	* NEXT!

	* In random play mode let's just select the next random
	* module instead of going through the subsongs.
	cmp.b	#pm_random,playmode(a5)	
	beq.b	.nosongs
	
	move.l	playerbase(a5),a0	
	move	p_liput(a0),d1		
	btst	#pb_song,d1
	beq.b	.nosongs
	move	songnumber(a5),d0
	cmp	maxsongs(a5),d0
	beq.b	.nosongs
	move	#$4e,rawkeyinput(a5)	* next song
.nosongs

	move.b	rawKeySignal(a5),d1
	bsr	signalit
	pop	d0
.ok0
    ; ---------------------------------
    ; Early load - disabled 
    
;	move.b	earlyload(a5),d1
;	beq.b	.noerl
;	tst.b	playing(a5)
;	beq.b	.noerl
;
;	tst.b	do_early(a5)		* joko oli p‰‰ll‰?
;	bne.b	.noerl
;
;	move	pos_maksimi(a5),d2
;	sub	pos_nykyinen(a5),d2
;	cmp.b	d1,d2
;	bhi.b	.noerl
;
;	st	do_early(a5)
;	move	#$28,rawkeyinput(a5)
;	move.b	rawKeySignal(a5),d1
;	pushm	all
;	bsr	signalit
;	popm	all
;.noerl

    ; ---------------------------------

    * Use mp3 position if possible
    pushm    d0
    moveq   #0,d1
    cmp     #pt_sample,playertype(a5)
    bne     .notSamplee
    jsr     getMp3DurationInSeconds
    * d0 = position
    * d1 = total len
    move.l  d0,d1
.notSamplee
    popm     d0

	bsr	logo

    tst.l   d1  * position in secs
    beq     .notSecs
    move.l  d1,d0
    bra     .doSecs
.notSecs

    ;add.l  #(59*60+50)*50,d0    * 59:12
    ;add.l   #8*60*60*50,d0        * +8h
    ;add.l   #1*60*60*50,d0        * +1h

;    add.l  #(59*60+50),d0    * 59:12
;    add.l   #8*60*60,d0        * +8h
;    add.l   #1*60*60,d0        * +1h
    ;add.l   #8*60*60,d0        * +8h
    ;
    ;cmp.l   #10*60*60*50,d0      * upper limit: 10 hours, wrap
	cmp.l   #99*60*60,d0      * upper limit: 99 hours, wrap
	blo.b	.ok
	bsr	settimestart
	moveq	#0,d0
.ok

	;divu	#50,d0
.doSecs
    * d0 = total seconds

    moveq   #'0',d2

    divu    #60*60,d0
    * d0 = hours
    beq     .noHours
    * Handle tens of ours
    cmp     #10,d0
    blo.b   .smallHours
    moveq   #0,d1
    move.w  d0,d1
    divu    #10,d1
    add.b   d2,d1
    move.b  d1,(a0)+
    swap    d1
    move.w  d1,d0
    * hours 0-9 in d0.w
.smallHours
    add.b   d2,d0
    move.b  d0,(a0)+
    move.b  #":",(a0)+
.noHours
    swap    d0
    ext.l   d0
    * d0 = remaining seconds
	divu	#60,d0
	swap	d0
	moveq	#0,d1
	move	d0,d1
	clr	d0
	swap	d0

	divu	#10,d0
	add.b	d2,d0
	move.b	d0,(a0)+
	swap	d0
	add.b	d2,d0
	move.b	d0,(a0)+
	move.b	#':',(a0)+

	divu	#10,d1
	add.b	d2,d1
	move.b	d1,(a0)+
	swap	d1
	add.b	d2,d1
	move.b	d1,(a0)+

******

;    * SID song length?
;    cmp.w   #pt_sid,playertype(a5)
;    bne     .nosid
;    * SID length is stored here during song init:
;    tst.l   kokonaisaika(a5)    
;    bne    .koa
;.nosid
;	cmp	#pt_sample,playertype(a5)
;	beq.b	.koa
;	cmp  #pt_vgm_tnt,playertype(a5)
;	beq.b	.koa
;	cmp	#pt_prot,playertype(a5)
;	bne.b	.oai
;.koa	cmp	#TITLEBAR_TIMEDUR_POSLEN,lootamoodi(a5)
;	bne.b	.oai
;	
;
;	move.b	#'/',(a0)+
;	tst.l	kokonaisaika(a5)
;	bne.b	.aik
;	move.b	#'-',(a0)+
;	move.b	#'-',(a0)+
;	move.b	#':',(a0)+
;	move.b	#'-',(a0)+
;	move.b	#'-',(a0)+
;	bra.b	.oai
;.aik

    * Put total time if available
 	tst.l	kokonaisaika(a5)
	beq.b	.oai
	move.b	#'/',(a0)+

	moveq	#0,d0
	move	kokonaisaika(a5),d0
	divu	#10,d0
	add.b	#'0',d0
	move.b	d0,(a0)+
	swap	d0
	add.b	#'0',d0
	move.b	d0,(a0)+
	move.b	#':',(a0)+

	moveq	#0,d1
	move	kokonaisaika+2(a5),d1
	divu	#10,d1
	add.b	#'0',d1
	move.b	d1,(a0)+
	swap	d1
	add.b	#'0',d1
	move.b	d1,(a0)+
.oai

*****
	tst.l	playingmodule(a5)
	bmi	.jaa

    * Put position/length if available
	move.l	playerbase(a5),a1       
	move	p_liput(a1),d0
	btst	#pb_poslen,d0
	beq.b	.lootaan_song

	move.b	#" ",(a0)+
.lootaan_pos
	move	pos_nykyinen(a5),d0
	bsr	putnumber
	move.b	#'/',(a0)+
	move	pos_maksimi(a5),d0
	bsr	putnumber


.lootaan_song
    * Put songnumber if available

	move.l	playerbase(a5),a1
	move	p_liput(a1),d0
	btst	#pb_song,d0
	beq.b	.jaa

    * Protracker case
    cmp     #pt_prot,playertype(a5)
    bne     .noPt
    cmp.b	#$ff,ptsonglist+1(a5)	* onko enemm‰n kuin yksi songi??
    beq     .jaa    * show nothing if PT and no subsongs
.noPt

    * If just one song then display nothing
	move	maxsongs(a5),d2
	addq	#1,d2
	sub		minsong(a5),d2  
    cmp     #1,d2
    bls     .jaa

    * Put current song
	move	songnumber(a5),d0
	addq	#1,d0
	sub	minsong(a5),d0
	move.b	#' ',(a0)+
	move.b	#'#',(a0)+
	bsr	putnumber
    * Put max song
	move.b	#"/",(a0)+
    move.w  d2,d0
	bsr	putnumber

; Original logic:
;	cmp	#pt_prot,playertype(a5)
;	bne.b	.pot
;	cmp	#TITLEBAR_TIMEDUR_POSLEN,lootamoodi(a5)
;	beq.b	.jaa
;.pot

;	move	songnumber(a5),d0
;	addq	#1,d0
;	sub	minsong(a5),d0
;
;	move.b	#' ',(a0)+
;	move.b	#'#',(a0)+
;	bsr	putnumber
;
;	cmp	#pt_prot,playertype(a5)		* ei maxsongeja
;	bne.b	.nptr
;	cmp.b	#$ff,ptsonglist+1(a5)	* onko enemm‰n kuin yksi songi??
;	bne.b	.nptr
;.ql	cmp.b	#'#',-(a0)		* jos vain yksi, ei songnumberia!
;	bne.b	.ql
;	bra.b	.jaa
;.nptr
;	move.b	#"/",(a0)+
;	moveq	#0,d0
;	move	maxsongs(a5),d0
;	addq	#1,d0
;	sub		minsong(a5),d0
;	bsr	putnumber
.jaa	

;	tst.b	uusikick(a5)	
;	beq.b	.eisitten

;	cmp.b	#' ',-1(a0)
;	beq.b	.piz
;	move.b	#' ',(a0)+		* tungetaan aina modnimi v‰liin
;.piz	lea	modulename(a5),a1
;	moveq	#40-1,d0
;.he	move.b	(a1)+,(a0)+
;	dbeq	d0,.he

;.eisitten	* vanhalla kickill‰ ei, koska se sotkee gadgetit jos liian pitk‰
		* uudella tulee errori amigaguidella scrollailtaessa jos
		* teksti menee reunuksen yli.. kai. 
		

	clr.b	(a0)

	bra	lootaus





lootaan_kello
	cmp	#TITLEBAR_CLOCK_FREEMEM,lootamoodi(a5)
	beq.b	.ook
	rts
.ook
	pushm	all
	moveq	#0,d7

	lea	-16(sp),sp
	move.l	sp,d1
	lore	Dos,DateStamp
	move.l	4(sp),d1
	lea	16(sp),sp
	cmp	#TITLEBAR_CLOCK_FREEMEM,lootassa(a5)
	bne.b	.erp
	cmp	vanhaaika(a5),d1
	bne.b	.erp
	addq	#1,d7

.erp	move	#TITLEBAR_CLOCK_FREEMEM,lootassa(a5)

	move	d1,vanhaaika(a5)
	divu	#60,d1			* tunnit/minuutit
	move.l	d1,d2

	move	d1,d3
	lsl	#8,d3			* d3 = alarm-vertaus


	lea	-10(sp),sp
	move.l	sp,a0
	move	d1,d0
	bsr	putnumber2
	move.b	#":",(a0)+
	move.l	d2,d0
	swap	d0
	add	d0,d3
	bsr	putnumber2
	clr.b	(a0)
	move.l	sp,a3

	cmp.b	#2,do_alarm(a5)
	beq.b	.noal
	cmp	alarm(a5),d3
	bne.b	.noal
	addq.b	#1,do_alarm(a5)
.noal


	moveq	#MEMF_CHIP,d1
	lore	Exec,AvailMem
	move.l	d0,d4
	moveq	#MEMF_FAST,d1
	lob	AvailMem
	move.l	d0,d5

	moveq	#10,d1
	lsr.l	d1,d4
	lsr.l	d1,d5
	
	cmp	oldchip(a5),d4
	bne.b	.new
	cmp	oldfast(a5),d5
	bne.b	.new
	addq	#1,d7
.new
	move	d4,oldchip(a5)
	move	d5,oldfast(a5)

	cmp	#2,d7
	bne.b	.pr
	lea	10(sp),sp
	bra	xloota
.pr

	move.l	a3,d0
	moveq	#0,d1
	moveq	#0,d2
	move	d4,d1
	move	d5,d2
	lea	.form(pc),a0
	jsr	desmsg
	lea	10(sp),sp

	bra.b	lootaus

.form	dc.b	"HiP %s c%ld f%ld",0
 even

lootaan_nimi
	cmp	#TITLEBAR_NAME,lootamoodi(a5)
	beq.b	.ook
	rts
.ook
	pushm	all
	clr.b	do_alarm(a5)		* sammutetaan her‰tys
	move	#TITLEBAR_NAME,lootassa(a5)

	bsr.b	logo
	lea	modulename(a5),a1
	move.l	#INFO_MODULE_NAME_LEN-1,d0
.he	move.b	(a1)+,(a0)+
	dbeq	d0,.he
	clr.b	(a0)

lootaus

* Tulostetaan vain jos on muuttunut!

	lea	desbuf(a5),a0
	lea	wintitl(a5),a2
	move.l	a2,a1
.c	move.b	(a0)+,(a2)+
	bne.b	.c

	lea	wintitl2(a5),a0
	move.l	a1,a2

.fpel	move.b	(a0)+,d1
	move.b	(a2)+,d0
	beq.b	.e
	cmp.b	d0,d1
	bne.b	.jep
	bra.b	.fpel
.e	tst.b	d1
	beq.b	xloota

.jep	lea	wintitl2(a5),a0
	move.l	a1,a2
.poa	move.b	(a2)+,(a0)+
	bne.b	.poa

	tst.b	win(a5)
	beq.b	xloota
	move.l	windowbase(a5),a0
	lea	-1.w,a2			* Screentitle (ei ole)
	lore	Intui,SetWindowTitles

xloota	popm	all
	rts	


* titleen mahtuu 23 kirjainta 8*8 fontilla.

;wintitl ds.b	80
;wintitl2 ds.b	80

logo	lea	desbuf(a5),a0
	rts
;	lea	.hip(pc),a1
;.c	move.b	(a1)+,(a0)+
;	bne.b	.c
;	move.b	#' ',-1(a0)
;	rts
;.hip	dc.b	"HiP ",0
; even

* a0 = mihink‰ laitetaan
* d0 = luku joka k‰‰nnet‰‰n ASCIIksi
putnumber2:
	st	d1
	bra.b	putnu
putnumber:
	moveq	#0,d1
putnu	ext.l	d0
	divu	#100,d0
	beq.b	.e
	or.b	#'0',d0
	move.b	d0,(a0)+
	st	d1
.e
	clr	d0
	swap	d0
	divu	#10,d0
	bne.b	.b
	tst	d1
	beq.b	.c

.b	or.b	#'0',d0
	move.b	d0,(a0)+

.c	swap	d0
	or.b	#'0',d0
	move.b	d0,(a0)+
	rts


*******************************************************************************
* Hiiren nappuloita painettu, tutkitaan oliko tiedostojen p‰‰ll‰
* ja pistet‰‰n palkki
*******

* Out:
*   d0 = zero if no files hit under mouse, 1 otherwise
*   d1 = Index of selected file
getFileBoxIndexFromMousePosition:
	tst	boxsize(a5)
	beq	.out

	move	mousex(a5),d0
	move	mousey(a5),d1
	sub	windowleft(a5),d0
	sub	windowtop(a5),d1	* suhteutus fonttiin

	cmp	#30+WINX,d0		* onko tiedostolistan p‰‰ll‰?
	blo.b	.out

	; Left edge value
	move	WINSIZX(a5),d2
	sub	#9,d2
	;cmp	#251+WINX,d0
	cmp	d2,d0
	bhi.b	.out
	
	move	fileBoxTopEdge(a5),d2		* Top edge
	cmp	d2,d1
;	cmp	#63+WINY,d1
	blo.b	.out

	move	fileBoxTopEdge(a5),d2
	* use original height - original top edge to
	* get bottom edge:
	add		#126-63,d2	
	;move	#126+WINY,d2		* Bottom edge
	add	boxy(a5),d2		* Height of box
    sub     BOTTOM_MARGIN(a5),d2
	cmp	d2,d1
	bhi.b	.out

	* converts y-koordinate into a line number (font is 8 pix tall)
	sub	fileBoxTopEdge(a5),d1

 if DEBUG
 	push	d1
 	moveq	#0,d0
 	move	d1,d0
 	moveq	#0,d1
	move	mousey(a5),d1
 	DPRINT	"hit %ld mouseY=%ld"
 	pop	d1
 endif

; hit 44 -> line 5
; hit 58 -> line 7
;     81 ->      11

	* round up?
	;move	listFontHeight(a5),d0
	;lsr	#1,d0
	;add	d0,d1

	;lsr	#3,d1	
	ext.l	d1
	divu	listFontHeight(a5),d1

 if DEBUG
 	moveq	#0,d0
 	move	d1,d0
 	DPRINT	"line %ld"
 endif

	moveq	#1,d0			* success
	rts
.out  
	* nothing marked
	moveq	#0,d0 
	rts


* Calculates chosenmodule, which is an index of the selected item.
* Chosen line is highlighted and previously chosen line highlight removed.

markline:
	bsr getFileBoxIndexFromMousePosition
	beq.b  .out
	bsr.b	.doMark
	* something marked
	moveq	#1,d0
	rts
.out  
	* nothing marked
	moveq	#0,d0 
	rts

* filebox line number in d1
.doMark

	* list is empty
	; this may allow doubleclicking of empty list to open file req
	tst.l	modamount(a5)
	bne.b	.ona
	moveq	#0,d1		* ei oo modeja, otetaan eka
.ona
	ext.l	d1
	move.l	d1,d2
	add.l	firstname(a5),d1
	* See if clicking on an already chosen module
	cmp.l	chosenmodule(a5),d1
	beq.b	.oo
	* This does not seem to happen ever?
	cmp.l	#PLAYING_MODULE_REMOVED,chosenmodule(a5)
	beq.b	.oo2
	pushm	d1/d2
	bsr.b	unmarkit
	popm	d1/d2
.u	st	dontmark(a5)
.oo2	
.oo
.continue
	move.l	d1,chosenmodule(a5)
	move.l	d2,markedline(a5)

	move.l	clickmodule(a5),d3
	move.l	d1,clickmodule(a5)

	* double click test
	cmp.l	d1,d3
	bne.b	.nodouble
	move.l	#-1,clickmodule(a5)	

	subq.l	#8,sp
	lea	(sp),a0
	lea	4(sp),a1
	lore	Intui,CurrentTime
	movem.l	(sp)+,d2/d3
	movem.l	clicksecs(a5),d0/d1
	lob	DoubleClick
	tst.l	d0
	beq.b	.double
* Tiedostoa doubleclickattu! Soitetaan...
* Double click detected
	tst.b	doubleclick(a5)		* onko sallittua?
	bne	rbutton1		* Play!
	rts

.nodouble
	lea	clicksecs(a5),a0	* klikin aika talteen
	lea	clickmicros(a5),a1
	lore	Intui,CurrentTime
.double
	bsr	showNamesNoCentering
	bra	reslider

* Highlight line by xorring/complementing it
* Highlight is cleared by doing the same operation again on the same line.
unmarkit:			* pyyhitaan merkkaus pois
markit:
	move.l	chosenmodule(a5),d0

	* Bounds check
	cmp.l	modamount(a5),d0
	bhs.b	.outside

	move.l	markedline(a5),d5
	bmi.b	.outside
	moveq	#0,d0
	move	boxsize(a5),d0
    tst.w   searchLayoutActive(a5)   
    beq.b   .lm1
    subq    #SEARCH_BOXSIZE_DELTA,d0
.lm1
	cmp.l	d0,d5
	bhs.b	.outside
	tst.b	win(a5)
	beq.b	.outside

; TODO: this probably prevents clicking on empty parts of the list
;       to highlight lines
	; Why is the above done? remove?
;	move.l	d5,d1
;	bsr	 obtainModuleList
;	lea	moduleListHeader(a5),a4	
;	move.l	chosenmodule(a5),d0	* etsit‰‰n kohta
;.luuppo
	* a4=current node
	* a3=next node
	* test if at end
;	TSTNODE	a4,a3
;	beq.b	.nomods
;	move.l	a3,a4
;	;dbf	d0,.luuppo
;	subq.l #1,d0 
;	bpl.b  .luuppo

	move	d5,d1
	;lsl	#3,d1		* mulu #8,d1
	mulu	listFontHeight(a5),d1
	add		fileBoxTopEdge(a5),d1

	moveq	#33+WINX,d0 
	add	windowleft(a5),d0
	add	windowtop(a5),d1
	move	d0,d2
	move	d1,d3
;	move	#216,d4
	move	WINSIZX(a5),d4
	sub	#264-216-1,d4

	;moveq	#8,d5
	move	listFontHeight(a5),d5
	moveq	#$50,d6		* EOR
	
	move.l	rastport(a5),a1
	move.b	rp_Mask(a1),d7
	move.b	#%11,rp_Mask(a1)	* K‰sitell‰‰n kahta alinta bittitasoa.
	move.l	a1,a0
	lore	GFX,ClipBlit

	move.l	rastport(a5),a1
	move.b	d7,rp_Mask(a1)

.nomods
;	bsr	 releaseModuleList

.outside	
	rts

marklineRightMouseButton
	* Check if feature is enabled in prefs
	tst.b	favorites(a5)
	beq.b	.out
	bsr	 getFileBoxIndexFromMousePosition
	beq.b  .out
	* RMB was hit on top of the list.
	* In fav list ignore the click.
	cmp.b 	#LISTMODE_FAVORITES,listMode(a5)
	beq.b	.ou
	bsr.b	.doMark
	* something marked
.ou	moveq	#1,d0
	rts
.out  
	* nothing marked
	moveq	#0,d0 
	rts

.doMark
	moveq	#0,d0
	move	d1,d0
	move.l	d0,d3
	DPRINT	"RMB mark on line %ld"

	* To get node index add index of the first visible
	* item
	add.l	firstname(a5),d0
	move.l	d0,d4

	* Toggle for node at index d0
	bsr	toggleFavoriteStatus
	beq.b	.failed

	move.l	d4,d0
	* d0 contains the node index
	move	d3,d1 	* target y-line
	moveq	#1,d2   * just do one line
	push 	d3
	bsr	doPrintNames
	pop 	d3

	* see if this line happened to be chosen already.
	* in this case the highlight should be restored as it was just
	* wiped away above.
	cmp.l	 markedline(a5),d3	
	bne.b	.different
	bsr	markit
.different
	rts	
.notFile
.failed
	DPRINT	"Not favoriting this line"
	rts


*******************************************************************************
*** SECTION *******************************************************************
*
* List node utilities
*
*******************************************************************************


* Gets the chosen module list element 
* Out:
*    d0 = 0 if not found
*    d0 = 1 if data available
*    a3 = list node pointer
*** Chosenmodule node A3:een
getcurrent:
	tst.l	modamount(a5)
	beq.b	.q
	move.l	chosenmodule(a5),d0
	bpl.b	getcurrent2
.q	moveq	#0,d0
	rts

* Gets the chosen module list element into a3
* In:
*   d0 = Module index
* Out:
*    d0 = 0 if not found
*    d0 = 1 if data available
*    a3 = list node pointer
getcurrent2:
	bsr.b getListNode
	move.l	a0,a3
	rts


* Gets the list header that corresponds to the current list mode,
* either normal, or favorites list, or filebrowser list.
* Out:
*  a0 = list header address
getVisibleModuleListHeader:
	cmp.b 	#LISTMODE_FAVORITES,listMode(a5)
	beq.b	.isFav
	cmp.b	 #LISTMODE_BROWSER,listMode(a5)
	beq.b	.isBrowser
	cmp.b	 #LISTMODE_SEARCH,listMode(a5)
	beq.b	.isSearch
	lea	moduleListHeader(a5),a0
	rts
.isFav
	lea	favoriteListHeader(a5),a0
	rts
.isBrowser
	lea	fileBrowserListHeader(a5),a0
	rts
.isSearch
	lea	searchResultsListHeader(a5),a0
	rts
	

* When an element is moved, added, inserted, deleted,
* random bookkeeping must be reset,
* and cached node as well. They would otherwise
* no longer represent the list state correctly.
* Also set a flag, this is used to detect chnages in favorites
* content.
* In file browser mode contents can NOT be changed.

listChanged:
	DPRINT "List changed"
	bsr	clearCachedNode
	bsr	clear_random	
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	beq.b	.browser
	st	moduleListChanged(a5)
.browser
	rts

; TODO: list traversal end check should not be needed,
; unless for some reason listamount and list ocntents are
; not in sync

* Node getter
* in:
*   d0=index, 32-bit
* out:
*   a0=list node
*   Z=set if index is out of bounds
getListNode:
	DPRINT	"getListNode %ld"

	tst.l	modamount(a5)
	beq.b	.out
	cmp.l 	modamount(a5),d0
	bhs.b	.out

	jsr	obtainModuleList
	;lea	moduleListHeader(a5),a0
	bsr	getVisibleModuleListHeader

	move.l	a0,d1	* Sanity check
	beq.b	.out

	* When using dbf loop usually subtract 1, but here
	* one SUCC is needed to get to the head element
	* so don't subtract
	move.l	d0,d1
	swap	d0
.loop
	SUCC    a0,a0
	dbf	d1,.loop
	dbf	d0,.loop
	jsr	releaseModuleList

 if DEBUG
 	move.l	l_nameaddr(a0),d0
	DPRINT	"->found=%s"
 endc
	moveq	#1,d0 	* found
	rts
.out
	moveq	#0,d0
	rts



* Cached list node getter
* in:
*   d0 = index
* out:
*   a0 = list node
*   Z-flag = set if error (out of bounds), not set if ok
getListNodeCached

* algo (not actually used here):
* - if index is nearer head than cached node
*   - use head as cached reference node
* - else if index is nearer tail than cached node
*   - use tail as cached reference node
* - else
*   - use cached node as reference node

	tst.l	modamount(a5)
	beq.b	.out
	cmp.l 	modamount(a5),d0
	bhs.b	.out

	tst.l	cachedNode(a5)
	bne.b	.n
	* Get head node from the minimal list header
	bsr	getVisibleModuleListHeader
	move.l	MLH_HEAD(a0),cachedNode(a5)
	;move.l	moduleListHeader+MLH_HEAD(a5),cachedNode(a5)
	clr.l	cachedNodeIndex(a5)
.n
	move.l	cachedNodeIndex(a5),d1
	* New cached index
	move.l	d0,cachedNodeIndex(a5)
	;DPRINT	"Getlistnode to=%ld cached=%ld"
	move.l	cachedNode(a5),a0

	* See if cached is the same as requested:
	sub.l	d1,d0
	beq.b   .x
	bpl.b  	.forward2
	bra.b	.backward2

.x	* Same, just return
	moveq	#1,d0
	rts
.out
	moveq	#0,d0 * error
	rts

; These allow jump to be over 16 bits
.backward2 
	neg.l 	d0
	subq.l	#1,d0
	move.l	d0,d1
	swap 	d0
.bloop
	PRED   	a0,a0
	dbf 	d1,.bloop 
	dbf	d0,.bloop
	move.l 	a0,cachedNode(a5)
	rts 

.forward2
	subq.l	#1,d0
	move.l	d0,d1
	swap 	d0
.floop
	SUCC    a0,a0
	dbf 	d1,.floop 
	dbf	d0,.floop
	move.l 	a0,cachedNode(a5)
	rts

clearCachedNode
	clr.l	cachedNode(a5)	
	rts

*******************************************************************************
*** SECTION *******************************************************************
*
* Tooltip popup
*
*******************************************************************************

* in: 
*   a0=structure of
*       dc.b <width in characters>
*       dc.b <height in characters>
*       dc.b "string",0
showTooltipPopup

.wflags = WFLG_SIMPLE_REFRESH!WFLG_BORDERLESS
.idcmpflags = 0

	pushm	all
	move.l	a0,a4

	* where is the mouse?
	move	mousex(a5),d6 
	move	mousey(a5),d7

	move.l	windowbase(a5),a0	* main window
	add	wd_LeftEdge(a0),d6	* relative mouse position
	add	wd_TopEdge(a0),d7

	lea	.tooltipPopup(pc),a0		

	* set width based from given parameters
	* which provide width and height in chars
	moveq	#0,d5
	move.b	(a4),d5
	mulu	#8,d5
	add	#16,d5
	move	d5,nw_Width(a0)

	* center horizontally around the pointer
	lsr	#1,d5
	sub	d5,d6
	bpl.b	.oe
	moveq	#0,d6
.oe	move	d6,nw_LeftEdge(a0)

	* height
	moveq	#0,d5
	move.b	1(a4),d5
	mulu	#8,d5
	addq	#7,d5
	move	d5,nw_Height(a0)

	* place above pointer a bit
	sub	d5,d7
	subq	#8,d7
	move	d7,nw_TopEdge(a0)

	* see if it fits on screen and adjust
	bsr	tark_mahtu

	lore	Intui,OpenWindow
	move.l	d0,d5
	beq	.x
	DPRINT	"Tooltip opened %lx"
	move.l	d0,a0
	move.l	wd_RPort(a0),d7		* rastport
	move.l	a0,tooltipPopupWindow(a5)

	* set pens and font
	move.l	d7,a1
	move.l	pen_1(a5),d0
	lore	GFX,SetAPen
	move.l	d7,a1
	move.l	pen_0(a5),d0
	lob	SetBPen
	move.l	d7,a1
	move.l	fontbase(a5),a0
	lob	SetFont	

	moveq	#0,d4
	move.b	(a4)+,d4	* max leveys
	lsl	#3,d4

	moveq	#0,d5
	move.b	(a4)+,d5	* vaakarivej‰
	subq	#1,d5
	move.l	a4,a0

	* initial y-coordinate for the rows
	moveq	#10,d3
.prl	
	move	d3,d1
	moveq	#8,d0	* x-coord
	bsr.b	.print
	* next y
	addq	#8,d3
	* find next line
.eol
	tst.b 	(a0)+
	bne.b	.eol
	dbf	d5,.prl

	* d7 = rastport
	* draw a bordaer
	move.l	d7,a1
	lea	.tooltipPopup(pc),a0
	moveq	#0,plx1
	move	nw_Width(a0),plx2
	moveq	#0,ply1
	move	nw_Height(a0),ply2
	subq	#1,ply2
	subq	#1,plx2
	jsr	laatikko1
.x
	popm	all
	rts


.print	pushm	all
	move.l	d7,a4
	jmp	doPrint

* Tooltip window structure
.tooltipPopup
	dc	0,0	* paikka 
	dc	0,0	* koko
	dc.b	0,0	;palkin v‰rit
	dc.l	.idcmpflags
	dc.l	.wflags
	dc.l	0
	dc.l	0	
	dc.l	0	; title
	dc.l	0
	dc.l	0	
	dc	0,0	 * min x,y
	dc	1000,1000 * max x,y
	dc	WBENCHSCREEN
	dc.l	enw_tags

* Closes the tooltip popup if open.
* Also deactivates any tooltip that is about to open.
closeTooltipPopup
	pushm	all
	jsr	deactivateTooltip
	move.l	tooltipPopupWindow(a5),d0
	beq.b	.exit
	move.l	d0,a0
	bsr.b	flushWindowMessages
	move.l	tooltipPopupWindow(a5),a0
	lore	Intui,CloseWindow
	clr.l	tooltipPopupWindow(a5)
.exit 	
	popm	all
	rts


* Flush the window message queue. This should be done before closing window.
* This way the message sender can free the message data, if it was dynamically created.
* in:
*   a0 = intuition window
flushWindowMessages
	pushm 	d2/a6
	move.l	a0,d2
	bne.b	.loop
.exit
	popm    d2/a6
	rts
.loop
	move.l	d2,a0
	* Window may not have a user port, eg. if no IDCMP set 	
	move.l	wd_UserPort(a0),d0
	beq.b	.exit
	move.l	d0,a0
	lore	Exec,GetMsg
	tst.l	d0
	beq.b	.exit
	move.l	d0,a1
	lob	ReplyMsg
	bra.b	.loop


*******************************************************************************
* Lataa keyfilen
*******

loadkeyfile
	pushm	all
	move.l	_DosBase(a5),a6
	pushpea	keyfilename(pc),d1
	moveq	#_LVOOpen*4,d0
	move.l	#400,-(sp)
	add.l	#605,(sp)
	pop	d2
	bsr.b	.nixi	
	move.l	d0,d4
	beq.b	.error

	move.l	d4,d1
	pushpea	keyfile(a5),d2
	moveq	#64,d3
	lob	Read

	move.l	d4,d1
	lob	Close	

.error
	popm	all
	rts


.nixi	asr.l	#2,d0
	jmp	(a6,d0)



*******************************************************************************
*** SECTION *******************************************************************
*
* Info window
* - module info
* - about info
*
*******************************************************************************

sulje_foo
	cmp	#33,info_prosessi(a5)
	shs	oli_infoa(a5)
	rts

*** Sulkee module infon
sulje_info:
	cmp	#33,info_prosessi(a5)
	bhs.b	.joo
	clr.b	oli_infoa(a5)
	rts

.joo	
	pushm	d0/d1/a0/a1/a6
	move.l	info_task(a5),a1
	moveq	#0,d0
	move.b	info_signal(a5),d1
	bset	d1,d0
	lore	Exec,Signal	

.t	tst	info_prosessi(a5)	* odotellaan
	beq.b	.tt
	jsr	dela
	bra.b	.t
.tt
	popm	d0/d1/a0/a1/a6
	rts


	
start_info
	tst.b	oli_infoa(a5)
	bne.b	.j
	tst	info_prosessi(a5)
	beq.b	.x
.j
	tst	info_prosessi(a5)
	beq.b	rbutton10b
	move.l	info_task(a5),a1		* P‰ivityspyyntˆ!
	moveq	#0,d0
	move.b	info_signal2(a5),d1
	bset	d1,d0
	move.l	(a5),a6
	jmp	_LVOSignal(a6)


.x	clr.b	oli_infoa(a5)
	rts

infoWindowButtonAction
rbutton10b
	tst	info_prosessi(a5)
	bne.b	sulje_info

	movem.l	d0-a6,-(sp)
	move.l	_DosBase(a5),a6
	move.l	#infoprocname,d1
	move.l	priority(a5),d2

	move.l	#info_segment,d3
	lsr.l	#2,d3
	move.l	#4000,d4
	lob	CreateProc
	tst.l	d0
	beq.b	.n
	addq	#1,info_prosessi(a5)
.n	movem.l	(sp)+,d0-a6
.x	rts


metaData1  dc.b    "Authors: %s",0
metaData2  dc.b    "Publishers: %s",0
metaData3  dc.b    "Product: %s",0
metaData4  dc.b    "Year: %s"
 even
 
info_code:
	lea	var_b,a5
	addq	#1,info_prosessi(a5)

	sub.l	a1,a1
	lore	Exec,FindTask
	move.l	d0,info_task(a5)

	moveq	#-1,d0
	lob	AllocSignal
	move.b	d0,info_signal(a5)
	moveq	#-1,d0
	lob	AllocSignal
	move.b	d0,info_signal2(a5)

    * Switch process current dir so that STIL db can be found
    move.l  homelock(a5),d1 * This is available in kick2+, PROGDIR:
    bne     .n1
    move.l  lockhere(a5),d1 * Fallback option, the current dir
    beq     .n2
.n1 
    lore    Dos,DupLock
    move.l  d0,d1
    lob     CurrentDir
    move.l  d0,d1
    beq     .n2
    lob     UnLock
.n2

	bsr.b	.infocode

	move.b	info_signal(a5),d0
	jsr	freesignal
	move.b	info_signal2(a5),d0
	jsr	freesignal

	lore	Exec,Forbid
	clr	info_prosessi(a5)
	rts


************* Module info
.infocode

*** Avataan ikkuna
* 39 kirjainta mahtuu laatikkoon
* Linefeedi ILF joka myˆhemmin korvataan 10:ll‰. Sit‰varten ett‰ voidaan
* karsia ylim‰‰r‰set linefeedit pois.

ILF	=	$83
ILF2	=	$03

swflags set WFLG_SMART_REFRESH!WFLG_NOCAREREFRESH!WFLG_DRAGBAR
swflags set swflags!WFLG_CLOSEGADGET!WFLG_DEPTHGADGET!WFLG_RMBTRAP
sidcmpflags set IDCMP_CLOSEWINDOW!IDCMP_GADGETUP!IDCMP_MOUSEMOVE!IDCMP_RAWKEY
sidcmpflags set sidcmpflags!IDCMP_MOUSEBUTTONS!IDCMP_NEWSIZE
sidcmpflags set sidcmpflags!IDCMP_ACTIVEWINDOW!IDCMP_INACTIVEWINDOW


	tst.b	gotscreeninfo(a5)
	bne.b	.joo
	jsr	getscreeninfo
.joo

	lea	swinstruc,a0
	basereg swinstruc,a0
	move	nw_Height+swinstruc(a0),oldswinsiz(a5)
	move	gg_Height+gAD1(a0),oldsgadsiz(a5)

	move	infosize(a5),d0
	subq	#3,d0
	lsl	#3,d0
	add	d0,nw_Height+swinstruc(a0)
	add	d0,gg_Height+gAD1(a0)
	endb	a0

	; Set window size limits
	; Max height 50 lines
	move	oldswinsiz(a5),d0
	move	d0,nw_MinHeight(a0)
	add	#(50-3)*8,d0
	move	d0,nw_MaxHeight(a0)

	; fit into the screen
	
	move	wbkorkeus(a5),d2
.lo	cmp	nw_Height(a0),d2
	bhi.b	.fine
	
	clr	nw_TopEdge(a0)		* sijoitetaan mahd. ylˆs
	subq	#1,infosize(a5)
	subq	#8,nw_Height(a0)

	move	infosize(a5),d0
	subq	#3,d0
	lsl	#3,d0
	add	oldsgadsiz(a5),d0
	move	d0,gg_Height+gAD1
	bra.b	.lo

.fine
	move.l	infopos2(a5),(a0)
	bsr	tark_mahtu

	move.l	a0,a2
	basereg swinstruc,a2

	move	#7,slim2height(a2)
	
	lore	Intui,OpenWindow
	move.l	d0,swindowbase(a5)

	and.l	#~WFLG_ACTIVATE,sflags(a2) * clearataan active-flaggi
	move	d7,swinstruc+nw_Height(a2)
	endb	a2

	tst.l	d0
	bne.b	.koo
	lea	windowerr_t(pc),a1
	bsr	request
	bra	.sexit
.koo

	move.l	d0,a0
	move.l	wd_RPort(a0),srastport(a5)
	move.l	wd_UserPort(a0),suserport(a5)

	move.l	srastport(a5),a1
	move.l	fontbase(a5),a0
	lore	GFX,SetFont	
	
	move.l	swindowbase(a5),a0
	jsr	setscrtitle

	; Reset slider position
	lea	gAD1,a0
	move.l	gg_SpecialInfo(a0),a1
	move	pi_Flags(a1),d0
	move.l	swindowbase(a5),a1
	sub.l	a2,a2
	moveq	#0,d1
	moveq	#0,d2
	moveq	#0,d3
	moveq	#0,d4
	lore	Intui,ModifyProp

.redraw
	DPRINT	"Info redraw"
	move.l	srastport(a5),a2
	moveq	#4,d0
	moveq	#11,d1
	move	#356-5-2+2,d2
	moveq	#147-13*8-2,d3
	move	infosize(a5),d4
	subq	#3,d4
	lsl	#3,d4
	add	d4,d3
	bsr	drawtexture

	; set slider height
	move	infosize(a5),d0
	subq	#3,d0
	lsl	#3,d0
	add	oldsgadsiz(a5),d0
	;move	d0,gg_Height+gAD1

	lea	gAD1,a3
	move	d0,gg_Height(a3)

	movem	4(a3),plx1/ply1/plx2/ply2	* slider
	add	plx1,plx2
	add	ply1,ply2
	subq	#2,plx1
	addq	#1,plx2
	subq	#2,ply1
	addq	#1,ply2
	move.l	srastport(a5),a1
	jsr	sliderlaatikko

.reprint

	moveq	#29,plx1
	move	#351-3,plx2
	moveq	#13,ply1
	moveq	#143-13*8,ply2
	move	infosize(a5),d0
	subq	#3,d0
	lsl	#3,d0
	add	d0,ply2
	add	windowleft(a5),plx1
	add	windowleft(a5),plx2
	add	windowtop(a5),ply1
	add	windowtop(a5),ply2
	move.l	srastport(a5),a1

	* Select box frame depending on if info or about window
	lea	laatikko2,a0
	tst.b	infolag(a5)
	bne.b	.a
	cmp	#pt_prot,playertype(a5)
	bne.b	.a
	lea	laatikko1,a0
.a	jsr	(a0)

	moveq	#31-2+2,d0		* tyhjennet‰‰n
	moveq	#15-1,d1
	move	#350-31-5+2,d4
	moveq	#144-15-13*8,d5
	move	infosize(a5),d6
	subq	#3,d6
	lsl	#3,d6
	add	d6,d5
	add	windowleft(a5),d0
	add	windowtop(a5),d1
	move.l	srastport(a5),a0
	move.l	a0,a1
	move	d0,d2
	move	d1,d3
	moveq	#$0a,d6
	lore	GFX,ClipBlit
	st	skokonaan(a5)

	jsr	obtainModuleData
	bsr	.prepareInfoWindowContent
	jsr	releaseModuleData
	; check if got data
	tst.l	infotaz(a5)
	beq	.sexit


	clr	riviamount(a5)
	move.l	infotaz(a5),a0
.fii	tst.b	(a0)
	beq.b	.kii
	cmp.b	#10,(a0)+
	bne.b	.fii
	addq	#1,riviamount(a5)
	bra.b	.fii
.kii

	bsr	.print

	clr	sfirstname(a5)
	bsr	.reslider
	bsr	.refreshInfoWindowResizeGadget

*** Info window message loop
.SKIP
	DPRINT	"info msg loop"
	bra.b	.msgLoop
.returnmsg
	bsr	.flush_messages
.msgLoop
	moveq	#0,d0			* viestisilmukka
	moveq	#0,d1
	move.l	suserport(a5),a4
	move.b	MP_SIGBIT(a4),d1	* signalibitti
	bset	d1,d0
	move.b	info_signal(a5),d1
	bset	d1,d0
	move.b	info_signal2(a5),d1
	bset	d1,d0
	lore	Exec,Wait

	; exit signal?
	move.b	info_signal(a5),d1
	btst	d1,d0
	bne	.sexit
	; content refresh signal?
	move.b	info_signal2(a5),d1
	btst	d1,d0
	beq.b	.noRefresh
	* refresh content signal
	bsr	.flush_messages
	bsr	.fraz
	bra	.reprint
.noRefresh

.idcmpLoop	
	move.l	a4,a0
	lore	Exec,GetMsg
	tst.l	d0
	beq.b	.msgLoop

	move.l	d0,a1
	move.l	im_Class(a1),d2		* luokka	
	move	im_Code(a1),d3		* koodi
	move.l	im_IAddress(a1),a2 	* gadgetin tai olion osoite
	move	im_Qualifier(a1),d4	* RAWKEY: IEQUALIFIER_?
	move	im_MouseX(a1),d5
	move	im_MouseY(a1),d6

	lob	ReplyMsg

	cmp.l	#IDCMP_ACTIVEWINDOW,d2
	bne.b	.noActive
	bsr	.refreshInfoWindowResizeGadget
	bra.b	.idcmpLoop

.noActive
	cmp.l	#IDCMP_INACTIVEWINDOW,d2
	bne.b	.noInactive
	bsr	.refreshInfoWindowResizeGadget
	bra.b	.idcmpLoop
	
.noInactive
	;cmp.l	#IDCMP_NEWSIZE,d2
	moveq	#IDCMP_NEWSIZE,d0
	cmp.l	d0,d2
	bne.b	.noNewSize
	bsr	.infoWindowNewSize
	beq.b	.idcmpLoop
	bsr	.flush_messages
	bra	.redraw

.noNewSize
	cmp.l	#IDCMP_RAWKEY,d2
	bne.b	.noRawKey
	bsr	.srawkeyz
	bne.b	.sexit
	bra.b	.idcmpLoop

.noRawKey
	;cmp.l	#IDCMP_MOUSEMOVE,d2
	moveq	#IDCMP_MOUSEMOVE,d0
	cmp.l	d0,d2
	bne.b	.noMouseMove
	bsr	.smousemoving
	bra.b	.idcmpLoop


.noMouseMove
	moveq	#IDCMP_GADGETUP,d0
	cmp.l	d0,d2
	bne.b	.noGadgetsUp
    * This event comes for the slider with mousewheel 
	bsr	.smousemoving
	bra 	.idcmpLoop

.noGadgetsUp
	;cmp.l	#IDCMP_MOUSEBUTTONS,d2
	moveq	#IDCMP_MOUSEBUTTONS,d0
	cmp.l	d0,d2
	bne.b	.noMouseButtons
	cmp	#SELECTDOWN,d3			* vasen
	bne.b	.noSelectDown
	bsr	.samplePlay
	bra	.idcmpLoop

.noSelectDown
	cmp	#MENUDOWN,d3			* oikea
	beq.b	.sexit

.noMouseButtons
	cmp.l	#IDCMP_CLOSEWINDOW,d2
	bne	.idcmpLoop
	
.sexit	
	DPRINT	"info exit"
	bsr.b	.flush_messages

	move	oldswinsiz(a5),nw_Height+swinstruc
	move	oldsgadsiz(a5),gg_Height+gAD1

	move.l	_IntuiBase(a5),a6		
	move.l	swindowbase(a5),d0
	beq.b	.uh1
	move.l	d0,a0
	move.l	4(a0),infopos2(a5) * preserve position
	lob	CloseWindow
	clr.l	swindowbase(a5)
.uh1
	bsr.b	.fraz

	;bsr	freeinfosample
	rts


.fraz	move.l	infotaz(a5),a0
	cmp.l	#about_t,a0
	beq.b	.fr0z
	jsr	freemem
.fr0z	clr.l	infotaz(a5)
	rts


.flush_messages
	move.l	swindowbase(a5),a0
	bra  flushWindowMessages
	
.reslider
	moveq	#0,d0
	move	riviamount(a5),d0
	bne.b	.xe
	moveq	#1,d0
.xe

	moveq	#0,d1
	move	infosize(a5),d1
	beq	.eiup
	cmp	d1,d0		* v‰h boxsize
	bhs.b	.ok
	move	d1,d0
.ok
	lsl.l	#8,d0
	jsr	divu_32
 	
	move.l	d0,d1
	move.l	#65535<<8,d0
	jsr	divu_32
	move.l	d0,d1

	lea	gAD1,a0
	basereg	gAD1,a0

	move.l	gg_SpecialInfo+gAD1(a0),a1
	cmp	pi_VertBody(a1),d1
	sne	d2
	lsl	#8,d2
	move	d1,pi_VertBody(a1)

	move	riviamount(a5),d1
	sub	infosize(a5),d1
	beq.b	.pp
	bpl.b	.p
.pp	moveq	#1,d1
.p	ext.l	d1

	move	sfirstname(a5),d0
	mulu	#65535,d0
	jsr	divu_32
	cmp	pi_VertPot(a1),d0
	sne	d2
	move	d0,pi_VertPot(a1)

;	tst	d2
;	beq.b	.eiup


	move	gg_Height+gAD1(a0),d0
	mulu	pi_VertBody(a1),d0
	divu	#$ffff,d0
	bne.b	.f
	moveq	#8,d0
.f
	cmp	#8,d0
	bhs.b	.zze
	moveq	#8,d0
.zze
	move	d0,slim2height(a0)
	subq	#2+1,d0
	move	d0,d1

	lea	slim2,a2
	lea	slim1a(a0),a1
	tst.b	uusikick(a5)
	bne.b	.newz
	* Select alternate gfx
	lea	slim1a_kick13-slim1a(a1),a1
.newz
	move	(a1)+,(a2)+
.filf	move	(a1),(a2)+
	dbf	d0,.filf
	addq	#2,a1
	move	(a1)+,(a2)+

	move	(a1)+,(a2)+
.fil	move	(a1),(a2)+
	dbf	d1,.fil
	move	2(a1),(a2)
.bar	
	endb	a0
	;lea	gAD1,a0
	bsr	.refreshInfoWindowGadget
.eiup	rts


.infoWindowNewSize
	DPRINT	"info newsize"
	move.l	swindowbase(a5),a0
	lore	Intui,RefreshWindowFrame
	bsr	.refreshInfoWindowResizeGadget

	move.l	swindowbase(a5),a0
 	move	wd_Height(a0),d0

	* account for bottom border
	subq	#6,d0
	sub	windowbottom(a5),d0

	* calculate new size
	moveq	#11,d1
	add	windowtop(a5),d1

	sub	d1,d0
	lsr	#3,d0
	move	infosize(a5),d3 
	move	d0,infosize(a5)

 if DEBUG
 	ext.l	d0
 	DPRINT	"size=%ld"
 endif
	* adjust window height to match infosize
	subq	#3,d0
	lsl	#3,d0
	add	oldswinsiz(a5),d0
	sub	wd_Height(a0),d0
	beq.b	.skipSize
	bmi.b	.neg
	* ensure negative change to not go over screen,
	* kick1.3 does not do sanity checks
	subq	#8,d0 * font height
.neg
 if DEBUG
 	ext.l	d0
	DPRINT	"adjust by %ld"
 endif
	move	d0,d1
	moveq	#0,d0
	lore	Intui,SizeWindow
	; restore previous infosize, await for another
	; new size event
	move	d3,infosize(a5)
	bra.b	.sizeNotChanged
.skipSize
	bsr	setPrefsInfoBox
	bsr	updateprefs
	; return 1: do refresh
	moveq	#1,d0
	rts
.sizeNotChanged
	; no refresh
	moveq	#0,d0
	rts

.refreshInfoWindowResizeGadget
    DPRINT  "refreshInfoWindowResizeGadget"
	lea	gadgetResizeInfoWindow,a0
.refreshInfoWindowGadget
	move.l	swindowbase(a5),a1
	sub.l	a2,a2
	moveq	#1,d0	
	lore	Intui,RefreshGList
	rts


.srawkeyz
* ylˆs: $4c
* alas: $4d
	cmp	#$45,d3		* ESC
	beq.b	.rawkeyExitExit

	move	infosize(a5),d0
	cmp	riviamount(a5),d0
	bhi.b	.rawkeyExit

	moveq	#1,d0
	and	#IEQUALIFIER_LSHIFT!IEQUALIFIER_RSHIFT,d4
	beq.b	.nsh
	move	infosize(a5),d0
	lsr	#1,d0
.nsh
	move	sfirstname(a5),d2

	cmp	#$4d,d3
	beq.b	.alaz
	cmp	#$4c,d3
	bne	.rawkeyExit

	sub	d0,sfirstname(a5)
	bpl.b	.zoo
	clr	sfirstname(a5)
	bra.b	.zoo
.alaz	
	move	sfirstname(a5),d1
	add	d0,d1
	move	riviamount(a5),d0
	sub	infosize(a5),d0
	cmp	d0,d1
	bls.b	.foop
	move	d0,d1
.foop
	move	d1,sfirstname(a5)

.zoo	
	cmp	d2,d1
	beq.b	.rawkeyExit
	bsr	.reslider
	bsr.b	.print
	
.rawkeyExit
	moveq	#0,d0
	rts

.rawkeyExitExit
	moveq	#1,d0
	rts

.smousemoving
	lea	gAD1,a2
	move.l	gg_SpecialInfo(a2),a0
	move	pi_VertPot(a0),d0
	cmp	ssliderold(a5),d0
	bne.b	.new
.q	rts
.new	move	d0,ssliderold(a5)


	move	riviamount(a5),d1
	sub	infosize(a5),d1
	bpl.b	.ye
	moveq	#0,d1
.ye	mulu	d1,d0
	add.l	#32767,d0
	divu	#65535,d0

	cmp	sfirstname(a5),d0
	beq.b	.q
	move	d0,sfirstname(a5)

	;bra.b	.print

.print
	tst.b	skokonaan(a5)
	beq.b	.naht
	clr.b	skokonaan(a5)

	moveq	#0,d0
.all0	moveq	#0,d1
	move	infosize(a5),d2
	bra	.print2

.all	move	sfirstname(a5),d0
	bra.b	.all0
	

.naht

	move	sfirstname(a5),d0
	move	sfirstname2(a5),d7
	move	d0,sfirstname2(a5)
	cmp	d0,d7
	beq.b	.xx
	sub	d0,d7
	bmi.b	.alas


.ylos	cmp	infosize(a5),d7
	bhs.b	.all


* siirrytty d7 rivi‰ ylˆsp‰in:
* kopioidaan rivit 0 -> d7 (koko: infosize-d7 r) kohtaan 0 ja printataan
* kohtaan 0 d7 kpl uusia rivej‰

	moveq	#16-1,d1		* source y

	move	d7,d3
	lsl	#3,d3
	add	#16-1,d3		* dest y

	bsr.b	.copy

	move	sfirstname(a5),d0
	moveq	#0,d1
	move	d7,d2
	bra.b	.print2



.alas	neg	d7		
	cmp	infosize(a5),d7
	bhs.b	.all

* siirrytty d7 rivi‰ alasp‰in:
* kopioidaan rivit d7 -> infosize (koko: infosize-d7 r) kohtaan 0 ja printataan
* kohtaan infosize-d7 d7 kpl uusia rivej‰

	move	d7,d1
	lsl	#3,d1
	add	#16-1,d1		* source y	
	moveq	#16-1,d3		* dest y

	bsr.b	.copy

	move	sfirstname(a5),d0
	add	infosize(a5),d0
	sub	d7,d0
	move	infosize(a5),d1
	sub	d7,d1
	move	d7,d2
	bsr.b	.print2

	
.xx
	rts

** kopioidaan 

.copy	

	move	infosize(a5),d5	* y size
	sub	d7,d5
	lsl	#3,d5

	move.b	#$c0,d6		* minterm: a->d
	moveq	#31-2,d0		* source x =
	move.l	d0,d2		* dest x
	move	#39*8+4,d4	* x size
	add	windowleft(a5),d0
	add	windowtop(a5),d1
	add	windowleft(a5),d2
	add	windowtop(a5),d3
	move.l	srastport(a5),a0
	move.l	a0,a1
	move.l	_GFXBase(a5),a6
	jmp	_LVOClipBlit(a6)



* d0 = alkurivi
* d1 = eka rivi ruudulla
* d2 = printattavien rivien m‰‰r‰
.print2
	move.l	infotaz(a5),a3
	subq	#1,d0
	bmi.b	.rr
.fle	cmp.b	#10,(a3)+
	bne.b	.fle
	dbf	d0,.fle
.rr	cmp.b	#10,-1(a3)	
	bne.b	.ra
	addq	#1,a3		* skip ILF2
.ra

	move	d1,d7
	lsl	#3,d7
	add	#22-1,d7
	
	move	d2,d6
	subq	#1,d6		* ???

.lorp
	lea	-50(sp),sp
	move.l	sp,a0
	move.l	a0,a1

	move.l	a1,d0

.lorp2	move.b	(a3)+,(a1)+
	beq.b	.xp
	
	cmp.b	#10,-1(a1)
	bne.b	.lorp2
	clr.b	-1(a1)	
	addq	#1,a3		* skipataan ILF2
.xp	subq	#1,a1

	move.l	a1,d1
	sub.l	d0,d1
	moveq	#39,d0
	sub	d1,d0
	subq	#1,d0
	bmi.b	.xo
.pe	move.b	#' ',(a1)+
	dbf	d0,.pe
	clr.b	(a1)
.xo

;	cmp.l	#"----",(a0)
;	bne.b	.xq
;	bsr.b	.palk
;	bra.b	.xw
;.xq

	moveq	#35-2,d0
	move	d7,d1
	jsr	sprint

.xw	addq	#8,d7
	lea	50(sp),sp
	tst.b	-1(a3)
	beq.b	.xip

	dbf	d6,.lorp
.xip
	rts
	

* x = 35
* y = d7
* x size = 39*8
* y size = 8
;.palk
;	pushm	all
;	tst.b	uusikick(a5)		* uusi kick?
;	beq.b	.oz

;	push	d7

;	move	d7,ply1
;	subq	#6,ply1
;	moveq	#7,ply2
;	moveq	#35,plx1
;	move.l	#39*8-2,plx2
;	add.l	plx1,plx2
;	add.l	ply1,ply2
;	bsr	.1

;	pop	d7
	
;	move.l	srastport(a5),a2
;	moveq	#35+1,d0
;	subq	#5,d7
;	move	d7,d1
;	move	#39*8+35-3,d2
;	moveq	#5,d3
;	add	d7,d3
;	bsr	drawtexture

;.oz	popm	all
;	rts

* Local desmsg variant
* in: 
*   a3 = desbuf
*   a1 = parametrit
.desmsg4:
	movem.l	d0-d7/a0-a3/a6,-(sp)
	jmp	pulppa

; Put line change with special line feed so that ordinary line feeds
; can be filtered out.
.putLineChange	
	move.b	#ILF,(a3)+
	move.b	#ILF2,(a3)+
	rts

.prepareFailed
	DPRINT	"prepare fail"
	rts

.prepareInfoWindowContent

	; which content to display?
	move.b	infolag(a5),d0
	;clr.b	infolag(a5)
	;tst.b	d0
	beq.b	.modinf
	* Display generic about text

******** About- aiheet
	move	#39,info_prosessi(a5)		* info-lippu
	lea	about_t,a0
	move.l	a0,infotaz(a5)
	* Displays some statistics with correct keyfile.
	* tst.b	keycheck(a5)
	* bne	.nox
	
	lea	(about_t1-about_t)(a0),a4
	lea	(about_tt-about_t1)(a4),a0
	lea	-200(sp),sp
	move.l	sp,a3

	move.l	modamount(a5),d0
	move.l	divideramount(a5),d1
	sub.l	d1,d0
	movem.l	d0/d1,-(sp)
	pea	keyfile(a5)
	move.l	sp,a1
	bsr.b	.desmsg4
	add	#8+4,sp
	st	eicheck(a5)

	move.l	sp,a0
.c	move.b	(a0)+,(a4)+
	bne.b	.c
	move.b	#'≠',-1(a4)

	lea	200(sp),sp
	bra	.nox

.modinf
	* Display module specific information
******** Kehitell‰‰n infoa moduulista


	clr	sfirstname(a5)
	clr	sfirstname2(a5)
	clr.l	infotaz(a5)

	; safety checks
	tst	playertype(a5)
	beq.b	.1
	cmp	    #pt_sample,playertype(a5)
	beq.b   .2 ; no address for samples
    cmp     #pt_delicustom,playertype(a5)
    beq     .2
	tst.l	moduleaddress(a5)
	beq.b	.1
.2	tst.l	playingmodule(a5)
	bpl.b	.bah
.1
	* Nothing is being played. Display "No info available".

	move	#35,info_prosessi(a5)		* lipbub

	moveq	#3,d5
	bsr	.allo2
	beq	.prepareFailed

	lea	.huhe(pc),a0
	move.l	infotaz(a5),a1
.faz	move.b	(a0)+,(a1)+
	bne.b	.faz

	bra	.selvis

.bah
	* Something is being played.
	* Check supported types.

******************* Sample
	cmp	#pt_sample,playertype(a5)
	bne 	.nosample
    
    ;----------------------------------
    ; Provide information about MP3 stuff,
    ; no extra info on other sample formats available.

    * Local?
    move.l	modulefilename(a5),a0
    jsr     id_mp3filename
    beq     .wazMp3
    * Remote?
    jsr     streamIsAlive
    beq     .nosample
    jsr     streamIsMpegAudio
    beq     .nosample
.wazMp3
    DPRINT  "sample info"
    move	#33,info_prosessi(a5)

    * lines to allocate, max tags 20, 3 lines per one
    moveq   #3*20,d5 
    bsr     .allo2
    beq     .prepareFailed
    move.l  infotaz(a5),a3

    move.l  a3,a0
    jsr     getMp3TagText

    ;----------------------------------
    lea	-300(sp),sp
    move.l  streamHeaderIcyName(a5),d0
    beq.b   .noIcyName
    move.l  sp,a3
    lea     .icyForm1(pc),a0
    bsr     .putIcy
.noIcyName
    move.l  streamHeaderIcyDescription(a5),d0
    beq.b   .noIcyDesc
    move.l  sp,a3
    lea     .icyForm2(pc),a0
    bsr     .putIcy
.noIcyDesc
    move.l  infotaz(a5),d0
    lea     300(sp),sp
    ;----------------------------------

    move.l  infotaz(a5),a3
    tst.b   (a3)
    bne     .yesText
    
    * Free buffer if nothing got 
    move.l  a3,a0
    jsr     freemem
    clr.l   infotaz(a5)
    bra     .nosample
.yesText
    move.l  a3,d0
    bra     .selvis

; Icy specific putter
.putIcy
    push    a3
    jsr     desmsg3
    pop     a0
	; target output buffer
	move.l	infotaz(a5),a3
	bsr	.lloppu
    ; do ines wrapping at space
	bsr    	.doLine
    bpl    	.ic1
    move.b  #" ",(a3)+
	bsr    	.doLine
	bpl    	.ic1
    move.b  #" ",(a3)+
	bsr    	.doLine
	bpl    	.ic1
    move.b  #" ",(a3)+
	bsr    	.doLine
	bpl    	.ic1
    move.b  #" ",(a3)+
	bsr    	.doLine
	bpl    	.ic1
    move.b  #" ",(a3)+
	bsr    	.doLine
.ic1   
    rts


.icyForm1
    dc.b    ILF,ILF2," Name:",ILF,ILF2
    dc.b    " %s",ILF,ILF2,0
.icyForm2
    dc.b    ILF,ILF2," Description:",ILF,ILF2
    dc.b    " %-.250s",ILF,ILF2,0
 even

.nosample
******************* THX

	cmp	#pt_thx,playertype(a5)
	bne.b	.nothx
	move	#33,info_prosessi(a5)

	move.l	moduleaddress(a5),a4
	moveq	#0,d5
	move.b	12(a4),d5
	move	d5,d7
	bsr	.allo * out: a3 = output buffer
	beq	.prepareFailed

	move.l	moduleaddress(a5),a4
	move.l	a4,a2
	add.l	modulelength(a5),a2

	add	4(a4),a4
	bsr.b	.fo

	subq	#1,d7
	moveq	#1,d0

.thxb
	lea	-10(sp),sp
	move.l	sp,a1

	move.l	d0,(a1)	 * param 1
	move.l	a4,4(a1) * param 2
	lea	.thxform(pc),a0
	bsr	.desmsg4
	bsr	.lloppu
	lea	10(sp),sp
	bsr.b	.fo
	
	addq	#1,d0
	dbf	d7,.thxb

	bra	.selvis

.fo	cmp.l	a2,a4
	beq.b	.fox
	tst.b	(a4)+
	bne.b	.fo
.fox	rts

******************* DIGI Booster
.nothx

	cmp	#pt_digibooster,playertype(a5)
	bne.b	.nobooster
	move	#33,info_prosessi(a5)

	moveq	#31,d5
	bsr	.allo
	beq	.prepareFailed


	move.l	moduleaddress(a5),a0
	lea	176(a0),a2		* lengths
	lea	642(a0),a4		* samplenames

	moveq	#31-1,d7
	moveq	#1,d0

.digib

	lea	-16(sp),sp
	move.l	sp,a1

	move.l	d0,(a1)
	move.l	(a2)+,8(a1)
	move.l	a4,4(a1)

	lea	.medform(pc),a0
	bsr	.desmsg4

	lea	16(sp),sp
	bsr	.lloppu

	lea	30(a4),a4
	
	addq	#1,d0
	dbf	d7,.digib

	bra	.selvis


.nobooster


	cmp	#pt_med,playertype(a5)		* MED
	bne.b	.nomed
	move	#33,info_prosessi(a5)		* lipub

***************** MED
	tst.b	medrelocced(a5)		* pit‰Ê olla relokatoitu
	beq	.noo

	move.l	moduleaddress(a5),a0
	move.l	32(a0),a1		* MMD0exp
	tst.l	20(a1)
	beq	.noo_med
	move.l	20(a1),a2		* MMDInstrInfo (samplenamet)
	move	24(a1),d4		* samplejen m‰‰r‰
	move	26(a1),d6		* entry size

	move.l	24(a0),d7		* insthdr

	move	d4,d5
	bsr	.allo
	beq	.prepareFailed

	move.l	d7,a0

	subq	#1,d4
	moveq	#1,d0
.medl
	move.l	a2,d1
	move.l	(a0)+,d2
	bne.b	.moe
	lea	.zero(pc),a1
	moveq	#0,d2
	bra.b	.moee
.moe
	move.l	d2,a1
	move.l	(a1),d2
.moee

	push	a0
	lea	-16(sp),sp
	move.l	sp,a1
	movem.l	d0/d1/d2,(a1)
	lea	.medform(pc),a0
	bsr	.desmsg4
	lea	16(sp),sp
	bsr	.lloppu
	pop	a0

	add	d6,a2
	addq	#1,d0
	dbf	d4,.medl

	bra	.selvis



.nomed
	cmp	#pt_sid,playertype(a5)		* PSID
	bne	.nosid

***************************************
* PSID
***************************************
* SID piisista infoa

	move	#33,info_prosessi(a5)		* PSID info-lippu

    lea     t6581,a2
    jsr     sid_getSidVersion
    beq     .6581
    lea     t8580-t6581(a2),a2
.6581
    jsr     sid_getSongSpeed
    * d0 = speed number 
    * d1 = speed hz 

	lea	-128(sp),sp
	move.l	sp,a1
	pushpea	sidheader+sidh_name(a5),(a1)+
	pushpea	sidheader+sidh_author(a5),(a1)+
	pushpea	sidheader+sidh_copyright(a5),(a1)+
	clr.l	(a1)+
	clr.l	(a1)+
	move	sidheader+sidh_number(a5),-6(a1)
	move	sidheader+sidh_defsong(a5),-2(a1)
    move.l  d0,(a1)+    * song speed
    move.l  d1,(a1)+    * song speed hz
    move.l  a2,(a1)+    * sid type
    pushpea .stilNag(pc),(a1)+ * stil comment
	move.l	modulelength(a5),(a1)+
	move.l	moduleaddress(a5),d0
	move.l	d0,(a1)+
	add.l	modulelength(a5),d0
	move.l	d0,(a1)+
	pushpea	filecomment(a5),(a1)+
	clr.l	(a1)

    moveq	#13,d5  * allocate 13 lines text buffer initially

    * Check if there is STIL data available
	
    moveq   #0,d4
    jsr     getSTILInfo
    * a0 = text, to be freed
    * d0 = length or null if not found, negative if no stil data
    tst.l   d0
    bmi     .noSTIL
    clr.l   -20(a1)     * remove STIL nag
    tst.l   d0
    beq     .noSTIL

    * Add more lines to be allocated
    move.l  a0,d4
    * How many 40 char lines does this need 
    move.l  d0,d1

    divu    #40,d1
    addq    #1,d1   * round up
    add     d1,d5
.noSTIL
    * Allocate text buffer, amount of lines in d5
	bsr	.allo2
	bne.b	.jee9
	lea	128(sp),sp
	bra	.prepareFailed
.jee9

	lea	.form(pc),a0
	move.l	sp,a1       * parameters in
	move.l	infotaz(a5),a3
	bsr	.desmsg4
	lea	128(sp),sp

	bsr	.putcomment

    ;----------------------------------
    ; Insert STIL data

    tst.l   d4
    beq     .selvis
    * d4 now has STIL data

    ; Find end of current buffer
    move.l	infotaz(a5),a3
	bsr     .lloppu
    ; extra space
    bsr     .putLineChange
    * put stil stuff there

    move.l  d4,a0
.copyStil  
    move.b  (a0)+,(a3)+
    bne     .copyStil

    ; Free it after copying
    move.l  d4,a0
    jsr     freemem

	bra	.selvis


.form	dc.b	"PSID-module",ILF,ILF2
	dc.b	"≠≠≠≠≠≠≠≠≠≠≠",ILF,ILF2
	dc.b	"Name: %-33.33s",ILF,ILF2
	dc.b	"Author: %-31.31s",ILF,ILF2
	dc.b	"Copyright: %-28.28s",ILF,ILF2
	dc.b	"Songs: %ld (default %ld)",ILF,ILF2
    dc.b	"Song speed: %ld (%ld Hz)",ILF,ILF2
    dc.b	"SID type: %-4.4s %24.24s",ILF,ILF2
	dc.b	"Size: %-7.ld     ($%08.lx-$%08.lx)",ILF,ILF2
	dc.b	"Comment:",ILF,ILF2,0
 even

.huhe	dc.b	ILF,ILF2
	dc.b	"          No info available.",0
.zero = *-1
.stilNag    dc.b     "Get STIL for more!",0
 even

.nosid

	* Check for IT special case,
	* handle it as an eagleplayer
	jsr	isImpulseTrackerActive
	beq.b	.yesIT
	cmp	#pt_eagle_start,playertype(a5)		* eagleplayer
	blo	.noeagle
.yesIT
	move	#33,info_prosessi(a5)		* some magic flag

	lea	.form3(pc),a0
	lea	-32(sp),sp
	move.l	sp,a4
	bsr	.namtypsizcom

	moveq	#10+20,d5
	bsr	.allo2
	bne.b	.jee9eg
	lea	32(sp),sp
	bra	.prepareFailed
.jee9eg
	move.l	sp,a1
	move.l	infotaz(a5),a3
	bsr	.desmsg4
	bsr	.putcomment
	lea	32(sp),sp

	move.l	infotaz(a5),a3
	bsr	.lloppu
	bsr	.putLineChange

	move.l	#MI_SongName,d1
	lea	.eagleSong(pc),a0
	bsr	.deliPutInfo
	move.l	#MI_AuthorName,d1
	lea	.eagleAuthor(pc),a0
	bsr	.deliPutInfo
	move.l	#MI_SubSongs,d1
	lea	.eagleSubsongs(pc),a0
	bsr	.deliPutInfo
	move.l	#MI_Prefix,d1
	lea	.eaglePrefix(pc),a0
	bsr	.deliPutInfo
	move.l	#MI_Samples,d1
	lea	.eagleSamples(pc),a0
	bsr	.deliPutInfo
	move.l	#MI_SynthSamples,d1
	lea	.eagleSynthSamples(pc),a0
	bsr	.deliPutInfo
	move.l	#MI_Songsize,d1
	lea	.eagleSongSize(pc),a0
	bsr	.deliPutInfo
	move.l	#MI_SamplesSize,d1
	lea	.eagleSamplesSize(pc),a0
	bsr	.deliPutInfo
	move.l	#MI_Voices,d1
	lea	.eagleVoices(pc),a0
	bsr	.deliPutInfo

	move.l	#MI_Duration,d1
	jsr	deliFindInfoValue
	ble.b	.noEagleDur
	divu	#60,d0 
	move.l	d0,d1
	swap	d1 
	ext.l 	d0 
	ext.l 	d1
	lea	.eagleDuration(pc),a0
	bsr	.deliPutInfo2
.noEagleDur

	move.l	#MI_About,d1
	lea	.eagleAbout(pc),a0
	bsr	.deliPutInfo

	move.l	infotaz(a5),a3
	bsr	.lloppu
	bsr	.putLineChange
	
	move.l	#DTP_PlayerName,d0 
	jsr	deliGetTag 
	beq.b 	.noPlrName 
	lea	.eagleName(pc),a0 
	bsr 	.deliPutInfo2	
.noPlrName 
	* Creator, 1-3 lines
	move.l	#DTP_Creator,d0 
	jsr	deliGetTag 
	beq 	.noCrtr
	lea	.eagleCreator(pc),a0 
	; format output buffer
	lea	-200(sp),sp
	move.l	sp,a3
	jsr	desmsg3
	move.l	sp,a0

	; target output buffer
	move.l	infotaz(a5),a3
	bsr	.lloppu
	; do three lines wrapping at space
	bsr 	.doLine
	bpl 	.endss
	bsr 	.doLine
	bpl 	.endss
	bsr 	.doLine
.endss
	move.l	infotaz(a5),a3
	bsr	.lloppu
	bsr	    .putLineChange
    bsr     .putMetaData
	bra 	.ends

* Copies a line to output, cuts at space near the end of line
* in:
*   a0 = input text
*   a3 = output buffer
* out:
*   a0 = pointer to next line if available
*   a3 = pointer to next position in output buffer
*   d0 = negative: all input handled
*        positive: data left in input for the next row
.doLine:
 	moveq	#39-1,d0
	moveq	#0,d1
.cl1	cmp.b	#" ",(a0)
	bne.b	.ns1
	addq	#1,d1 ; keep track of spaces
.ns1	
    move.b  (a0)+,d2
    cmp.b   #ILF2,d2
    bne.b   .noIlf2
    * Line change resets the counter
    moveq	#39-1,d0    
.noIlf2
    move.b  d2,(a3)+
	dbeq	d0,.cl1
    ; d0 = -1, all chars copied
 	tst 	d0
	bpl	    .endLine
 	; find previous space to cut from
	; SAFETY: if there are any
	tst	d1
	beq.b	.endLin
.li1	subq	#1,a3
	cmp.b	#" ",-(a0)
	bne.b	.li1
	addq	#1,a0
	move.l	a0,d0
.endLin
	moveq	#-1,d0
.endLine
	bsr	.putLineChange
	tst	d0
	rts

.ends
	lea	200(sp),sp
.noCrtr
	bra	.selvis

.deliPutInfo
	push 	a0
	jsr	deliFindInfoValue
	pop  	a0
	tst.l	d0
	* zero or lower
	ble.b	.noInfo
.deliPutInfo2
	move.l	infotaz(a5),a3
	bsr	.lloppu
	bsr.b	.deliFormat
.noInfo
	rts

.deliFormat	
	pushm	d0-d7
	move.l	sp,a1
	lea	putc,a2	;merkkien siirto
	lore 	Exec,RawDoFmt
	popm	d0-d7
	rts

* max width: 39
.eagleSong	 	dc.b	"Song: %-33.33s",ILF,ILF2,0
.eagleAuthor		dc.b	"Author: %-31.31s",ILF,ILF2,0
.eagleSubsongs		dc.b	"Subsongs: %ld",ILF,ILF2,0
.eagleSamples		dc.b	"Samples: %ld",ILF,ILF2,0
.eagleSynthSamples	dc.b	"Synth samples: %ld",ILF,ILF2,0
.eagleSongSize	 	dc.b	"Song size: %ld bytes",ILF,ILF2,0
.eagleSamplesSize	dc.b	"Samples size: %ld bytes",ILF,ILF2,0
.eaglePrefix 		dc.b	"Prefix: %s",ILF,ILF2,0
.eagleVoices	 	dc.b	"Voices: %ld",ILF,ILF2,0
.eagleDuration	 	dc.b	"Duration: %02ld:%02ld",ILF,ILF2,0
.eagleAbout	     	dc.b	"About: %-32.32s",ILF,ILF2,0
.eagleName		dc.b	"Eagleplayer: %-26.26s",ILF,ILF2,0
.eagleCreator       	dc.b	"Creator: %s",0
 even

.noeagle

********* module (PT)

	move	#34,info_prosessi(a5)		* show samplenames info-lippu

	

	cmp	#pt_startrekker,playertype(a5)
	beq.b	.yes
	cmp	#pt_prot,playertype(a5)
	bne.b	.nop
.yes	move.l	#ptheader,d4
	bra.b	.mod
.nop

	move.l	moduleaddress(a5),d4
	cmp	    #pt_multi,playertype(a5)
	bne	.noo

	move.l	ps3m_mtype(a5),a0
	cmp	#mtMOD,(a0)
	beq.b	.mod
	cmp	#mtS3M,(a0)
	beq	.s3m
	cmp	#mtMTM,(a0)
	beq	.mtm
	cmp	#mtXM,(a0)
	beq	.xm
	bra	.noo


.mod	
	moveq	#31,d5
	bsr	.allo
	beq	.prepareFailed

	moveq	#0,d7
	moveq	#31-1,d6
.loop2	move	d7,d0
	mulu	#30,d0
	move.l	d4,a0
	lea	20(a0,d0),a2		* 22 bytes samplename

** kludge, jos eka char on 0 ja toka ei, se on samplename.
	tst.b	(a2)
	bne.b	.nokl
	tst.b	1(a2)
	beq.b	.nokl
	move.b	#' ',(a2)
.nokl

	lea	-24(sp),sp
	move.l	sp,a0
	move.l	a0,d1			* name, null terminated
	move.l	a2,a1
	moveq	#22-1,d0
.copz	move.b	(a1)+,(a0)+
	dbeq	d0,.copz
	clr.b	(a0)

	moveq	#0,d2
	move	22(a2),d2
	add.l	d2,d2			* length

	move.l	d7,d0
	addq	#1,d0


	lea	-16(sp),sp
	move.l	sp,a1
	movem.l	d0/d1/d2,(a1)
	lea	.form0(pc),a0
	bsr	.desmsg4
	lea	16(sp),sp
	bsr	.lloppu

	lea	24(sp),sp

	addq	#1,d7
	dbf	d6,.loop2
	bra	.selvis






******* screamtracker

.s3m
	move.l	d4,a0
	move	insnum(a0),d5
	iword	d5
	bsr	.allo
	beq	.prepareFailed

* a3 = pointteri tekstipuskuriin

	move.l	d4,a0
	move	insnum(a0),d5
	iword	d5

	moveq	#0,d7

.loop	move	d7,d0
	add	d0,d0

	move.l	ps3m_samples(a5),a2
	move.l	(a2),a2
	move	(a2,d0),d0
	iword	d0
	lsl	#4,d0
	move.l	d4,a0
	lea	(a0,d0),a0
	lea	insname(a0),a1
	move.l	a1,d1
	move.l	inslength(a0),d2
	ilword	d2
	and.l	#$7ffff,d2
	move.l	d7,d0
	addq	#1,d0

	lea	-16(sp),sp
	move.l	sp,a1
	movem.l	d0/d1/d2,(a1)
	lea	.form2(pc),a0
	bsr	.desmsg4
	lea	16(sp),sp
	bsr	.lloppu

	addq	#1,d7
	cmp	d5,d7
	blo.b	.loop
.pois	
	bra	.selvis


***** XM

.xm
	move.l	d4,a0
	lea	xmNumInsts(a0),a0
	tword	(a0)+,d5
	bsr	.allo
	beq	.prepareFailed

	move.l	d4,a0
	move.l	ps3m_xm_insts(a5),a0
	moveq	#0,d7

.loop0	move	d7,d0
	lsl	#2,d0
	move.l	(a0,d0),a2
	moveq	#0,d1
	move.l	a2,a1
	tlword	(a1)+,d0
	move.l	a1,d6			; Name

	lea	xmNumSamples(a2),a1
	tword	(a1)+,d2
	tst	d2
	beq	.skip
	lea	xmSmpHdrSize(a2),a1
	tlword	(a1)+,d3
	add.l	d0,a2
	subq	#1,d2
.k0o	move.l	a2,a1
	tlword	(a1)+,d0
	add.l	d0,d1
	add.l	d3,a2
	dbf	d2,.k0o

.skip	
;	move.l	d1,(a4)+	* size

	pushm	d0-a2/a4-a6
	move.l	d1,d2
	and.l	#$7ffff,d2
	move.l	d7,d0
	addq	#1,d0
	move.l	d6,d1
	lea	-16(sp),sp
	move.l	sp,a1
	movem.l	d0/d1/d2,(a1)
	lea	.form2(pc),a0
	bsr	.desmsg4
	lea	16(sp),sp
	popm	d0-a2/a4-a6
	bsr	.lloppu

  	addq.l	#1,d7
	cmp	d5,d7
	blo	.loop0

	bra	.selvis


***** multitracker

.mtm
	move.l	d4,a0
	moveq	#0,d5
	move.b	30(a0),d5
	bsr	.allo
	beq	.prepareFailed

	moveq	#0,d7
.loop3	move	d7,d0
	mulu	#37,d0
	move.l	d4,a0
	lea	66(a0,d0),a2
	move.l	a2,d1			; Name

	moveq	#0,d2
	move.b	22(a2),d2
	lsl	#8,d2
	move.b	23(a2),d2
	lsl.l	#8,d2
	move.b	24(a2),d2
	lsl.l	#8,d2
	move.b	25(a2),d2
	ilword	d2
;	move.l	d2,(a4)+		* size


	move.l	d7,d0
	addq	#1,d0

	lea	-16(sp),sp
	move.l	sp,a1
	movem.l	d0/d1/d2,(a1)
	lea	.form2(pc),a0
	bsr	.desmsg4
	lea	16(sp),sp
	bsr	.lloppu


	addq.l	#1,d7
	cmp	d5,d7
	blo.b	.loop3
	bra	.pois



* PS3M
.form11	dc.b	"Name: %-33.33s",ILF,ILF2
	dc.b	"Type: %-25.25s %2.ld.%1.1ldkHz",ILF,ILF2
	dc.b	"Size: %-7.ld     ($%08.lx-$%08.lx)",ILF,ILF2
	dc.b	"Comment: ",0


* PT
.form1	dc.b	"Name: %-33.33s",ILF,ILF2
	dc.b	"Type: %-33.33s",ILF,ILF2
	dc.b	"Size: %-7.ld     ($%08.lx-$%08.lx)",ILF,ILF2
	dc.b	"Comment: ",0

** PT

.form0	dc.b	'%02ld %-22.22s        %6ld',ILF,ILF2,0

** PS3M

.medform 
.form2	dc.b	"%03ld %-28.28s %6.6ld",ILF,ILF2,0

.thxform
 	dc.b	"%03ld %-35.35s",ILF,ILF2,0

 even



** Joku muu modi

.noo_med
.noo
	* DEFAULT INFO
	DPRINT	"default info"
	
	move	#35,info_prosessi(a5)

	lea	.form3(pc),a0

	lea	-32(sp),sp
	move.l	sp,a4
	bsr	.namtypsizcom

	moveq	#10,d5
	bsr	.allo2
	bne.b	.jee9a
	lea	32(sp),sp
	bra	.prepareFailed
.jee9a
	* parameters in a1
	move.l	sp,a1
	move.l	infotaz(a5),a3
	bsr	.desmsg4
	bsr	.putcomment
	lea	32(sp),sp
	
	moveq	#0,d0 
	move.l	playerbase(a5),a0 
	jsr	p_author(a0) 
	tst.l	d0 
	beq.b 	.noAuth

	lea	.author(pc),a0
	; format output buffer
	lea	-200(sp),sp
	move.l	sp,a3
	jsr	desmsg3
	move.l	sp,a0
	move.l	a0,d0

	; target output buffer
	move.l	infotaz(a5),a3
	bsr	.lloppu
	bsr	.doLine
	bpl.b	.endA
	bsr	.doLine
	bpl.b	.endA
	bsr	.doLine
.endA	lea	200(sp),sp
.noAuth

    bsr     .putMetaData

	bra	.selvis



.form3	
	dc.b	"Name: %-33.33s",ILF,ILF2
	dc.b	"Type: %-33.33s",ILF,ILF2
	dc.b	"Size: %-9.ld   ($%08.lx-$%08.lx)",ILF,ILF2
	dc.b	ILF,ILF2
	dc.b	"Comment:",ILF,ILF2,0
.author
	dc.b	"Player: %s",0
  even

* Put UADE-Audacious metadata
.putMetaData
    move.l  umeMetaDataPtr(a5),d0
    beq     .noMeta
    move.l  d0,a4
    tst.b   (a4)
    beq     .noMeta

    lea     metaData1(pc),a0 
    bsr     .putMetaLine
    lea     metaData2(pc),a0 
    bsr     .putMetaLine
    lea     metaData3(pc),a0 
    bsr     .putMetaLine
    lea     metaData4(pc),a0 
    bsr     .putMetaLine
.noMeta
    rts

.putMetaLine
    tst.b   (a4)            * skip empty
    beq     .nextMeta

    lea     -100(sp),sp
    move.l  a4,d0
    move.l  sp,a3
    jsr     desmsg3

	move.l	infotaz(a5),a3
	bsr	    .lloppu
    bsr     .putLineChange
    
    move.l  sp,a0
    move.l  a3,a1
    bsr     .doLine
    bpl     .endM
    bsr     .doLine
    bpl     .endM
    bsr     .doLine
.endM

    lea     100(sp),sp

.nextMeta
    tst.b   (a4)+
    bne     .nextMeta
    rts


.putcomment:
	pushm	d0/d1/a0/a3
	moveq	#39+1,d1
	bra.b	.puct

.putcomment2
	pushm	d0/d1/a0/a3
	moveq	#30+1,d1
.puct
	move.l	infotaz(a5),a3
	bsr	.lloppu
	lea	filecomment(a5),a0
 if DEBUG
	move.l	a0,d0
	DPRINT	"comment: %s"
 endif
	tst.b	(a0)
	beq.b	.empty
	bsr.b	.putlines
	bsr	.putLineChange
	bsr	.putLineChange
.empty
	popm	d0/d1/a0/a3
	rts

* d1 = character limit for the first line to be put
.putlines
	moveq	#0,d0
.com	addq	#1,d0
	cmp	d1,d0
	bne.b	.naga
	moveq	#39,d1
	tst.b	(a0)
	beq.b	.naga
	moveq	#0,d0
	bsr	.putLineChange
.naga	move.b	(a0)+,(a3)+
	bne.b	.com
	subq	#1,a3 ; back to NULL
	rts
 
*************************************

* writes into a4 depending on format:
* - module name address
* - module type address
* - mix rate integer
* - mix rate decimal
* - module length
* - module start addr
* - module end addr

.namtypsizcom
	pushm	d0/d1

	pushpea	modulename(a5),(a4)+
	pushpea	moduletype(a5),(a4)+

	cmp	#pt_med,playertype(a5)
	bne.b	.lee
	cmp.b	#2,medtype(a5)		* Med 1-64ch?
	bne.b	.lee

	move.l	moduleaddress(a5),a1	* onko samplenimiÊ?
	move.l	32(a1),a1		* MMD0exp
	tst.l	20(a1)
	bne.b	.rrqq

.lee
	cmp	#pt_multi,playertype(a5)		* mixing rate
	bne.b	.nah
	jsr	isImpulseTrackerActive
	beq.b	.nah
.rrqq	
	move.l	mixirate(a5),d0
	tst.b	ahi_use_nyt(a5)
	beq.b	.psz
	move.l	ahi_rate(a5),d0
.psz
	divu	#1000,d0
	move.l	d0,d1
	clr	d1
	swap	d1
	ext.l	d0
	move.l	d0,(a4)+
	move.l	d1,(a4)+
.nah

	move.l	modulelength(a5),(a4)

	tst.b	lod_xpkfile(a5)		* v‰hennet‰‰n xpk:n turvapuskurin koko
	beq.b	.noxp
	sub.l	#256,(a4)
.noxp
	addq.l	#4,a4

	cmp	#pt_sample,playertype(a5)
	beq.b	.jccc
	cmp	#pt_tfmx,playertype(a5)
	beq.b	.jt
	cmp	#pt_tfmx7,playertype(a5)
	bne.b	.jcc

.jt
	move.l	tfmxsampleslen(a5),d0
	add.l	d0,-4(a4)

* tfmx? pistet‰‰n mdat ja smpl alkuosoitteet
	move.l	moduleaddress(a5),(a4)+
	move.l	tfmxsamplesaddr(a5),(a4)+
	bra.b	.xop
.jccc
	clr.l	(a4)+		* sampleilla ei osoitteita
	clr.l	(a4)+
	bra.b	.xop
.jcc


	move.l	moduleaddress(a5),d0
	move.l	d0,(a4)+
	add.l	modulelength(a5),d0
	move.l	d0,(a4)+

.xop

	popm	d0/d1
	rts

* In:
*   d5 = lines to allocate
* Out:
*   a3 = buffer
.allo:
	bsr 	.allo2
	beq 	.xiipo

	lea	-32(sp),sp
	move.l	sp,a4
	bsr	.namtypsizcom

	lea	.form1(pc),a0

	cmp	#pt_med,playertype(a5)
	bne.b	.nee
	cmp.b	#2,medtype(a5)
	beq.b	.okod
;	move.l	moduleaddress(a5),a0
;	move.l	32(a0),a0		* MMD0exp
;	tst.l	20(a0)			* onko samplenimi‰?
;	beq.b	.okod
.nee
	cmp	#pt_multi,playertype(a5)
	bne.b	.bahz
.okod	lea	.form11(pC),a0
.bahz	


	move.l	sp,a1
	move.l	infotaz(a5),a3
	bsr	.desmsg4
	lea	32(sp),sp

	bsr	.putcomment2
	
	move.l	infotaz(a5),a3
	bsr 	.lloppu
    bsr     .putMetaData
	move.l	infotaz(a5),a3
	bsr 	.lloppu

	bsr	.putLineChange
	moveq	#39-1,d0
.ca	move.b	#"≠",(a3)+
	dbf	d0,.ca
	bsr	.putLineChange
	clr.b	(a3)

	moveq	#1,d0
.xiipo	rts

* Progresses to the next line in text buffer
.lloppu:
	tst.b	(a3)+
	bne.b	.lloppu
	subq	#1,a3
	rts
	

.allo2:
** Varataan muistia tekstipuskurille
	move	d5,d0
	add	#20,d0		* 20 vararivi‰ varalle
	mulu	#40,d0
	move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
	jsr	getmem
	move.l	d0,infotaz(a5)
	rts

.selvis:
** If we made this far the module information text has been built

**  Karsitaan kummat merkit pois
	move.l	infotaz(a5),a2

* sallittu alue: 33-126, 160-255
	lea	asciitable,a0
	moveq	#0,d0
	moveq	#0,d1
	move.b	#'≠',d2

.clo	tst.b	(a2)
	beq.b	.nox
	move.b	(a2),d0

	cmp.b	#ILF,d0
	bne.b	.per
	cmp.b	#ILF2,1(a2)
	bne.b	.per
	move.b	#10,(a2)+
	bra.b	.nomu
.per


* charset conversion s3m, xm
* tehd‰‰n vasta ≠≠≠≠≠ rivin j‰lkeen

	tst.b	d1
	bne.b	.conve

	cmp.b	d2,d0
	bne.b	.ohic
	cmp.b	1(a2),d2
	bne.b	.ohic
	st	d1

.conve
	cmp	#pt_multi,playertype(a5)
	bne.b	.ohic
	move.l	ps3m_mtype(a5),a1
	cmp	#mtS3M,(a1)
	beq.b	.con
	cmp	#mtMTM,(a1)
	beq.b	.con
	cmp	#mtXM,(a1)
	bne.b	.ohic
.con
	cmp.b	d2,d0
	beq.b	.ohic
	move.b	(a0,d0),d0		* PC -> Amiga
	move.b	d0,(a2)
.ohic

	cmp.b	#10,d0
	beq.b	.mur
	cmp.b	#33,d0
	blo.b	.mur
	cmp.b	#126,d0
	bls.b	.nomu
	cmp.b	#160,d0
	bhs.b	.nomu
.mur	move.b	#' ',(a2)
.nomu	addq	#1,a2
	bra.b	.clo
.nox
	rts

****** PT sample play

.samplePlay
	sub	windowleft(a5),d5
	sub	windowtop(a5),d6	* suhteutus fonttiin

	cmp	#31,d5
	blo	.samplePlayExit
	cmp	#345,d5
	bhi	.samplePlayExit
	cmp	#14,d6
	blo	.samplePlayExit
	move	infosize(a5),d0
	lsl	#3,d0
	add	#14,d0
	cmp	d0,d6
	bhi	.samplePlayExit

	tst.b	ahi_muutpois(a5)
	bne	.samplePlayExit

	cmp	#pt_prot,playertype(a5)
	bne	.samplePlayExit
	tst.l	playingmodule(a5)
	bmi	.samplePlayExit

* d5/d6 = mouse x/y

	move	d6,d0
	sub	#14+1,d0
	lsr	#3,d0
	add	sfirstname(a5),d0
	subq	#1,d0
	bmi	.samplePlayExit

	move.l	infotaz(a5),a0
.ff	cmp.b	#10,(a0)+
	bne.b	.ff
	dbf	d0,.ff

	addq	#1,a0
	cmp.b	#' ',2(a0)
	bne	.samplePlayExit

	move.b	(a0)+,d0
	cmp.b	#'0',d0
	blo	.samplePlayExit
	cmp.b	#'3',d0
	bhi	.samplePlayExit
	and	#$f,d0
	mulu	#10,d0
	move.b	(a0)+,d1
	and	#$f,d1
	add	d1,d0		* d0 = samplenum

	cmp	#$1f,d0
	bhi.b	.samplePlayExit

	move	d0,d7
	subq	#1,d7
	bmi.b	.samplePlayExit
	
	jsr	obtainModuleData
	move.l	moduleaddress(a5),a1	* onko chipiss‰?
	lore	Exec,TypeOfMem
	jsr	releaseModuleData
	btst	#MEMB_CHIP,d0
	beq.b	.samplePlayExit

	jsr	obtainModuleData
	move.l	moduleaddress(a5),a1

	lea	952(a1),a0		* tutkitaan patternien m‰‰r‰
	moveq	#128-1,d0
	moveq	#0,d1
.k_lop1
	move.b	(a0)+,d2
	cmp.b	d2,d1
	bhi.b	.k_lop2
	move.b	d2,d1
.k_lop2	dbf	d0,.k_lop1
	addq	#1,d1
	mulu	#1024,d1		* Eka sample patternien j‰lkeen
	lea	1084(a1),a0
	add.l	d1,a0

	move	d7,d0
	moveq	#0,d1

.l	add.l	d1,a0
	moveq	#0,d1
	move	42(a1),d1	* len
	add.l	d1,d1
	moveq	#0,d2
	move	46(a1),d2	* repeat point
	add.l	d2,d2
	add.l	a0,d2
	move	48(a1),d3	* repeat len
	bne.b	.lw
	moveq	#1,d3
.lw

	lea	30(a1),a1
	dbf	d0,.l

	tst	d1
	bne.b	.sampleLenOk
	;* Something wrong with the data, go back to loop
	jsr	releaseModuleData
.samplePlayExit
	rts

.sampleLenOk

* a0 = sampleaddr
* d1 = samplelen
* d2 = repeat point
* d3 = repeat len

;	push	d5

*** Onko sample fastissa?
;	bsr	freeinfosample
;	move.l	d1,d6
;	sub.l	a0,d2
	
; ei taida toimia koska lev4 interruptit sotkevat

;	lea	foosample,a1
;	move.l	a1,a2
;.lrr	move.b	(a0)+,(a1)+
;	subq.l	#1,d6
;	bne.b	.lrr

;	move.l	a2,a0
;	add.l	a0,d2	

;	move.l	a0,d5
;	move.l	d1,d6

;	move.l	a0,a1
;	lore	Exec,TypeOfMem
;	btst	#MEMB_CHIP,d0
;	bne.b	.okc

;	move.l	d6,d0
;	moveq	#MEMF_CHIP,d1
;	bsr	getmem

;	sub.l	d5,d2
;	add.l	d0,d2

;	move.l	d5,a0
;	move.l	d0,d5
;	move.l	d0,a1
;	move.l	d6,d0
;	lob	CopyMem

;	move.l	d5,infosample(a5)

;	move.l	#nullsample,d2
;	moveq	#1,d3

.okc
;	move.l	d5,a0
;	move.l	d6,d1

;****
;	pop	d5


	tst.b	playing(a5)
	beq.b	.s1
	pushm	all
	* Pause playback first
	jsr	stopcont		* pausetaan
	popm	all
.s1

	* Set up audio registers for playback

	lea	$dff096,a3

	move	#$f,(a3)
	move.l	a0,$a0-$96(a3)
	move.l	a0,$b0-$96(a3)
	move.l	a0,$c0-$96(a3)
	move.l	a0,$d0-$96(a3)
	move	mainvolume(a5),d0
	lsr	#1,d0
	move	d0,$a8-$96(a3)
	move	d0,$b8-$96(a3)
	move	d0,$c8-$96(a3)
	move	d0,$d8-$96(a3)

	lsr.l	#1,d1
	move	d1,$a4-$96(a3)
	move	d1,$b4-$96(a3)
	move	d1,$c4-$96(a3)
	move	d1,$d4-$96(a3)

** Mouse coordinate defines the sample period
** perioidi mousen x-koordinaatista
	sub	#31,d5			* d5 = 0-315
	mulu	#36,d5
	divu	#315,d5
	add	d5,d5
	move	periods(pc,d5),d5

	move	d5,$a6-$96(a3)
	move	d5,$b6-$96(a3)
	move	d5,$c6-$96(a3)
	move	d5,$d6-$96(a3)

	lore	GFX,WaitTOF
	move	#$800f,(a3)
	lob		WaitTOF

	move.l	d2,$a0-$96(a3)
	move.l	d2,$b0-$96(a3)
	move.l	d2,$c0-$96(a3)
	move.l	d2,$d0-$96(a3)
	move	d3,$a4-$96(a3)
	move	d3,$b4-$96(a3)
	move	d3,$c4-$96(a3)
	move	d3,$d4-$96(a3)

	* Sample is now playing
	jsr	releaseModuleData

	bra	.samplePlayExit

periods
	dc	856,808,762,720,678,640,604,570,538,508,480,453
	dc	428,404,381,360,339,320,302,285,269,254,240,226
	dc	214,202,190,180,170,160,151,143,135,127,120,113
periodsEnd

* NOT USED
;freeinfosample
;	tst.l	infosample(a5)
;	beq.b	.x
;	pushm	all
;	move.l	infosample(a5),a0
;	clr.l	infosample(a5)
;	jsr	freemem
;	popm	all
;.x	rts


****************************************************************
* About
**

calculateDividersInList
	jsr	obtainModuleList
	bsr	getVisibleModuleListHeader
	moveq	#0,d0
.l	TSTNODE	a0,a0
	beq.b	.e
	tst.b	l_divider(a0)
	beq.b	.l
	addq.l	#1,d0
	bra.b	.l
.e	jmp	releaseModuleList

aboutButtonAction
rbutton10
	DPRINT	"about"
	movem.l	d0-a6,-(sp)

* lasketaan dividereitten m‰‰r‰
	DPRINT  "aboutButtonAction obtain list"
	* calculate the amount of list dividers in the list
	;lea	moduleListHeader(a5),a4
	bsr.b	calculateDividersInList
	move.l	d0,divideramount(a5)
	DPRINT  "aboutButtonAction release list"

	; set flag: info window should display the about info
	st	infolag(a5)

	tst	info_prosessi(a5)
	beq.b	.z

	move.l	infotaz(a5),a0		* jos oli jo aboutti niin suljetaan
	cmp.l	#about_t,a0
	bne.b	.rr
	bsr	sulje_info
	bra.b	.x
.rr
	bsr	start_info
	bra.b	.x

.z	bsr	rbutton10b

.x	movem.l	(sp)+,d0-a6
	rts


*******************************************************************************
* (error) Requesteri
*******
* a1 = teksti

request:
	movem.l	d0-a6,-(sp)
	sub.l	a4,a4
request2:
	lea	.ok_g(pc),a2
	bsr	rawrequest
	movem.l	(sp)+,d0-a6
	tst.l	d0	* not needed?!
	rts

.ok_g	dc.b	"OK",0
 even

areyousure_delete
	movem.l	d1-a6,-(sp)
	lea	.z(pc),a1
	lea	.y(pc),a2
	lea	infodefresponse(pc),a4
	move.l	(a4),d7
	clr.l	(a4)
	bsr	rawrequest
	move.l	d7,(a4)
	movem.l	(sp)+,d1-a6
	tst.l	d0
	rts

.z	dc.b	"Delete this file (or divider section)?",0
.y	dc.b	"_Yes|_No",0
 even

* Check if favorites list should be modified from the user
* Out:
*   d0 = 0 if modification not allowed
*   d0 = 1 if modification allowed
confirmFavoritesModification:
	; Check if in favorites list
	cmp.b	#LISTMODE_FAVORITES,listMode(a5)
	beq.b	.favs
	* No confirmation, all ok	
.ok	moveq	#1,d0
	rts
.favs
	tst.b	confirmFavoritesModificationDisabled(a5)
	bne.b	.ok

	pushm	d1-a6
	lea	infodefresponse(pc),a4
	move.l	(a4),-(sp)
	; Set "Nope" as the default response
	clr.l	(a4)
	lea	.z(pc),a1
	lea	.y(pc),a2
	bsr.b	rawrequest
	move.l	(sp)+,(a4)
	popm		d1-a6
	; d0 = 1: yes
	; d0 = 2: yes, dont ask again
	; d0 = 0: nope

	; Nope
	tst.l	d0
	beq.b	.x
	; Yes
	cmp	#1,d0
	beq.b	.ok
	; Yes, dont ask again
	cmp	#2,d0
	bne.b	.x
	st	confirmFavoritesModificationDisabled(a5)
	bra.b	.ok

.x	moveq	#0,d0
	rts

.z dc.b	"Modify the favorites list?",0
.y dc.b "_Yes|Yes, _don't ask again|_Nope!",0
 even
 
rawrequest:
	jsr	get_rt
	movem.l	a0-a4,-(sp)
	moveq	#RT_REQINFO,D0
	sub.l	a0,a0
;	move.l	_ReqBase+var_b,a6		* ???
	lob	rtAllocRequestA
	move.l	d0,d7
	movem.l	(sp)+,a0-a4
	tst.l	d0
	beq.b	.w
	move.l	d7,a3
	lea	inforeqtags0(pc),a0
	jsr	setMainWindowWaitPointer
	lob	rtEZRequestA
	jsr	clearMainWindowWaitPointer
	move.l	d0,-(sp)
	move.l	d7,a1
	lob	rtFreeRequest
	move.l	(sp)+,d0
	tst.l	d0
.w	rts





inforeqtags0
	dc.l	RTEZ_Flags,EZREQF_CENTERTEXT
	dc.l	RTEZ_ReqTitle,reqtitle

	dc.l	RTEZ_DefaultResponse,1
infodefresponse	=	*-4

	dc.l	RT_Underscore,"_"
	dc.l	RT_TextAttr,text_attr
otag8	dc.l	RT_PubScrName,pubScreenNameTags+var_b
	dc.l	TAG_END

init_error
	* Eagle related error messages shown elsewhere
	cmp	#ier_eagleplayer,d0 
	beq.b 	.skip
	cmp #ier_error_nomsg,d0
    beq     .skip
	neg	d0
	add	d0,d0
	lea	.ertab-2(pc,d0),a1
	add	(a1),a1
	bsr	request
.skip
* vapautetaan moduuli
	jsr	freemodule
* printataan infoa
	bra	inforivit_initerror


.ertab	dr	ier_error_t
	dr	ier_nochannels_t
	dr	ier_nociaints_t
	dr	ier_noaudints_t
	dr	ier_nomedplayerlib_t
	dr	ier_nomedplayerlib2_t
	dr	ier_mederr_t
	dr	ier_playererr_t
	dr	memerror_t
	dr	ier_nosid_t
	dr	ier_sidicon_t
	dr	ier_sidinit_t
	dr	ier_nopr_t
	dr	nochip_t
	dr	unknown_t
	dr	grouperror_t
	dr	filerr_t
	dr	hardware_t
	dr	ahi_t
	dr	ier_nomled_t
	dr	ier_mlederr_t
	dr	ier_not_compatible_t
	dr	ier_eagleplayer_t
    dr  ier_mpega_t
    dr  ier_mhi_t

ier_error           = -1
ier_nochannels      = -2
ier_nociaints       = -3
ier_noaudints       = -4
ier_nomedplayerlib  = -5
ier_nomedplayerlib2 = -6
ier_mederr          = -7
ier_playererr       = -8
ier_nomem           = -9
ier_nosid           = -10
ier_sidicon         = -11
ier_sidinit         = -12
ier_noprocess       = -13
ier_nochip          = -14
ier_unknown         = -15
ier_grouperror      = -16
ier_filerr          = -17
ier_hardware        = -18
ier_ahi             = -19
ier_nomled          = -20
ier_mlederr         = -21
ier_not_compatible  = -22
ier_eagleplayer     = -23
ier_mpega           = -24
ier_mhi             = -25
ier_error_nomsg     = -26 ; error code without showning a message

ier_playererr_t
ier_error_t
	dc.b	"Init error!?",0
ier_nochannels_t
	dc.b	"Couldn't allocate audio channels!",0
ier_nociaints_t
	dc.b	"Couldn't allocate CIA timer(s)!",0
ier_noaudints_t
	dc.b	"Couldn't allocate audio interrupts!",0
ier_nomedplayerlib_t
ier_nomedplayerlib2_t
 dc.b	"Couldn't open medplayer, octaplayer or octamixplayer.library!",0
	
ier_mederr_t
ier_sidinit_t
	dc.b	"Couldn't allocate audio channels or CIA interrupts!",0
ier_nosid_t
	dc.b	"Couldn't open playsid.library!",0
ier_sidicon_t
	dc.b	"Trouble with SID icon!",0
ier_nomled_t
	dc.b	"Couldn't open mline.library!",0
ier_mlederr_t
	dc.b	"MusiclineEditor init error!",0
ier_nopr_t
	dc.b	"Couldn't create process!",0
nochip_t dc.b	"Not enough chip memory!",0
filerr_t	dc.b	"File error!",0
hardware_t	dc.b "68020 or better required!",0
ahi_t	dc.b	"AHI device error!",0
ier_not_compatible_t
	dc.b	"Unsupported module type!",0
ier_eagleplayer_t
	dc.b	"Couldn't load eagleplayer!",0
ier_mpega_t
    dc.b    "Couldn't open mpega.library!",0
ier_mhi_t
    dc.b    "Couldn't initialize MHI!",0
 even


 ifne EFEKTI
efekti
	tst.b	win(a5)		* onko ikkunaa?
	beq.b	.r
	tst.b	kokolippu(a5)	* ikkuna pieni?
	beq.b	.r

	moveq	#.sine-.sin-1,d7
	lea	.sin(pc),a3
.loop
	lore	GFX,WaitTOF
	lob	WaitTOF
	
	lea	slider1,a0
;	move	#65535,d1		* 65535*arvo/max
	moveq	#-1,d1
	moveq	#0,d0
	move.b	(a3)+,d0
	bmi.b	.sk
	mulu	d0,d1
	lsr.l	#6,d1			* uusi HorizPot

	move.l	gg_SpecialInfo(a0),a1
	move	pi_Flags(a1),d0
	move	pi_HorizBody(a1),d3
	moveq	#0,d2
	moveq	#0,d4
	move.l	windowbase(a5),a1
	sub.l	a2,a2
	moveq	#1,d5
	lore	Intui,NewModifyProp


.sk	dbf	d7,.loop
.r
	rts

.sin
	DC.b	0,-1,3,6,$B,$11,$17,$1D,$24
	DC.b	$2A,$30,$36,$3B,$40

	dc.b	$3C,$38,$36
	DC.b	$34,$33,$32,$31,$32,-1,$33,$34
	DC.b	$35,$37,$38,$39,$3B,$3C,$3D,$3F
	DC.b	$40

	dc.b	$3F,$3E,$3D,-1,-1,$3C,-1
	DC.b	-1,$3D,-1,-1,-1,$3E,-1,-1
	DC.b	-1,$3F,$40
.sine

 even

  endc
  

*******************************************************************************
*** SECTION *******************************************************************
*
* Vertical blanking interrupt
* CIA interrupt
* Software interrupt
*
*******************************************************************************

*******************************************************************************
* Keskeytykset
*******


intserver
	dc.l	0,0
	dc.b	2
	dc.b	0	* priority
	dc.l	.intname
	dc.l	var_b		* is_Data passed in a1
	dc.l	.vbinterrupt


.intname dc.b	"HiP-VBlank",0
 even

.vbinterrupt
	pushm	d2-d7/a2-a6
	move.l	a1,a5			* a1 = is_Data = var_b

	* Check if tooltip tick count is active.
	* It it expires, trigger a signal
	tst	tooltipTick(a5)
	beq.b	.notActive
	subq	#1,tooltipTick(a5)
	bne.b	.notActive
	move.b	tooltipSignal(a5),d1
	bsr	signalit
.notActive

	* Are we playing something?
	tst.b	playing(a5)
	beq.b	.notPlaying

	* Yes.
	* Let's call the CIA-replay routine if user has opted
	* for VBlank timing.

	push	a5
	* Check for VBlank timing flag
	tst.b	vbtimeruse(a5)
	beq.b	.novb
	* Play some music!
	move.l	playerbase(a5),a0
	jsr	p_ciaroutine(a0)
	move.l	(sp),a5
.novb
	* Whatever happened above, let's call the VBlank-replay routine.
	move.l	playerbase(a5),a0
	jsr	p_vblankroutine(a0)
	pop	a5

	* Call scope interrupt code.
	* This will keep track of sample playback positions for drawing.
	bsr	scopeinterrupt

	* Set filter 
	move.b	filterstatus(a5),d0
	bne.b	.oop
	btst	#1,$bfe001
	sne	modulefilterstate(a5)
	bra.b	.uup
.oop	subq.b	#1,d0
	bne.b	.eep
.peep	bset	#1,$bfe001
	bra.b	.uup
.eep	bclr	#1,$bfe001
.uup
	
	* Check if song has ended
	tst.b	songover(a5)
	beq.b	.huh
.songover	
	clr.b	songover(a5)

	* Trigger signal for the main application loop indicating song has ended.
	* If there is a loading operation going on, let's not signal.
	* This tests both "loading" and "loading2"
	tst	loading(a5)	
	bne.b	.wasLoading
	move.b	songHasEndedSignal(a5),d1
	bsr	signalit
.huh
.notPlaying
.wasLoading
	* Another are we playing check?
	tst.b	playing(a5)
	beq.b	.notPlaying2

	* Yes, we still are. Let's check if the playing position has changed
	* since the last check.
	move	pos_nykyinen(a5),d0	* current position
	move	positionmuutos(a5),d1	* last known position
	cmp	d1,d0
	beq.b	.eee
	move	d0,positionmuutos(a5)	* was different, store new changed position

	tst.b	kelattiintaakse(a5)	* check if there was some rewinding going on
	beq.b	.norewind
	clr.b	kelattiintaakse(a5)	* there was, let's not check for songend based 
					* on positions
	bra.b	.rewind
.norewind
	* If the last known position is higher than the current position,
	* we deduce that the song has actually ended and may have restarted
	* from the beginning.
	* This may trigger an extra songend signal after 
	* the above signal, so it should only be enabled for formats
	* that have pos/len but not songend support.
	* These are: MED, SoundFX, StarTrekker
	move.l	playerbase(a5),a0
	move	#pf_end,d2
	and	p_liput(a0),d2
    ;bne     .skipCheck
	beq.b	.noSongEnd

    * Protracker case:
    * - backwards jump is a songover signal
    *   for songs that have subsongs
    * - it is not a songover signal if mod has no
    *   subsongs
    cmp.w   #pt_prot,playertype(a5)
    bne     .noProt
    tst.w   maxsongs(a5)
    beq     .skipCheck
.noProt


	* This player supports songend. 
	* To avoid extra songend detections, do the song position
	* check only if the current position is non-zero.
	* This detects PT modules that jump from the last position to 
	* some other than position zero.
	tst	    d0
	beq.b	.skipCheck

.noSongEnd

	* Current format does not have songend support, do the check!
	sub	d1,d0	
	bmi.b	.songover
.rewind
.skipCheck
	* Send a signal indicating that playing position has changed
	move.b	posUpdateSignal(a5),d1
	bsr	signalit
.eee
.notPlaying2

	* UI refresh signal
	* When playing: every 1/2th of second
	* When not: every second
	
	move	vertfreq(a5),d0
	tst.b	playing(a5)
	beq.b	.notPlaying3
	lsr     #1,d0				
    tst.b    infoScrollEnabled(a5)
    beq     .notPlaying3
    * Scroller enabled, update more often
    moveq   #SCROLL_UPDATE_RATE,d0
.notPlaying3

	* Count if enough VBlanks have passed and then signal
	addq	#1,ticktack(a5)		
	cmp	ticktack(a5),d0
	bhi.b	.nope
	clr	ticktack(a5)
	move.b	uiRefreshSignal(a5),d1
	bsr	signalit
.nope

	* YET ANOTHER TEST!
	tst.b	playing(a5)	
	beq	.notPlaying4
	tst.b	vbtimeruse(a5)
	bne.b	.eir
	* Yes we are still playing and actually using CIA-timers
	* Check if user wants to fast forward.

	move.l	playerbase(a5),a0	* Kelaus CIA-ajastimella
	move	p_liput(a0),d0
	* Check if the replayer supports forwarding using timer
	btst	#pb_ciakelaus,d0
	bne.b	.joog
	* Check if the replayers forwarding by skipping patterns
	btst	#pb_ciakelaus2,d0
	beq.b	.eir
	
	cmp	#pt_prot,playertype(a5)		* ProTracker??
	bne.b	.joog
	* Yes it was protracker. Some special handling here.
	lea	kplbase(a5),a0
	move	k_timerhi(a0),d0
	move.b	k_whichtimer(a0),d1
	tst.b	kelausnappi(a5)
	beq.b	.bb
	lsr	#1,d0
.bb	move.l	k_cia(a0),a0
	lea	ciatalo(a0),a0
	tst.b	d1
	beq.b	.aap
	lea	$200(a0),a0
.aap	bra.b	.aa

	* Timer based forward.
	* Set a new timer delay into the CIA timer
.joog
	move	timerhi(a5),d0
	tst.b	kelausnappi(a5)		* onko painettu kelausnappia?
	beq.b	.kel
	move.b	kelausvauhti(a5),d1
	lsr	d1,d0
.kel
	move.l	ciaddr(a5),a0
	lea	ciatalo(a0),a0
	tst.b	whichtimer(a5)
	beq.b	.aa
	lea	$200(a0),a0
.aa
	move.b	d0,(a0)
	ror	#8,d0
	move.b	d0,$100(a0)
.eir
	* CIA timer based forwarding setup done.

	* Next up, update HippoPort contents for any external users.

	move.b	mainvolume+1(a5),hippoport+hip_mainvolume(a5)
	move.b	playertype+1(a5),hippoport+hip_playertype(a5)

	cmp	#pt_multi,playertype(a5)
	bne.b	.por

	* PS3M data update
	move.l	ps3m_buff1(a5),a0
	move.l	(a0),hippoport+hip_ps3mleft(a5)
	move.l	ps3m_buff2(a5),a0
	move.l	(a0),hippoport+hip_ps3mright(a5)
	move.l	ps3m_playpos(a5),a0
	move.l	(a0),d0
	lsr.l	#8,d0
	move.l	d0,hippoport+hip_ps3moffs(a5)
	move.l	ps3m_buffSizeMask(a5),a0
	move.l	(a0),hippoport+hip_ps3mmaxoffs(a5)
.por
.nop
.notPlaying4
	* Final piece of data
	move.b	playing(a5),hippoport+hip_play(a5)

	popm	d2-d7/a2-a6
	moveq	#0,d0
	rts


* d1 = signal number sent to the main task
signalit:
	move.l	owntask+var_b,a1
	moveq	#0,d0
	bset	d1,d0
	move.l	4.w,a6			
	jmp	_LVOSignal(a6)


******************************************************************************
*
* CIA timer interrupt
* Software interrupt
*
******************************************************************************

ciaserver
	dc.l	0,0
	dc.b	2
	dc.b	0	* prioriteetti
	dc.l	.intname2
	dc.l	softserver		* is_Data passed in a1
	dc.l	ciainterrupt

.intname2 dc.b	"HiP-CIA",0
 even

* cdtv-compatible CIA interrupt driver
* All this does is trigger the software interrupt so as not to disturb
* level 5 stuff, such as serial transfers.

ciainterrupt	
	push	a6
;	move.l	4.w,a6
	move.l	exeksi(pc),a6    * Probably faster compared to CHIP RAM access
	lob	Cause
	pop	a6
	moveq	#0,d0
	rts

exeksi	dc.l	0

softserver
	dc.l	0,0
	dc.b	2
	dc.b	0	* priority
	dc.l	.softintname
	dc.l	var_b		* is_Data passed in a1
	dc.l	softint     * code entry point

.softintname
	dc.b "HiP-SoftInt",0
 even

softint	
	* Do nothing if not playing
	tst.b	playing(a1)
	beq.b	.exit
	pushm	d2-d7/a0/a2-a4/a6
	move.l	a1,a5
	* Call the CIA replay routine if it's a non-AHI routine and AHI is not enabled
	move.l	playerbase(a5),a0	
	* AHI is active?
	tst.b	ahi_use_nyt(a5)
	beq.b	.noAHI
	* AHI is active, check if player supports it.
	move	p_liput(a0),d0
	and		#pf_ahi,d0
	bne.b	.yesAHI
	* Player is not AHI player. Can play music here.
.noAHI
	* Play music!
	jsr	p_play(a0)
.yesAHI
	popm	d2-d7/a0/a2-a4/a6
.exit	
	moveq	#0,d0
	rts




********************************************************************************
*** SECTION ********************************************************************
*
* ARexx support
*
********************************************************************************

******************************************************************************
*
* ARexx-toiminnot
*
******************************************************************************

rexxmessage
	pushm	all
	lea	rexxport(a5),a0
	lore	Exec,GetMsg
	move.l	d0,rexxmsg(a5)
	beq 	.nomsg

    tst.l   _RexxBase(a5)
    bne     .1
    * This shouldn't fail as an ARexx msg was received
	lea	rexxname,a1
    lob	OldOpenLibrary
	move.l	d0,_RexxBase(a5)
.1

	move.l	rexxmsg(a5),a1
	clr.l	rm_Result1(a5)
	clr.l	rm_Result2(a5)
	clr.l	rexxresult(a5)

	lea	rm_Args(a1),a4
	tst.l	(a4)
	beq.b	.end

 if DEBUG
	move.l	(a4),d0
	DPRINT	"ARexx: %s"
 endif

	lea	.komennot-4(pc),a3
.loop	addq.l	#4,a3
	tst	(a3)
	beq.b	.end
	move.l	a3,a2
	add	(a2),a2
	move.l	a2,a0
	lore	Rexx,Strlen
	move.l	d0,d3
	move.l	a2,a0
	move.l	(a4),a1
	lob	StrcmpN
	tst.l	d0
	bne.b	.loop
	move.l	(a4),a1
	add.l	d3,a1
	cmp.b	#' ',(a1)+	* Onko komennon j‰lkeen SPACE?
	seq	d0		* Lippu p‰‰lle jos on.
	move.l	a3,a0
	addq	#2,a0
	add	(a0),a0
	pushm	all
	jsr	(a0)
	popm	all
.end

	move.l	rexxmsg(a5),a1
	move.l	rexxresult(a5),rm_Result2(a1)
	lore	Exec,ReplyMsg
.nomsg
	popm	all
	rts	returnmsg

.komennot
	dr	.playt,.playr
	dr	.cleart,._clearlist
	dr	.contt,._actionContinue
	dr	.stopt,._actionStopButton
	dr	.ejectt,._rbutton4
	dr	.lprgt,.loadprg
	dr	.addt,.add
	dr	.delt,rbutton8
	dr	.volt,.volume
	dr	.rewt,._rbutton_kela1
	dr	.ffwdt,._rbutton_kela2
	dr	.movet,.move
	dr	.sortt,._rsort
	dr	.insertt,.insert
	dr	.quitt,.quit
	; Put these before "CHOOSE" since matcher will 
	; get the shorter one otherwise
	dr	.chooseNextT,.chooseNext
	dr	.choosePrevT,.choosePrev
	dr	.chooset,.choose
	dr	.psongt,.playsong
	dr	.gett,.get
	dr	.randt,.playrand
	dr	.hidet,.hide
	dr	.sizet,.size
	dr	.pbsct,.setpubscreen
	dr	.toutt,.timeout
	dr	.ps3m1,.ps3mmode
	dr	.ps3m2,.ps3mboost
	dr	.ps3m3,.ps3mrate
	dr	.loadp,.loadprefs
	dr	.sampt,rbutton10b
	dr	.listmodet,toggleListMode
	dr	.favoritet,.toggleFavorite
	dc 	0 ; END

.playt	dc.b	"PLAY",0
.cleart	dc.b	"CLEAR",0
.contt	dc.b	"CONT",0
.stopt	dc.b	"STOP",0
.ejectt	dc.b	"EJECT",0
.lprgt	dc.b	"LOADPRG",0
.addt	dc.b	"ADD",0
.delt	dc.b	"DEL",0
.volt	dc.b	"VOLUME",0
.rewt	dc.b	"REW",0
.ffwdt	dc.b	"FFWD",0
.movet	dc.b	"MOVE",0
.sortt	dc.b	"SORT",0
.insertt dc.b	"INSERT",0
.quitt	dc.b	"QUIT",0
.chooset dc.b	"CHOOSE",0
.chooseNextT dc.b "CHOOSENEXT",0
.choosePrevT dc.b "CHOOSEPREV",0
.psongt	dc.b	"SONGPLAY",0
.gett	dc.b	"GET",0
.randt	dc.b	"RANDPLAY",0
.hidet	dc.b	"HIDE",0
.sizet	dc.b	"ZIP",0
.pbsct	dc.b	"PUBSCREEN",0
.toutt	dc.b	"TIMEOUT",0
.ps3m1	dc.b	"PS3MMODE",0
.ps3m2	dc.b	"PS3MBOOST",0
.ps3m3	dc.b	"PS3MRATE",0
.loadp	dc.b	"LOADPREFS",0
.sampt	dc.b	"SAMPLES",0
.listmodet dc.b "TOGGLEMODE",0
.favoritet dc.b "FAVORITE",0
 even

._clearlist
	jmp	clearlist
._rbutton4
	jmp	rbutton4
._actionStopButton
	jmp	actionStopButton
._actionContinue
        jmp     actionContinue
._rbutton_kela1
	jmp	rbutton_kela1
._rbutton_kela2
	jmp	rbutton_kela2
._rsort	
	jmp	rsort

*** PLAY
.playr	
	tst.b	d0
	bne .nx
    jmp rbutton1
.nx
	move.l	a1,sv_argvArray+4(a5)
	clr.l	sv_argvArray+8(a5)
    jsr     engageNormalMode
    jsr     clearlist
    bra	    komentojono

*** LOADPRG
.loadprg
	tst.b	d0
	beq	rloadprog
	move.l	a1,d7
	bra	rloadprog2

*** QUIT
.quit	st	exitmainprogram(a5)
.exit	rts


*** ADD	
.add	
    jsr     engageNormalMode

	tst.b	d0
    bne .__1
    jmp     rbutton8
.__1

.add2	cmp.l	#MAX_MODULES,modamount(a5)	* Ei enemp‰‰ kuin ~16000
	bhs.b	.exit

	move.l	a1,a2
.fe	tst.b	(a2)+
	bne.b	.fe
	sub.l	a1,a2
	add	#l_size,a2
	move.l	a2,d0			* nimen pituus

	move.l	#MEMF_CLEAR,d1		* varataan muistia
	jsr	getmem
	beq.b	.exit
	move.l	d0,a3

	lea	l_filename(a3),a2
	move.l	a2,a0
.cp1	move.b	(a1)+,(a2)+
	bne.b	.cp1

	move.l	a0,a1
	move.l	a2,a0
	bsr	nimenalku
	move.l	a0,l_nameaddr(a3)	* pelk‰n nimen osoite

	jsr	addfile
	bsr	listChanged

	tst.l	chosenmodule(a5)
	bpl.b	.ee
	clr.l	chosenmodule(a5)	* moduuliksi eka jos ei ennest‰‰n
.ee	
	jmp	forceRefreshList


*** INSERT
.insert
    jsr     engageNormalMode

	tst.b	d0
	bne	    .rinsert0
    jmp     rinsert
.rinsert0
	jsr     rinsert2
	bsr.b	.add2
	clr.b	filereqmode(a5)
	rts


*** MOVE
.move
    jsr     engageNormalMode

	bsr	a2i
	move	d0,-(sp)
	jsr	rmove
	move	(sp)+,d0
	subq	#1,d0
	bsr.b	.choo
	jmp	rmove	


*** CHOOSE
.choose
	bsr	a2i
	subq.l	#1,d0
	bsr.b	.choo
	jmp	resh

*** valitaan d0:ssa olevan numeron tiedosto
.choo
	move.l	d0,chosenmodule(a5)
	cmp.l	modamount(a5),d0
	blo.b	.chosenOk
	move.l	modamount(a5),chosenmodule(a5)
	subq.l	#1,chosenmodule(a5)
	bpl.b	.chosenOk
	clr.l	chosenmodule(a5)
.chosenOk
	rts

.chooseNext
	moveq	#0,d4	* rawkey modifier, no shift
	jmp	lista_alas
.choosePrev	
	moveq	#0,d4	* rawkey modifier, no shift
	jmp	lista_ylos
	
*** VOLUME
.volume
	bsr	a2i
	jmp	volumerefresh


*** PLAYSONG
.playsong
	bsr	a2i
	subq	#1,d0
	move	d0,songnumber(a5)
	moveq	#0,d1
	jmp	songSkip
	
	

*** PLAYRAND
.playrand
	jmp	soitamodi_random
	

*** HIDE
.hide
	bsr	a2i		* d0 = 0 tai 1
	tst.b	d0
	beq.b	.hide_hide
	tst.b	win(a5)
	beq.b	.hide1
	rts
.hide_hide
	tst.b	win(a5)
	bne.b	.hide1
	rts
.hide1	move	#$25,rawkeyinput(a5)
.hide2
	move.b	rawKeySignal(a5),d1
	bra	signalit


*** SIZE

;	move.l	windowbase(a5),a0	* Kick2.0+
;	lore	Intui,ZipWindow
	
.size
	bsr	a2i
	tst.b	d0
	beq.b	.size_small
	tst.b	kokolippu(a5)
	beq.b	.size1
	rts
.size_small
	tst.b	kokolippu(a5)
	bne.b	.size1
	rts
.size1	
	tst.b	uusikick(a5)
	beq.b	.oldk
	move.l	windowbase(a5),a0	* Kick2.0+
;	lore	Intui,ZipWindow
	move.l	_IntuiBase(a5),a6
	jmp	_LVOZipWindow(a6)

.oldk	jsr	sulje_ikkuna		* kick1.2+
;	bra	avaa_ikkuna
	jmp	avaa_ikkuna


*** PUBSCREEN
.setpubscreen
	tst.b	uusikick(a5)
	bne.b	.nwkd
	rts

.nwkd	bsr.b	.prefspo
	lea	pubscreen(a5),a0
.c123	move.b	(a1)+,(a0)+
	bne.b	.c123
	st	newpubscreen(a5)
	move.b	ownsignal2(a5),d1
	bra	signalit

*** TIMEOUT
.timeout
	bsr.b	.prefspo
	bsr	a2i
	cmp	#600,d0
	bls.b	.ok32
	move	#600,d0
.ok32	move	d0,timeout(a5)
	bra	sliderit

*** PS3M
.ps3mmode
	bsr.b	.prefspo
	bsr	a2i
	move.b	d0,s3mmode2(a5)
	rts

.ps3mboost
	bsr.b	.prefspo
	bsr	a2i
	cmp.b	#8,d0
	bls.b	.ok12
	moveq	#8,d0
.ok12	move.b	d0,s3mmode3(a5)
	bra	sliderit

.ps3mrate
	bsr.b	.prefspo
	bsr	a2i
	cmp.l	#5000,d0
	bhs.b	.ok55
	move.l	#5000,d0
.ok55	cmp.l	#58000,d0
	bls.b	.ok76
	move.l	#58000,d0
.ok76	move.l	d0,mixirate(a5)
	bra	sliderit

.prefspo
	push	a1
	bsr	sulje_prefs
	pop	a1
	rts



**** LOADPREFS
* This probably doesn't work perfectly
.loadprefs
	push	a1
	jsr	rbutton4		* eject
	jsr	clearlist
	;bsr	sulje_quad
	bsr	stopScopeTasks
	bsr.b	.prefspo
	jsr	sulje_ikkuna
	jsr	rem_inputhandler
	pop	d7
	bsr	loadprefs2
	jsr	setboxy
	jsr	init_inputhandler
;	tst.b	quadon(a5)			* avataanko scope?
;	beq.b	.q
;	bsr	start_quad
;.q
	not.b	kokolippu(a5)
	jmp	avaa_ikkuna

.toggleFavorite
	bra	toggleFavoriteStatusForCurrentModule

* GET:
* 	current song
* 	chosenmodule
*	subsongs
*	play on/off
*	num files
*	current songpos
*	max songpos
*	playingmodule
*	modulename
*	moduletype
*	duration
*	hide status
*	app version
*	volume

.get	move.b	(a1)+,d0
	lsl.l	#8,d0
	move.b	(a1)+,d0
	lsl.l	#8,d0
	move.b	(a1)+,d0
	lsl.l	#8,d0
	move.b	(a1)+,d0

	lea	.getlist-2(pC),a1
.getloop
	addq.l	#2,a1
	tst.l	(a1)
	beq.b	.getx
	cmp.l	(a1)+,d0
	bne.b	.getloop
	add	(a1),a1
	jsr	(a1)
.getx	rts

.getlist
	dc.l	"PLAY"
	dr	.getplay
	dc.l	"CFIL"
	dr	.getcfil
	dc.l	"NFIL"
	dr	.getnfil
	dc.l	"CSNG"
	dr	.getcsng
	dc.l	"NSNG"
	dr	.getnsng
	dc.l	"CSPO"
	dr	.getcspo
	dc.l	"MSPO"
	dr	.getmspo
	dc.l	"CURR"
	dr	.getcurrent
	dc.l	"NAME"
	dr	.getname
	dc.l	"TYPE"
	dr	.gettype
	dc.l	"CNAM"
	dr	.currname
	dc.l	"FNAM"
	dr	.fullname
	dc.l	"COMM"
	dr	.getcomment
	dc.l	"SIZE"
	dr	.getsize
	dc.l	"HIDS"
	dr	.hidestatus
	dc.l	"DURA"
	dr	.duration
	dc.l	"FILT"
	dr	.filter
	dc.l	"VERS"
	dr	.version
	dc.l	"VOLU"
	dr	.getVolume
	dc.l	0

.getplay
	moveq	#1,d0
	and.b	playing(a5),d0
	bra	i2amsg

.getcfil
	move.l	chosenmodule(a5),d0
	bmi.b	.getcfil0
	cmp.l	#PLAYING_MODULE_REMOVED,d0
	beq.b	.getcfil0
	addq.l	#1,d0
	bra	i2amsg2
.getcfil0
	moveq	#0,d0
	bra	i2amsg

.getnfil
	move.l	modamount(a5),d0
	bra	i2amsg2

.getcsng
	move	songnumber(a5),d0
	addq	#1,d0
	bra	i2amsg

.getnsng
	move	maxsongs(a5),d0
	addq	#1,d0
	bra	i2amsg

.getcspo
	move	pos_nykyinen(a5),d0
	bra	i2amsg

.getmspo
	move	pos_maksimi(a5),d0
	bra	i2amsg

.getname
	lea	modulename(a5),a2
	bra	str2msg

.gettype
	lea	moduletype(a5),a2
	bra	str2msg

.getcurrent
	move.l	playingmodule(a5),d0
	bmi.b	.getc0
	addq.l	#1,d0
	cmp.l	#PLAYING_MODULE_REMOVED+1,d0
	bne	i2amsg2
.getc0	moveq	#0,d0
	bra	i2amsg

.currname
	bsr	getcurrent
	bne.b	.curr0
	lea	.empty(pc),a2
	bra	str2msg
.curr0	lea	l_filename(a3),a2
	bra	str2msg

.fullname
	move.l	playingmodule(a5),d0
	bmi.b	.curr1
	cmp.l	#PLAYING_MODULE_REMOVED,d0
	bne.b	.curr2
.curr1	lea	.empty(pc),a2
	bra	str2msg	
.curr2	bsr	getcurrent2
	lea	l_filename(a3),a2
	bra	str2msg

.getcomment
	lea	filecomment(a5),a2
	bra	str2msg

.getsize
	move.l	modulelength(a5),d0
	add.l	tfmxsampleslen(a5),d0
	bra.b	i2amsg2

.duration
	cmp	#pt_prot,playertype(a5)
	beq.b	.d9	
	moveq	#0,d0
	bra.b	i2amsg2
.d9
	move	kokonaisaika(a5),d0
	mulu	#60,d0
	add	kokonaisaika+2(a5),d0
	bra.b	i2amsg2

.hidestatus
	moveq	#1,d0
	and.b	win(a5),d0
	eor.b	#1,d0
	bra.b	i2amsg

.filter
	btst	#1,$bfe001
	seq	d0
	and.l	#%1,d0
	bra.b	i2amsg

.getVolume
	moveq	#0,d0
	move	mainvolume(a5),d0
	bra.b	i2amsg

* provide version string
.version
	lea	-30(sp),sp
	lea	versionStringStart,a0
	lea	versionStringEnd-versionStringStart(a0),a1
	move.l 	sp,a2
.copy
	move.b	(a0)+,(a2)+
	cmp.l	a0,a1
	bne.b	.copy
	clr.b	(a2)
	move.l	sp,a2
	bsr.b	str2msg
	lea	30(sp),sp
	rts

.empty	dc	0

** a1:ssa oleva ascii-luku D0:aan
a2i	pushm	d1/a0/a6
	move.l	a1,a0
	lore	Rexx,CVa2i
	popm	d1/a0/a6
	rts

*** d0:ssa oleva luku rexxviestiksi
i2amsg	ext.l	d0
i2amsg2	pushm	d0/d1/a0/a1/a6
	moveq	#3,d1
	lore	Rexx,CVi2arg
	move.l	d0,rexxresult(a5)
	popm	d0/d1/a0/a1/a6
	rts

** a2:ssa oleva tekstinp‰tk‰ rexxviestiksi
str2msg	pushm	d0/d1/a0/a1/a6
	move.l	a2,a0
	lore	Rexx,Strlen
	move.l	a2,a0
	lob	CreateArgstring
	move.l	d0,rexxresult(a5)
	popm	d0/d1/a0/a1/a6
	rts




;	move.l	rm_Args(a1),a0	; test for different commands here!
;	bsr	CLI_Write	; you must parse the parameters yourself

;	move.l	_RexxSysLibBase(pc),a6
;	lea	ret_string(pc),a0
;	move.l	a0,a1
;.len	tst.b	(a1)+
;	bne.s	.len
;	move.l	a1,d0
;	sub.l	a0,d0
;	subq.l	#1,d0
;	jsr	_LVOCreateArgstring(a6)

;	move.l	4.w,a6
;	move.l	RexxMsg_Ptr,a1
;	clr.l	rm_Result1(a1)		; result1 (Include:rexx/error.i)
;				; reselt1=rc (a global arexx var)
;	clr.l	rm_Result2(a1)		; result2 (0 for no return argstring)
;	move.l	d0,rm_Result2(a1)	; result2 (result=your string)
				; result only accept if arexx contains
				; Options Results
;	jsr	_LVOReplyMsg(a6)


********************************************************************************
*** SECTION ********************************************************************
*
* Scopes
*
********************************************************************************

* SID pattern scope voice
* clr-fields: 
* - when the main value is set from 1 to 0, clr is set to non-zero.
* - clr is subtracted every frame
* - when clr reaches zero, display zero
    rsreset
sv_freq        rs.w 1
sv_pulseWidth  rs.w 1
sv_envelope    rs.w 1   * 0..63
sv_gate        rs.b 1  * current value
sv_gateClr     rs.b 1  
sv_sync        rs.b 1
sb_syncClr     rs.b 1
sv_ring        rs.b 1
sv_ringClr     rs.b 1
sv_test        rs.b 1
sv_testClr     rs.b 1
sv_triangle    rs.b 1
sv_triangleClr rs.b 1
sv_saw         rs.b 1
sv_sawClr      rs.b 1
sv_pulse       rs.b 1
sv_pulseClr    rs.b 1
sv_noise       rs.b 1
sv_noiseClr    rs.b 1
sv_filter      rs.b 1   * filter enable for this voice
sv_filterClr   rs.b 1
sv_size        rs.b 0

* SID scope data
    rsreset
ss_voice1      rs.b  sv_size
ss_voice2      rs.b  sv_size
ss_voice3      rs.b  sv_size
ss_filterCut   rs.w  1
ss_filterRes   rs.b  1
ss_filterLp    rs.b  1
ss_filterLpClr rs.b  1
ss_filterBp    rs.b  1
ss_filterBpClr rs.b  1
ss_filterHp    rs.b  1
ss_filterHpClr rs.b  1
               rs.b  1 * pad
sids_size      rs.b  0

* Scope data
                              rsreset
s_global                      rs.l       1
s_quad_task                   rs.l       1
s_windowTitle                 rs.l      1
* Pointer to the running status flag
s_runningStatusAddr            rs.l      1
s_storedPositionAddr		rs.l 	1
s_newWindow                   rs.b       enw_SIZEOF
s_scopeWindowBase             rs.l       1
s_rastport3                   rs.l       1	
s_userport3                   rs.l       1
* Draw raster buffer address
s_buffer0                     rs.l       1
* Buffer width
s_buffer0w                    rs.w       1
* Buffer height rasterlines
s_buffer0h                    rs.w       1
* Set to true if draw buffer is in CHIP
s_bufferIsChip                rs.b       1 
s_syncMode                    rs.b       1 * 0: vblank, 1: timer device
s_quadmode                    rs.b       1
s_quadmode2                   rs.b       1
s_scopeDrawAreaWidth		rs.w 	1
s_scopeDrawAreaModulo		rs.w 	1
s_scopeDrawAreaWidthRequest   rs.w       1
s_scopeDrawAreaHeightRequest  rs.w       1
s_scopeDrawAreaHeight         rs.w       1
s_quadNoteScrollerLines       rs.w       1
s_quadNoteScrollerLinesHalf   rs.w       1
s_scopePreviousLeftEdge       rs.w       1
s_scopePreviousTopEdge        rs.w       1
s_scopePreviousWidth          rs.w       1
s_scopePreviousHeight         rs.w       1
s_scopePreviousPattPos        rs.w       1
s_scopePreviousSongPos        rs.w       1
s_omabitmap                   rs.b      bm_SIZEOF
s_buffer1                     rs.l       1
s_buffer2                     rs.l       1
s_draw1                       rs.l       1
s_draw2                       rs.l       1
* Triggered channel volumes for Protracker animated volume bars
s_patternScopeVolumes	      rs.w       4
                              ifne       FEATURE_FREQSCOPE
s_deltab1                     rs.l       1	
s_deltab2                     rs.l       1	
s_deltab3                     rs.l       1	
s_deltab4                     rs.l       1	
                              endif
                              ifne       FEATURE_SPECTRUMSCOPE
s_spectrumMemory              rs.l       1
s_spectrumVolumeTable         rs.l       1
s_spectrumMuluTable           rs.l       1
s_spectrumExpTable            rs.l       1
s_spectrumSineTable           rs.l       1
s_spectrumChannel1            rs.l       1
s_spectrumChannel2            rs.l       1
s_spectrumChannel3            rs.l       1
s_spectrumChannel4            rs.l       1
s_spectrumMixedData           rs.l       1
s_spectrumImagData            rs.l       1
s_spectrumInitialized         rs.w       1
                              endif

s_sidScopeData                rs.b      sids_size 
s_sid2ScopeData               rs.b      sids_size 
s_sid3ScopeData               rs.b      sids_size 

s_timerPort                   rs.b      MP_SIZE
s_timerIORequest              rs.b      IOTV_SIZE

s_multab                      rs.w       256 * modulo multiplication table
s_scopeHorizontalBarTable     rs.b       512
s_mtab                        rs.b       64*256*2 * volume table for scopes
sizeof_scopeVars              rs.b       1

* Incoming volume values need to be validated or else there will
* be over indexing mayhem and memory corruption!
CLAMPVOL macro
	cmp	#$40,\1
	bls.b	*+4
	moveq	#$40,\1
	endm


* Structure to help task starting and stopping
    STRUCTURE ScopeTaskDefinition,0
        UWORD st_runningStatusOffset * Relative to a5
        UWORD st_prefsStatusOffset * Relative to a5+prefsdata
        UWORD st_taskOffset * Relative to a5
        UWORD st_entryPoint * Code start address relative offset
    LABEL ScopeTaskDefinition_SIZEOF

quadraScopeTaskDefinition
	dc.w	quadraScopeRunning
	dc.w	prefs_quadraScope
	dc.w	taskQuadraScope
	dr.w	quadraScopeEntry

quadraScopeFTaskDefinition
	dc.w	quadraScopeFRunning
	dc.w	prefs_quadraScopeF
	dc.w	taskQuadraScopeF
	dr.w	quadraScopeFEntry

hippoScopeTaskDefinition
	dc.w	hippoScopeRunning
	dc.w	prefs_hippoScope
	dc.w	taskHippoScope
	dr.w	hippoScopeEntry

patternScopeTaskDefinition
	dc.w	patternScopeRunning
	dc.w	prefs_patternScope
	dc.w	taskPatternScope
	dr.w	patternScopeEntry

spectrumScopeTaskDefinition
	dc.w	spectrumScopeRunning
	dc.w	prefs_spectrumScope
	dc.w	taskSpectrumScope
	dr.w	spectrumScopeEntry


* In:
*   a2 = Task name
*   a3 = Task structure
* Out:
*   d0 = 1: ok, 0: out of mem
initScopeTask:
	bsr.b	resetScopeTask

	* Initialize ln_Node
	move.b	#NT_TASK,LN_TYPE(a3)
	* Initial priority 0
	clr.b	LN_PRI(a3)
	move.l	a2,LN_NAME(a3)

	* Allocate stack mementry
	lea	.memList(pc),a0
	lore	Exec,AllocEntry
	* Sets bit 31 on failure
	tst.l	d0
	bmi.b	.fail

	* a1 = MemList
	move.l	d0,a1
	* a2 = allocated mem block
	move.l	ML_ME+ME_ADDR(a1),a2

	* Set stack pointers
	move.l	a2,TC_SPLOWER(a3)
	lea	3000(a2),a2
	move.l	a2,TC_SPUPPER(a3)
	move.l	a2,TC_SPREG(a3)

	* Create mementry list in task 
	lea	TC_MEMENTRY(a3),a0
	NEWLIST	a0

	* Add stack memory entry at a1 to the task mementry list,
	* to be freed on task exit.
	lob	AddHead

	moveq	#1,d0
.x	rts

.fail	
	moveq	#0,d0
	rts

.memList
	* reserve space for list node
	DS.B	LN_SIZE 	  
	* number of entries
	DC.W	1		
    	* entry #1 - stack space
	DC.L	MEMF_PUBLIC!MEMF_CLEAR
	DC.L	3000
	
* In:
*   a3 = Task structure
resetScopeTask
	* Reset task structure
	move.l	a3,a0
	moveq	#TC_SIZE-1,d0
.c	clr.b	(a0)+
	dbf	d0,.c
	rts

* In:
*  a4 = task definition
*  d7 = capability bits, pf_samplescope/pf_patternscope
startScopeTask:
	pushm	d2-d7/a2-a6
	* Check player caps, do not start
	* scope if not supported
;	move.l	playerbase(a5),d0
;	beq.b	.1
;	move.l	d0,a0
;	move	p_liput(a0),d0
;	and	d7,d0
;	beq.b	.x
;.1

	* Check if running already
	move	st_runningStatusOffset(a4),d7
	tst.b 	(a5,d7)
	bne.b	.x

	;DPRINT	"startScopeTask"

	* Get task structure
	move	st_taskOffset(a4),d0
	lea	(a5,d0),a3
	lea	.tn(pc),a2
	bsr	initScopeTask

	* Mark it as running
	move.b	#RUNNING_YES,(a5,d7)

	* Start
	move.l	a3,a1
	* initialPC
	lea	st_entryPoint(a4),a2
	add	(a2),a2
	* finalPC (system default)
	sub.l a3,a3		 
	lore	Exec,AddTask

	* Update prefs status as well
	move	st_prefsStatusOffset(a4),d0
	lea	prefsdata(a5),a0
	st	(a0,d0)
.x
	popm	d2-d7/a2-a6
	rts

.tn	dc.b	"HiP-Scope",0
	even

* Sets up scopes open or close according to prefs.
startAndStopScopeTasks
	DPRINT	"startAndStopScopeTasks"
	tst.b	prefsdata+prefs_quadraScope(a5)
	beq.b	.1
	bsr.b	startQuadraScopeTask
	bra.b	.2
.1	bsr.b	stopQuadraScopeTask
.2
	tst.b	prefsdata+prefs_quadraScopeF(a5)
	beq.b	.3
	bsr.b	startQuadraScopeFTask
	bra.b	.4
.3	bsr.b	stopQuadraScopeFTask	
.4
	tst.b	prefsdata+prefs_hippoScope(a5)
	beq.b	.5
	bsr.b	startHippoScopeTask
	bra.b	.6
.5	bsr.b	stopHippoScopeTask	
.6
	tst.b	prefsdata+prefs_patternScope(a5)
	beq.b	.7
	bsr.b	startPatternScopeTask
	bra.b	.8
.7	bsr.b	stopPatternScopeTask	
.8
	tst.b	prefsdata+prefs_spectrumScope(a5)
	beq.b	.9
	bsr.b	startSpectrumScopeTask
	bra.b	.10
.9	bsr	stopSpectrumScopeTask	
.10
	rts

startQuadraScopeTask
	;DPRINT	"startQuadraScopeTask"
	lea	quadraScopeTaskDefinition(pc),a4
	bra	startScopeTask

stopQuadraScopeTask
	;DPRINT	"stopQuadraScopeTask"
	lea	quadraScopeTaskDefinition(pc),a4
	bra	stopScopeTask

restartQuadraScopeTask
	tst.b	quadraScopeRunning(a5)
	beq.b	.x
	bsr.b	stopQuadraScopeTask
	bsr.b	startQuadraScopeTask
.x	rts	

startQuadraScopeFTask
	;DPRINT	"startQuadraScopeFTask"
	lea	quadraScopeFTaskDefinition(pc),a4
	bra	startScopeTask

stopQuadraScopeFTask
	;DPRINT	"stopQuadraScopeFTask"
	lea	quadraScopeFTaskDefinition(pc),a4
	bra	stopScopeTask

restartQuadraScopeFTask
	tst.b	quadraScopeFRunning(a5)
	beq.b	.x
	bsr.b	stopQuadraScopeFTask
	bsr.b	startQuadraScopeFTask
.x	rts	

startHippoScopeTask
	;DPRINT	"startHippoScopeTask"
	lea	hippoScopeTaskDefinition(pc),a4
	bra	startScopeTask

stopHippoScopeTask
	;DPRINT	"stopHippoScopeTask"
	lea	hippoScopeTaskDefinition(pc),a4
	bra	stopScopeTask

restartHippoScopeTask
	tst.b	hippoScopeRunning(a5)
	beq.b	.x
	bsr.b	stopHippoScopeTask
	bsr.b	startHippoScopeTask
.x	rts	

startPatternScopeTask
	;DPRINT	"startPatternScopeTask"
	bsr	getScopeMiniFontIfNeeded
	lea	patternScopeTaskDefinition(pc),a4
	bra	startScopeTask

stopPatternScopeTask
	;DPRINT	"stopPatternScopeTask"
	lea	patternScopeTaskDefinition(pc),a4
	bra.b	stopScopeTask

restartPatternScopeTask
	tst.b	patternScopeRunning(a5)
	beq.b	.x
	bsr.b	stopPatternScopeTask
	bsr.b	startPatternScopeTask
.x	rts	

startSpectrumScopeTask
	;DPRINT	"startSpectrumScopeTask"

	move.l	(a5),a6
	tst.l	_FFPBase(a5)
	bne.b	.1
	lea	_FFPName,a1
	lob	OldOpenLibrary
	move.l	d0,_FFPBase(a5)
	beq.b	.fail
.1
	tst.l	_MTBase(a5)
	bne.b	.2
	lea	_MTName,a1
	lob  	OldOpenLibrary
	move.l	d0,_MTBase(a5)
	bne.b	.2
.fail
	rts
.2
	lea	spectrumScopeTaskDefinition(pc),a4
	bra	startScopeTask
		
stopSpectrumScopeTask
	;DPRINT	"stopSpectrumScopeTask"
	lea	spectrumScopeTaskDefinition(pc),a4
	bra.b	stopScopeTask

restartSpectrumScopeTask
	tst.b	spectrumScopeRunning(a5)
	beq.b	.x
	bsr.b	stopSpectrumScopeTask
	bsr.b	startSpectrumScopeTask
.x	rts	

stopScopeTasks
	DPRINT	"stopScopeTasks"
	bsr	stopQuadraScopeTask
	bsr	stopQuadraScopeFTask
	bsr	stopHippoScopeTask
	bsr.b	stopPatternScopeTask
	bra.b	stopSpectrumScopeTask

stopScopeTask
	* Check if running already
	move	st_runningStatusOffset(a4),d7
	tst.b 	(a5,d7)
	beq	.x

	;DPRINT	"stopScopeTask"

	* Get task structure
	move	st_taskOffset(a4),d0
	lea	(a5,d0),a1

	* Raise task priority to normal
	* so it will exit promptly
	moveq	#0,d0
	lore	Exec,SetTaskPri

	* Flag indicates scope should quit
	move.b	#RUNNING_SHUT_IT,(a5,d7)
.loop
	tst.b 	(a5,d7)
	beq.b	.z
	jsr	smallDelay
	bra.b	.loop
.z

;; Display some performance measurements when scope is stopped.
 if DEBUG
	move.l	scopeStopTimeSecs(a5),d0
	sub.l	scopeStartTimeSecs(a5),d0
	bne.b	.zz
	moveq	#1,d0
.zz
	move.l	scopeFrameCounter(a5),d1
	move.l	d1,d2
	divu	d0,d2
	move.l	d2,d3
	ext.l	d2
	swap	d3
	ext.l	d3

	move.l	scopeRenderTime(a5),d4
	move.l	scopeFrameCounter(a5),d5
	bne.b	.zzz
	moveq	#1,d5
.zzz	
 	divu	d5,d4
	ext.l	d4
	tst.b	uusikick(a5)
	bne.b	.zzzz
	moveq	#-1,d4
.zzzz
	DPRINT	"Time=%lds frames=%ld fps=%ld.%ld avg=%ldms"
 endif
.x	rts


* Out:
*   Z not set if any of the scopes is running
anyScopeRunning
	move.b	quadraScopeRunning(a5),d0
	or.b	quadraScopeFRunning(a5),d0
	or.b	hippoScopeRunning(a5),d0
	or.b	patternScopeRunning(a5),d0
	or.b	spectrumScopeRunning(a5),d0
	rts

toggleScopes
	DPRINT	"toggleScopes"
	lea	scopeToggleTable(a5),a2
	* Is any scope running?
	bsr.b	anyScopeRunning
	beq.b	.start
	* Preserve running statuses and stop all
	move.b	quadraScopeRunning(a5),(a2)+
	move.b	quadraScopeFRunning(a5),(a2)+
	move.b	hippoScopeRunning(a5),(a2)+
	move.b	patternScopeRunning(a5),(a2)+
	move.b	spectrumScopeRunning(a5),(a2)+
	bra	stopScopeTasks
	
.start
	* Start scopes that were toggled off.
	* If none were toggled off, start the default
	* one. Test 5 bytes:
	tst.b	(a2)
	bne.b	.some
	tst.b	1(a2)
	bne.b	.some
	tst.b	2(a2)
	bne.b	.some
	tst.b	3(a2)
	bne.b	.some
	tst.b	4(a2)
	bne.b	.some
	* Enable the 1st one if all are off
	st	(a2)
.some
	tst.b	(a2)+
	beq.b	.a
	bsr	startQuadraScopeTask
.a	tst.b	(a2)+
	beq.b	.b
	bsr	startQuadraScopeFTask
.b	tst.b	(a2)+
	beq.b	.c
	bsr	startHippoScopeTask
.c	tst.b	(a2)+
	beq.b	.d
	bsr	startPatternScopeTask
.d	tst.b	(a2)+
	beq.b	.e
	bsr	startSpectrumScopeTask
.e
	* Make prefs window show the correct status
	bsr.b	updateScopeStatusesToPrefs
	bra	updateprefs

* Update the prefs scope toggle statuses to match
* actual runtime state.
updateScopeStatusesToPrefs
	tst.b	quadraScopeRunning(a5)
	sne	prefsdata+prefs_quadraScope(a5)
	tst.b	quadraScopeFRunning(a5)
	sne	prefsdata+prefs_quadraScopeF(a5)
	tst.b	hippoScopeRunning(a5)
	sne	prefsdata+prefs_hippoScope(a5)
	tst.b	patternScopeRunning(a5)
	sne	prefsdata+prefs_patternScope(a5)
	tst.b	spectrumScopeRunning(a5)
	sne	prefsdata+prefs_spectrumScope(a5)
	rts


*******************************************************************************
* Scoperutiinit
*******************************************************************************
wflags3 set WFLG_SMART_REFRESH!WFLG_DRAGBAR!WFLG_CLOSEGADGET!WFLG_DEPTHGADGET
wflags3 set wflags3!WFLG_RMBTRAP
idcmpflags3 = IDCMP_CLOSEWINDOW!IDCMP_MOUSEBUTTONS

; These could be useful to detect window changes but they don't
; seem to work on kick1.3 similarly as on kick3.0.
;!IDCMP_NEWSIZE!IDCMP_CHANGEWINDOW!IDCMP_REFRESHWINDOW

QUADMODE2_QUADRASCOPE = 0
QUADMODE2_QUADRASCOPE_BARS = 1
QUADMODE2_HIPPOSCOPE = 2
QUADMODE2_HIPPOSCOPE_BARS = 3
QUADMODE2_FREQANALYZER = 4
QUADMODE2_FREQANALYZER_BARS = 5
QUADMODE2_PATTERNSCOPE = 6
QUADMODE2_PATTERNSCOPE_BARS = 7
QUADMODE2_FQUADRASCOPE = 8
QUADMODE2_FQUADRASCOPE_BARS = 9
QUADMODE2_PATTERNSCOPEXL = 10
QUADMODE2_PATTERNSCOPEXL_BARS = 11

SCOPE_DRAW_AREA_WIDTH_DEFAULT = 320
SCOPE_DRAW_AREA_HEIGHT_DEFAULT = 64
SCOPE_DRAW_AREA_HEIGHT_DOUBLE = 2*64

* If more channels than defined here,
* switch to small font.
SCOPE_SMALL_FONT_CHANNEL_LIMIT = 8

; DPRINT can't be used as scope is now a task,
; DPRINT uses dos.library which is not allowed.
SDPRINT macro
    if SERIALDEBUG
        DPRINT \1
    endif
	endm

* Scope task entry points:

quadraScopeEntry
	lea	var_b,a5
	move	#quadraScopeRunning,d6
	moveq	#QUADMODE_QUADRASCOPE,d7
	move.b	#$80,d0
	and.b	prefsdata+prefs_quadraScopeBars(a5),d0
	or.b	d0,d7
	
	lea	.t(pc),a3
	lea	prefsdata+prefs_quadraScopePos(a5),a2
	bra	scopeEntry

.t	dc.b	"QuadraScope",0
 even

quadraScopeFEntry
	lea	var_b,a5
	move	#quadraScopeFRunning,d6
	moveq	#QUADMODE_FQUADRASCOPE,d7
	move.b	#$80,d0
	and.b	prefsdata+prefs_quadraScopeFBars(a5),d0
	or.b	d0,d7

	lea	.t(pc),a3
	lea	prefsdata+prefs_quadraScopeFPos(a5),a2
	bra	scopeEntry

.t	dc.b	"Filled QuadraScope",0
 even

hippoScopeEntry
	lea	var_b,a5
	move	#hippoScopeRunning,d6
	moveq	#QUADMODE_HIPPOSCOPE,d7
	move.b	#$80,d0
	and.b	prefsdata+prefs_hippoScopeBars(a5),d0
	or.b	d0,d7

	lea	.t(pc),a3
	lea	prefsdata+prefs_hippoScopePos(a5),a2
	bra.b	scopeEntry

.t	dc.b	"HippoScope",0
 even

patternScopeEntry
	lea	var_b,a5
	move	#patternScopeRunning,d6
	moveq	#QUADMODE_PATTERNSCOPE,d7
	tst.b	prefsdata+prefs_patternScopeXL(a5)
	beq.b	.1
	moveq	#QUADMODE_PATTERNSCOPEXL,d7
.1
	
	lea	.t(pc),a3
	lea	prefsdata+prefs_patternScopePos(a5),a2
	bra.b	scopeEntry

.t	dc.b	"PatternScope",0
 even

spectrumScopeEntry
	lea	var_b,a5
	move	#spectrumScopeRunning,d6
	moveq	#QUADMODE_FREQANALYZER,d7
	move.b	#$80,d0
	and.b	prefsdata+prefs_spectrumScopeBars(a5),d0
	or.b	d0,d7

	lea	.t(pc),a3
	lea	prefsdata+prefs_spectrumScopePos(a5),a2
	bra.b	scopeEntry

.t	dc.b	"SpectrumScope",0
 even

* Main scope task entry point
* In:
*   d6 = Offset to scope running flag 
*   d7 = operating mode
*   a2 = Address to load-from and store-to the window position
*   a3 = window title
*   a5 = global variables
scopeEntry:
	move.l	(a5),a6
	SDPRINT	"Scope task started"

	* Allocate local state variables
	move.l	#sizeof_scopeVars,d0
	move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
	jsr	getmem
	bne.b	.gotMem
	* Quit with error
	lea	memerror_t(pc),a1
	bra	request
.gotMem
	move.l	d0,a4
	move.l	a5,s_global(a4)

	* Store address for the running status flag to check and pass shutdown info
	pea	(a5,d6)
	move.l	(sp)+,s_runningStatusAddr(a4)
	* Store requested operating mode
	move.b	d7,s_quadmode(a4)
	* Store window position on exit to this address
	move.l	a2,s_storedPositionAddr(a4)
	* Window title should be set to this
	move.l	a3,s_windowTitle(a4)

	sub.l	a1,a1
	lore	Exec,FindTask
	move.l	d0,s_quad_task(a4)

    * Store task local data address to the task struct
    move.l  d0,a0
    move.l  a4,TC_Userdata(a0)

    ; ---------------------------------
    ; Select sync mode
    ; 68020 or higher, use timer.device
	btst	#AFB_68020,AttnFlags+1(a6)
	sne     s_syncMode(a4)
    ; ---------------------------------
    ; Create port
    lea     s_timerPort(a4),a3
    moveq   #-1,d0
    lob     AllocSignal	
    move.b	d0,MP_SIGBIT(a3)
 	move.l	s_quad_task(a4),MP_SIGTASK(a3)
	move.b	#NT_MSGPORT,LN_TYPE(a3)
	clr.l	LN_NAME(a3)
	move.b	#PA_SIGNAL,MP_FLAGS(a3)
	lea     MP_MSGLIST(a3),a0
	NEWLIST	a0
    ; ---------------------------------
    ; Create IO
	lea     s_timerIORequest(a4),a2
	move.l	a3,MN_REPLYPORT(a2)
	move.b	#NT_MESSAGE,LN_TYPE(a2)
	move	#IOTV_SIZE,MN_LENGTH(a2)
    ; ---------------------------------
    ; timer.device
    lea     timerDeviceName,a0
	lea     s_timerIORequest(a4),a1
    moveq   #UNIT_VBLANK,d0
    moveq   #0,d1
    lob     OpenDevice * returns d0=non-zero on error
    tst.l   d0
    ; ---------------------------------

* Modulo multab 
	lea	s_multab(a4),a0
	moveq	#0,d0
.mu	move	d0,(a0)+
	add	#40,d0
	cmp	#40*256,d0
	bne.b	.mu

	;clr.l	s_mtab(a4)
	clr.l	s_buffer0(a4)
  ifne FEATURE_FREQSCOPE
	clr.l	s_deltab1(a4)
  endif

	move	#SCOPE_DRAW_AREA_WIDTH_DEFAULT,s_scopeDrawAreaWidth(a4) 
	move	#SCOPE_DRAW_AREA_WIDTH_DEFAULT/8,s_scopeDrawAreaModulo(a4)
	move	#SCOPE_DRAW_AREA_HEIGHT_DEFAULT,s_scopeDrawAreaHeight(a4)


 if DEBUG
	moveq	#0,d0 
	move.b	s_quadmode(a4),d0
	SDPRINT	"Quad mode: %lx"
 endif
	* This creates a jumptable compatible value out of quadmode,
	* where bit 8 indicates "bars enabled"
	move.b	s_quadmode(a4),d0
	moveq	#$f,d1
	and.b		d0,d1
	add.b	d1,d1
	tst.b	d0
	bpl.b	.e
	addq.b	#1,d1
.e	move.b	d1,s_quadmode2(a4)	* 0-9

	moveq	#0,d0
	move.b	s_quadmode2(a4),d0
	lsl	#1,d0
	jmp	.t(pc,d0)
.t	
	bra.b	.1		* quadrascope
	bra.b	.3		* quadrascope bars
	bra.b	.2		* hipposcope 
	bra.b	.4		* hipposcope bars
	bra.b	.5		* freq. analyzer
	bra.b	.6		* freq. analyzer bars
	bra.b	.patternScopeNormal	* patternscope
	bra.b	.patternScopeNormalBars	* patternscope bars (ei oo!)
	bra.b	.7		* filled quadrascope
	bra.b	.8		* filled quadrascope & bars
	bra.b	.patternScopeXL	* patternscope xl
	bra.b	.patternScopeXLBars	* patternscope xl bars (no bars available though)


.7	moveq	#-1,d7
	bra.b	.11
.8	moveq	#-1,d7
	bra.b	.33

* Quadrascope
.1	moveq	#0,d7
.11	
	bsr	voltab
	bra.b	.cont

* Hipposcope
.2
	bsr	voltab2
	bra.b	.cont


.3	moveq	#0,d7
.33
	bsr	voltab

.wo	
	bsr	makeScopeHorizontalBars		* tehd‰‰n palkkitaulu
	bra.b	.cont


.4
	bsr	voltab2
	bra.b	.wo

.5	
  ifne FEATURE_FREQSCOPE
	bsr	voltab3
	bsr.b	.delt
	beq	.memer
 endif
 ifne FEATURE_SPECTRUMSCOPE
	jsr	spectrumInitialize
	beq	.memer
 endif
	bra.b	.cont

  ifne FEATURE_FREQSCOPE 
.delt	move.l	#(256+32)*4,d0
	move.l	#MEMF_CLEAR,d1
	jsr	getmem
	move.l	d0,s_deltab1(a4)
	beq.b	.r
	add.l	#256+32,d0
	move.l	d0,s_deltab2(a4)
	add.l	#256+32,d0
	move.l	d0,s_deltab3(a4)
	add.l	#256+32,d0
	move.l	d0,s_deltab4(a4)
.r	rts
  endif

.6	
  ifne FEATURE_FREQSCOPE 
	bsr	voltab3
	bsr.b	.delt
	beq	.memer
  endif
  if FEATURE_SPECTRUMSCOPE
   	jsr	spectrumInitialize
	beq	.memer
  endif
	bra.b	.wo * go to bar init

.patternScopeNormal
.patternScopeNormalBars
	* Prevent use of _BARS enumeration in quadmode2,
	* makes things easier. 
	move.b	#QUADMODE2_PATTERNSCOPE,s_quadmode2(a4)
	SDPRINT	"Patternscope NORMAL"
	bra.b	.cont
.patternScopeXL
.patternScopeXLBars
	move.b	#QUADMODE2_PATTERNSCOPEXL,s_quadmode2(a4)
	SDPRINT	"Patternscope XL"
.cont

	* Start with no size request active.
	move	s_scopeDrawAreaWidth(a4),s_scopeDrawAreaWidthRequest(a4)
	move	s_scopeDrawAreaHeight(a4),s_scopeDrawAreaHeightRequest(a4)
		
	* lines count for patternscope, 8px high rows
	move	s_scopeDrawAreaHeight(a4),d0
	lsr	#3,d0 
	move	d0,s_quadNoteScrollerLines(a4)
	lsr	#1,d0
	move	d0,s_quadNoteScrollerLinesHalf(a4)

	move.l	_IntuiBase(a5),a6
	
	* Copy new window structure for modifications
	lea	winstruc3,a2
	lea	s_newWindow(a4),a1
	move.l	a1,a0
	moveq	#enw_SIZEOF-1,d0
.copy	move.b	(a2)+,(a1)+
	dbf	d0,.copy

	* Restore top/left to some previous used value
	move.l	s_storedPositionAddr(a4),a1
	move.l	(a1),(a0)

	move	quadWindowHeightOriginal(a5),d0
	add	s_scopeDrawAreaHeight(a4),d0
	move	d0,nw_Height(a0)

	move	wbleveys(a5),d0		* WB:n leveys
	move	(a0),d1			* Ikkunan x-paikka
	add	4(a0),d1		* Ikkunan oikea laita
	cmp	d0,d1
	bls.b	.ok1
	sub	4(a0),d0	* Jos ei mahdu ruudulle, laitetaan
	move	d0,(a0)		* mahdollisimman oikealle
.ok1	move	wbkorkeus(a5),d0	* WB:n korkeus
	move	2(a0),d1		* Ikkunan y-paikka
	add	6(a0),d1		* Ikkunan oikea laita
	cmp	d0,d1
	bls.b	.ok2
	sub	6(a0),d0	* Jos ei mahdu ruudulle, laitetaan
	move	d0,2(a0)	* mahdollisimman alas
.ok2
	lob	OpenWindow
	move.l	d0,s_scopeWindowBase(a4)
	bne.b	.ok3
	lea	windowerr_t(pc),a1
.me	bsr	request
	bra	qexit

.memer	lea	memerror_t(pc),a1
	bra.b	.me

.ok3
	move.l	d0,a0
	move.l	wd_RPort(a0),s_rastport3(a4)
	move.l	wd_UserPort(a0),s_userport3(a4)
	
	move.l	s_windowTitle(a4),a1
	lea	scrtit,a2
	lore	Intui,SetWindowTitles

	move.l	_GFXBase(a5),a6
	move.l	s_rastport3(a4),a1
	move.l	pen_1(a5),d0
	lob	SetAPen

	move.l	s_scopeWindowBase(a4),a0 
	move	wd_LeftEdge(a0),s_scopePreviousLeftEdge(a4)
	move	wd_TopEdge(a0),s_scopePreviousTopEdge(a4)
	move	wd_Width(a0),s_scopePreviousWidth(a4)
	move	wd_Height(a0),s_scopePreviousHeight(a4)

	bsr	drawScopeWindowDecorations
	bsr	initScopeBitmaps
	beq.b	.memer

; TEST! OK

	* State flag indicating whether scope has been cleared
	moveq	#0,d7
	* State flag indicating font request has been shown 
	* Up bit for patternscope
	moveq	#0,d6	
	bsr	patternScopeIsActive
	bne.b	.noPatts
	SDPRINT	"Patternscope active"
	st	d6
.noPatts

	* Set to non-zero if LMB is pressed
	move.b	scopeManualActivation(a5),d5
	jsr	printHippoScopeWindow	

;; Scope performance measurements
 if DEBUG
	lea	scopeStartTimeSecs(a5),a0
	lea	scopeStartTimeMicros(a5),a1
	lore	Intui,CurrentTime
	clr.l	scopeFrameCounter(a5)
	clr.l scopeRenderTime(a5)
 endif

    * Set priority
    * 0 = -30
    * 1 =  -1
    * 2 =   0
    * 3 =  +1
    move.b  scopePriority(a5),d1
    moveq   #-1,d0
    subq.b  #1,d1   * 1
    beq     .pr1   
    moveq   #0,d0
    subq.b  #1,d1   * 2
    beq     .pr1
    moveq   #1,d0
    subq.b  #1,d1   * 3
    beq     .pr1
    moveq   #-30,d0 * 0
.pr1

	; Ready to run	
	move.l	s_quad_task(a4),a1
	;;moveq	#-30,d0				* Prioriteetti 0:sta -30:een
	lore	Exec,SetTaskPri

 if DEBUG
    moveq   #1,d0
    and.b   s_syncMode(a4),d0
    SDPRINT "Enter scope loop, timer sync=%ld"
 endif

*********************************************************************
* Scope main loop, scope loop, main scope loop, scope main loop
*********************************************************************

    tst.b   s_syncMode(a4)
    bne     scopeLoop\.first    * Start with SendIO, not WaitIO

scopeLoop:

    ; ---------------------------------
    tst.b   s_syncMode(a4)
    beq     .vbl
    ; ---------------------------------
    lea     s_timerIORequest(a4),a1  
	lore    Exec,WaitIO
.first:
    lea     s_timerIORequest(a4),a1  
	move.w	#TR_ADDREQUEST,IO_COMMAND(a1)
	clr.l   IOTV_TIME+TV_SECS(a1)
	move.l	#19*1000,IOTV_TIME+TV_MICRO(a1)
	lore    Exec,SendIO
    bra     .timer
    ; ---------------------------------
.vbl
    move.l  _GFXBase(a5),a6
	lob     WaitTOF
.timer
    ; ---------------------------------


	;tst.b	tapa_quad(a5)		* pit‰‰kˆ poistua?
	;bne	qexit
	move.l	s_runningStatusAddr(a4),a0
	tst.b	(a0)
	bmi	qexit

	* Bypass screen check if LMB has been pressed
	tst.b 	d5
	bne.b	.screenVisible

	move.l	_IntuiBase(a5),a1
	move.l	ib_FirstScreen(a1),a1
	move.l	s_scopeWindowBase(a4),a0	* ollaanko p‰‰llimm‰isen‰?

	* Scope screen is the active screen?
	cmp.l	wd_WScreen(a0),a1
	beq.b	.screenVisible
	* Scope screen is not active, but screen might be partially
	* visible? sc_TopEdge==0 means it can't be partially visible.
	tst	sc_TopEdge(a1)
	beq 	.continue
.screenVisible

	tst.b	playing(a5)
	beq 	.doNotDraw

	* No scopes when AHI
	;tst.b	ahi_use_nyt(a5)
	;bne.b	.doNotDraw

	* Does the active player support scopes?
	move.l	playerbase(a5),d0
	beq 	.doNotDrawClear
	move.l	d0,a0
	move	p_liput(a0),d0 
	btst	#pb_scope,d0 
	beq 	.doNotDrawClear

	* Do not draw if patternmode and no pattern info
	cmp.b	#QUADMODE2_PATTERNSCOPE,s_quadmode2(a4)
	beq.b	.testPattern
	cmp.b	#QUADMODE2_PATTERNSCOPEXL,s_quadmode2(a4)
	bne.b	.noPattern
.testPattern	
	* Protracker special case
	cmp	#pt_prot,playertype(a5)
	beq.b	.izOk
	cmp	#pt_sid,playertype(a5)
	beq.b	.izOk
	* Pattern data check
	tst.l	deliPatternInfo(a5)
	bne.b	.izOk
	bra 	.doNotDrawClear
.noPattern
	* Check for sample scope support
	and	#pf_quadscopeUps!pf_quadscopePoke,d0
	beq 	.doNotDrawClear
.izOk
	bsr	scopeDrawAreaSizeChangeRequestIsActive
	bne 	.doNotDraw

	tst.b	d7
	bne.b	.doDraw
	* This clears the hippo gfx away when starting again
	bsr	scopeDrawAreaClear
.doDraw
	* Needs a clear in the future
	moveq	#-1,d7

	pushm	d5/d6/d7
	jsr	obtainModuleData
	* Final safety check
	tst.b	playing(a5)
	beq.b	.1
	bsr	drawScope
.1	jsr 	releaseModuleData
	popm	d5/d6/d7
	bra.b	.continue


; We come here if the current module does not support
; the current scope mode, ie. the window is cleared.
.doNotDrawClear
	* See if clear requested
	tst.b	d7
	beq.b	.continue
	* Request fulfilled
	moveq	#0,d7
	bsr	scopeDrawAreaClear
	jsr	printHippoScopeWindow
	bra	.continue 
    
; We come here if nothing should be drawn, there is a pause
; for example. The previous drawn content is left.
.doNotDraw
    * In case there is no module in memory clear and print hippo
    tst.w   playertype(a5)
    beq     .doNotDrawClear

.m
.continue
	* Manual size and position detection by polling.
	bsr	scopeWindowChangeHandler

	* Store window position so it gets saved with prefs
	move.l	s_scopeWindowBase(a4),a0
	move.l	s_storedPositionAddr(a4),a1
	move.l	4(a0),(a1)

.getMoreMsg
	* Poll for messages
	move.l	s_userport3(a4),a0
	lore	Exec,GetMsg
	tst.l	d0
	beq	scopeLoop
	move.l	d0,a1

	move.l	im_Class(a1),d2		* luokka	
	move	im_Code(a1),d3
	lob	ReplyMsg

;	cmp.l	#IDCMP_REFRESHWINDOW,d2 
;	bne.b 	.noRefresh
;	bsr	scopeRefreshWindow
;	bra.b	.getMoreMsg
;.noRefresh
;	cmp.l	#IDCMP_CHANGEWINDOW,d2 
;	bne.b 	.noChangeWindow
;	bsr	scopeWindowChanged
;	bra.b	.getMoreMsg
;.noChangeWindow
;	cmp.l	#IDCMP_NEWSIZE,d2 
;	bne.b 	.noNewSize
;	bsr	scopeWindowSizeChanged
;	bra.b	.getMoreMsg
;.noNewSize

	cmp.l	#IDCMP_MOUSEBUTTONS,d2
	bne.b	.noButtons

	* RMB closes window
	cmp	#MENUDOWN,d3
	beq.b	.quit
	cmp	#SELECTDOWN,d3
	bne.b	.noButtons
	* LMB activates 
	st	d5
	move.b	d5,scopeManualActivation(a5)

.noButtons
	cmp.l	#IDCMP_CLOSEWINDOW,d2
	beq.b	.quit
	bra.b	.getMoreMsg
	
.quit
	;clr.b	scopeflag(a5)
	
*********************************************************************
* Scope exit
*********************************************************************

qexit:

;; Scope performance measurements
 if DEBUG
	lea	scopeStopTimeSecs(a5),a0
	lea	scopeStopTimeMicros(a5),a1
	lore	Intui,CurrentTime
 endif
    ; ---------------------------------
    tst.b   s_syncMode(a4)
    beq     .nos
    lea     s_timerIORequest(a4),a1  
	lore    Exec,WaitIO
.nos
    lea     s_timerIORequest(a4),a1
    lore    Exec,CloseDevice
    ; ---------------------------------

	SDPRINT	"Scope task will exit"
	bsr.b	qflush_messages

	bsr.b	freeScopeBitmaps
  ifne FEATURE_FREQSCOPE
	move.l	s_deltab1(a4),a0
	clr.l	s_deltab1(a4)
	jsr	freemem
  endif
  ifne FEATURE_SPECTRUMSCOPE
	jsr	spectrumUninitialize
  endif

	move.l	_IntuiBase(a5),a6		
	move.l	s_scopeWindowBase(a4),d0
	beq.b	.uh1
	move.l	d0,a0
	lob	CloseWindow
	clr.l	s_scopeWindowBase(a4)
.uh1

	SDPRINT	"Scope task exiting"
	;clr	quad_prosessi(a5)	* lippu: lopetettiin

	* Dangerous exit procedures!	
	lore	Exec,Forbid

	* Prevent scope interrupt from rusing the task local data
	move.l	s_quad_task(a4),a0
	clr.l	TC_Userdata(a0)

	* Not running anymore
	move.l	s_runningStatusAddr(a4),a0
	clr.b	(a0)

	* Is prefs displayed? Update as scope status changes
	bsr	updateScopeStatusesToPrefs
	cmp	#1,prefsivu(a5)		
	bne.b	.x
	* This will Signal()
	bsr	updateprefs
.x


	* Free local data. a4 invalid after this
	move.l	a4,a0
	jsr	freemem

	* Exit task into default task clean up
	rts




qflush_messages
	move.l	s_scopeWindowBase(a4),a0 
	bra	flushWindowMessages

freeScopeBitmaps
	move.l	s_buffer0(a4),d0
	beq.b	.noFree
	move.l	d0,a0
	clr.l	s_buffer0(a4)
	move	s_buffer0w(a4),d0
	move	s_buffer0h(a4),d1
	lore	GFX,FreeRaster
.noFree
	rts

initScopeBitmaps
	bsr.b 	freeScopeBitmaps

	moveq	#0,d0
	move	s_scopeDrawAreaWidth(a4),d0 
	moveq	#0,d1
	move	s_scopeDrawAreaHeight(a4),d1
	* allocate 6 extra rasterlines per buffer
	addq.l	#6,d1
	* two buffers
	add.l	d1,d1
	move	d0,s_buffer0w(a4)
	move	d1,s_buffer0h(a4)
	lore	GFX,AllocRaster
	move.l	d0,s_buffer0(a4)
	beq		.memError 

 	move.l	d0,a0
	move.l	a0,s_buffer0(a4)

	* AllocRaster does not clear memory, clear it
	move.l 	a0,a1
	move	s_scopeDrawAreaModulo(a4),d1
	mulu	s_buffer0h(a4),d1
	lsr.l	#2,d1
	subq	#1,d1
.clr
	clr.l	(a1)+
	dbf	d1,.clr

	move	s_scopeDrawAreaModulo(a4),d1
	* leave two lines spare at the top
	add	d1,a0
	add	d1,a0
	;add.l	#320/8*2,d0		* yl‰‰lle 2 vararivi‰
	move.l	a0,s_buffer1(a4)

	move	s_scopeDrawAreaModulo(a4),d0
	move	s_scopeDrawAreaHeight(a4),d1
	* four lines spare at the botrom
	addq	#4,d1
	mulu	d1,d0
	add.l	d0,a0
	move.l	a0,s_buffer2(a4)
	
*** Initialisoidaan oma bitmappi
	lea	s_omabitmap(a4),a0
	moveq	#1,d0
	move	s_scopeDrawAreaWidth(a4),d1
	move	s_scopeDrawAreaHeight(a4),d2
	* why add 2 here? 
	addq	#2,d2
	lore	GFX,InitBitMap
	move.l	s_buffer1(a4),s_omabitmap+bm_Planes(a4)
 
	move.l	s_buffer1(a4),s_draw1(a4)
	move.l	s_buffer2(a4),s_draw2(a4)
	move	s_scopeDrawAreaModulo(a4),d0
	* make draw buffer start at 3rd line. why?
	mulu	#3,d0
	add.l	d0,s_draw1(a4)
	add.l	d0,s_draw2(a4)

	move.l	s_buffer0(a4),a1
	lore	Exec,TypeOfMem
	btst	#MEMB_CHIP,d0
	sne		s_bufferIsChip(a4)
    
    cmp.w   #50,LIB_VERSION(a6)
    blo.b   .1
    * Kickstart 4.0, 4.1, CPU is PPC.
    * Could be non-classic HW in this case.
    * Switch to CPU only routines.
.cpu
    clr.b   s_bufferIsChip(a4)
.1
 if DEBUG
    moveq   #1,d0
    and.b   s_bufferIsChip(a4),d0
    SDPRINT "Scope buffer is chip=%ld"
 endif


	moveq	#1,d0 * ok
.memError
	rts

* Z is set if patternscope is active
patternScopeIsActive
	cmp.b	#QUADMODE2_PATTERNSCOPE,s_quadmode2(a4) 
	beq.b	.isPatts
	cmp.b	#QUADMODE2_PATTERNSCOPEXL,s_quadmode2(a4)
.isPatts
	rts


scopeDrawAreaClear
	move.l	s_rastport3(a4),a1
	move.l	pen_0(a5),d0
	lore	GFX,SetAPen
	move.l	s_rastport3(a4),a1
	moveq	#10,d0
	moveq	#14,d1
	move	s_scopeDrawAreaWidth(a4),d2
	add	#10,d2
	move	s_scopeDrawAreaHeight(a4),d3
	add	#79-64,d3
	add	windowleft(a5),d0
	add	windowleft(a5),d2
	add	windowtop(a5),d1
	add	windowtop(a5),d3
	jmp	_LVORectFill(a6)


* Called each scope loop to detect changes in window position
* and size. This provides IDCMP_NEWSIZE and IDCMP_CHANGEWINDOW
* kind of functionality by polling. Seems to work on kick1.3 and kick3.0,
* for some reason the IDCMP approach did not work similarly on
* both kickstarts.
scopeWindowChangeHandler
	move.l	s_scopeWindowBase(a4),a0
	move	wd_Width(a0),d0 
	move	wd_Height(a0),d1 
	move	wd_TopEdge(a0),d2 
	move	wd_LeftEdge(a0),d3

	cmp	s_scopePreviousTopEdge(a4),d2
	bne.b	.posChange
	cmp	s_scopePreviousLeftEdge(a4),d3 
	bne.b	.posChange
	cmp	s_scopePreviousWidth(a4),d0 
	bne.b	.sizeChange
	cmp 	s_scopePreviousHeight(a4),d1 
	bne.b	.sizeChange
	rts
.posChange
	move	d2,s_scopePreviousTopEdge(a4) 
	move	d3,s_scopePreviousLeftEdge(a4)
	bra		scopeWindowChanged
	
.sizeChange 
	move	d0,s_scopePreviousWidth(a4)
	move	d1,s_scopePreviousHeight(a4)
	bra		scopeWindowSizeChanged
	

;scopeRefreshWindow
;	move.l	scopeWindowBase(a5),a0
;	lore	Intui,BeginRefresh
;;	bsr.b	drawScopeWindowDecorations
;	moveq	#1,d0 * true: complete
;	move.l	scopeWindowBase(a5),a0 
;	lore	Intui,EndRefresh
;	rts

drawScopeWindowDecorations
	move.l	s_rastport3(a4),a2
	moveq	#4,d0
	moveq	#11,d1
	move	s_scopeDrawAreaWidth(a4),d2
	add	#335-320,d2
	move	s_scopeDrawAreaHeight(a4),d3
	add	#82-64,d3
	bsr	drawtexture

	moveq	#8,d0
	moveq	#13,d1
	move	s_scopeDrawAreaWidth(a4),d4
	add	#323-320,d4
	move	s_scopeDrawAreaHeight(a4),d5
	addq	#67-64,d5
	moveq	#$0a,d6
	move.l	s_rastport3(a4),a0
	move.l	a0,a1
	add	windowleft(a5),d0
	add	windowtop(a5),d1
	move.l	d0,d2
	move.l	d1,d3
	lore	GFX,ClipBlit
	;bra.b	.drawBox 

.drawBox
	moveq	#7,plx1
	move	s_scopeDrawAreaWidth(a4),plx2
	add	#332-320,plx2
	moveq	#13,ply1
	move	s_scopeDrawAreaHeight(a4),ply2
	add	#80-64,ply2
	add	windowleft(a5),plx1
	add	windowleft(a5),plx2
	add	windowtop(a5),ply1
	add	windowtop(a5),ply2
	move.l	s_rastport3(a4),a1
	push	a4
	jsr	laatikko2
	pop	a4
	rts


requestNormalScopeDrawArea
	move	#SCOPE_DRAW_AREA_WIDTH_DEFAULT,d0 
	moveq	#SCOPE_DRAW_AREA_HEIGHT_DEFAULT,d1
	* falling thru!

* Resize window based on relative change to
* the draw area.
* In:
*   d0 = new draw area width, must be divisible by 16
*        for blitter
*   d1 = new draw area height
* Out:
*   d0 = 0 if draw area is already matching
*   d0 = ~0 window will change to accommodate
requestScopeDrawAreaChange

	move	d0,s_scopeDrawAreaWidthRequest(a4)
	move	d1,s_scopeDrawAreaHeightRequest(a4)
	sub	s_scopeDrawAreaWidth(a4),d0
	sub	s_scopeDrawAreaHeight(a4),d1
	move	d1,d2
	or	d0,d2
	beq 	.noDiff

 if DEBUG 	
	ext.l 	d0 
	ext.l 	d1
	SDPRINT	"Draw area change %ld %ld"
 endif


	move.l	s_scopeWindowBase(a4),a0
	* Calculate new right edge position for window 
	move	wd_LeftEdge(a0),d2
	add	wd_Width(a0),d2
	add	d0,d2
	move	wbleveys(a5),d3
	sub	d2,d3

	move	wd_TopEdge(a0),d4
	add	wd_Height(a0),d4
	add	d1,d4
	move	wbkorkeus(a5),d5
	sub	d4,d5

	tst	d3
	bmi.b	.1
	moveq	#0,d3
.1	tst	d5
	bmi.b	.2
	moveq	#0,d5
.2
	move	d3,d2
	or	d5,d2
	beq.b	.fits
 
	move	d3,d0
	move	d5,d1 
 if DEBUG 
 	ext.l 	d0 
 	ext.l 	d1
	SDPRINT	"->move %ld %ld"
 endif
   
	lore	Intui,MoveWindow
	moveq	#1,d0
	rts
.fits
 if DEBUG 
 	ext.l 	d0 
 	ext.l 	d1
	SDPRINT	"->resize %ld %ld"
 endif 

	move.l	s_scopeWindowBase(a4),a0 
	lore 	Intui,SizeWindow
	moveq	#1,d0
	rts
.noDiff
;	SDPRINT	"->no change!"
	moveq	#0,d0
	rts

scopeDrawAreaSizeChangeRequestIsActive
	move	s_scopeDrawAreaWidthRequest(a4),d0 
	cmp	s_scopeDrawAreaWidth(a4),d0 
	bne.b 	.yes
	move	s_scopeDrawAreaHeightRequest(a4),d0 
	cmp	s_scopeDrawAreaHeight(a4),d0 
	bne.b 	.yes
	moveq	#0,d0
	rts
.yes	
	moveq	#1,d0
	rts

* Called when IDCMP_CHANGEWINDOW message arrives.
scopeWindowChanged
	SDPRINT	"scopeWindowChanged"
 if DEBUG
	move.l	s_scopeWindowBase(a4),a0
	moveq	#0,d0
	moveq	#0,d1
	moveq	#0,d2
	moveq	#0,d3
	move	wd_LeftEdge(a0),d0
	move	wd_TopEdge(a0),d1
	move	wd_Width(a0),d2
	move	wd_Height(a0),d3
	SDPRINT	"left=%ld top=%ld width=%ld height=%ld"
 endif
	* Request again after window move
 	bsr 	scopeDrawAreaSizeChangeRequestIsActive
	beq.b 	.nope 
	move	s_scopeDrawAreaWidthRequest(a4),d0
	move	s_scopeDrawAreaHeightRequest(a4),d1
	bsr 	requestScopeDrawAreaChange
.nope
	rts

* Called when IDCMP_NEWSIZE message arrives.
* Window size change request has been fulfilled.
scopeWindowSizeChanged
	pushm	d2-d6
	SDPRINT	"scopeWindowSizeChanged"
 if DEBUG
	move.l	s_scopeWindowBase(a4),a0
	moveq	#0,d0
	moveq	#0,d1
	moveq	#0,d2
	moveq	#0,d3
	move	wd_LeftEdge(a0),d0
	move	wd_TopEdge(a0),d1
	move	wd_Width(a0),d2
	move	wd_Height(a0),d3
	SDPRINT	"left=%ld top=%ld width=%ld height=%ld"
 endif
	move	s_scopeDrawAreaWidthRequest(a4),s_scopeDrawAreaWidth(a4)
	move	s_scopeDrawAreaHeightRequest(a4),s_scopeDrawAreaHeight(a4)
	move	s_scopeDrawAreaWidth(a4),d0 
	lsr	#3,d0 
	move	d0,s_scopeDrawAreaModulo(a4)

	* lines count for patternscope, 8px high rows
	move	s_scopeDrawAreaHeight(a4),d0
	lsr	#3,d0 
	move	d0,s_quadNoteScrollerLines(a4)
	lsr	#1,d0
	move	d0,s_quadNoteScrollerLinesHalf(a4)

	bsr	initScopeBitmaps
	bsr	drawScopeWindowDecorations
	popm	d2-d6
	rts


*********************************************************************
* Scope interrupt code, keeps track the play positions of 
* replayer samples
*********************************************************************

* in:
*    a5 = var_b
scopeinterrupt:				
	cmp	#pt_prot,playertype(a5)
	bne	.notProtracker

	* Copy scope data from Protracker data structures

	lea	kplbase(a5),a0
	move.b	k_usertrig(a0),d0
	or.b	d0,scopeData+scope_trigger(a5)
	clr.b	k_usertrig(a0)

	lea	k_chan1temp(a0),a2
	lea	scopeData+scope_ch1(a1),a0
	lea	hippoport+hip_PTtrigger1(a5),a3
	moveq	#4-1,d1
.setscope
	ror.b	#1,d0
	bpl.b	.e
	addq.b	#1,(a3)
	move.l	n_start(a2),ns_start(a0)
	move	n_length(a2),ns_length(a0)
	move.l	n_loopstart(a2),ns_loopstart(a0)
	move	n_replen(a2),ns_replen(a0)
.e	move	n_period(a2),ns_period(a0)	

	move	n_tempvol(a2),d2
	CLAMPVOL d2
	move	d2,ns_tempvol(a0)
	
	addq	#1,a3 * next trigger byte
	lea	n_sizeof(a2),a2
	lea	ns_size(a0),a0
	dbf	d1,.setscope

.quadScopeSampleFollow
	* Update quadrascope sample data pointers based on period

	moveq	#4-1,d1
	lea	scopeData+scope_ch1(a5),a0

.le	moveq	#0,d0
	tst	ns_period(a0)
	beq.b	.noe
	move.l	colordiv(a5),d0		* colorclock/vbtaajuus
	divu	ns_period(a0),d0
	ext.l	d0
.noe	
	add.l	d0,ns_start(a0)
	lsr	#1,d0
	moveq	#0,d2
	move	ns_length(a0),d2
	sub.l	d0,d2
	move	d2,ns_length(a0)
	move.l	d2,d0
	bpl.b	.plu

	* Negative overrun
	;move	ns_length(a0),d0
	;ext.l	d0
	;move.l	d2,d0

	* safety check
	move	ns_replen(a0),d2
	bne.b	.nz
	moveq	#1,d2
.nz
	* Modulo with respect to the replen
	divs	d2,d0
	swap	d0
	ext.l	d0
	* Adjust replen according to overrun, words
	moveq	#0,d2
	move	ns_replen(a0),d2
	add.l	d0,d2
	move	d2,ns_length(a0)
	* Adjust loopstart, bytes
	move.l	ns_loopstart(a0),ns_start(a0)
	add.l	d0,d0
	sub.l	d0,ns_start(a0)
.plu	
	lea	ns_size(a0),a0
	dbf	d1,.le
	rts

.notProtracker
	cmp	#pt_sample,playertype(a5)
	bne.b	.notSample

	* Sample scope data. Update sample follow position once per frame.
    jsr     getSampleDataAdd
	move.l	samplefollow(a5),d1
    beq     .x
    move.l  d1,a0
	add.l	d0,(a0)
.x	rts

.notSample
	* PSID uses it's own following mechanism
	cmp	#pt_sid,playertype(a5)
	beq.b	.x

	* Check player has generic quadrascope support
	move.l	playerbase(a5),a0
	move	p_liput(a0),d1

	* Poke method:
	btst	#pb_quadscopePoke,d1
	bne	.quadScopeSampleFollow
	
	* UPS method:
	btst	#pb_quadscopeUps,d1
	beq.b	.noScopes

	* UPS struct provided by eagle player?
	move.l	deliUPSStruct(a5),d0
	* Unnecessary check?
	beq	.quadScopeSampleFollow


	* Handle UPS, it will provide input for normal sample follow
	bsr.b	.handleUPS
	bra	.quadScopeSampleFollow

.noScopes
	* No scopes for u this time.
	rts

.handleUPS
	move.l	d0,a0
	tst	UPS_Enabled(a0)
	bne.b	.disabled
	lea	nullsample,a1

	lea	UPS_Voice1Adr(a0),a2
	lea	scopeData+scope_ch1(a5),a3
	moveq	#4-1,d0
.upsLoop
	move	UPS_Voice1Vol(a2),d1
	CLAMPVOL d1
	move	d1,ns_tempvol(a3)
	move	UPS_Voice1Per(a2),d1
	beq.b	.1
	* New sample starts as period is non-zero
	move	d1,ns_period(a3)
	move.l	UPS_Voice1Adr(a2),ns_start(a3)
	move	UPS_Voice1Len(a2),ns_length(a3)
.1	
	move.l	UPS_Voice1Adr(a2),d1
	move	UPS_Voice1Len(a2),d2

	tst	UPS_Voice1Repeat(a2)
	beq.b	.11
	* This case is very seldom used
	move.l	a1,d1
	moveq	#1,d2
.11
	move.l	d1,ns_loopstart(a3)
	move	d2,ns_replen(a3)

	lea	UPS_Modulo(a2),a2
	lea	ns_size(a3),a3
	dbf	d0,.upsLoop
.disabled
	rts


* Clears any scope data that points into module data.
clearScopeData
	clr.l	deliUPSStruct(a5)
	clr.b	scope_trigger+scopeData(a5)
	lea	scope_ch1+scopeData(a5),a0
	moveq	#4*ns_size/2-1,d0
.c	clr	(a0)+
	dbf	d0,.c
	rts

* Opens the mini font for 4+ channel notescroller if needed
getScopeMiniFontIfNeeded
	tst.l	minifontbase(a5)
	bne.b	.skip
	* See if we need the small font
;	bsr	patternScopeIsActive
;	bne.b	.skip
;	move.l	deliPatternInfo(a5),d0
;	beq.b	.skip
;	move.l	d0,a0
;	cmp	#SCOPE_SMALL_FONT_CHANNEL_LIMIT,PI_Voices(a0)
;	bls.b	.skip
	lea	diskfontname,a1
	lore	Exec,OldOpenLibrary
	tst.l 	d0 
	beq.b	.skip
	move.l	d0,a6
	lea	mini_text_attr,a0
	lob	OpenDiskFont
 	move.l	d0,minifontbase(a5)
	move.l	a6,a1
	lore 	Exec,CloseLibrary
;	tst.l	minifontbase(a5)
;	bne.b	.miniOk
;	lea	.noFontMsg(pc),a1 
;	tst.b	(a1)
;	beq.b	.skip
;	bsr	request
;	* Show this only once to not be annoying
;	clr.b	(a1)	
.skip
	rts
.miniOk
	DPRINT	"Got mini font"
	rts

showNoMiniFontMessage:
	tst.l	minifontbase(a5)
	bne.b	.skip
	lea	.noFontMsg(pc),a1 
	tst.b	(a1)
	beq.b	.skip
	bsr	request
	* Show this only once to not be annoying
	clr.b	(a1)	
.skip
    rts

.noFontMsg
	dc.b	"Couldn't open 'mini4' font for patternscope!",0;
	even

******* Quadrascopelle 
voltab
	lea	s_mtab(a4),a0
	moveq	#$40-1,d3
	moveq	#0,d2

	tst	d7
	bne.b	.voltab_fill

.olp2	moveq	#0,d0
	move	#256-1,d4
.olp1	move	d0,d1
	ext	d1
	muls	d2,d1
	asr	#8,d1
	add	#32,d1
	mulu	#40,d1
	add	#39,d1
	move	d1,(a0)+
	addq	#1,d0
	dbf	d4,.olp1
	addq	#1,d2
	dbf	d3,.olp2
	rts

******* Filled quadrascope

.voltab_fill
;	lea	mtab(a5),a0
;	moveq	#$40-1,d3
;	moveq	#0,d2
.olp2q	moveq	#0,d0
	move	#256-1,d4
.olp1q	move	d0,d1
	ext	d1
	muls	d2,d1
	asr	#8,d1
	tst	d1
	bmi.b	.mee
	moveq	#31,d5
	sub	d1,d5
	move	d5,d1
	sub	#32,d1
.mee	add	#32,d1
	mulu	#40,d1
	add	#39,d1
	move	d1,(a0)+
	addq	#1,d0
	dbf	d4,.olp1q
	addq	#1,d2
	dbf	d3,.olp2q
	rts



******* Hipposcopelle
voltab2
	lea	s_mtab(a4),a0

	moveq	#$40-1,d3
	moveq	#0,d2
.op2
	moveq	#0,d0
	move	#256-1,d4
.op1
	move	d0,d1
	ext	d1
	muls	d2,d1
	asr	#8,d1
	add.b	#$80,d1
	move.b	d1,(a0)+

	addq	#1,d0
	dbf	d4,.op1

	addq	#1,d2
	dbf	d3,.op2


	moveq	#$40-1,d3
	moveq	#0,d2
.olp2a
	moveq	#0,d0
	move	#256-1,d4
.olp1a
	move	d0,d1
	ext	d1
	muls	d2,d1
	asr	#7,d1
	muls	#80,d1		* x-alue: 0-80
	divs	#127,d1
	add.b	#$80,d1
	move.b	d1,(a0)+

	addq	#1,d0
	dbf	d4,.olp1a

	addq	#1,d2
	dbf	d3,.olp2a
	
	rts



***************** Freqscopelle
  ifne FEATURE_FREQSCOPE
voltab3
	move.l	m_mtab(a4),a0
	moveq	#$40-1,d3
	moveq	#0,d2
.olp2	moveq	#0,d0
	move	#256-1,d4
.olp1	move	d0,d1
	ext	d1
	muls	d2,d1
	asr	#6,d1
	move.b	d1,(a0)+
	addq	#1,d0
	dbf	d4,.olp1
	addq	#1,d2
	dbf	d3,.olp2
	rts
  endif

**************************************************************************
* Scope draw
**************************************************************************

drawScope:

	* See if the whole drawing phase can be skipped
	bsr	patternScopeIsActive
	bne.b	.noPattSc
    * For generic pattern scope, update only when position changes
	move.l	deliPatternInfo(a5),d0 
	beq.b 	.noPattSc 
	move.l	d0,a0
	movem	PI_Pattpos(a0),d0/d1 
	cmp	s_scopePreviousPattPos(a4),d0 
	bne.b	.doUpdate
	cmp	s_scopePreviousSongPos(a4),d1 
	bne.b	.doUpdate
	rts
.doUpdate
	move	d0,s_scopePreviousPattPos(a4)
	move	d1,s_scopePreviousSongPos(a4)
.noPattSc
	* s_draw1 = draw scope in this buffer
	* s_draw2 = clear this buffer

	* clear draw area
	tst.b	s_bufferIsChip(a4)
	beq.b	.cpuClear

	move.l	_GFXBase(a5),a6
	lob	OwnBlitter
	lob	WaitBlit

	lea	$dff058,a0
	move.l	s_draw2(a4),$54-$58(a0)	
	move	#0,$66-$58(a0)
	move.l	#$01000000,$40-$58(a0)

	* build BLTSIZ parameter
	move	s_scopeDrawAreaHeight(a4),d0
	lsl	#6,d0
	move	s_scopeDrawAreaModulo(a4),d1
	lsr	#1,d1	* words
	add	d1,d0
	* Do blit
	move	d0,(a0)

	* Continue clearing while scope is drawn into the other buffer
	lob	DisownBlitter
	bra.b	.c1

.cpuClear
	move.l	s_draw2(a4),a0
	move	s_scopeDrawAreaHeight(a4),d0
	mulu	s_scopeDrawAreaModulo(a4),d0
	lsr.l	#4,d0
	subq	#1,d0
.c2	clr.l	(a0)+
	clr.l	(a0)+
	clr.l	(a0)+
	clr.l	(a0)+
	dbf		d0,.c2
.c1


* Scope performance measurements
* Disaster is obvious, playing the first 40 seconds
* - v2.52 spectrumScope on A500: 75 ms average
* - v2.53 spectrumScope on A500: 70 ms
*               micro-optimized: 69 ms
*               alternative asr: 58 ms
 if DEBUG
	addq.l	#1,scopeFrameCounter(a5)
	jsr	startMeasure
	bsr	.render
	jsr	stopMeasure
	add.l	d0,scopeRenderTime(a5)
 else
	bsr	.render
 endif

	* scope processed, deliver unto screen

	* double buffer
	move.l	s_draw1(a4),d0
	move.l	s_draw2(a4),d1
	move.l	d1,s_draw1(a4)
	move.l	d0,s_draw2(a4)

	* Copy s_draw1 to screen
	
	lea	s_omabitmap(a4),a0
	move.l	d0,bm_Planes(a0)

	move.l	_GFXBase(a5),a6	* kopioidaan kamat ikkunaan
	move.l	s_rastport3(a4),a1
	moveq	#0,d0		* l‰hde x,y
	moveq	#0,d1
	moveq	#10,d2		* kohde x,y
	moveq	#15,d3
	add	windowleft(a5),d2
	add	windowtop(a5),d3
	move	#$c0,d6		* minterm, suora kopio a->d
	move	s_scopeDrawAreaWidth(a4),d4
	move	s_scopeDrawAreaHeight(a4),d5

	* Perform some adjustments based on mode and type
	cmp.b	#QUADMODE_FREQANALYZER,s_quadmode(a4)
	beq.b	.noMagic
	cmp.b	#QUADMODE_PATTERNSCOPE,s_quadmode(a4)
	beq.b	.pattern
	cmp.b	#QUADMODE_PATTERNSCOPEXL,s_quadmode(a4)
	beq.b	.pattern

	cmp	    #pt_sample,playertype(a5)
	beq.b	.centerStereo
    cmp     #pt_xmaplay,playertype(a5)
    beq.b   .x1
    jsr     playSidInRESIDMode
    bne     .x1
	cmp	#pt_multi,playertype(a5)
	bne.b	.noMagic
.x1	cmp.b	#QUADMODE_HIPPOSCOPE,s_quadmode(a4)
	bne.b	.centerStereo
	* Center PS3M + hipposcope
	addq	#4,d2		; target x
	subq	#4,d4		; width
	bra.b	.noMagic
	
.centerStereo
	* This will center the two wide stereo scope graphs
	* with sample player and PS3M
	addq	#4,d0		; source x
	subq	#4,d4		; width
	bra.b	.noMagic

.pattern
	* Move patternscope one pixel to the right
	* to have some space on the left border.
	addq	#1,d2		; target x
	subq	#1,d4		; width

.noMagic
	lob	BltBitMapRastPort
	rts


.render
	cmp	    #pt_sample,playertype(a5)
	beq 	.renderSample

	moveq	#0,d0
	move.b	s_quadmode2(a4),d0
	add	    d0,d0
    ; ---------------------------------
    cmp 	#pt_multi,playertype(a5)
    bne.b   .notMulti
	* PS3M with AmiGUS?
	tst.b	ps3mamigus(a5)
	bne		.amigus
    * PS3M without AHI?
    tst.b   ahi_use_nyt(a5)
    beq     .renderPS3M
.amigus
    * PS3M + AHI (or AmiGUS) is handled like a ordinary 4ch poke scope
    jsr     ahiOrGusWith4ChannelsActive
    bne     .goAhi
    * Too many AHI voices for wave scopes, check if can do patterns
    bsr     patternScopeIsActive
    beq     .goAhi
    * This didn't work out, not drawing.
    rts
    ; ---------------------------------
.notMulti  
    * XMAPlay and reSID provide compatible scope input
	cmp	    #pt_xmaplay,playertype(a5)
	beq	.renderPS3M
    * PSID specific notescroller launch
	cmp	    #pt_sid,playertype(a5)
    bne     .notPSID
    bsr     patternScopeIsActive
    beq     patternScopeSID
.notPSID
    jsr     playSidInRESIDMode
    bne     .renderPS3M
.goAhi

	* Protracker scope
	* .. or similarly working others

	jmp	.t(pc,d0)

* protracker jump table
.t	bra.b	.1 * quad
	bra.b	.3 * + bars
	bra.b	.2 * hippo
	bra.b	.4 * + bars
	bra.b	.5 * freq
	bra.b	.6 * + bars
	bra.b	.7 * pattern normal size
	bra.b	.7 * --""-- 
	bra.b	.8 * fquad
	bra.b	.9 * + bars
	bra.b	.7 * pattern extra large
	bra.b	.7 * --""--

.3	bsr	lever
.1	bra	quadrascope

.4	bsr	lever
.2	bra	hipposcope

.5	bra	freqscope

.6	bsr	freqscope
	lore	GFX,WaitBlit
	bra	leverEor

.7	* Protracker specific notescroller launch
	cmp	#pt_prot,playertype(a5)
	beq	notescroller
	* Generic notescroller launch
	tst.l	deliPatternInfo(a5)
	bne	noteScroller2
	rts
	
.8	bsr	quadrascope
	bra	mirrorfill

.9	bsr.b	.8
	lore	GFX,WaitBlit
	bra	leverEor * extra gfx drawn, must wait until fill done

;.other
;	* Fallback option!
;	* Display notescroller if possible.
;	* Non-Protracker formats.
;	tst.l	deliPatternInfo(a5)
;	beq.b	.cont
;	bsr	noteScroller2
;.cont
;	rts


* Sample scope
.renderSample
	* Get normal scope area
	bsr	requestNormalScopeDrawArea
	bne.b	.sampleSkip * wait for resize
    
    * bit 7 indicates bars
    moveq   #$1f,d0
    and.b   s_quadmode(a4),d0
    cmp.b   #QUADMODE_FQUADRASCOPE,d0
    beq     .fil
    cmp.b   #QUADMODE_FREQANALYZER,d0
    beq     freqscope
    cmp.b   #QUADMODE_HIPPOSCOPE,d0
    beq     sampleHippoScope
    cmp.b   #QUADMODE_PATTERNSCOPE,d0
    beq     .sampleSkip
	* Default
	bra     samplescope
.sampleSkip
	rts
.fil
	bsr	samplescopefilled
	bra.b	mirrorfill


.renderPS3M
	* PS3M scope
	* multichannel jump table
	jmp	.tt(pc,d0)
.tt	bra.b	.11 * quad
	bra.b	.11
	bra.b	.22 * hipp
	bra.b	.22
	bra.b	.33 * freq
	bra.b	.33
	bra.b	.55 * patt
	bra.b	.55
	bra.b	.44 * fquad
	bra.b	.44
	bra.b	.55 * patt
	bra.b	.55

.11	bra	multiscope
.22	bra	multihipposcope
.33	bra	freqscope
.44	bsr	multiscopefilled
	bra.b	mirrorfill
.55	* PS3M patternscope mode
	tst.l	deliPatternInfo(a5) 
	bne	noteScroller2
	rts


mirrorfill
	tst.b	s_bufferIsChip(a4)
	beq.b	.cpuMirrorFill

	lore	GFX,OwnBlitter
	lob	WaitBlit

	move.l	s_draw1(a4),a0
	lea	$dff058,a2

	move.l	a0,$50-$58(a2)	* A
	lea	40(a0),a1
	move.l	a1,$48-$58(a2)	* C
	move.l	a1,$54-$58(a2)	* D
	moveq	#0,d0
	move	d0,$60-$58(a2)	* C
	move	d0,$64-$58(a2)	* A
	move	d0,$66-$58(a2)	* D
	moveq	#-1,d0
	move.l	d0,$44-$58(a2)
	move.l	#$0b5a0000,$40-$58(a2)	* D = A not C
	move	#31*64+20,(a2)	

	lea	63*40(a0),a1		* kopioidaan
	lob	WaitBlit
	movem.l	a0/a1,$50-$58(a2)
	move	#-80,$66-$58(a2) 	* D
	move.l	#$09f00000,$40-$58(a2)
	move	#32*64+20,(a2)	

	lob	DisownBlitter
	rts

.cpuMirrorFill
	moveq	#31,d1
	bsr.b	cpuVerticalFill
	move.l	s_draw1(a4),a0
	lea		63*40(a0),a1
	moveq	#32-1,d1
.y	moveq	#320/64-1,d0
.x	move.l	(a0)+,(a1)+
	move.l	(a0)+,(a1)+
	dbf		d0,.x
	lea		-80(a1),a1
	dbf		d1,.y
	rts

* In:
*   d1 = height
cpuVerticalFill
	move.l	s_draw1(a4),a0
	lea		40(a0),a1 * target line
	mulu	#320/64,d1
	subq	#1,d1
.loop
	move.l	(a0)+,d2
	eor.l	d2,(a1)+
	move.l	(a0)+,d2
	eor.l	d2,(a1)+
	dbf		d1,.loop
	rts



* In: 
*   a3 = scope data
* Out:
*   d0 = sample start, or 0 if bounds check failed for any value
*   d1 = loop start
*   d2 = sample length
*   d3 = repeat length
*   
getScopeChannelData:
	cmp	#pt_prot,playertype(a5)
	bne.b	.notPt

	* Similar check as before
	move.l	ns_start(a3),d0
	beq.b	.fail
	move.l	ns_loopstart(a3),d1
	beq.b	.fail
	move	ns_length(a3),d2
	move	ns_replen(a3),d3
	tst.l	d0
	rts

.notPt
	* More comprehensive check for others
 REM
	move.l	ns_start(a3),d0
	move.l	ns_loopstart(a3),d2
	moveq	#0,d1
	move	ns_length(a3),d1
	moveq	#0,d3
	move	ns_replen(a3),d3
	move.l	moduleaddress(a5),d4
	move.l	d4,d5
	add.l	modulelength(a5),d5
	SDPRINT	"%lx %lx %lx %lx - %lx %lx"
 EREM

	move.l	ns_start(a3),d0
	beq.b	.fail
	move.l	ns_loopstart(a3),d1
	beq.b	.fail
	move	ns_length(a3),d2
	beq.b	.fail
	move	ns_replen(a3),d3
	beq.b	.fail
	cmp.l	#1024,d0
	blo.b	.fail
	cmp.l	#1024,d1
	blo.b	.fail

 REM
	
	* This one has waveforms inside the replay code:
	cmp	#pt_future10,playertype(a5)
	beq.b	.skipCheck
	;cmp	#pt_digitalmugician,playertype(a5)
	;beq.b	.skipCheck

	move.l	moduleaddress(a5),d4
	move.l	d4,d5
	add.l	modulelength(a5),d5

	* This one has samples loaded separately:
	cmp	#pt_robhubbard2,playertype(a5)
	bne.b	.notRH2
	* Samples are found elsewhere, get the bounds:
	move.l	deliLoadFileArray(a5),d4
	beq.b	.skipCheck
	push	a2
	move.l	d4,a2 
	move.l	(a2)+,d4 * addr
	move.l	d4,d5
	add.l	(a2),d5 * len
	pop	a2
;	SDPRINT	"%lx %lx %lx %lx-%lx %lx"
.notRH2

	* Check start
	cmp	#2,d2
	bls.b	.shortLen
	cmp.l	d4,d0
	blo.b	.fail
	cmp.l	d5,d0
	bhs.b	.fail
.shortLen

 EREM
 
 REM
	* Check loop start
	cmp	#2,d3
	bls.b	.shortRepLen
	cmp.l	d4,d1
	blo.b	.fail
	cmp.l	d5,d1
	blo.b	.fail
.shortRepLen
 EREM
 
.skipCheck
.go
	tst.l	d0
	rts
.fail
	moveq	#0,d0
	rts

quadrascope:
	lea	scopeData+scope_ch1(a5),a3
	move.l	s_draw1(a4),a0
	lea	-30(a0),a0
	bsr.b	.scope

	lea	scopeData+scope_ch2(a5),a3
	move.l	s_draw1(a4),a0
	lea	-20(a0),a0
	bsr.b	.scope

	lea	scopeData+scope_ch3(a5),a3
	move.l	s_draw1(a4),a0
	lea	-10(a0),a0
	bsr.b	.scope

	lea	scopeData+scope_ch4(a5),a3
	move.l	s_draw1(a4),a0

;	bsr	.scope
;	rts

.scope
	bsr	getScopeChannelData
	bne.b	.jolt
	rts

.jolt	
	
	move.l	d0,a1 * start
	move.l	d1,a6 * loopstart
	moveq	#0,d5
	move	d2,d5 * len
	moveq	#0,d4
	move	d3,d4 * replen
	
	move	ns_tempvol(a3),d1
	mulu	mainvolume(a5),d1
	lsr	#6,d1
	bne.b	.heee
	moveq	#1,d1
.heee	
	CLAMPVOL d1
	subq	#1,d1
	add	d1,d1
	lsl.l	#8,d1
	lea	s_mtab(a4),a2
	add.l	d1,a2

	lea	-40(a0),a3

	cmp.b	#8,s_quadmode2(a4)
	beq.b	.iik
	cmp.b	#9,s_quadmode2(a4)
	bne.b	.ook
	* Filled quadrascope
.iik	move.l	a0,a3
.ook

	;moveq	#0,d1
	moveq	#80/8-1,d7
	moveq	#1,d0
	moveq	#0,d6
		
drlo	

sco	macro
	moveq	#0,d2
	move.b	(a1)+,d2
	add	d2,d2
	move	(a2,d2),d3
	or.b	d0,(a0,d3)
	or.b	d0,(a3,d3)

	ifne	\2
	add.b	d0,d0
	endc
	
	ifne	\1
	subq.l	#2,d5
	bpl.b	hm\2	* $6a04
	move.l	d4,d5	* replen
	move.l	a6,a1   * loop start
hm\2
	endc
	endm

	sco	0,1
	sco	1,2
	sco	0,3
	sco	1,4
	sco	0,5
	sco	1,6
	sco	0,7
	sco	1,0

	* Reset bit pattern:
	moveq	#1,d0
	sub.l	d0,a0
	sub.l	d0,a3
	dbf	d7,drlo

	rts

hipposcope:
	lea	scopeData+scope_ch1(a5),a3
	move.l	s_draw1(a4),a6
	lea	-20-95*40(a6),a6
	bsr.b	.twirl
	* a6 is unchanged
	
	lea	scopeData+scope_ch2(a5),a3
	lea	10(a6),a6
	bsr.b	.twirl

	lea	scopeData+scope_ch3(a5),a3
	lea	10(a6),a6
	bsr.b	.twirl

	lea	scopeData+scope_ch4(a5),a3
	lea	10(a6),a6
	;bsr.b	.twirl
	;rts


.twirl
	push 	a4
	
	move	ns_tempvol(a3),d0
	mulu	mainvolume(a5),d0
	lsr	#6,d0
	CLAMPVOL d0
	subq	#1,d0
	bpl.b	.e
	moveq	#0,d0
.e	lsl	#8,d0

	* volume multab, y-specific value
	lea	s_mtab(a4),a0
	lea	(a0,d0),a2

	* modulo multab
	lea	s_multab(a4),a0

	* x-specific byte value is in the other half
	lea	64*256(a2),a4


lir	macro
	* x-value
	move.b	(a1)+,d1
	move.b	(a4,d1),d1

	* y-value
	moveq	#0,d2
	move.b	5(a1),d2
	move.b	(a2,d2),d2

	* modulo multab access
	add	d2,d2
	move	(a0,d2),d3

	* plot pixel
	move	d1,d2
	lsr	#3,d2
	sub	d2,d3
	bset	d1,(a6,d3)

	* progress in sample data,
	* check every other pixel
 ifne \2
	subq.l	#2,d4
	bpl.b	.h\1
	move.l	d5,d4
	move.l	d6,a1
.h\1	
 endc
	endm


	bsr	getScopeChannelData
	beq	.x


	move.l	d0,a1 * start
	move.l	d1,d6 * loopstart
	moveq	#0,d4
	move	d2,d4 * len
	moveq	#0,d5
	move	d3,d5 * replen
	
	* plot this many pixels
	moveq	#108/4-1,d0
	moveq	#0,d1
.d
	lir	0,0
	lir	1,1
	lir	2,0
	lir	3,1
	dbf	d0,.d
.x
	pop	a4
	rts



**** Taajuusanalysaattori

yip	macro
	move.b	(a0)+,d0
	not.b	d0
	add.b	d0,d0
	and	d5,d0
	move	(a2,d0),d0
	or.b	d6,(a1,d0)
	ror.b	#1,d6
	bpl.b	.b\1
	addq	#1,a1
.b\1
 	endm

piup	macro
	move.b	(a1)+,d0
	sub.b	(a1),d0
	bpl.b	.e\1
	neg.b	d0
.e\1	addq.b	#1,(a0,d0)
	subq.l	#1,d5
	bpl.b	.l\1
	cmp	d3,d4
	beq	.break
	move.l	d4,d5
	move.l	a4,a1
.l\1	
	endm

freqscope
  ifne FEATURE_SPECTRUMSCOPE
	jmp	runSpectrumScope
  endif
  
  ifne FEATURE_FREQSCOPE
  fail "Fix a4 accessess first"
	moveq	#0,d0
	moveq	#0,d1
	moveq	#0,d2
	moveq	#0,d3
	moveq	#0,d4
	moveq	#0,d5
	moveq	#0,d6
	moveq	#0,d7
	move.l	deltab1(a5),a0
	lea	(256+32)*4(a0),a1
.clr	movem.l	d0-d7,-(a1)
	movem.l	d0-d7,-(a1)
	cmp.l	a0,a1
	bne.b	.clr


*** PS3M freqscope
	cmp	#pt_multi,playertype(a5)
	bne.b	.protr

;	move.l	buff1,a1
	move.l	ps3m_buff1(a5),a1
	move.l	(a1),a1

	move.l	deltab1(a5),a0
	bsr	.tutps3m

;	move.l	buff2,a1
	move.l	ps3m_buff2(a5),a1
	move.l	(a1),a1

	move.l	deltab2(a5),a0
	bsr	.tutps3m

	bra.b	.drl

.protr

	lea	scopeData+scope_ch1(a5),a3
	move.l	deltab1(a5),a0
	bsr	.tut
	lea	scopeData+scope_ch4(a5),a3
	move.l	deltab4(a5),a0
	bsr	.tut

	lea	scopeData+scope_ch2(a5),a3
	move.l	deltab2(a5),a0
	bsr	.tut
	lea	scopeData+scope_ch3(a5),a3
	move.l	deltab3(a5),a0
	bsr	.tut

	move	ns_tempvol+scopeData+scope_ch1(a5),d1
	move	ns_tempvol+scopeData+scope_ch4(a5),d2
	move.l	deltab1(a5),a0
	move.l	deltab4(a5),a1
	bsr	.pre

	move	ns_tempvol+scopeData+scope_ch2(a5),d1
	move	ns_tempvol+scopeData+scope_ch3(a5),d2
	move.l	deltab2(a5),a0
	move.l	deltab3(a5),a1
	bsr.b	.pre

.drl	move.l	deltab1(a5),a0
	move.l	draw1(a5),a1
	addq	#3,a1
	bsr	.dr

	move.l	deltab2(a5),a0
	move.l	draw1(a5),a1
	lea	21(a1),a1
	bsr	.dr

* Pystyfillaus
	lore	GFX,OwnBlitter

	move.l	draw1(a5),a0
	addq	#2,a0
	moveq	#2,d0
	lea	40(a0),a1
	lea	$dff000,a2

	lob	WaitBlit
	move.l	a0,$50(a2)	* A
	move.l	a1,$48(a2)	* C
	move.l	a1,$54(a2)	* D
	move	d0,$60(a2)	* C
	move	d0,$64(a2)	* A
	move	d0,$66(a2)	* D
	move.l	#-1,$44(a2)
	move.l	#$0b5a0000,$40(a2)	* D = A not C
	move	#65*64+19,$58(a2)

	lob	WaitBlit
	jmp	_LVODisownBlitter(a6)


.pre
	mulu	mainvolume(a5),d1
	lsr	#6,d1
	bne.b	.1
	moveq	#1,d1
.1	subq	#1,d1
	lsl.l	#8,d1
	move.l	mtab(a5),a2
	add.l	d1,a2

	mulu	mainvolume(a5),d2
	lsr	#6,d2
	bne.b	.2
	moveq	#1,d2
.2	subq	#1,d2
	lsl.l	#8,d2
	move.l	mtab(a5),a3
	add.l	d2,a3

	moveq	#128/4-1,d0
	moveq	#0,d3
	moveq	#0,d4
.volm	
 rept 4
	move.b	(a0),d3
	move.b	(a1)+,d4
	move.b	(a2,d3),d3
	add.b	(a3,d4),d3
	move.b	d3,(a0)+
 endr
	dbf	d0,.volm
	rts
	


.dr
	clr.b	(a0)
;	lea	1*40(a1),a1
	lea	multab(a5),a2
	moveq	#128/8-1,d7
	move.b	#$80,d6
	move	#%01111110,d5
.dloop
	yip	0
	yip	1
	yip	2
	yip	3
	yip	4
	yip	5
	yip	6
	yip	7
	dbf	d7,.dloop
	rts


.tut	
	move	ns_tempvol(a3),d4
	mulu	mainvolume(a5),d4
	lsr	#6,d4
	bne.b	.h
	moveq	#1,d4
.h



;	move.l	ns_loopstart(a3),d0
;	beq.b	.halt
;	move.l	ns_start(a3),d1
;	bne.b	.jolt
;.halt	rts
;.jolt	

	bsr	getScopeChannelData
	bne.b	.jolt
	rts
.jolt

	;move.l	d0,a4
	;move.l	d1,a1
	move.l	d0,a1 * start
	move.l	d1,a4 * loop start

	moveq	#0,d4
	move	d3,d4 * replen
	moveq	#0,d5
	move	d2,d5 * len

;	moveq	#0,d4
;	move	ns_replen(a3),d4
;	add.l	d4,d4
;	moveq	#0,d5
;	move	ns_length(a3),d5
;	add.l	d5,d5

	move	ns_period(a3),d0
	bne.b	.noe
	rts

.noe	move.l	colordiv(a5),d7		* colorclock/vbtaajuus
	divu	d0,d7			* d7.w = bytes per 1/50s
	mulu	#11,d7		* tutkitaan 11/15 osa framesta (73%)
	divu	#15,d7

	move	d7,d6
	lsr	#3,d7
	subq	#1,d7
	moveq	#0,d0
	moveq	#2,d3


.loop1
	piup	0
	piup	1
	piup	2
	piup	3
	piup	00
	piup	11
	piup	22
	piup	33
	dbf	d7,.loop1	

	and	#%111,d6
	beq.b	.n
	subq	#1,d6
.loop2	piup	4
	dbf	d6,.loop2
.n
.break
	rts



.tutps3m
;	move.l	mixingperiod,d0
	push	a0
	move.l	ps3m_mixingperiod(a5),a0
	move.l	(a0),d0
	pop	a0
	bne.b	.oe
	rts

.oe	move.l	colordiv(a5),d7		* colorclock/vbtaajuus
	divu	d0,d7			* d7.w = bytes per 1/50s
	mulu	#11,d7		* tutkitaan 11/15 osa framesta (73%)
	divu	#15,d7

	lsr	#2,d7
	subq	#1,d7
	moveq	#0,d0

;	move.l	playpos,d5
	push	a0
	move.l	ps3m_playpos(a5),a0
	move.l	(a0),d5
	pop	a0
		
	lsr.l	#8,d5
	bsr	getps3mb

piup2	macro
	move.b	(a1,d5.l),d0
	sub.b	1(a1,d5.l),d0
	bpl.b	.w\1
	neg.b	d0
.w\1	addq.b	#1,(a0,d0)
	addq	#1,d5
	and	d4,d5
	endm

.loop11	piup2	0
	piup2	1
	piup2	2
	piup2	3
	dbf	d7,.loop11

	rts
  endif ; FEATURE_FREQSCOPE

*********** Scopet PS3M
*** stereoscope

multiscope:


    jsr     playSidInRESIDMode
    bne    .resid3
.notSid3
	move.l	ps3m_buff1(a5),a1
	move.l	(a1),a1

    * Start at pixel 19*8 = 152
	move.l	s_draw1(a4),a0
	lea	19(a0),a0
	bsr.b	.h

    * Start at pixel 39*8 = 312
	move.l	ps3m_buff2(a5),a1
	move.l	(a1),a1
	move.l	s_draw1(a4),a0
	lea	39(a0),a0
    bra     .h

    ; ---------------------------------
.resid3

    * Start at pixel 39*8 = 312
    move.l  residBufPtr3,d0
    beq     .notSid3
    move.l  d0,a1

	move.l	s_draw1(a4),a0
	lea 	3*96/8+2(a0),a0
	moveq	#96/8-1,d7
    bsr     .h2

    * sid1
	move.l	ps3m_buff1(a5),a1
	move.l	(a1),a1

    * Start at pixel 19*8 = 152
	move.l	s_draw1(a4),a0
	lea	96/8(a0),a0
    * Draw 96 pixels
	moveq	#96/8-1,d7
	bsr.b	.h2

    * sid2
    * Start at pixel 39*8 = 312
	move.l	ps3m_buff2(a5),a1
	move.l	(a1),a1
	move.l	s_draw1(a4),a0
	lea	2*96/8+1(a0),a0
	moveq	#96/8-1,d7
    bra    .h2

    ; ---------------------------------


    * Draw segment from right to left
.h
    * Draw 152 pixels
	moveq	#160/8-1-1,d7
.h2
	move.l	ps3m_playpos(a5),a2
	move.l	(a2),d5
	lsr.l	#8,d5
	lea	s_multab(a4),a2
		
    * Pixel mask: rightmost pixels
	moveq	#1,d0
    * Sample normalize constant
	move	#$80,d6
    * This returns the buffer mask or size limit in d4
	bsr	getps3mb
    move.l  ps3m_sampleDataModulo(a5),d3
multiscope0:
    * d3 = sample modulo
   
.drlo	
    * Do 8 horizontal pixels
    moveq   #2-1,d1
.p8
    rept 4
    * Get one data byte, adjust with $80
    * turns it from -128..127 to 0..256 I guess
 	move	d6,d2
	add.b	(a1,d5.l),d2
    * scale to 0..63
	lsr.b	#2,d2
    * Multiply by screen modulo using a table
	add	d2,d2
	move	(a2,d2),d2
    * Write two pixels on top of each other
	or.b	d0,-40(a0,d2)
	or.b	d0,(a0,d2)
    * Next pixel to the left
	add.b	d0,d0
    * Advance one byte in source data

    add.l   d3,d5

    ;bpl.b   .2
    bpl.b   *+6
    * Beginning bound check, ping pong
    neg.l   d3
    moveq   #0,d5
;.2
	cmp.l	d4,d5
;	blo.b	.1
    blo.b   *+6
    * End bound check, ping pong
    neg.l   d3
    add.l   d3,d5
; .1
    endr 
    dbf d1,.p8
	* Reset pixel to right
	moveq	#1,d0
    * Jump 8 pixels to left
	sub	d0,a0
	dbf	d7,.drlo
	rts




multiscopefilled:

	move.l	ps3m_buff1(a5),a1
	move.l	(a1),a1

	move.l	s_draw1(a4),a0
	lea	19(a0),a0
	bsr.b	.h

	move.l	ps3m_buff2(a5),a1
	move.l	(a1),a1
	move.l	s_draw1(a4),a0
	lea	39(a0),a0
.h

	move.l	ps3m_playpos(a5),a2
	move.l	(a2),d5
	lsr.l	#8,d5
	lea	s_multab(a4),a2
		
	moveq	#160/8-1-1,d7
	moveq	#1,d0
	move	#$80,d6
	bsr	getps3mb

     * sample modulo
    move.l  ps3m_sampleDataModulo(a5),d3

multiscopefilled0:

hurl	macro 
	move	d6,d2
	add.b	(a1,d5.l),d2
	bpl.b	.ok\1
	not.b	d2
.ok\1
	lsr.b	#2,d2
	add	d2,d2
	move	(a2,d2),d2
	or.b	d0,(a0,d2)
	add.b	d0,d0
	add.l	d3,d5

	cmp.l	d4,d5
	blo.b	*+4
	moveq	#0,d5
	endm

.drlo	
	hurl	1
	hurl	2
	hurl	3
	hurl	4
	hurl	5
	hurl	6
	hurl	7
	hurl	8

	moveq	#1,d0
	sub	d0,a0
	dbf	d7,.drlo
	rts




***** hipposcope ps3m:lle

multihipposcope:
	move.l	ps3m_buff1(a5),a1
	move.l	(a1),a1

	move	#240,d0
	bsr.b	.1
	move.l	ps3m_buff2(a5),a1
	move.l	(a1),a1
	moveq	#88,d0
	
.1

	move.l	ps3m_playpos(a5),a2
	move.l	(a2),d5
	lsr.l	#8,d5

	bsr.b	getps3mb

;    moveq   #1,d6   * sampledata modulo
    move.l  ps3m_sampleDataModulo(a5),d6

multihipposcope0:
	lea	s_multab(a4),a2
	move.l	s_draw1(a4),a3

    * Pointer to get the y-value: x+5
    move    d6,d7
    ;mulu    #5,d7
    lsl     #3,d7
    lea     (a1,d7.w),a0

	moveq	#120-1,d7
.d

	move.b	(a1,d5.l),d1
	asr.b	#1,d1
	ext	d1
	add	d0,d1

    ;move.b	5(a1,d5.l),d2
    move.b	(a0,d5.l),d2

	asr.b	#2,d2 
	ext	d2
	;add	d6,d2
    add     #32,d2
	add	d2,d2
	move	(a2,d2),d3

	move	d1,d2
	lsr	#3,d2
	sub	d2,d3
	bset	d1,39(a3,d3)

	add	d2,d3			* toinen pixeli viereen
	addq	#1,d1
	move	d1,d2
	lsr	#3,d2
	sub	d2,d3
	bset	d1,39(a3,d3)

;	addq.l	#1,d5
    add.l   d6,d5

	cmp.l	d4,d5
	bne.b	.x
	moveq	#0,d5
.x
	dbf	d7,.d

	rts


getps3mb:
	push	a0
	move.l	ps3m_buffSizeMask(a5),a0
	move.l	(a0),d4
	pop	a0
	rts






*********************************************************************
* NoteScroller (ProTracker)
*

noteScrollerHorizontalLines
*** viiva
	move.l	s_draw1(a4),a0
	move	s_scopeDrawAreaModulo(a4),d2
	* first line at y-coordinate
	move	s_scopeDrawAreaHeight(a4),d3
	lsr	#1,d3
	sub	#9,d3
	mulu	d2,d3
	add	d3,a0

.normal
	* 2nd row offset
	lsl	#3,d2
	subq	#2,d2
	* 19 times 16 pixels horizontally
	move	s_scopeDrawAreaModulo(a4),d0
	lsr	#1,d0
	subq	#1,d0
	move	#$aaaa,d1
.raita	
	* put 16 pixels here
	or.w	d1,(a0)+
	* ...and 8 pixels below
	or.w	d1,(a0,d2)
	dbf	d0,.raita
	rts

* out:
*  d4 = modulo, or NULL
*  a2 = data
noteScrollerGetFont
	* Check if font is usable
	move.l	fontbase(a5),a2
	moveq	#8,d4
	cmp	tf_YSize(a2),d4
	bne.b 	.try1
	cmp	tf_XSize(a2),d4 
	bne.b 	.try1
	btst	#FPB_PROPORTIONAL,tf_Flags(a2)
	beq.b	.okFont
.try1
	* Fallback to topaz
	move.l	topazbase(a5),a2
	cmp	tf_YSize(a2),d4 
	bne.b 	.badFont
	cmp	tf_XSize(a2),d4 
	bne.b 	.badFont
	btst	#FPB_PROPORTIONAL,tf_Flags(a2)
	beq.b	.okFont
.badFont
	* Can't use these fonts, give up!
	moveq	#0,d4
	rts
.okFont
	* store font data into a2 and d4 for fast access later
	move	tf_Modulo(a2),d4		* font modulo
	move.l	tf_CharData(a2),a2		* data
	rts

patternScopeSizeAdjust:
	move	#SCOPE_DRAW_AREA_WIDTH_DEFAULT,d0
	moveq	#SCOPE_DRAW_AREA_HEIGHT_DEFAULT,d1
	cmp.b	#QUADMODE2_PATTERNSCOPEXL,s_quadmode2(a4)
	bne.b 	.normHeight
	move	#SCOPE_DRAW_AREA_HEIGHT_DOUBLE,d1
.normHeight
patternScopeSizeAdjustDo:
	cmp	s_scopeDrawAreaWidth(a4),d0
	bne.b	.plz
	cmp	s_scopeDrawAreaHeight(a4),d1
	beq.b	.sizeOk
.plz	bsr	requestScopeDrawAreaChange
    moveq   #0,d0
	rts
.sizeOk
    moveq   #1,d1
    rts

patternScopePt:
noteScrollerPt:
notescroller:
    bsr     patternScopeSizeAdjust
    bne     .sizeOk
	rts
.sizeOk

	bsr	.notescr
	bsr	noteScrollerHorizontalLines

	* Volume update
	lea	scopeData+scope_ch1(a5),a0
	* channel bitmask
	moveq	#1,d2
	moveq	#4-1,d1
	lea	s_patternScopeVolumes(a4),a2
.setscope	
	* see if channel bit is on
	move.b	scopeData+scope_trigger(a5),d0
	and.b	d2,d0
	beq.b	.e	
	* was on, clear it, and copy the volume value
	move.b  d2,d0 	
	not.b   d0
	and.b  	d0,scopeData+scope_trigger(a5)
	move	ns_tempvol(a0),d0
	CLAMPVOL d0
	move	d0,(a2)
.e	
	* next bit
	add.b	d2,d2
	lea	ns_size(a0),a0
	addq	#2,a2
	dbf	d1,.setscope

	move	s_patternScopeVolumes+0(a4),d0
	moveq	#2,d1
	bsr.b	.palkki
	move	s_patternScopeVolumes+2(a4),d0
	moveq	#11,d1
	bsr.b	.palkki
	move	s_patternScopeVolumes+4(a4),d0
	moveq	#20,d1
	bsr.b	.palkki
	move	s_patternScopeVolumes+6(a4),d0
	moveq	#29,d1
	bsr.b	.palkki

	lea	scopeData+scope_ch1(a5),a3
	move.b	#%11100000,d2
	moveq	#38,d1
	bsr.b	.palkki2
	lea	scopeData+scope_ch2(a5),a3
	moveq	#%1110,d2
	moveq	#38,d1
	bsr.b	.palkki2
	lea	scopeData+scope_ch3(a5),a3
	moveq	#39,d1
	move.b	#%11100000,d2
	bsr.b	.palkki2
	lea	scopeData+scope_ch4(a5),a3
	moveq	#%1110,d2
	moveq	#39,d1
	bsr.b	.palkki2

.ohi
	* animate the volume bars towards bottom
	lea	s_patternScopeVolumes(a4),a0
	moveq	#4-1,d0
.orl	tst	(a0)+
	beq.b	.urh
	subq	#1,-2(a0)
.urh	dbf	d0,.orl
	rts


***** Volumepalkgi

.palkki
	mulu	mainvolume(a5),d0
	lsr	#6,d0

	move.l	s_draw1(a4),a0
	* horizontal position
	add	d1,a0
	* move to bottom
	move	s_quadNoteScrollerLines(a4),d1
	lsl	#3,d1
	mulu	s_scopeDrawAreaModulo(a4),d1
	add.l	d1,a0

	lea	.paldata(pC),a1
	moveq	#-2,d2
	subq	#1,d0
	bmi.b	.yg
.purl	and.b	d2,(a0)
	move.b	-(a1),d1
	or.b	d1,(a0)
	lea	-40(a0),a0
	dbf	d0,.purl	
.yg	rts



**** Periodpalkki
	
.palkki2
	cmp	#2,ns_length(a3)
	bls.b	.h
	moveq	#0,d0
	move	ns_period(a3),d0
	beq.b	.h
	* range is 108 - 907
	sub	#108,d0

	* this many vertical pixels
	move	s_quadNoteScrollerLines(a4),d3
	lsl	#3,d3
	subq	#5,d3
	mulu	d3,d0
	divu	#907-108,d0

	move.l	s_draw1(a4),a0
	lea	s_multab(a4),a1
	add	d0,d0
	move	(a1,d0),d0
	add	d0,a0
	add	d1,a0

	or.b	d2,(a0)
	or.b	d2,40(a0)
	or.b	d2,80(a0)
	or.b	d2,120(a0)

.h	rts




* 8x64
	DC.B	$FC,$FC,$FC,$FC
	DC.B	$FC,$DC,$FC,$7C
	DC.B	$FC,$DC,$FC,$54
	DC.B	$FC,$5C,$FC,$54
	DC.B	$FC,$54,$FC,$54
	DC.B	$B8,$54,$FC,$54
	DC.B	$B8,$54,$AC,$54
	DC.B	$B8,$54,$A8,$54
	DC.B	$A8,$54,$A8,$54
	DC.B	$88,$54,$28,$54
	DC.B	$88,$54,$00,$54
	DC.B	$88,$54,$00,$54
	DC.B	$00,$54,$00,$54
	DC.B	$00,$10,$00,$54
	DC.B	$00,$10,$00,$00
	DC.B	$00,$10,$00,$00
.paldata


**************** Piirret‰‰n patterndata

.notescr
	pushm	a4/a5/a6

	lea	kplbase(a5),a0
	move.l	k_songdataptr(a0),a3
	moveq	#0,d0
	move	k_songpos(a0),d0
	move.b	(a3,d0),d0
	lsl	#6,d0
	add	k_patternpos(a0),d0
	lsl.l	#4,d0
	add.l	d0,a3
	lea	1084-952(a3),a3

	* draw this many lines
	move	s_quadNoteScrollerLines(a4),d7
	subq	#1,d7 * dbf
	move	k_patternpos(a0),d6	* eka rivi?

	* Target
	move.l	s_draw1(a4),a0
	addq	#3,a0

	* figure out where to place the first line
	move	d6,d0
	; move the cursor in the middle
	sub	s_quadNoteScrollerLinesHalf(a4),d0
	bpl.b	.ok
	neg	d0
	sub	d0,d7

	move	s_quadNoteScrollerLinesHalf(a4),d1
	sub	d0,d1
	sub	d1,d6
	lsl	#4,d1
	sub	d1,a3

	; vertical position in target 
	mulu	#8*40,d0
	add.l	d0,a0

	bra.b	.ok2
.ok
	move	s_quadNoteScrollerLinesHalf(a4),d0
	lsl	#4,d0
	sub	d0,a3
	sub	s_quadNoteScrollerLinesHalf(a4),d6
.ok2

	
	bsr	noteScrollerGetFont * Uses d4,a2 only
	beq	.exitNoteScroller

	* Target screen addr goes in a4 
	move.l	a0,a4

	* convert row in D6 to BCD
	moveq	#0,d0
	move	d6,d0
	divu	#10,d0 
	lsl.b	#4,d0
	move.w	d0,d6
	swap	d0 
	or.b	d0,d6	

	* d3 is FREE!
	* use for horizontal skipping
	moveq	#9,d3

	* vertical loop
	* line loop
.plorl
	* print linenumber, in BCD format
	* avoid DIVU in loop this way
	lea	.pos(pc),a0		

	move.w	d6,d0	* $00XY
	lsl.w	#4,d0	* $0XY0
	lsr.b	#4,d0	* $0X0Y
	or.w	#$3030,d0
	move	d0,(a0)

	move.l	a4,a1
	subq	#3,a1
	moveq	#2-1,d1
	bsr	.print

	* horizontal loop
	* print 4 horizontal notes	
	moveq	#4-1,d5
.plorl2
	* builds a one note text here
	lea	.note(pc),a0

	moveq	#0,d0
	move.b	2(a3),d0
	bne.b	.jee
	* empty note
	clr.w	(a0)+
	clr.b	(a0)+
	bra.b	.nonote

* notes table is here so that a shorter
* access can be used below
.notes	dc.b	"C-"
	dc.b	"C#"
	dc.b	"D-"
	dc.b	"D#"
	dc.b	"E-"
	dc.b	"F-"
	dc.b	"F#"
	dc.b	"G-"
	dc.b	"G#"
	dc.b	"A-"
	dc.b	"A#"
	dc.b	"B-"
 	even

.jee
	* calculate octave number
	subq	#1,d0
	divu	#12*2,d0
	moveq	#'0',d1 
	* first octave is 1
	addq.b	#1,d0
	add.b	d0,d1
	* figure out note text
	swap	d0
	* two chars
	move	.notes(pc,d0.w),(a0)+
	move.b	d1,(a0)+
.nonote

	move.b	3(a3),d0	* sample num
	bne.b	.onh
	* a0 is odd here
	clr.b	(a0)+
	clr.b	(a0)+
	bra.b	.eihn
.onh
	* sample number pre-multiplied by 4
	lsr.b	#2,d0
	move.b	d0,d1
	* get the upper digit
	lsr.b	#4,d1
	bne.b	.onh2
	clr.b	(a0)+
	bra.b	.eihn2
.onh2	or.b	#'0',d1
	move.b	d1,(a0)+
.eihn2	
	* lower digit
	and.b	#$f,d0
	bsr.b	.hegs
.eihn

	move.b	(a3)+,d0	* command, premultiplied
	lsr.b	#2,d0
	bsr.b	.hegs
	move.b	(a3),d0 * command parameter
	move.b	d0,d1
	lsr.b	#4,d0	* upper char
	bsr.b	.hegs
	moveq	#$f,d0	* lower char
	and.b	d1,d0
	bsr.b	.hegs

	* print 8 chars
	* a4 = destination bufer
	move.l	a4,a1
	;lea	.note(pc),a0
	subq	#8,a0
	moveq	#8-1,d1
	bsr.b	.print

	* next note
	addq.l	#4-1,a3
	* next horizontal position
	;add	#9,a4
	add	d3,a4
	dbf	d5,.plorl2

	* next vertical position
	lea	(8*40-4*9)(a4),a4
	* next pattern line, check if at the end
	* clear X flag for ABCD
	sub.b	d0,d0
	* Next row in BCD
	moveq	#1,d0
	abcd.b	d0,d6
	* row 64 in BCD
	cmp.b	#$64,d6
	dbeq d7,.plorl
.exitNoteScroller
	popm	a4/a5/a6	
	rts

* convert decimal number 0-9 into ASCII char
.hegs	cmp.b	#9,d0
	bhi.b	.high1
	or.b	#'0',d0
	move.b	d0,(a0)+
	rts
.high1	
	add.b	#-10+'A',d0
	move.b	d0,(a0)+
	rts

.note	dc.b	"00000000"
.pos	dc.b	"00"
 even

.print
	* a2 contains font data
	* d4 contains font modulo
	
	* get one char to print
	moveq	#0,d0
.ooe	
	move.b	(a0)+,d0
	beq.b	.space	 * space check
	* get char pixels
	lea	-$20(a2,d0),a6

	* do 8 pixels height
 	move.b	(a6),(a1)+	
	add	d4,a6
	move.b	(a6),1*40-1(a1)	
	add	d4,a6
	move.b	(a6),2*40-1(a1)	
	add	d4,a6
	move.b	(a6),3*40-1(a1)	
	add	d4,a6
	move.b	(a6),4*40-1(a1)	
	add	d4,a6
	move.b	(a6),5*40-1(a1)	
	add	d4,a6
	move.b	(a6),6*40-1(a1)	
	add	d4,a6
	move.b	(a6),7*40-1(a1)	
	* go to next horiz position
	dbf	d1,.ooe
	rts 
.space	
	* go to next horiz position
	addq	#1,a1
	dbf	d1,.ooe
	rts

	




***************************************************************************
* a0 = bitmap
* a1 = (playsidbase+50)
* d0 = kanava


;SIDscope
;	move.l	draw1(a5),a0
;	moveq	#0,d0
;	bsr.b	.1
;	bsr.b	.1
;	bsr	.1

;.1	bsr.b	.2
;	add	#10,a0
;	addq	#1,d0
;	rts

;.2	movem.l	d0-a6,-(sp)
;	move.l	_SIDBase(a5),a1
;	move.l	50(a1),a1
;	lea	multab(a5),a6

;	add.w	d0,d0
;	move.w	d0,d1
;	add.w	d0,d0
;	move.l	0(a1,d0.w),a3  * dd_SampleX
;	add.w	d0,d0
;	lea	lbl006b58,a2
;	lea	lbl006950,a4
;	lsl.w	#4,d0
;	add.w	d0,a4
;	lea	lbl006b50,a5
;	moveq	#64-1,d3
;	move.w	#32*40,d4
;	move.w	$20(a1,d1.w),d6 * dd_EnveX
;	bne.s	.lbc006706

;.lbc0066f8	move.w	d4,(a4)+
;	dbra	d3,.lbc0066f8

;	lea	-$80(a4),a4
;	bra.b	.lbc006752

;.lbc006706	cmp.w	#$7a,$18(a1,d1.w)  * dd_PeriodX
;	bls.s	.lbc0066f8

;	moveq	#0,d4
;	move.l	#$7b0000,d5
;	divu	$18(a1,d1.w),d5 * dd_PeriodX
;	move.w	$10(a1,d1.w),d7 * dd_LengthX
;	move.w	0(a5,d1.w),d2
;.lbc006722	add.w	d5,0(a2,d1.w)
;	addx.w	d4,d2
;.lbc006728	cmp.w	d7,d2
;	blt.s	.lbc006730

;	sub.w	d7,d2
;	bra.s	.lbc006728

;.lbc006730	
;	move.b	0(a3,d2.w),d0
;	ext	d0
;	muls	d6,d0
;	asr	#8,d0
;;	asr	#1,d0
;	add	#32,d0
;	add	d0,d0
;	move	(a6,d0),(a4)+
;	dbra	d3,.lbc006722

;	lea	-$80(a4),a4
;	move.w	d2,0(a5,d1.w)
;.lbc006752
;;	move.w	#$3e0,d0
;;.lbc006756
;;	clr.l	0(a0,d0.w)
;;	clr.l	4(a0,d0.w)
;;	sub.w	#$20,d0
;;	bpl.s	.lbc006756

;	moveq	#31-1,d0
;	move.l	#$80000000,d1
;	move.l	#$40000000,d4
;	moveq	#40,d6
;.lbc006774
;	move.w	(a4)+,d2
;	move.w	(a4),d3
;	or.l	d1,0(a0,d2.w)
;	or.l	d4,0(a0,d3.w)
;	cmp.w	d3,d2
;	beq.s	.lbc0067b6

;	bhi.s	.lbc00679e

;.lbc006786	move.w	d3,d5
;	sub.w	d2,d5
;	cmp.w	d6,d5
;	bls.s	.lbc0067b6

;	add.w	d6,d2
;	sub.w	d6,d3
;	or.l	d1,0(a0,d2.w)
;	or.l	d4,0(a0,d3.w)
;	bra.b	.lbc006786

;.lbc00679e	move.w	d2,d5
;	sub.w	d3,d5
;	cmp.w	d6,d5
;	bls.s	.lbc0067b6

;	add.w	d6,d3
;	sub.w	d6,d2
;	or.l	d1,0(a0,d2.w)
;	or.l	d4,0(a0,d3.w)
;	bra.b	.lbc00679e

;.lbc0067b6	ror.l	#1,d1
;	ror.l	#1,d4
;	dbra	d0,.lbc006774

;	move.w	(a4)+,d2
;	move.w	(a4),d3
;	or.l	d1,0(a0,d2.w)
;	or.l	d4,4(a0,d3.w)
;	cmp.w	d3,d2
;	beq.s	.lbc006800

;	bhi.s	.lbc0067e8

;.lbc0067d0	move.w	d3,d5
;	sub.w	d2,d5
;	cmp.w	d6,d5
;	bls.s	.lbc006800

;	add.w	d6,d2
;	sub.w	d6,d3
;	or.l	d1,0(a0,d2.w)
;	or.l	d4,4(a0,d3.w)
;	bra.b	.lbc0067d0

;.lbc0067e8	move.w	d2,d5
;	sub.w	d3,d5
;	cmp.w	d6,d5
;	bls.s	.lbc006800

;	add.w	d6,d3
;	sub.w	d6,d2
;	or.l	d1,0(a0,d2.w)
;	or.l	d4,4(a0,d3.w)
;	bra.b	.lbc0067e8

;.lbc006800	ror.l	#1,d1
;	ror.l	#1,d4
;	moveq	#31-1,d0
;.lbc006806	move.w	(a4)+,d2
;	move.w	(a4),d3
;	or.l	d1,4(a0,d2.w)
;	or.l	d4,4(a0,d3.w)
;	cmp.w	d3,d2
;	beq.s	.lbc006848

;	bhi.s	.lbc006830

;.lbc006818	move.w	d3,d5
;	sub.w	d2,d5
;	cmp.w	d6,d5
;	bls.s	.lbc006848

;	add.w	d6,d2
;	sub.w	d6,d3
;	or.l	d1,4(a0,d2.w)
;	or.l	d4,4(a0,d3.w)
;	bra.b	.lbc006818

;.lbc006830	move.w	d2,d5
;	sub.w	d3,d5
;	cmp.w	d6,d5
;	bls.s	.lbc006848

;	add.w	d6,d3
;	sub.w	d6,d2
;	or.l	d1,4(a0,d2.w)
;	or.l	d4,4(a0,d3.w)
;	bra.b	.lbc006830

;.lbc006848	ror.l	#1,d1
;	ror.l	#1,d4
;	dbra	d0,.lbc006806

;	movem.l	(sp)+,d0-a6
;	rts


*******************************************************************

********** Palkit

leverEor
	* Flag: eor
	moveq	#1,d4
	bra.b	lever\.go

lever
	* Flag: or
	moveq	#0,d4
.go
	lea	scopeData+scope_ch1(a5),a3
	moveq	#4-1,d7
	move.l	s_draw1(a4),a2
.l	move.l	a2,a0
	bsr.b	.drawLever
	lea	10(a2),a2
	lea	ns_size(a3),a3
	dbf	d7,.l
	rts
	

* 907-108
.drawLever
	cmp	#2,ns_length(a3)
	bls.b	.h
	moveq	#0,d1
	move	ns_period(a3),d1
	beq.b	.h
	sub	#108,d1
	lsl	#1,d1
	divu	#27,d1		* lukualueeksi 0-59

	* clamp
	cmp	#59,d1
	bls.b	.1
	move	#59,d1
.1

	lea	s_multab(a4),a1
	add	d1,d1
	add	(a1,d1),a0

	move	ns_tempvol(a3),d0
	mulu	mainvolume(a5),d0
	lsr	#6,d0
	bne.b	.pad
	moveq	#1,d0
.pad	
	lsl	#3,d0
	subq	#8,d0
	bpl.b	.ojdo
	moveq	#0,d0
.ojdo
	lea	s_scopeHorizontalBarTable(a4),a1
	movem.l	(a1,d0),d0/d1

	move.l	#$55555555,d3
	and.l	d3,d0
	and.l	d3,d1

	move.l	d0,d2
	move.l	d1,d3
	roxl.l	#1,d3
	roxl.l	#1,d2

	tst.b	d4
	bne.b	.eor

	or.l	d0,(a0)+
	or.l	d1,(a0)
	or.l	d2,40-4(a0)
	or.l	d3,40(a0)
	or.l	d0,80-4(a0)
	or.l	d1,80(a0)
	or.l	d2,120-4(a0)
	or.l	d3,120(a0)

.h	rts

.eor
	eor.l	d0,(a0)+
	eor.l	d1,(a0)
	eor.l	d2,40-4(a0)
	eor.l	d3,40(a0)
	eor.l	d0,80-4(a0)
	eor.l	d1,80(a0)
	eor.l	d2,120-4(a0)
	eor.l	d3,120(a0)
	rts

****** taulukkoon 1-64 pix leveit‰ palkkeja

makeScopeHorizontalBars	
	lea	s_scopeHorizontalBarTable(a4),a0
	moveq	#64-1,d0
	moveq	#0,d1
	moveq	#0,d2
.l	roxr.l	#1,d1
	roxr.l	#1,d2
	bset	#31,d1
	move.l	d1,(a0)+
	move.l	d2,(a0)+
	dbf	d0,.l
	rts


*** Sample scope
*** Any sample played by the sample player

samplescope:
	bsr 	samples0
    bne     .hasData
    rts
.hasData
    jsr     getSampleDataModulo
    move.l  d0,d3 * d3 = 1 or 2
	move.l	samplepointer(a5),a1
	move.l	(a1),a1
	tst.b	samplestereo(a5)
	bne.b	.st
	lea	39(a0),a0
	moveq	#39-1,d7
	bra	multiscope0
.st	
	lea	19(a0),a0
	moveq	#19-1,d7
	bsr	multiscope0
	bsr 	samples0
	lea	39(a0),a0
	move.l	samplepointer2(a5),a1
	move.l	(a1),a1
	moveq	#19-1,d7
	bra	multiscope0

sampleHippoScope:
	tst.b	samplestereo(a5)
	beq     .mono
	bsr 	samples0
    * d4 = sample data mask
    * d5 = sample follow  position
    bne     .hasData
.mono
    ; not supported
    rts
.hasData
    jsr     getSampleDataModulo
    move.l  d0,d6 * d6 = 1 or 2
	move.l	samplepointer(a5),a1
	move.l	(a1),a1
	move	#240,d0
    bsr     multihipposcope0

	move.l	samplepointer2(a5),a1
	move.l	(a1),a1
	move	#88,d0
    bra     multihipposcope0

samplescopefilled:
	bsr.b	samples0
    bne     .hasData
    rts
.hasData
    jsr     getSampleDataModulo
    move.l  d0,d3 * d3 = 1 or 2
	move.l	samplepointer(a5),a1
	move.l	(a1),a1
	tst.b	samplestereo(a5)
	bne.b	.st
	lea	39(a0),a0
	moveq	#39-1,d7
	bra	multiscopefilled0
.st	
	lea	19(a0),a0
	moveq	#19-1,d7
	bsr	multiscopefilled0
	bsr.b	samples0
	lea	39(a0),a0
	move.l	samplepointer2(a5),a1
	move.l	(a1),a1
	moveq	#19-1,d7
	bra	multiscopefilled0


* Gets some parameters needed for drawing sample scopes
* Out:
*   
samples0:
	move.l	samplefollow(a5),d5
    beq     .error
    move.l  d5,a0
	move.l	(a0),d5
;	move.l	samplefollow(a5),d5

	move.l	samplebufsiz(a5),d4

    * Check if AHI 16-bit buffer
    tst.b   ahi_use_nyt(a5)
    beq     .noA
    cmp     #2,ahiSampleModulo(a5)
    bne     .noA
    add.l   d4,d4
.noA
	subq.l	#1,d4
    
	moveq	#1,d0
	move	#$80,d6

	lea	s_multab(a4),a2
	move.l	s_draw1(a4),a0
.error
	rts


*********************************************************************
* GENERIC NOTESCROLLER
* Note scroller supporting the PI_PatternInfo data
* patternScopeGeneric
* noteScrollerGeneric
* patternScope2
noteScroller2:
	move.l	deliPatternInfo(a5),a1
	lea	PI_Stripes(a1),a0
	move	PI_Voices(a1),d7
	clr	PI_CurrentChannelNumber(a1)

* Required height in d1
	moveq	#SCOPE_DRAW_AREA_HEIGHT_DEFAULT,d1
	cmp.b	#QUADMODE2_PATTERNSCOPEXL,s_quadmode2(a4)
	bne.b	.notXl
	move	#SCOPE_DRAW_AREA_HEIGHT_DOUBLE,d1
.notXl
	cmp	#4,d7
	bhi.b	.over

	move	#SCOPE_DRAW_AREA_WIDTH_DEFAULT,d0
	bsr	requestScopeDrawAreaChange
	beq.b	.proceed
	* resize will happen later
	rts
.over
	
	* max 18 stripes fit into 640 pixels
	cmp	#18,d7
	bls.b	.max16
	moveq	#18,d7
.max16
	* Request larger/wider/narrower window
	move	d7,d0

	cmp	#SCOPE_SMALL_FONT_CHANNEL_LIMIT,d7
	bhi.b	.narrow
	* normal font stripe
	mulu	#72,d0
	bra.b	.wide
.narrow
    * Need narrow font,
	* test if font is available
	tst.l	minifontbase(a5)
	bne 	.yesFont
    * bail out with msg
    bsr     showNoMiniFontMessage
    bra     .x
.yesFont
	* each narrow stripe is 32 pix
	lsl	#5,d0 ;mulu	#32,d0 	
.wide
	* some right margin
	;add	#32,d0
	* ensure divisible by 16 for blitter safety
	;add	#15,d0
	add	#32+15,d0
	and	#$fff0,d0

	bsr	requestScopeDrawAreaChange
	beq.b	.proceed
	rts

.proceed

	* magic flag: display row numbers column	 
	lea	.pos(pc),a6
	clr.b	(a6)

	* Draw here
	move.l	s_draw1(a4),a6

	* Channel count
	subq	#1,d7
.loop
	pushm	d6/d7/a0/a4/a5/a6
	move.l	(a0),a0		* stripe data
	bsr.b	.doStripe
	popm	d6/d7/a0/a4/a5/a6

	* magic flag: no row numbers more than once
	lea	.pos(pc),a2
	tst.b	(a2)
	bmi.b	.wasSet
	* jump over number column
	addq	#3,a6
	st	(a2)
.wasSet
	addq	#4,a0 		* next stripe

	cmp	#SCOPE_SMALL_FONT_CHANNEL_LIMIT,PI_Voices(a1)
	bls.b	.voices4
	* 32 pixels per stripe
	addq	#4,a6		* next screen pos horizontal
	bra.b	.continue
.voices4
	* 72 pixels per stripe
	add	#9,a6
.continue
	addq	#1,PI_CurrentChannelNumber(a1)
	dbf	d7,.loop

	bsr	noteScrollerHorizontalLines
.x	rts

.xy	

 if DEBUG
* MTM modules commonly have empty stripes, caught
* by insanity checks.

; 	move	#$0f0,$dff180
;	move.l	moduleaddress(a5),d0
;	move.l	modulelength(a5),d1
;	move.l	a0,d2
;	SDPRINT	"INSANITY %lx %ld -> %lx"
 endif
	rts


***********************************************************
* Draw one stripe
***********************************************************

.doStripe

*** Sanity check, is the stripe address legal?

	move.l	a0,d0
	beq.b	.xy

	move.l	ps3mUnpackedPattern(a5),d0
	tst.l	d0
	beq.b	.noPattern
	* Pointer within the unpacked pattern region?

	cmp.l	d0,a0
	bhs.b	.sane
	add.l	#32*4*64,d0
	cmp.l	d0,a0
	blo.b	.sane

.noPattern
	* Pointer within the module data?

	cmp.w	#1024,a0
	bls.b	.xy
	move.l  moduleaddress(a5),a3
   	cmp.l   a3,a0
	bls.b	.xy
    	add.l   modulelength(a5),a3
    	cmp.l   a3,a0
   	bhs.b   .xy
.sane

*** calculate stuff
	
	* draw this many lines
	move	s_quadNoteScrollerLines(a4),d7
	subq	#1,d7 * dbf
	move	PI_Pattpos(a1),d6

	* current position in data
	move	d6,d0
	mulu	PI_Modulo+2(a1),d0 
	add.l	d0,a0

	* figure out where to place the first line
	move	d6,d0
	; move the cursor in the middle
	sub	s_quadNoteScrollerLinesHalf(a4),d0
	bpl.b	.ok
	neg	d0
	sub	d0,d7

	move	s_quadNoteScrollerLinesHalf(a4),d1
	sub	d0,d1
	sub	d1,d6
	mulu	PI_Modulo+2(a1),d1
	* adjust data pointer
	sub	d1,a0

	* vertical position in target 
	mulu	s_scopeDrawAreaModulo(a4),d0
	lsl.l	#3,d0
	add.l	d0,a6
	bra.b	.ok2
.ok
	move	s_quadNoteScrollerLinesHalf(a4),d0
	mulu	PI_Modulo+2(a1),d0
	sub	d0,a0
	sub	s_quadNoteScrollerLinesHalf(a4),d6
.ok2
	bsr	noteScrollerGetFont * uses d4,a2
	beq	.exitNoteScroller
	
	
* d4 = font modulo
* d6 = line number
* d7 = rows to draw
* d7 = screen modulo, other half
* a0 = pattern data
* a1 = pattern info
* a2 = font data
* a4 = destination draw buffer

	swap	d7
	move	s_scopeDrawAreaModulo(a4),d7
	move	d7,d0 
	lsl	#3,d0 	* x8, full height of font
	swap	d7

	* destination draw buffer	
	move.l	a6,a4

***********************************************************
* Line numbers column
***********************************************************

	lea	.pos(pc),a3
	tst.b	(a3)
	bmi.b	.skipNumbers

	pushm	d6/d7/a4/a5
	* row modulo in d0
	
	* row number in D2 as BCD
	moveq	#0,d3
	move	d6,d3
	* Keep visual range at 0..99, larger won't fit
	cmp		#100,d3
	blo.b	.s
	sub		#100,d3 * TODO: what if still doesn't fit?
.s
	divu	#10,d3 
	lsl.b	#4,d3
	move	d3,d2
	swap	d3 
	or.b	d3,d2
	
.lineNumberRowLoop
	* get screen modulo
	swap	d7

	* print line number as BCD from D2 
	move	d2,d3	* $00XY
	lsl.w	#4,d3	* $0XY0
	lsr.b	#4,d3	* $0X0Y
	or.w	#$3030,d3
	move	d3,(a3)

	move.l	a4,a5
	moveq	#2-1,d3
	bsr	.print
	subq	#2,a3 	* restore a3

	* next vertical draw position, one font height down
	* row modulo is in d0
	add	d0,a4

	* clear X flag for ABCD
	sub.b	d3,d3
	* Next row in BCD
	moveq	#1,d3
	abcd.b	d3,d2
	
	* get loop counter
	swap	d7

	* next pattern line, check if at the end
	addq	#1,d6
	cmp	PI_Pattlength(a1),d6
	dbeq	d7,.lineNumberRowLoop

	popm	d6/d7/a4/a5
	* move "cursor" 3 chars to the right 
	addq	#3,a4

.skipNumbers

	* Select font for note data
	cmp	#SCOPE_SMALL_FONT_CHANNEL_LIMIT,PI_Voices(a1)
	bls.b	.normalFont
	move.l	minifontbase(a5),a2
	move	tf_Modulo(a2),d4		
	move.l	tf_CharData(a2),a2		
.normalFont
	
***********************************************************
* Note column
***********************************************************

.rowLoop
	* get screen modulo for .print and .printSmall routines
	swap	d7

	* save a1
	move.l	a1,d5

* ChipTracker, TME, Mugician2, TCBTracker, etc
* register usage: d0-d3, a1

	* Get note data at a0
	move.l	PI_Convert(a1),a3
	jsr	(a3)
	move.l	d5,a1

* d0 = period
* d1 = sample num
* d2 = command 
* d3 = command argument

	moveq	#0,d5
	lea	.note(pc),a3
	tst	d0
	beq.b	.emptyNote
	* Check magic flag: negative indicates note indices
	tst	PI_Speed(a1)	
	bmi.b	.notPeriod
	lea	periods(pc),a5
	lea	periodsEnd(pc),a6
.findPeriod
	cmp	(a5)+,d0
	beq.b	.found
	addq	#1,d5
	cmp.l	a6,a5
	bne.b	.findPeriod
* Unknown
	move.w  #'**',(a3)+
	move.b  #'*',(a3)+
	bra.b	.unknownNote

.notes	dc.b	"C-"
	dc.b	"C#"
	dc.b	"D-"
	dc.b	"D#"
	dc.b	"E-"
	dc.b	"F-"
	dc.b	"F#"
	dc.b	"G-"
	dc.b	"G#"
	dc.b	"A-"
	dc.b	"A#"
	dc.b	"B-"
 	even

* Use value as an index
.notPeriod
	move	d0,d5
	* indices start from 1
	subq	#1,d5
.found
	* print note
	* divide to get octave
	divu	#12,d5
	* convert octave into text
	moveq	#'0',d0
	* first octave shall be 1, not 0
	addq.b	#1,d5
	add.b	d5,d0
	* convert note into text
	swap 	d5
	add	d5,d5
	move.w	.notes(pc,d5),(a3)+
	* print octave
	move.b	d0,(a3)+
	bra.b	.wasNote

.emptyNote
	clr.w	(a3)+
	clr.b	(a3)+
.unknownNote
.wasNote

	* sample 00-ff
	move.b	d1,d0
	beq.b	.noSampleNum

	lsr.b	#4,d0
	bsr.b	.convertD0ToCharInA3
	moveq	#$f,d0
	and.b	d1,d0
	bsr.b	.convertD0ToCharInA3Fill
	bra.b	.wasSampleNum

.noSampleNum
	clr.b	(a3)+
	clr.b	(a3)+

.wasSampleNum

	* Command 0-Z
	move.b	d2,d0
	bsr.b	.convertD0ToCharInA3Fill

	* Param 00-ff
	move.b	d3,d0
	lsr.b	#4,d0
	bsr.b	.convertD0ToCharInA3Fill
	moveq	#$f,d0
	and.b	d3,d0
	bsr.b	.convertD0ToCharInA3Fill

	; to the start of .note
	;lea	.note(pc),a3
	subq	#8,a3

	* print a3 into a4
	move.l	a4,a5
	moveq	#8-1,d3
	
	cmp	#SCOPE_SMALL_FONT_CHANNEL_LIMIT,PI_Voices(a1)
	bls.b	.printNorm
	bsr.b	.printSmall
	bra.b	.wasSmall
.printNorm
	bsr.b	.print
.wasSmall
	* next vertical draw position, one font height down
	move	d7,d3
	lsl	#3,d3	* times 8
	add	d3,a4

	* get loop counter
	swap	d7

	* Next row in data
	add.l	PI_Modulo(a1),a0
	* Row counter
	addq	#1,d6
	cmp	PI_Pattlength(a1),d6
	dbeq	d7,.rowLoop

.exitNoteScroller
	rts

.convertD0ToCharInA3
	beq.b	.emptyChar
.convertD0ToCharInA3Fill
	cmp.b	#9,d0
	bhi.b	.high1
	or.b	#'0',d0
	move.b	d0,(a3)+
	rts
.high1	
	add.b	#-10+'A',d0
	move.b	d0,(a3)+
	rts
.emptyChar 
	clr.b	(a3)+
	rts

* Large font print
* in:
*   a5 = dest draw buffer
*   a3 = text to draw
*   a2 = contains font data
*   d4 = contains font modulo

.print:
	* get one char to print
	moveq	#0,d5
	move.l	a5,d1
.charLoop	
	move.b	(a3)+,d5
	beq.b	.space
	* get char pixels
	lea	-$20(a2,d5),a6
	* do 8 pixels height
 rept 7
 	move.b	(a6),(a5)	
	add	d4,a6
	add	d7,a5
 endr
	move.b	(a6),(a5)	
.space
	* next horiz position in screen buffer
	addq.l	#1,d1
	move.l	d1,a5
	
	* go to next horiz position
	dbf	d3,.charLoop
	rts

* Print text with small font
* Assumes:
* - fixed font
* - width 4
* - height 8
* - even number of chars as input text
* - d7 = screen modulo

.printSmall	

	* nibble mask
	move	#$f0,d2

	* dest buffer pointer
	move.l	a5,d1

	* get one char to print here
	moveq	#0,d5
.charLoop2	
	* even position

	move.b	(a3)+,d5
	beq	.evenCharSkip * space check

	* get char pixels
	* check which source nibble to use
	* index should be halved since 4 pixels per char
	ror.l	#1,d5
	lea	-$10(a2,d5),a6	* space char $20/2
	bmi.b	.lowNib

 rept 7
 	move.b	(a6),d0 
	and.b	d2,d0 
 	or.b	d0,(a5)	
	add	d4,a6
	add	d7,a5
 endr
	move.b	(a6),d0 
	and.b	d2,d0 
 	or.b	d0,(a5)	

	bra.b	.evenCharDone

.lowNib

 rept 7
 	move.b	(a6),d0 
	lsl.b	#4,d0 
 	or.b	d0,(a5)	
	add	d4,a6
	add	d7,a5
 endr
	move.b	(a6),d0 
	lsl.b	#4,d0 
 	or.b	d0,(a5)	
* odd char done	


.evenCharDone
	move.l	d1,a5
.evenCharSkip

	* odd position

	move.b	(a3)+,d5
	beq	.oddCharDone	* space check

	* get char pixels
	ror.l	#1,d5
	lea	-$10(a2,d5),a6
	bmi.b	.lowNib2
 
  rept 7
 	move.b	(a6),d0 
	lsr.b	#4,d0
	or.b	d0,(a5)	
	add	d4,a6
	add	d7,a5
 endr
	move.b	(a6),d0 
	lsr.b	#4,d0
 	or.b	d0,(a5)	

	bra.b	.oddCharDone
.lowNib2
 rept 7
	moveq	#$f,d0
 	and.b	(a6),d0 
 	or.b	d0,(a5)	
	add	d4,a6
	add	d7,a5
 endr
	moveq	#$f,d0
 	and.b	(a6),d0 
 	or.b	d0,(a5)	
* odd char done	

.oddCharDone
	* go to next horiz position 
	addq.l	#1,d1
	move.l	d1,a5
	
	* next two input chars
	subq	#1,d3
	dbf	d3,.charLoop2
	rts

.note	dc.b	"00000000"
.pos	dc.b	"00"
 even


; End of scopes for now

********************************************************************************
*** SECTION ********************************************************************
*
* Module loading
*
********************************************************************************

*******
* Module loading
* Moduulin lataus
*
* in:
*  a0 = module file name with path 
*  a3 = list node 
*  d0 = ~0: Use double buffering
*
loadmodule:
 if DEBUG
    push    d0
    pushpea l_filename(a3),d0
    DPRINT  "loadmodule %s"
    pop     d0
 endif
	; Popup should close so that window is visible during load
	bsr	closeTooltipPopup
    st	loading(a5)
	* Store pointer to the name part. Used
	* do determine what to show in the infobox, and
	* also with the PS3M configuration file.
	move.l	l_nameaddr(a3),solename(a5)
	move.b	l_remote(a3),lastLoadedModuleWasRemote(a5)

	* Check if a remote file
    tst.b   l_remote(a3)
	beq		.doLoadModule

    * This is a remote file.
    * Open up a stream.
    lea     l_filename(a3),a0
    push    d0
    push    a0
    bsr     inforivit_connecting
    pop     a0
    jsr     startNewStreaming
    DPRINT  "startStreaming=%ld"
    move.l  d0,d1
    pop     d0
    tst.l   d1
    bne     .streamOk
    DPRINT  "startStreaming failed, clean up"
    jsr     stopStreaming
    jsr     showStreamerError

    jsr     awaitStreamerAndFlush
    lea     .msg(pc),a1
    jsr     request
	jsr	    inforivit_clear
    moveq   #lod_remoteError,d0
    rts
.msg
    dc.b    "Error downloading data!",0
    even

.streamOk

    * Bypass the rest of the file loading, to be
    * continued in sampleplayer PIPE read mechanism later.
    pushm   d0/a0
    * mpeg stream?
    jsr     streamIsMpegAudio
    tst.l   d0
    popm    d0/a0
    bne     .doLoadModule

	move.b	d0,d6	* doublebuffering flag
	moveq	#lod_remoteError,d7	* status: fail

	lea	-200(sp),sp	* space for output path
	move.l	sp,a1
	lea	l_filename(a3),a0	
	jsr	fetchRemoteFile
 if DEBUG
    move.l  sp,d1
	DPRINT	"fetchRemoteFile=%ld %s"
 endif
	tst.l	d0
	bne		.ok1
	move.l	d7,d0
	bsr		loaderr
	bsr	inforivit_clear
	bra		.skip
.ok1
	
	* TFMX special case!
	* See if smpl can be loaded, store the output 
	* path here.
	lea		100(sp),a1
	bsr		.loadTFMXsamples
	tst.l	d0
	bne.b	.ok2
	move.l	d7,d0
	bsr		loaderr
	bsr	inforivit_clear
	bra		.skip2
.ok2
	
	* Then do ordinary load, this will also pick 
	* the TFMX smpl file in the temp dir.
	move.l	sp,a0	* path to load from
	move.b	d6,d0   * double buffering fla
    push    a3
	bsr		.doLoadModule
	move.l	d0,d7	* save status
    pop     a3
    * loadmodule will store the temp filepath address in stack into modulefilename(a5),
    * put the actual path there, it's needed in module info for example.
    pushpea l_filename(a3),modulefilename(a5)
.skip2
	* Delete TFMX smpl temp file if it is there
	lea		100(sp),a0
	tst.b	(a0)
	beq.b	.skip
	move.l	a0,d1
	lore	Dos,DeleteFile 
.skip
	move.l	sp,d1
	lore	Dos,DeleteFile * delete tempfile
	lea	200(sp),sp
	move.l	d7,d0	* status here
	rts

* TFMX special case!
* Look for mdat in the url.
* Convert url from mdat->smpl and fetch, restore url.
.loadTFMXsamples
	* null output string to start with
	clr.b	(a1)	
	lea		l_filename(a3),a2	
.1	move.b	(a2)+,d0
	beq.b	.no
	cmp.l	#"mdat",d0
	beq.b	.yes
	rol.l	#8,d0
	bra.b	.1
.no	rts

.yes
	subq	#4,a2
	move.b	#"s",(a2)
	move.b	#"m",1(a2)
	move.b	#"p",2(a2)
	move.b	#"l",3(a2)
	lea		l_filename(a3),a0
	jsr		fetchRemoteFile
	move.b	#"m",(a2)
	move.b	#"d",1(a2)
	move.b	#"a",2(a2)
	move.b	#"t",3(a2)
	rts


* in:
*   a0 = path to load from
*   d0 = double buffering flag
.doLoadModule
	move.b	d0,d7
	beq	.nodbf

*****************************************************************
* Double buffer load
*****************************************************************
  if DEBUG
    push    d0
    move.l  a0,d0
	DPRINT	"Double buffer load: %s"
    pop     d0
  endif

	* Load with double buffering.
	* Module being played is preserved while new one is loaded.

	* Tampering with module data here
	jsr	obtainModuleData

	move.l	a0,modulefilename(a5)

	* Store properties of current module
	lea	-40(sp),sp
	lea	(sp),a2
	move.l	modulelength(a5),(a2)+
	move.l	tfmxsamplesaddr(a5),(a2)+
	move.l	tfmxsampleslen(a5),(a2)+
	move.b	lod_tfmx(a5),(a2)

	* Reset the extra data properties
	* loadfile() sets for TFMX. For other files
	* they are untouched. freemodule() will free
	* these, setting to zero avoids double freemem
	* crash.
	clr.l	tfmxsamplesaddr(a5) 
	clr.l	tfmxsampleslen(a5)

;	move.l	modulefilename(a5),a0
	move.l	#MEMF_CHIP!MEMF_CLEAR,d0
	lea	moduleaddress2(a5),a1
	lea	modulelength(a5),a2
	moveq	#0,d1			* kommentti talteen
	bsr	loadfile
	move.l	d0,d7			* store loadfile status

	clr.b	loading(a5)		* lataus loppu

	clr	songnumber(a5)
	clr	pos_maksimi(a5)
	clr	pos_nykyinen(a5)

	* Store properties of the module that was just loaded
	lea	20(sp),a2
	move.l	modulelength(a5),(a2)+
	move.l	tfmxsamplesaddr(a5),(a2)+
	move.l	tfmxsampleslen(a5),(a2)+
	move.b	lod_tfmx(a5),(a2)

	* Restore properties of current module
	lea	(sp),a2
	move.l	(a2)+,modulelength(a5)
	move.l	(a2)+,tfmxsamplesaddr(a5)
	move.l	(a2)+,tfmxsampleslen(a5)
	move.b	(a2),lod_tfmx(a5)

	push	d7

	jsr	releaseModuleData

	* At this point correct properties
	* for current module should be in place
	* for freeing to NOT CRASH.


	jsr	fadevolumedown
	move	d0,-(sp)
	DPRINT	"Replay end"
	;lore    Exec,Disable
	jsr	halt			* Vapautetaan se jos on
	;lore    Exec,Enable
	;;;move.l	modulefilename(a5),a0
	move.l	playerbase(a5),a0
	jsr	p_end(a0)

	;;;move.l	modulefilename(a5),a0
	jsr	freemodule	
	move	(sp)+,mainvolume(a5)

	pop	d7

	jsr	obtainModuleData

	* Finally store properties of the newly loaded module.
	lea	20(sp),a2
;	move.l	(a2)+,moduleaddress(a5)
	move.l	moduleaddress2(a5),moduleaddress(a5)
	move.l	(a2)+,modulelength(a5)
	move.l	(a2)+,tfmxsamplesaddr(a5)
	move.l	(a2)+,tfmxsampleslen(a5)
	move.b	(a2),lod_tfmx(a5)

	tst.l	d7
	beq.b	.nay
* errori? putsataan tfmx osotteet
	clr.l	tfmxsamplesaddr(a5)
	clr.l	tfmxsampleslen(a5)
.nay

	lea	40(sp),sp

	jsr	releaseModuleData

	cmp	#XPKERR_NOMEM,lod_xpkerror(a5)
	beq.b	.nomemdbf
	cmp	#XPKERR_SMALLBUF,lod_xpkerror(a5)
	beq.b	.nomemdbf
	cmp	#lod_nomemory,d7	* tuliko out of memory?
	beq.b	.nomemdbf		* uusi yritys, kun edellinen modi
	cmp	#lod_nomemoryf,d7	* ei enaa oo muistissa
	beq.b	.nomemdbf

	move.l	d7,-(sp)
	bra.b	.diddbf

.nomemdbf
	move.l	modulefilename(a5),a0

.nodbf
*****************************************************************
** Normal loading
*****************************************************************
	
 ifne DEBUG
	move.l	a0,d0
	DPRINT	 "Loading: %s"
 endif

	jsr	freemodule		* Varmistetaan

	clr	songnumber(a5)
	clr	pos_maksimi(a5)
	clr	pos_nykyinen(a5)
	move.l	a0,modulefilename(a5)

;	move.l	modulefilename(a5),a0
	move.l	#MEMF_CHIP!MEMF_CLEAR,d0
	lea	moduleaddress(a5),a1
	lea	modulelength(a5),a2
	moveq	#0,d1			* kommentti talteen
	bsr	loadfile
	move.l	d0,-(sp)		* NULL or lod_??? code
	clr.b	loading(a5)		* lataus loppu

	clr.b	songover(a5)	* varmistuksia, hˆlmˆo


.diddbf	bsr	inforivit_clear
	jsr	reslider

	move.l	(sp)+,d0
	tst	d0
	bne	.err			* virhe lataamisessa

	* These two case have been identifier earlier during load phase
	tst.b	sampleinit(a5)
	bne 	.nip

    move.l	modulefilename(a5),a0
    jsr     getFileExtension4
    cmp.l   #".m3u",d0
    seq     d0
    beq     .nipa

	move.l	moduleaddress(a5),a0	* Oliko moduleprogram??
	cmp.l	#"HiPP",(a0)
	bne 	.nip
	cmp	    #"rg",4(a0)
    bne     .nip
;	beq 	.nipa

;.nipz
;	cmp.l	#"HIPP",(a0)
;	bne 	.nip
;	cmp	#"RO",4(a0)
;	bne 	.nip

.nipa
    DPRINT  "module program detected"
    move.b  d0,-(sp)

;       lea     -150(sp),sp
;       move.l  sp,a3
;       move.l  modulefilename(a5),a0
;.cop   move.b  (a0)+,(a3)+
;       bne.b   .cop
;
;       jsr     freemodule
;       jsr     clearlist       * lista tyhj<E4>ks
;
;      move.l  sp,a0                   * ohjelman nimi
;      moveq   #-1,d4                  * lippu
;      jsr     loadprog                * ladataan moduuliohjelma
;      lea     150+4(sp),sp
;
;    rts

    * The list data is already loaded, use it
    bsr     engageNormalMode
    jsr     freelist

    jsr     obtainModuleList
    lea	    moduleListHeader(a5),a2
    move.l  moduleaddress(a5),a3
    move.l  a3,a4
    add.l   modulelength(a5),a4
    ; ---------------------------------
    tst.b   (sp)+
    beq     .norml
    jsr     importModuleProgramM3u
    bra     .m3uz
    ; ---------------------------------
.norml
    jsr     importModuleProgramFromData
.m3uz
    move.l	d0,modamount(a5)
    DPRINT  "modamount=%ld"
	move.l	#PLAYING_MODULE_NONE,playingmodule(a5)
	clr.l	chosenmodule(a5)
    jsr     listChanged
    tst.b   autosort(a5)
    beq     .noSort
    jsr     sortButtonAction
    bra     .sorted
.noSort
	jsr	    forceRefreshList
.sorted
	jsr		releaseModuleList

    * Return error here so that the playback process is stopped.
    * The list gets invalidated and any node that is to be played
    * will also be.

    * Send an event to start the playback later with the new
    * list contents. Fake the "play" key event.

    * rawkey $44 = play
    * rawkey $2b = play random
    move    #$44,rawkeyinput(a5)
    cmp.b   #pm_random,playmode(a5)
    bne     .noRnd
    move    #$2b,rawkeyinput(a5)
.noRnd
	move.b	rawKeySignal(a5),d1
	bsr 	signalit

    moveq   #-1,d0   * status: failed
    rts




.nip
	bsr	tutki_moduuli
	tst.l	d0
	bne.b	.unk_err		* ep‰m‰‰r‰inen tiedosto

    push    d0
    jsr     readUsl
    jsr     readUme
    pop     d0

	clr.b	contonerr_laskuri(a5)	* nollataan virhelaskuri
	rts	

**** Virhe, ja pit‰isi ladata toinen moduuli.
.iik
	cmp.l	#1,modamount(a5)
	beq.b	loaderr

	addq.b	#1,contonerr_laskuri(a5) 	* jos sattuu viisi per‰kk‰ist‰ 
	cmp.b	#5,contonerr_laskuri(a5) 	* virhett‰, keskeytet‰‰n
	bne.b	.iik2				* contonerror-toiminto
	clr.b	contonerr_laskuri(a5)
	bra.b	loaderr
.iik2
    DPRINT  "Continue on error activated"
	bsr	inforivit_errc		* Skipping -teksti   
    
	moveq	#50,d1
	lore	Dos,Delay
    
	move.l	#PLAYING_MODULE_NONE,playingmodule(a5)

    * Fake "Next" keyboard event
    move    #$28,rawkeyinput(a5)
	move.b	rawKeySignal(a5),d1
	bsr 	signalit

    moveq   #-1,d0 * status: load error
    rts

; Historical piece of code preserved, which started crashing recently:
;	moveq	#1,d7			* seuraava piisi!
;   jsr	soitamodi
;	addq	#4,sp			* ei samaan paluuosoitteeseen!
;	rts


.unk_err
	move.l	d0,-(sp)
	jsr	freemodule
	move.l	(sp)+,d0

.err	
	tst.b	contonerr(a5)		* Continue on error?
	bne.b	.iik
loaderr:
    DPRINT  "load error"
	cmp	#lod_xpkerr,d0
	beq	xpkvirhe
	cmp	#lod_xfderr,d0
	beq	xfdvirhe
	cmp	#lod_tuntematon,d0
	beq	tuntematonvirhe

	move	d0,d1
	neg	d1
	add	d1,d1
	lea	.ertab2-2(pc,d1),a1
	add	(a1),a1
	bra	request			* requesteri

* Table to map lod_??? error codes
.ertab2	dr	openerror_t
	dr	readerror_t
	dr	memerror_t
	dr	cryptederror_t
	dr	error_t
	dr	unknownpperror_t
	dr	grouperror_t
	dr	noxpkerror_t
	dr	nopperror_t
	dr	error_t		* xpk errori muualla
	dr	unknown_t
	dr	nofast_t
	dr	execerr_t
	dr	lockerr_t
	dr	notafile_t
	dr	openerror_t
	dr	error_t
	dr	extract_t
	dr  readerror_t  * loadseg failure 
	dr	remoteerror_t 

cryptederror_t
;	dc.b	"File is encrypted!",0
unknownpperror_t
;	dc.b	"Unknown PowerPacker format!",0

error_t
	dc.b	"Error!?",0
openerror_t
	dc.b	"Error opening file!",0
readerror_t
	dc.b	"Read error!",0
noxpkerror_t
	dc.b	"No xpkmaster.library!",0
nopperror_t
	dc.b	"No powerpacker.library!",0
unknown_t
	dc.b	"Unknown file format!",0
unknownDueToAhi_t
	dc.b	"Unknown file format!",10
	dc.b	"This may be because non-AHI",10
	dc.b	"replayers are disabled.",0
unknownDueToGroupDisabled_t
	dc.b	"Unknown file format!",10
	dc.b	"This may be because the",10
	dc.b	"player group is disabled.",0
nofast_t
memerror_t	
	dc.b	"Not enough memory!",0
;nofast_t dc.b	"Not enough fast memory!",0
execerr_t dc.b	"External error!",0
lockerr_t dc.b	"Can't lock on file!",0
notafile_t dc.b	"Not a file!",0
grouperror_t dc.b "Trouble with the player group!",10
		dc.b "Check that the file "
		dc.b '"HippoPlayer.group"'
		dc.b " is up-to-date.",0

windowerr_t	dc.b	"Couldn't to open window!",0
;extract_t	dc.b	"Extraction error!",0
extract_t	dc.b	"Extraction error!",10
		dc.b	"No known files found in archive.",0
remoteerror_t
	dc.b	"Error downloading file!",0
 even	



xpkvirhe			* N‰ytet‰‰n XPK:n oma virheilmoitus.
	movem.l	d0-a6,-(sp)
	lea	.x(pc),a1
	lea	xarray(pc),a4
	pushpea	xpkerror(a5),(a4)
	bra	request2

.x	dc.b	"XPK error:",10
	dc.b	"%s",0
 even

xarray	dc.l	0

xfdvirhe			* N‰ytet‰‰n XFD:n oma virheilmoitus.
	movem.l	d0-a6,-(sp)
	move	lod_xfderror(a5),d0
	lore	XFD,xfdGetErrorText
	lea	.x(pc),a1
	lea	xarray(pc),a4
	move.l	d0,(a4)
	bra	request2

.x	dc.b	"XFD error:",10
	dc.b	"%s",0
 even


** Moduuli oli tuntematon!
* Poistetaanko listasta??

tuntematonvirhe
	movem.l	d0-a6,-(sp)
	lea	unknown_t(pc),a1
	tst.b ahi_muutpois(a5)
	beq.b	.noAhiSkip
	lea	unknownDueToAhi_t(pc),a1
.noAhiSkip
	cmp.b	#GROUPMODE_DISABLE,groupmode(a5)
	bne.b	.groupSkip
	lea	unknownDueToGroupDisabled_t(pc),a1
.groupSkip
    tst.b   moduleWasRSID(a5)
    beq     .1
    lea     .rsid_msg(pc),a1
.1
	lea	.g(pc),a2
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	bne.b	.noBr	
	lea	.onlyOk(pc),a2
	bsr	rawrequest
	bra.b	.w
.noBr
	bsr	rawrequest
	tst.l	d0
	beq.b	.w	
	bsr	delete
.w	movem.l	(sp)+,d0-a6
	rts

.g	dc.b	"_Delete from list|_OK",0
.onlyOk = *-4
.rsid_msg
    dc.b	"RSID format not supported!",0
 even

*******************************************************************************
* Ladataan tiedosto, jos pakattu - FImp, XPK, PP, LhA, Zip, LZX - puretaan
****
* a0 <= nimi
* d0 <= muistin tyyppi
* a1 <= mihin pistet‰‰n alkuosoite
* a2 <= mihin pistet‰‰n pituus
* d0 => 0 tai virhe

* Virheet (d0:ssa):
lod_openerr	=	-1
lod_readerr	=	-2
lod_nomemory	=	-3
lod_crypted	=	-4	; ( vain PP )
lod_unknownpp	=	-6	; ( vain PP )
lod_grouperror	=	-7
lod_noxpk	=	-8
lod_nopp	=	-9
lod_xpkerr	=	-10
lod_tuntematon	=	-11
lod_nomemoryf	=	-12
lod_execerr	=	-13
lod_lockerr	=	-14
lod_notafile	=	-15
lod_openerr2	=	-16
lod_xfderr	=	-17
lod_extract	=	-18
lod_loadsegfail = -19
lod_remoteError		= -20


* Load file variant 
* - Skips XPK identification
* - Loads remote files if url detected
* Used to load StarTrekker data file.
* Used by deliplayers to load data files.
loadfileStraight:
	cmp.b	#'h',(a0)
	bne		.local
	cmp.b	#'t',1(a0)
	bne		.local
	cmp.b	#'t',2(a0)
	bne		.local
	cmp.b	#'p',3(a0)
	bne		.local
	cmp.b	#':',4(a0)
	bne		.local
    DPRINT  "loadfileStraight REMOTE"

	pushm	d1-a6
	lea		-100(sp),sp
	moveq	#0,d7	* status ok

	move.l	sp,d1
	pushm	d0/a1
	move.l	d1,a1	* space for target file path
	jsr		fetchRemoteFile
	moveq	#0,d7 * status: ok
	tst.l	d0
	bne.b	.fetchOk
    DPRINT  "lod_remoteError %ld"
	moveq	#lod_remoteError,d7 * status: fail
.fetchOk
	popm	d0/a1

	tst.l	d7
	bne.b	.remoteErr

	move.l	sp,a0
	* a0 is now the downloaded file path, 
	* parameters unchanged
	bsr.b	.local

.remoteErr
	move.l	d0,d7	* save status
	move.l	sp,d1
	lore	Dos,DeleteFile

	move.l	d7,d0	* restore status
	lea		100(sp),sp
	popm	d1-a6
    DPRINT  "loadfileStraight status=%ld"
	rts

.local
    DPRINT  "loadfileStraight LOCAL"

	push	d7
	move.b	xpkid(a5),d7
	* DISABLE:
	st	xpkid(a5)
	push	d7
	bsr.b	loadfile
	pop	d7
	move.b	d7,xpkid(a5)
	pop	d7
	rts

* Ordinary load file
loadfile:
	movem.l	d1-a6,-(sp)
    DPRINT  "loadfile"

	jsr	setMainWindowWaitPointer

	lea	lod_a(a5),a3
	lea	lod_b(a5),a4
.clr	clr	(a3)+
	cmp.l	a4,a3
	bne.b	.clr

	move.l	d0,lod_memtype(a5)	
	move.b	d1,lod_kommentti(a5)
	move.l	a0,lod_filename(a5)
	move.l	a1,lod_start(a5)
	move.l	a2,lod_len(a5)
	clr.l	(a1)
	clr.l	(a2)

	move.l	lod_filename(a5),a0	* tutkitaan nimen liite
	move.l	a0,a2
.fe	tst.b	(a0)+
	bne.b	.fe
	subq	#1,a0

*********************************************************************
** Archiven purku

	move.b	-(a0),d0
	ror.l	#8,d0
	move.b	-(a0),d0
	ror.l	#8,d0
	move.b	-(a0),d0
	ror.l	#8,d0
	move.b	-(a0),d0

	move.l	d0,d1
	* upper case conversion for easy matching
	and.l	#$dfdfdfff,d1
	cmp.l	#'LHA.',d1
	beq.b	.lha
	cmp.l	#'LZH.',d1
	beq.b	.lha
	cmp.l	#'LZX.',d1
	beq.b	.lzx
	cmp.l	#'ZIP.',d1
	beq.b	.zip
	cmp.l	#'VGZ.',d1 * gzipped VGM file
	beq.b	.vgz
	* gzip test
	* ".gzX"
	and.l	#$ffdfdf00,d0
	cmp.l	#'.GZ'<<8,d0
	bne	.nope
.vgz
	lea	gzipDecompressCommand,a0
	moveq	#1,d6	* "Unzipping" message
	bra.b	.unp

.lha	lea	arclha(a5),a0
	moveq	#0,d6
	bra.b	.unp
.zip	lea	arczip(a5),a0
	moveq	#1,d6
	bra.b	.unp
.lzx	lea	arclzx(a5),a0
	moveq	#2,d6

.unp	
    DPRINT  "Extracting archive!"

	pushm	all
	* takes type in d6
	bsr	inforivit_extracting
	bsr	remarctemp	* varmuuden vuoksi poistetan tempdirri jos on
	popm	all

	* lod_buf will contain the command line to Execute
	* unarchive into current dir, which will be a temp dir created here

	move.l	lod_filename(a5),d0
	lea	lod_buf(a5),a3
	jsr	desmsg3

	st	lod_archive(a5)		* lippu!!

* SP = RAM:∞HiP∞

	lea	-160(sp),sp
	move.l	sp,a1
	lea	arcdir(a5),a0
	jsr	copyb
	subq	#1,a1
	cmp.b	#':',-1(a1)
	beq.b	.na
	move.b	#'/',(a1)+
.na	
	lea	tdir(pc),a0
	jsr	copyb

** vanha kick: kopioidaan parametrin per‰‰n RAM:∞HiP∞/
	tst.b	uusikick(a5)
	bne.b	.nu
	lea	lod_buf(a5),a1
.barf	tst.b	(a1)+
	bne.b	.barf
	subq	#1,a1
	move.b	#' ',(a1)+
	lea	(sp),a0
	jsr	copyb
	subq	#1,a1
	cmp.b	#':',-1(a1)
	beq.b	.na0
	move.b	#'/',(a1)+
.na0	clr.b	(a1)

.nu

	move.l	sp,a4

	moveq	#0,d6
	moveq	#0,d5

*** Luodaan dirri
 if DEBUG
    move.l  a4,d0
    DPRINT  "Creating %ls"
 endif

	move.l	a4,d1
	lore	Dos,CreateDir
    DPRINT  "CreateDir=%lx"
	tst.l	d0
	beq.b	.onjo
	move.l	d0,d1
	lob	UnLock


.onjo
*** Lockki dirriin
	move.l	a4,d1
	moveq	#ACCESS_READ,d2
	lob	Lock
    DPRINT  "Lock=%lx"

	move.l	d0,d7
	beq	.x

*** CD dirriin

 if DEBUG
    push    d0
    move.l  d0,d1
    lea     -100(sp),sp
    move.l  sp,d2
    moveq   #99,d3
    jsr     getNameFromLock
    move.l  sp,d0
    DPRINT  "Changing dir1=%s"
    lea     100(sp),sp
    pop     d0
 endif

	move.l	d7,d1
	lob	CurrentDir
    * d6 = previous current dir
	move.l	d0,d6

*** Ajetaan kamat

	pushpea	lod_buf(a5),d1
 if DEBUG
    move.l  d1,d0
    DPRINT  "cmd=%s"
 endif
	moveq	#0,d2			* input
	move.l	nilfile(a5),d3		* output
	lob	Execute
    DPRINT  "Execute=%lx"

 if DEBUG
    move.l  d7,d1
    lea     -100(sp),sp
    move.l  sp,d2
    moveq   #99,d3
    jsr     getNameFromLock
    move.l  sp,d0
    DPRINT  "Changing dir2=%s"
    lea     100(sp),sp
 endif

*** Skannataan dirrin filÈt

	move.l	d7,d1
	pushpea	fileinfoblock(a5),d2
	lob	Examine
    DPRINT  "Examine=%lx"
	tst.l	d0
	beq	 .x

 if DEBUG
	pushpea	fib_FileName+fileinfoblock(a5),d0
	DPRINT  "Scanning: %s"
 endif
	
.loop	
	move.l	d7,d1
	lob	ExNext
    DPRINT  "ExNext=%lx"
	tst.l	d0
	beq	.x

	pushm	all

 if DEBUG
	pushpea	fib_FileName+fileinfoblock(a5),d0
	DPRINT  "->%s"
 endif
	pushpea	fib_FileName+fileinfoblock(a5),d1
	move.l	#MODE_OLDFILE,d2
	lob	Open
    DPRINT  "Open=%lx"
	move.l	d0,d4
	beq	.bah

	move.l	d4,d1

	lea	probebuffer(a5),a0
	move.l	a0,d2

	move.l	#PROBE_BUFFER_LEN/4-1,d0	* tyhj‰ks
.clear	clr.l	(a0)+
	dbf	d0,.clear

	move.l	#PROBE_BUFFER_LEN,d3
	lob	Read
	move.l	d0,d7
	cmp.l	#100,d0
	bls	.nah

*** Tsekataan tyyppi‰

	lea	probebuffer(a5),a0

** Tutkaillaan moduulia tarkistusrutiineilla

	pushm	d4/a4
	move.l	a0,a4
	bsr	id_protracker
	beq	.on

    jsr     id_xmaplay
    beq     .on

	jsr	id_ps3m		
	tst.l	d0
	beq	.on

	bsr	id_tfmxunion
	beq	.on

	bsr	id_TFMX_PRO
	tst	d0
	beq	.on

	bsr	id_TFMX7V
	tst	d0
	beq.b	.on

	bsr	id_tfmx
	beq.b	.on

	DPRINT	"Internal"
	lea	internalFormats(pc),a3 
	bsr	identifyFormatsOnly 
	beq.b .on
	DPRINT	"Group"
	lea	groupFormats(pc),a3 
	bsr	identifyFormatsOnly 
	beq.b .on
	DPRINT	"Eagle"
	lea	eagleFormats,a3 
	bsr	identifyFormatsOnly 
	beq.b .on

 ifne FEATURE_P61A
	move.l	fileinfoblock+8(a5),d0	* Tied.nimen 4 ekaa kirjainta
	bsr	id_player2
	beq.b	.on
 endif

	cmp.l   #"XPKF",(a4)             * pakatut kelpaavat!
	beq.b   .on
	cmp.l   #"IMP!",(a4)
	beq.b   .on
	cmp.l   #"PP20",(a4)
	beq.b	.on

;	bsr	id_oldst		* oldst tunnistus viimeiseksi
;	beq.b	.on

	moveq	#-1,d0
	bra.b	.ei

.on	moveq	#0,d0
.ei	popm	d4/a4
	
	tst	d0
	bne.b	.nah

.joo

* juhuu! kopioidaan tied. nimi talteen

	lea	lod_buf(a5),a1
	move.l	a1,lod_filename(a5)
	move.l	a4,a0
	jsr	bcopy
	subq	#1,a1
	move.b	#'/',(a1)+
	lea	fib_FileName+fileinfoblock(a5),a0
	push	a0
	jsr	bcopy
	pop	a0		* tfmx?

	move.l	(a0),d0
	and.l	#$dfdfdfdf,d0
	cmp.l	#"MDAT",d0
	bne.b	.now
	st	lod_tfmx(a5)	* lippu: archive = tfmx
.now
	
	move.l	d4,d1
	lob	Close
	popm	all
	st	d5
	bra.b	.x
.nah
    DPRINT  "Rejected"
	move.l	d4,d1
	lob	Close
.bah
	popm	all
	bra	.loop

.x

 if DEBUG
    move.l  d6,d1
    lea     -100(sp),sp
    move.l  sp,d2
    moveq   #99,d3
    jsr     getNameFromLock
    move.l  sp,d0
    DPRINT  "Changing dir3=%s"
    lea     100(sp),sp
 endif

    ; Back to old currentdir
	move.l	d6,d1
	lob	CurrentDir
    DPRINT  "CurrentDir=%lx"

	move.l	d7,d1
	beq.b	.xx
	lob	UnLock
.xx

	lea	160(sp),sp
    DPRINT  "Archive phase finished!"

	tst	d5
	bne.b	.nope

    DPRINT  "Nothing found"
* oliko sopivaa file‰?
	move	#lod_extract,lod_error(a5)
	bra	.exit

*********************************************************************

.nope
	* Ordinary file load below, archive extraction above.

    * mp3 shortcut check to allow remote mp3 files to 
    * bypass filesystem operations and allow remote mp3 files. 
    * This loses local file comments too but that's not too bad.
;     move.l  lod_filename(a5),a0
;     bsr     id_mp3filename
;     tst.l   d0
;     beq     .sampleCheck


    * Bypass the rest of the file loading, to be
    * continued in sampleplayer PIPE read mechanism later.
    jsr     streamIsAlive
    beq     .notRemote
    jsr     streamIsMpegAudio
    bne     .sampleCheck
.notRemote

    * Get info on the file
     
	move.l	_DosBase(a5),a6
	move.l	lod_filename(a5),d1
	moveq	#ACCESS_READ,d2
	lob	Lock			
	move.l	d0,d3
	beq	.open_error
	move.l	d0,d1
	lea	fileinfoblock(a5),a3
	move.l	a3,d2
	lob	Examine
	tst.l	d0 
	bne.b 	.exOk
	move.l	d3,d1
	lob	UnLock
	bra	.open_error
.exOk
	move.l	d3,d1
	lob	UnLock

	;tst.l	fib_DirEntryType(a3)	* onko tiedosto vai hakemisto?
	;bpl	.nofile_err
	cmp.l	#ST_FILE,fib_DirEntryType(a3)
	beq.b	.isFile
	cmp.l	#ST_LINKFILE,fib_DirEntryType(a3)
	bne	.nofile_err
.isFile

	move.l	124(a3),lod_length(a5)	* tiedoston pituus
	beq	.open_error		* jos 0 -> errori

	tst.b	lod_kommentti(a5)
	bne.b	.noc
	lea	fileinfoblock+144(a5),a0	* kopioidaan kommentti talteen
	lea	filecomment(a5),a1
	moveq	#80-1,d0
.cece	move.b	(a0)+,(a1)+
	dbeq	d0,.cece
	clr.b	(a1)
.noc

	* Read some bytes of data into the probebuffer

	DPRINT	"Probing"

	move.l	#1005,d2
	move.l	lod_filename(a5),d1
	lob	Open
	move.l	d0,lod_filehandle(a5)
	beq	.open_error

	lea	probebuffer(a5),a0
	move.w	#PROBE_BUFFER_LEN/4-1,d0
.clrProbe
	clr.l	(a0)+
	dbf	d0,.clrProbe

	* Here the full buffer is not used for some reason.
	* Probably for optimization.
	
	move.l	lod_filehandle(a5),d1
	lea	probebuffer(a5),a0
	move.l	a0,d2
	move.l	#1084,d3
	lob	Read
	DPRINT	"Probe read: %ld"
;	cmp.l	#1084,d0
;	bne	.read_error

* Check if this is an archive file
*** onko lha, lzx, zip?

	cmp	#'PK',probebuffer(a5)
	bne.b	.nozip
	cmp.b	#$20,2+probebuffer(a5)
	bhs.b	.nozip
	cmp.b	#$20,3+probebuffer(a5)
	bhs.b	.nozip

	bsr	.closeit
	clr.l	lod_filehandle(a5)
	bra	.zip
.nozip

	cmp.l	#"LZX"<<8,probebuffer(a5)
	bne.b	.nolzx

	bsr	.closeit
	clr.l	lod_filehandle(a5)
	bra	.lzx
.nolzx

	cmp	#'-l',2+probebuffer(a5)
	bne.b	.nolha
	move.l	4+probebuffer(a5),d0
* d0 = "h5-v"
	and.l	#$ff00ff00,d0
	cmp.l	#$68002d00,d0
	bne.b	.nolha

	bsr	.closeit
	clr.l	lod_filehandle(a5)
	bra	.lha

.nolha

** Is this a sample file, stop loading if so.
** Jos havaitaan file sampleks, ei ladata enemp‰‰
.sampleCheck
	lea	probebuffer(a5),a0
	clr.b	sampleinit(a5)
	bsr	.dosamplecheck
	bne.b	.nosa
    DPRINT  "sample detected"
	st	sampleinit(a5)
	bra	.exit

.nosa	clr.b	sampleformat(a5)

	* This checks whether the file should be loaded into FAST ram

	lea	probebuffer(a5),a0	* Kannattaako ladata fastiin??
	bsr	.checkm

	* XPK compressed file check
    clr.l   lod_xpkOutLen(a5)       * clear previous outlen initially
	cmp.l	#"XPKF",probebuffer(a5)
	bne	.wasnt_xpk

	bsr	get_xpk
	beq	.lib_error1

** file on xpk, katsotaan jos se on sample:
	lea	probebuffer+16(a5),a0
	clr.b	sampleinit(a5)
	bsr	.dosamplecheck
	bne.b	.nosa2
	st	sampleinit(a5)
	bra	.exit

.nosa2	clr.b	sampleformat(a5)


	st	lod_xpkfile(a5)	* lippu: xpk file

* Ladataan eka XPK-hunkki tiedostosta ja katsotaan voidaanko se
* ladata fastiin.

	tst.b	xpkid(a5)	* Oliko XPK id p‰‰ll‰?
	bne	.noid

	bsr	inforivit_xpkload2

	lea	.xpktags2(pc),a1
	move.l	lod_filename(a5),.in2-.xpktags2(a1)
	lea	.xfhpointerp(pc),a0
	lore	XPK,XpkOpen
 	tst.l	d0
	bne	.xpk_error

	move.l	.xfhpointerp(pc),a0	* Varataan ekalle hunkille muistia.
	move.l	xf_NLen(a0),d0
	move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
	jsr	getmem
	move.l	d0,d4
	bne.b	.ok

	move.l	.xfhpointerp(pc),a0
	lob	XpkClose
	bra	.nomem_error
.ok


	move.l	.xfhpointerp(pc),a0
	move.l	xf_NLen(a0),d0
	move.l	d4,a1
	lob	XpkRead
	tst.l	d0
	bpl.b	.oka

	push	d0
	move.l	.xfhpointerp(pc),a0
	lob	XpkClose
	move.l	d4,a0
	jsr	freemem
	pop	d0
	bra	.xpk_error
.oka

	move.l	.xfhpointerp(pc),a0
	lob	XpkClose

	move.l	lod_length(a5),-(sp)
	move.l	12+probebuffer(a5),lod_length(a5)	* unXPKed length

	move.l	d4,a0
	bsr	.checkm
	move.l	(sp)+,lod_length(a5)

	move.l	d4,a0
	jsr	freemem
	bra.b	.oo

.xpktags2
	dc.l	XPK_InName
.in2	dc.l	0

	dc.l	XPK_GetError
	dc.l	xpkerror+var_b	* virheilmoitus
	dc.l	TAG_END

.xfhpointerp dc.l	0


.oo
.noid

	bsr	.infor
	bsr	inforivit_xpkload

	tst.b	win(a5)
	beq.b	.eilo
	moveq	#81+WINX-1,plx1
	;move	#245+WINX+2,plx2
	move	WINSIZX(a5),plx2
	sub	#18,plx2
	;moveq	#21+WINY,ply1
	;moveq	#27+WINY,ply2
	move	infoBoxTopEdge(a5),ply1
	move	infoBoxHeight(a5),d7
	lsr		#1,d7
    add     d7,ply1
    move	infoBoxHeight(a5),d7
    lsr     #1,d7
    subq    #6,d7
    lsr     #1,d7
    add     d7,ply1   
    addq    #1,ply1
    
	move	ply1,ply2
	addq	#6,ply2     * height

	add	windowleft(a5),plx1
	add	windowleft(a5),plx2
	add	windowtop(a5),ply1
	add	windowtop(a5),ply2
	move.l	rastport(a5),a1
	jsr	laatikko2
.eilo

	lea	.xpktags(pc),a0
	lea	lod_address(a5),a1
	move.l	a1,.xpkaddr-.xpktags(a0)
	lea	lod_length(a5),a1
	move.l	a1,.xpklen1-.xpktags(a0)

	move.l	lod_filename(a5),.xpkfile-.xpktags(a0)
	move.l	lod_memtype(a5),.xpkmem-.xpktags(a0)
    pushpea lod_xpkOutLen(a5),.xpkoutlen-.xpktags(a0)
	move.l	_XPKBase(a5),a6
	lob	XpkUnpack
    DPRINT  "XpkUnpack=%ld"
	tst.l	d0
	bne	.xpk_error
	bra	.exit

.xpktags
		dc.l	XPK_InName
.xpkfile	dc.l	0

		dc.l	XPK_GetOutBuf
.xpkaddr	dc.l	0

		dc.l	XPK_GetOutBufLen
.xpklen1	dc.l	0

		dc.l	XPK_OutMemType
.xpkmem		dc.l	2		* muistin tyyppi

		dc.l	XPK_PassThru
		dc.l	1

		dc.l	XPK_GetError
		dc.l	xpkerror+var_b	* virheilmoitus

		dc.l	XPK_ChunkHook
		dc.l	.hook

        dc.l    XPK_GetOutLen   * exact size of decompressed data
.xpkoutlen
        dc.l    0

		dc.l	TAG_END



.hook	ds.b	MLN_SIZE
	dc.l	.hookroutine	* h_Entry
	dc.l	0		* h_SubEntry
	dc.l	0		* h_Data



** Printataan infoa ladattaessa xpk filett‰
.hookroutine
* a1 = progress report structure
	pushm	d1-d7/a0/a1/a5/a6
	lea	var_b,a5
	tst.b	win(a5)
	beq.b	.xxx

	moveq	#$7f,d4
	and.l	xp_Done(a1),d4
	cmp	#100,d4
	bls.b	.h0
	moveq	#100,d4
.h0

        move.l  rastport(a5),a0
        move.l  a0,a1

        move.b  rp_Mask(a0),d7
        move.b	#%11,rp_Mask(a0)

        moveq   #82+WINX,d0

		move	infoBoxTopEdge(a5),d1
		move	infoBoxHeight(a5),d2
		lsr		#1,d2
		add		d2,d1
		move	infoBoxHeight(a5),d2
        lsr     #1,d2
        subq    #6,d2
        lsr     #1,d2
        add     d2,d1
		addq	#2,d1
	
    ;    moveq   #22+WINY,d1
        add     windowleft(a5),d0
        add     windowtop(a5),d1

        move.l  d0,d2
        move.l  d1,d3
        ;mulu    #163,d4	
		move	WINSIZX(a5),d5
		sub	#101+2,d5
		mulu	d5,d4
        divu    #100,d4

        moveq   #5,d5
        move    #$f0,d6
        lore    GFX,ClipBlit

        move.l  rastport(a5),a0
        move.b  d7,rp_Mask(a0)

.xxx	popm	d1-d7/a0/a1/a5/a6
	moveq	#0,d0		* ei breakkia!	
	rts



.wasnt_xpk

	* Was not XPK compressed. Is it powerpacker compressed?

	cmp.l	#"PP20",probebuffer(a5)
	bne.b	.wasnt_pp

	bsr	infolines_loadToChipMemory
	bsr	inforivit_ppload

	bsr	get_pp
	beq	.lib_error2

	move.l	d0,a6
	move.l	lod_filename(a5),a0		* filename
	moveq	#4,d0		* col
	move.l	lod_memtype(a5),d1
	lea	lod_address(a5),a1
	lea	lod_length(a5),a2
	sub.l	a3,a3
	lob	ppLoadData
	tst.l	d0
	beq	.exit
	bra	.pp_error	
.wasnt_pp

	* FImp compressed file?

	cmp.l	#"IMP!",probebuffer(a5)
	bne.b	.wasnt_fimp

	bsr	infolines_loadToChipMemory
	bsr	inforivit_fimpload

	move.l	lod_length(a5),d4
	move.l	4+probebuffer(a5),lod_length(a5)

	bsr	.alloc
	move.l	d0,lod_address(a5)
	beq	.fimp_error

	bsr	.seekstart

	move.l	_DosBase(a5),a6
	move.l	lod_filehandle(a5),d1
	move.l	lod_address(a5),d2
	move.l	d4,d3
	lob	Read
	cmp.l	d4,d0
	bne	.fimp_error2

	bsr	inforivit_fimpdecr

	move.l	lod_address(a5),a0
	jsr	fimp_decr	
	bra	.exit

.wasnt_fimp

*	Next up, try loading with XFDMaster if it is enabled
********* Lataus XFDmaster.libill‰

	tst.b	xfd(a5)
	beq	.wasnt_xfd

	bsr	get_xfd
	beq	.wasnt_xfd

** Tavallinen lataus t‰ss‰ v‰liss‰

	bsr	.alloc
	move.l	d0,lod_address(a5)
	beq	.error

	bsr	.infor
	bsr	.seekstart

	move.l	lod_filehandle(a5),d1
	move.l	lod_address(a5),d2
	move.l	lod_length(a5),d3
	move.l	_DosBase(a5),a6
	lob	Read
	cmp.l	lod_length(a5),d0
	bne	.error2

    DPRINT  "Read=%ld"

	lore	XFD,xfdAllocBufferInfo	
	move.l	d0,a3	
	tst.l	d0
	beq	.exit		* Error: menee tavallisena filen‰

	move.l	lod_address(a5),xfdbi_SourceBuffer(a3)
	move.l	lod_length(a5),xfdbi_SourceBufLen(a3)
	move.l	a3,a0
	lob	xfdRecogBuffer
    DPRINT  "xfdRecogBuffer=%ld"
	tst.l	d0
	bne.b	.xok1		* Error: tavallisena filen‰

.xok0	
    move.l	a3,a1
	lob	xfdFreeBufferInfo
	bra	.exit
.xok1
	move.l	xfdbi_PackerName(a3),d0
    push    a6
	bsr	inforivit_xfd
    pop     a6

	move	xfdbi_PackerFlags(a3),d0
	and	#XFDPFF_PASSWORD!XFDPFF_RELOC!XFDPFF_ADDR,d0
	beq.b	.xok2		* Pakkerityyppi v‰‰r‰.. Ei kelpaa!
	move	#lod_tuntematon,lod_error(a5)
	bra 	.xok0
.xok2
	moveq	#MEMF_CHIP,d0
	move.l	d0,xfdbi_TargetBufMemType(a3)
	move.l	a3,a0
	lob	xfdDecrunchBuffer
    DPRINT  "xfdDecrunchBuffer=%ld"
	tst.l	d0
	bne.b	.xok3
	move	xfdbi_Error(a3),lod_xfderror(a5) * error numba talteen
	move	#lod_xfderr,lod_error(a5)
	bsr	.free			* Vapautetaan pakattu file
	bra 	.xok0
.xok3
	bsr	.free			* Vapautetaan pakattu file

	move.l	xfdbi_TargetBuffer(a3),lod_address(a5)	* Puretun tiedot
	move.l	xfdbi_TargetBufLen(a3),lod_length(a5)

	move.l	a3,a1
	lore	XFD,xfdFreeBufferInfo
** OK!
    DPRINT  "xfdDecrunch ok"
	bra	.exit


.wasnt_xfd

* Finally here we just do an ordinary read.
****** Ihan Tavallinen Lataus

 if DEBUG
	move.l	lod_length(a5),d0
	DPRINT	"Normal load %ld"
 endif

	bsr	.alloc
.itAlloc
	move.l	d0,lod_address(a5)
	beq	.error

	bsr	.infor

;	bsr	.seekstart

	* Make use of the already read data in probebuffer
	move.l	lod_filehandle(a5),d1		
	moveq	#0,d2
	moveq	#OFFSET_CURRENT,d3
	lore	Dos,Seek
	DPRINT	"File position %ld"
	cmp.l	#-1,d0
	beq	.error2

	move.l	lod_address(a5),a0

	move.l	d0,d1
	beq.b	.skipInitial

	lea	probebuffer(a5),a1
	subq	#1,d0
.copyInitial
	move.b	(a1)+,(a0)+
	dbf	d0,.copyInitial
.skipInitial

 ifeq floadpr
	move.l	lod_filehandle(a5),d1
	move.l	lod_address(a5),d2
	move.l	lod_length(a5),d3
	move.l	_DosBase(a5),a6
	lob	Read
	cmp.l	lod_length(a5),d0
	bne	.error2
 else

*** laatukko file load progress indicator blabh
	pushm	d1/a0
	tst.b	win(a5)
	beq.b	.eilox
	moveq	#15+WINX,plx1
	;move	#245+WINX,plx2
	move	WINSIZX(a5),plx2
	sub	#18,plx2
	move	infoBoxTopEdge(a5),ply1
	move	infoBoxHeight(a5),d7
	* vertically center
	lsr		#1,d7
	add		d7,ply1
	subq	#6,d7
	lsr		#1,d7
	add		d7,ply1	
	addq	#1,ply1

	;addq	#8,ply1
	move	ply1,ply2
	addq	#6,ply2		* 6 pix tall box
;;	moveq	#21+WINY,ply1
;	moveq	#27+WINY,ply2
	add	windowleft(a5),plx1
	add	windowleft(a5),plx2
	add	windowtop(a5),ply1
	add	windowtop(a5),ply2
	move.l	rastport(a5),a1
	jsr	laatikko3
.eilox	popm	d1/a0

	move.l	lod_length(a5),d4
	* subtract already read amount
	sub.l	d1,d4
	* where to load data, considering the already read amount
	move.l	a0,d5
	;move.l	lod_address(a5),d5


.loadloop
 ;if DEBUG
 ;	move.l	d4,d0
 ;	DPRINT	"Bytes to read %ld"
 ;endif
	* See if we got all of it already?
	tst.l	d4
	beq	.don
	bmi	.don

	move.l	lod_filehandle(a5),d1
	move.l	d5,d2
	move.l	#$2000,d3
	lore	Dos,Read

	cmp.l	#-1,d0
	bne.b	.noErr
 if DEBUG
	lob	IoErr
	DPRINT	"IoErr=%ld"
 endif
	bra	.error2
.noErr

	* Subtract total bytes to be read
	sub.l	d0,d4
	bmi	.error2
	beq.b	.don

	* Advance target addres
	add.l	d0,d5
	bsr.b	.lood
	bra.b	.loadloop

* Draw progress bar
.lood
	tst.b	win(a5)
	beq.b	.wxx
	pushm	d4/d5

	* File length is in d5
	move.l	lod_length(a5),d5
	move.l	d5,d3
	lsr.l	#8,d3
	* Bytes left to read is in d4
	sub.l	d4,d5
	* Bytes read is in d5
	lsr.l	#8,d5

	* Calculate 
	;mulu	#229,d5
	move	WINSIZX(a5),d7
	sub	#35,d7
	mulu	d7,d5
	divu	d3,d5
	move	d5,d4 * XSize

        move.l  rastport(a5),a0
        move.l  a0,a1

        move.b  rp_Mask(a0),d7
        move.b	#%11,rp_Mask(a0)

        moveq   #16+WINX,d0
        ;moveq   #22+WINY,d1
		move	infoBoxTopEdge(a5),d1
		move	infoBoxHeight(a5),d2
		lsr		#1,d2
		add		d2,d1
		subq	#6,d2
		lsr		#1,d2
		add		d2,d1
		addq	#2,d1

		add     windowleft(a5),d0
        add     windowtop(a5),d1

        move.l  d0,d2	* DestX = SrcX
        move.l  d1,d3   * DestY = SrcY

        moveq   #5,d5   * YSize
        move    #$f0,d6
 ;ClipBlit(Src, SrcX, SrcY, Dest, DestX, DestY, XSize, YSize, Minterm)
;          A0   D0    D1    A1    D2     D3     D4     D5     D6
        lore    GFX,ClipBlit

        move.l  rastport(a5),a0
        move.b  d7,rp_Mask(a0)

	popm	d4/d5
.wxx
	rts
.don
	DPRINT	"Read done"
 endc

.exit:

	bsr.b	.closeit

	tst.b	lod_archive(a5)		* dellataan archivetempfile
	beq.b	.eiarc
	tst.b	lod_tfmx(a5)		* jos oli tfmx, ei dellata
	bne.b	.eiarc
	bsr	remarctemp
.eiarc

	tst	lod_error(a5)
	beq.b	.okk

	bsr	.free

;	tst.l	lod_address(a5)
;	beq.b	.noko
;	bsr	freemodule
	bra.b	.noko
.okk
	* Store results
	move.l	lod_start(a5),a0
	move.l	lod_address(a5),(a0)
	move.l	lod_len(a5),a0
	move.l	lod_length(a5),(a0)
.noko
	jsr	clearMainWindowWaitPointer

	move	lod_error(a5),d0
	ext.l	d0
	movem.l	(sp)+,d1-a6
	tst.l	d0
	rts



.seekstart
	move.l	lod_filehandle(a5),d1		* tiedoston alkuun
	moveq	#0,d2
	moveq	#-1,d3
	move.l	_DosBase(a5),a6
	lob	Seek
 if DEBUG
	lob	IoErr
	DPRINT	"Seek IoErr=%ld"
 endif	
	rts

.closeit:
	move.l	lod_filehandle(a5),d1
	beq.b	.em
	move.l	_DosBase(a5),a6
	lob	Close
.em	rts



* Sets lod_memtype(a5) that is used to allocate destination read buffer
.checkm
    bsr   tutki_moduuli2
	cmp.b	#3,d0   * MED detected?
	beq	.medfoo      * Do additional check, returns to .publl or exits.
	cmp.b	#2,d0   * Protracker detected?
	beq	.ptfoo      * Do additional check, returns to .publl or exits.
    cmp.b   #-1,d0  * -1 = load to chip
    beq.b   .nofast

.publl  move.l   #MEMF_PUBLIC!MEMF_CLEAR,d0
	DPRINT	"Loading to PUBLIC memory"

.osd    move.l  d0,lod_memtype(a5)
.nofast rts

.nofas	move.l	#MEMF_CHIP!MEMF_CLEAR,d0
	bra.b	.osd



***** tutkaillaan onko sample

* 
* In:
*   a0 = probebuffer
* Out:
*   Z-flag set if recognized
.dosamplecheck:
    DPRINT  "sample check"
** IFF
	move.b	#SAMPLE_FORMAT_IFF,sampleformat(a5)
	cmp.l	#"FORM",(a0)
	bne.b	.nosa0
	cmp.l	#"8SVX",8(a0)
	beq	.sampl
** AIFF
	move.b	#SAMPLE_FORMAT_AIFF,sampleformat(a5)
	cmp.l	#"AIFF",8(a0)
	beq	.sampl

.nosa0
** RIFF WAVE
	move.b	#SAMPLE_FORMAT_WAV,sampleformat(a5)
	cmp.l	#"RIFF",(a0)
	bne.b	.nosaa
	cmp.l	#"WAVE",8(a0)
	beq	.sampl
.nosaa
** MPEG
	move.b	#SAMPLE_FORMAT_MP3,sampleformat(a5)
    jsr     streamIsAlive
    beq     .noStream
    jsr     streamIsMpegAudio
    bne     .mpegaStream
.noStream
    push    a0
	move.l	modulefilename(a5),a0
    bsr     id_mp3filename
    pop     a0
    tst.l   d0
    beq     .sampl

	* Finally check probe buffer contents 
	bsr	id_mp3

.sampl	rts

.mpegaStream
    moveq   #0,d0
    rts
	

** Ladataan PT file fastiin jos ei mahdu chipppppiin
.ptfoo:
	tst.b	ahi_use(a5)		* AHI? -> public
	bne	.publl
	cmp.b	#2,ptmix(a5)		* PS3M? -> public
	beq	.publl
.medfoo:
	pushm	all
    DPRINT  "Check if fits into CHIP"
	move.l	#MEMF_LARGEST!MEMF_CHIP,d1
	lore	Exec,AvailMem
	cmp.l	lod_length(a5),d0
	popm	all
	blo	.publl
	rts

.infor	
	move.l	lod_memtype(a5),d0
	btst	#MEMB_PUBLIC,d0
	bne	infolines_loadToPublicMemory
	bra	infolines_loadToChipMemory

.nofile_err
	move	#lod_notafile,lod_error(a5)
	bra	.exit

.open_error
 if DEBUG
	lore	Dos,IoErr
	DPRINT	"Open IoErr=%ld"
 endif

	move	#lod_openerr,lod_error(a5)
	bra	.exit

.error
.nomem_error
.fimp_error
	move	#lod_nomemory,lod_error(a5)
	bra	.exit

.fimp_error2
.error2	
	bsr.b	.free
.read_error
	move	#lod_readerr,lod_error(a5)
	bra	.exit
.lib_error1
	move	#lod_noxpk,lod_error(a5)
	bra	.exit
.lib_error2
	move	#lod_nopp,lod_error(a5)
	bra	.exit
.xpk_error
	move	#lod_xpkerr,lod_error(a5)
	move	d0,lod_xpkerror(a5)
;	bra	.exit
	bra	.noko	

.pp_error
	move	d0,lod_error(a5)	* PP:n virhekoodi (yhteensopiva)
	bra	.exit


.alloc:
	move.l	lod_length(a5),d0
	move.l	lod_memtype(a5),d1
    or.l    #MEMF_CLEAR,d1
    DPRINT  "allocate=%lx"
	move.l	(a5),a6
	lob	AllocMem
	tst.l	d0
	rts

.free	move.l	lod_address(a5),d0
	beq.b	.eee
	clr.l	lod_address(a5)
	move.l	d0,a1
	move.l	lod_length(a5),d0
 if DEBUG
 	move.l	a1,d1
	DPRINT	"Free %ld bytes at 0x%lx"
 endif
	move.l	(a5),a6
	lob	FreeMem
.eee	rts


* Removes the temp directory used for unarchiving lha etc
remarctemp
	pushm	all
	lea	-200(sp),sp
	move.l	sp,a1
	lea	.del1(pc),a0
	jsr	copyb
	subq	#1,a1

	lea	arcdir(a5),a0
	jsr	copyb
	subq	#1,a1
	cmp.b	#':',-1(a1)
	beq.b	.nar
	move.b	#'/',(a1)+
.nar	
	lea	tdir(pc),a0
	jsr	copyb
	subq	#1,a1
	lea	.del2(pc),a0
	jsr	copyb

	move.l	sp,d1
	moveq	#0,d2
	move.l	nilfile(a5),d3
	lore	Dos,Execute
	lea	200(sp),sp
	popm	all
	rts

.del1	dc.b	"c:delete ",0
.del2	dc.b	" ALL QUIET",0 ;FORCE

tdir	dc.b	"∞HiP∞",0
 even


get_xpk	move.l	_XPKBase(a5),d0
	beq.b	.noep
	rts
.noep	lea 	xpkname,a1		
	move.l	a6,-(sp)
	move.l	(a5),a6
	lob	OldOpenLibrary
	move.l	(sp)+,a6
	move.l	d0,_XPKBase(a5)
	rts

get_pp	move.l	_PPBase(a5),d0
	beq.b	.noep
	rts
.noep	lea 	ppname,a1		
	move.l	a6,-(sp)
	move.l	(a5),a6
	lob	OldOpenLibrary
	move.l	(sp)+,a6
	move.l	d0,_PPBase(a5)
	rts

get_sid:
	move.l	_SIDBase(a5),d0
	beq.b	.noep
	rts
.noep
    lea 	sidname,a1		
	move.l	a6,-(sp)
	move.l	(a5),a6
	lob	OldOpenLibrary
	move.l	(sp)+,a6
	move.l	d0,_SIDBase(a5)
	beq.b	.q
    
    move.l  d0,a0
    moveq   #0,d0
    moveq   #0,d1
    move.w  LIB_VERSION(a0),d0
    move.w  LIB_REVISION(a0),d1
    move.l  LIB_IDSTRING(a0),d2
    DPRINT  "Opened playsid: %ld.%ld - %s"
    cmp.w   #1,d0
    blo     .fail
    cmp.w   #2,d1
    blo     .fail

	bsr	init_sidpatch
	moveq	#1,d0
.q	rts

.fail
    moveq   #0,d0
    rts

get_xfd
	move.l	_XFDBase(a5),d0
	beq.b	.x
	rts
.x	lea	xfdname,a1
	push	a6
	lore	Exec,OldOpenLibrary
	pop	a6
	move.l	d0,_XFDBase(a5)
	rts

get_med1
	move.l	_MedPlayerBase1(a5),d0
	beq.b	.q
	rts
.q	lea	medplayername1,a1
 if DEBUG
    move.l  a1,d0
    DPRINT  "Opening %s"
 endif
	moveq	#7,d0
	push	a6
	lore	Exec,OpenLibrary
	pop	a6
	move.l	d0,_MedPlayerBase1(a5)
	rts	

get_med2
	move.l	_MedPlayerBase2(a5),d0
	beq.b	.q
	rts
.q	lea	medplayername2,a1
 if DEBUG
    move.l  a1,d0
    DPRINT  "Opening %s"
 endif
	moveq	#7,d0
	push	a6
	lore	Exec,OpenLibrary
	pop	a6
	move.l	d0,_MedPlayerBase2(a5)
	rts	

get_med3
	move.l	_MedPlayerBase3(a5),d0
	beq.b	.q
	rts
.q	lea	medplayername3,a1
 if DEBUG
    move.l  a1,d0
    DPRINT  "Opening %s"
 endif
	moveq	#7,d0
	push	a6
	lore	Exec,OpenLibrary
	pop	a6
	move.l	d0,_MedPlayerBase3(a5)
	rts	


get_mline
	move.l	_MlineBase(a5),d0
	beq.b	.q
	rts
.q	lea	mlinename,a1
	push	a6
	lore	Exec,OldOpenLibrary
	pop	a6
	move.l	d0,_MlineBase(a5)
	rts	



*******************************************************************************
* Analysoidaan tiedosto
*******************************************************************************


*******
* Search
*******
* in:
*   a1 = etsitt‰v‰
*   a4 = mist‰ etsit‰‰n
*   d0 = etsitt‰v‰n pituus
*   d7 = modin pituus
* out:
*   d0 =  0: found
*   d0 = -1: not found
*   a0 = end of last match

search:
	move.l	#2048,d2
	cmp.l	d7,d2
	blo.b	.sea
	move.l	d7,d2		
.sea	
	lea	(a4,d2.l),a3	 * Etsit‰‰n kaksi kilotavua tai modin pituus

	move	d0,d2
	subq	#2,d2
	move.l	a4,a0
	move.b	(a1)+,d0
.moh	move.l	a1,a2
.findi	
	cmp.l	a3,a0
	bhs.b	.eieh
	cmp.b	(a0)+,d0
	bne.b	.findi

	move	d2,d1
.fid	cmpm.b	(a2)+,(a0)+
	dbne	d1,.fid
	beq.b	.yeah

.fof	cmp.l	a3,a0
	blo.b	.moh
.eieh	moveq	#-1,d0
	rts
.yeah	moveq	#0,d0
	rts


*******
* Analysoidaan moduuli
*******
* Tutkitaan, onko moduuli sellanen jonka vois ladata fastiin.
* a0 = moduuli, 1084 bytee

* Out:
*   d0: 0 = load into public mem
*       1 = load to fast mem: protracker fast mem player active
*       2 = protracker file
*      -1 = load to chip

tutki_moduuli2:
	DPRINT	"Check where to load"
	pushm	d1-a6
	move.l	a0,a4   * module in both a0 and a4, id routines may use either
	move.l	#1084,d7
	bsr.b	.do
	popm	d1-a6
	rts
.do
* ptmix -> 0: chip, 1: fast, 2: ps3m
	tst.b	ahi_use(a5)
	bne.b	.er

	tst.b	ptmix(a5)
	beq.b	.er

	cmp.b	#2,ptmix(a5)
	beq.b	.er

	bsr	.ptch		* fast
	beq	.rf
	bra.b	.nom

.er	bsr	.ptch		* 
	beq	.ff

.nom
;	bsr	id_ps3m
;	tst.l	d0
;	beq	.goPublic
	cmp.l	#'SCRM',44(a0)		* Screamtracker ]I[
	beq	.f
	cmp.l	#"OCTA",1080(a0)	* Fasttracker
	beq	.f

	cmp.l	#"Exte",(a0)		* Fasttracker ][ XM
	bne.b	.kala
	cmp.l	#"nded",4(a0)
	bne.b	.kala
	cmp.l	#" Mod",8(a0)
	bne.b	.kala
	cmp.l	#"ule:",12(a0)
	beq	.f

.kala	move.l	1080(a0),d0
	and.l	#$ffffff,d0		* fast
	cmp.l	#"CHN",d0
	beq	.f
	cmp	#"CH",1082(a0)		* fast
	beq	.f
	move.l	(a0),d0
	lsr.l	#8,d0
	cmp.l	#'MTM',d0		* multi
	beq	.f
	move.l	1080(a0),d0
	lsr.l	#8,d0
	cmp.l	#"TDZ",d0		* take
	beq 	.f

    jsr     id_vgm
    beq     .f

	bsr	id_it			 * IT
	beq 	.f

* tfmx song data?

* This check also matches "Hippel7", but apparently
* the probebuffer data at this point is not enough
* to id Hippel7 properly. Those will be moved into 
* chip ram at later tage

	cmp.l	#"TFMX",(a4)
	beq 	.goPublic
	cmp.l	#"tfmx",(a4)
	beq 	.goPublic

	bsr	id_oktalyzer8ch
	beq 	.goPublic

	cmp.l	#'PSID',(a4)		* PSID-tiedosto
	beq 	.goPublic

	bsr	id_thx_
	tst.l	d0
	beq 	.goPublic
	jsr	id_pretracker_
	tst.l	d0
	beq 	.goPublic
	bsr	id_mline
	tst.l	d0
	beq 	.goPublic
	jsr	id_musicmaker8_
	tst.l	d0
	beq 	.goPublic

    jsr     id_delicustom
    beq     .goPublic

	;bsr	id_digitalmugician2 
	;beq.b	.goPublic

    jsr     p_midiext\.id
    beq     .goPublic

** OctaMed SoundStudio mixattavat moduulit
	move.l	(a4),d0
	lsr.l	#8,d0
	cmp.l	#'MMD',d0
	bne.b	.nome
    tst.b   medfastmemplay(a5)  * MED FastMemPlay enabled in Prefs
    bne     .goPublic
	btst	#0,20(a4)		* mmdflags, MMD_LOADTOFASTMEM
	bne.b	.goPublic
    bra     .fff             * go public if doesn't fit into chip
.nome

	bsr	id_digibooster_
	tst.l	d0
	beq.b	.goPublic
	bsr	id_digiboosterpro_
	tst.l	d0
	beq.b	.goPublic
	bsr		id_aon8
	tst.l	d0
	beq.b	.goPublic
	

	tst.b	ahi_use(a5)
	bne.b	.ahitun

.goChip
.nf	
	moveq	#-1,d0		* chip
	rts
.goPublic
.f	moveq	#0,d0		* public
	rts
.ff	moveq	#2,d0		* Protracker file
	rts
.fff	
    moveq	#3,d0		* MED file
	rts
.rf	moveq	#1,d0		* fast
	rts
 

.ptch	cmp.l	#"M.K.",1080(a0)
	beq.b	.petc
	cmp.l	#"M!K!",1080(a0)
;	beq.b	.petc
;	cmp.l	#"FLT4",1080(a0)
.petc	rts

.ahitun
	pushm	all

	move.l	a0,a4
	bsr	id_hippelcoso
	beq.b	.ok
	moveq	#-1,d0

.ok	popm	all
	beq.b	.f
	bra.b	.nf



tutki_moduuli:
	DPRINT	"Identify module"
;	bsr	inforivit_identifying
 ifne PILA

	lea	keyfile(a5),a4
	push	a4

	lea	.aag_id(pc),a1		 * onko AAG'97 keyfile?
	moveq	#4,d0
	moveq	#40,d7
	bsr	search
	pop	a0
	beq.b	.screw

	move.l	#$20202020,d0	
	or.l	(a0),d0
	cmp.l	#"wrec",d0		* wREC oF zYMOSIS?
	bne.b	.nwr
	move.l	(a5),a0
	btst	#AFB_68060,AttnFlags+1(a0)	* 68060?
	bne.b	.nwr
.screw	
	moveq	#-128,d1		* odotellaan
	ror.l	#7,d1
	lore	Dos,Delay
.nwr


 endc


	* Address may be null in case of sample file
	move.l	moduleaddress(a5),a4
	move.l	modulelength(a5),d7

	* NOTE! Some are very slow
	* - hippel
	* - activision pro

;	tst.b	keyfile+49(a5)	* datan v‰lilt‰ 38-50 pit‰‰ olla nollia
;	beq.b	.zz
;	move.l	(a5),a2
;	addq.l	#1,IVSOFTINT+IV_CODE(a2)
;.zz

	
	tst.b	ahi_use(a5)
	bne.b	.ohi
	cmp.b	#2,ptmix(a5)	* Normaali vai miksaava PT replayeri?
	beq.b	.ohi
	
	* See if there is data to check
	move.l	a4,d0
	beq.b	.ohi
	bsr	id_protracker
	beq	.protracker

.ohi
	* Test for formats that do not require an external
	* replay code.
	clr.b	external(a5)		* Lippu: ei tartte player grouppia 

	tst.b	sampleinit(a5)
	bne.b	.noop

	tst.b	ahi_muutpois(a5)	
	bne.b	.noop

	* These do not require player group:

	DPRINT	"Internal"
	lea	internalFormats(pc),a3 
	bsr	identifyFormats
	beq 	.ex2

;	DPRINT	"Eagle"
;	lea	eagleFormats(pc),a3
;	bsr 	identifyFormats 
;	beq 	.ex2

	***********************************

	tst.l	externalplayers(a5)
	bne.b	.noop

	bsr	id_sid
	beq	.sid

	bsr	id_oldst
	beq	.oldst
.noop

	tst.l	externalplayers(a5)	* ladataan playerit
	bne.b	.rite
	cmp.b	#GROUPMODE_DISABLE,groupmode(a5)	* onko disabled
	beq	.nopl

	cmp.b	#GROUPMODE_LOAD_SINGLE,groupmode(a5)	* tarpeen vaatiessa 1 replayeri?
	bne.b	.rote
	st	external(a5)		* Lippu!
	bra.b	.rite
.rote
	bsr	loadplayergroup
	move.l	d0,externalplayers(a5)
	bne.b	.rite
	moveq	#lod_grouperror,d0
	rts


.rite

	tst.b	ahi_muutpois(a5)
	beq.b	.mpa

** AHIa tukevat replayerit
    tst.b   sampleinit(a5)
    bne     .sample
    bsr	id_hippelcoso
	beq	.hippelcoso

	bra.b	.mp
.mpa

	tst.b	sampleinit(a5)		* sample??
	bne	.sample

	bsr	id_TFMX_PRO
	tst	d0
	beq	.tfmx

	bsr	id_TFMX7V
	tst	d0
	beq	.tfmx7

	bsr	id_tfmx
	beq	.tfmx

	bsr	id_tfmxunion
	beq	.tfmxunion

	DPRINT	"Group"
	lea	groupFormats(pc),a3 
	bsr	identifyFormats
	beq.b .ex2

	DPRINT	"Eagle"
	lea	eagleFormats(pc),a3
	bsr 	identifyFormats 
	beq.b 	.ex2

 ifne FEATURE_P61A
	move.l	fileinfoblock+8(a5),d0	* Tied.nimen 4 ekaa kirjainta
	bsr	id_player2
	beq	.player
 endif

.mp
    move.l  a4,a0
    jsr     id_xmaplay
    beq     .xmaplay

	bsr	id_ps3m		
	tst.l	d0
	beq	.multi

	clr.b	external(a5)
.nope
.nopl

	tst.b	ahi_muutpois(a5)
	bne.b	.er

	bsr	id_sid
	beq	.sid

	bsr	id_oldst
	beq.b	.oldst


.er	
	DPRINT 	"Unknown format"
	moveq	#lod_tuntematon,d0
	rts	

.ex
	 bsr	tee_modnimi
.ex2	
	cmp	#pt_prot,playertype(a5)
	beq.b	.wew
	cmp	#pt_med,playertype(a5)
	beq.b	.wew
	bsr	whatgadgets
.wew
 if DEBUG
	moveq	#0,d0
	move	playertype(a5),d0
	moveq	#p_name,d1
	add.l	playerbase(a5),d1 
	DPRINT 	"Detected %ld %s"
 endif
	moveq	#0,d0
	rts

.oldst	st	oldst(a5)
	bsr	convert_oldst
	bra.b	.pro0

.protracker	
	clr.b	oldst(a5)
.pro0	pushpea	p_protracker(pc),playerbase(a5)
	move	#pt_prot,playertype(a5)
	moveq	#20-1,d0
	bsr	copyNameFromModule
	bra.b	.ex2

.multi	
    pushpea	p_multi(pc),playerbase(a5)
	move	#pt_multi,playertype(a5)
.moveData
	bsr	moveModuleToPublicMem		* siirret‰‰n fastiin jos mahdollista

	move.l	moduleaddress(a5),a1	* tutkaillaan onko miss‰ muistissa
	lore	Exec,TypeOfMem
	and.l	#MEMF_CHIP,d0
	beq	.ex2

** Arf! Ladattiin chippiin!
** Onko vehkeess‰ fastia laisinkaan? Jos on, pistet‰‰n warn-tekstinp‰tk‰.

	moveq	#MEMF_FAST,d1
	lob	AvailMem
	tst.l	d0
	beq	.ex2

	bsr	inforivit_warn
	moveq	#65,d1
	lore	Dos,Delay
	bra	.ex2

.xmaplay
    move.l  #p_xmaplay,playerbase(a5)
	move	#pt_xmaplay,playertype(a5)
    bra     .moveData

.sid	pushpea	p_sid(pc),playerbase(a5)
	move	#pt_sid,playertype(a5)
	bsr	moveModuleToPublicMem		* siirret‰‰n fastiin jos mahdollista
	bra	.ex2

 ifne FEATURE_P61A
.player
	pushpea	p_player(pc),playerbase(a5)
	move	#pt_player,playertype(a5)
	bra	.ex
 endif

.hippelcoso
	move	d5,maxsongs(a5)
	pushpea	p_hippelcoso(pc),playerbase(a5)
	move	#pt_hippelcoso,playertype(a5)
	bra	.ex

.delicustom
	pushpea	p_delicustom(pc),playerbase(a5)
	move	#pt_delicustom,playertype(a5)
	bra	.ex

;.futureplayer
;	pushpea	p_futureplayer,playerbase(a5)
;	move	#pt_futureplayer,playertype(a5)
;	bra	.ex
;
;.davelowe
;	pushpea	p_davelowe,playerbase(a5)
;	move	#pt_davelowe,playertype(a5)
;	bra	.ex

**** Oliko  sample??
.sample:
	pushpea	p_sample(pC),playerbase(a5)
	move	#pt_sample,playertype(a5)
	bra	.ex



** Yhdistetty TFMX formaatti

.tfmxunion
	moveq	#0,d7
	moveq	#$7f,d0
	and.b	8(a4),d0		*  tyyppi
	cmp.b	#3,d0
	beq.b	.t7
	moveq	#1,d7
.t7	bra	.ok



* TFMX onkin hankalampi homma..

.tfmx7	moveq	#0,d7
	bra.b	.t	

.tfmx	moveq	#1,d7
.t	
	moveq	#0,d0

	lea	fileinfoblock+fib_FileName(a5),a0		* tied.nimi: mdat.*
 
	cmp.l	#'MDAT',(a0)
	beq.b	.uq
	cmp.l	#'mdat',(a0)
	bne.b	.qo
.uq	cmp.b	#'.',4(a0)
	beq.b	.ook


.qo	tst.b	(a0)+			* tied.nimi: *.mdat
	bne.b	.qo
	subq	#1,a0
	moveq	#0,d0
	move.b	-(a0),d0
	rol.l	#8,d0
	move.b	-(a0),d0
	rol.l	#8,d0
	move.b	-(a0),d0
	rol.l	#8,d0
	move.b	-(a0),d0
	and.l	#$dfdfdfdf,d0
	cmp.l	#'TADM',d0	* MDAT nurinp‰i
	bne	.er
	cmp.b	#'.',-(a0)
	bne	.er

.ook
	
	lea	-150(sp),sp		* tied nimi stackkiin
	move.l	sp,a1

	tst.b	lod_archive(a5)		* archivesta?
	beq.b	.pin
	lea	lod_buf(a5),a0
	bra.b	.cop

.pin	move.l	modulefilename(a5),a0
.cop	move.b	(a0)+,(a1)+
	bne.b	.cop

	lea	(sp),a0
.leep	lea	.tfmxid(pc),a1			* Etsit‰‰n nimest‰ 'mdat'
.luup	move.b	(a1)+,d1
	beq.b	.olioikea
	move.b	(a0)+,d0
	beq	.er
	bset	#5,d0			* pieneksi kirjaimeksi	
	cmp.b	d1,d0
	bne.b	.leep
	bra.b	.luup
.olioikea

	;subq.l	#1,a0			* muunnetaan 'smpl'
	move.b	#'l',-(a0)
	move.b	#'p',-(a0)
	move.b	#'m',-(a0)
	move.b	#'s',-(a0)

	lea	(sp),a1
* KPK 2016: removed debug requester when loading
* TFMX module
*	bsr	request		

	bsr	inforivit_tfmxload

	clr.b	lod_tfmx(a5)

	move.b	lod_archive(a5),d6


	lea	(sp),a0
	moveq	#MEMF_CHIP,d0
	lea	tfmxsamplesaddr(a5),a1
	lea	tfmxsampleslen(a5),a2
	moveq	#1,d1			* Ei oteta filen kommenttia talteen
	move.b	xpkid(a5),d4		* ei XPK ID:t‰ samplefileille
	st	xpkid(a5)
    move.l  lod_xpkOutLen(a5),d2 * preserve mdat lenght for MD5sum
	bsr	loadfile
    move.l  d2,lod_xpkOutLen(a5)
	move.b	d4,xpkid(a5)
	move.l	d0,-(sp)

;	tst.b	lod_archive(a5)
	tst.b	d6
	beq.b	.bar
	bsr	remarctemp
.bar

	bsr	inforivit_clear

	move.l	(sp)+,d0
	lea	150(sp),sp
	tst.l	d0
	beq.b	.ok
	rts
	
.ok	pushpea	p_tfmx(pc),playerbase(a5)
	move	#pt_tfmx,playertype(a5)
	tst	d7
	bne	.ex
	pushpea	p_tfmx7(pc),playerbase(a5)
	move	#pt_tfmx7,playertype(a5)
	bra	.ex

;.tfmxid	dc.b	"mdat.",0
.tfmxid		dc.b	"mdat",0
 even


* Utility function
* In:
*   Z-flag
* Out:
*   d0 = 0, if Z set, -1 if not
idtest:
	beq.b	.y
	moveq	#-1,d0
	rts
.y	moveq	#0,d0
	rts

* Run through format list and execute id function for each format
* in:
*   a4 = module
*   a3 = array of formats
* out:
*   d0 = 0 if some format accepted the module, ~0 otherwise
identifyFormatsOnly:
	* Flag: only identify, do not grab data
	moveq	#1,d1
	bra.b 	doIdentifyFormats
identifyFormats
	* Flag: identify and grab module name and type
	moveq	#0,d1
	clr.b	modulename(a5)
doIdentifyFormats
.loop 
	tst.l	(a3)
	beq.b	.notFound
	move.l	a3,a0
    add.l   (a0),a0
 if DEBUG
;;;    push    d1
;;;    move.l  (a3),d0
;;;	pushpea	p_name(a0),d1
;;;	DPRINT	"- %ld -> %s"
;;;    pop     d1
 endif
	pushm	all
	jsr	p_id(a0)
	tst.b	d0
	popm 	all
	beq.b 	.found
	addq	#4,a3
	bra.b	.loop
.found
	tst.b	d1 
	bne.b 	.nameOk

	move.l	a0,playerbase(a5)
	move	p_type(a0),playertype(a5)
	
	tst.b	modulename(a5)
	bne.b 	.nameOk 
	* Name was not provided by identifiers, make one
	bsr.b	tee_modnimi
.nameOk
	moveq	#0,d0
	rts
.notFound
	moveq	#-1,d0 
	rts

* Grab name from loaded module data
* In:
*   d0 = max length for name
* From start of the data:
copyNameFromModule
	move.l	moduleaddress(a5),a1
* From pointer in A1:
copyNameFromA1:
	lea	modulename(a5),a0
.co	move.b	(a1)+,(a0)+
	dbeq	d0,.co
	clr.b	(a0)
	rts 
	
*******************************************************************
* Formaattien tunnistusrutiinit
*
* Parametrit: 
* D7 <= moduulin pituus (tai tutkittavan alueen pituus)
* A4 <= moduulin osoite (tutkittavan alueen osoite)
*
*
* Tulos:
* D0 => 0 jos moduuli on tunnettu
* D0 => -1 jos moduuli ei tunnetti
* 
* Jotkut palauttavat myˆs muuta informaatiota rekistereiss‰,
* kuten D5 => maxsong
*
 

keyfilename	dc.b	"L:HippoPlayer.Key",0
 even


*******
* Virittelee nimen tied.nimest‰
*******
tee_modnimi:
 	move.w  #INFO_MODULE_NAME_LEN-1,d1
	lea		modulename(a5),a1
	tst.b	lod_archive(a5)		* Paketista purettuna
	bne.b	.arc				* otetaan pelkk‰ filename
	move.l	solename(a5),a0
	tst.b	lastLoadedModuleWasRemote(a5)
	beq.b	.copy
    move.l  a0,a2
    * Remote file, go forward to next slash if possible.
    * If NULL reached, do nothing
.slash
    tst.b   (a2)
    beq.b   .copy
	cmp.b	#"/",(a2)+
	bne.b	.slash
    move.l  a2,a0
    bra     .copy
.arc
	* This contains info from the last archive loaded file 
	lea	fib_FileName+fileinfoblock(a5),a0
.copy	
	move.b	(a0)+,(a1)+
	dbeq	d1,.copy
	clr.b	(a1)
	rts


*******************************************************************************
* Lataa ulkoisen soittorutiinirykelm‰n
*******

loadplayergroup
	DPRINT	"Load player group"
	pushm	d1-a6


	bsr	inforivit_group

	moveq	#0,d7
	bsr		openPlayerGroupFile
	beq	.error
.ok
	move.l	d4,d1		* selvitet‰‰n filen pituus
	moveq	#0,d2	
	moveq	#1,d3
	lob	Seek
	move.l	d4,d1
	moveq	#0,d2	
	moveq	#1,d3
	lob	Seek
	move.l	d0,d5

	move.l	d4,d1		* alkuun
	moveq	#0,d2
	moveq	#-1,d3
	lob	Seek

	move.l	d5,d0
	moveq	#MEMF_PUBLIC,d1
	jsr	getmem
	move.l	d0,d7
	beq		.error

	move.l	d4,d1
	move.l	d7,d2
	move.l	d5,d3
	lob	Read
	cmp.l	d5,d0
	bne.b	.er

	move.l	d7,a0
	cmp.l	#"HiPx",(a0)
	beq.b	.x

.er
	move.l	d7,a0
	jsr	freemem
	bra.b	.error

.x	move.l	d4,d1
	beq.b	.xx
	lob	Close	

	move.l	d7,a0		* onko oikee versio??

 if DEBUG
	moveq	#0,d0
	move.b	4+3(a0),d0
	moveq	#xpl_versio,d1
	DPRINT	"Version: %ld, required: %ld"
 endif

	cmp.b	#xpl_versio,4+3(a0)
	bhs.b	.xx

	move.l	d7,a0
	jsr	freemem
	moveq	#0,d7

.xx	
	;bsr	inforivit_clear

 if DEBUG 
    tst.l   d7
    beq     .x1
	move.l	d7,a0 
	move.l	-4(a0),d0 
	DPRINT	"Group size %ld"
.x1
 endif

	move.l	d7,d0
	popm	d1-a6
	rts

.error	moveq	#0,d7
	bra.b	.x

* out:
*  d4 = file handle, or NULL if error
openPlayerGroupFile
	move.l	_DosBase(a5),a6
	
	* First try home dir
	tst.l	homelock(a5)
	beq.b	.noHome

	lea	-100(sp),sp 
	move.l	sp,a0
	lea	progdir(pc),a1 
.c1 	move.b	(a1)+,(a0)+
	bne.b	.c1
	subq	#1,a0 
	lea	hipGroupFileName,a1
.c2	move.b	(a1)+,(a0)+
	bne.b	.c2
 if DEBUG 
	move.l	sp,d0
	DPRINT	"->%s"
 endif
	move.l	sp,d1
	move.l	#1005,d2
	lob		Open
	lea	100(sp),sp
	move.l	d0,d4
	bne.b	.ok 

.noHome
 if DEBUG 
	pushpea	groupname(a5),d0
	DPRINT	"->%s"
 endif

	pushpea	groupname(a5),d1
	move.l	#1005,d2
	lob	Open
	move.l	d0,d4
.ok 
	rts

progdir 
	dc.b	"PROGDIR:",0
	even



* lataa yksitt‰isen replayerin playergroupista
* d1 = muistin tyyppi

loadreplayer
	DPRINT	"Load single replayer"
	pushm	d1-d6/a0/a2-a6
	move.l	d6,a4				* muistin tyyppi!

	move.l	externalplayers(a5),a0		* grouppi poies
	jsr	freemem
	clr.l	externalplayers(a5)

	move	playertype(a5),d0		* onko jo sama ladattuna?
	cmp	xtype(a5),d0
	bne.b	.jou
	DPRINT	"Using already loaded"
	move.l	xplayer(a5),a1			* osoite a1:een
	move.l	xlen(a5),d7
	moveq	#1,d0
	popm	d1-d6/a0/a2-a6
	rts

.jou
	move	d0,xtype(a5)
	
	move.l	xplayer(a5),a0			* vapautetaan vanha 
	jsr	freemem
	clr.l	xplayer(a5)

	bsr	inforivit_group2

	bsr	openPlayerGroupFile
	beq	.error

	move.l	d4,d1
	pushpea	probebuffer+1024(a5),d2
	move.l	#1024,d3
	lob	Read
	cmp.l	#1024,d0
	bne	.error	


 if DEBUG
	moveq	#0,d0
	move.b	7+probebuffer+1024(a5),d0
	moveq	#xpl_versio,d1
	DPRINT	"Version: %ld, required: %ld"
 endif


	cmp.b	#xpl_versio,7+probebuffer+1024(a5)
	blo	.error

	lea	probebuffer+8+1024(a5),a0
	move	playertype(a5),d0
.find
	tst	(a0)
	beq 	.error
	cmp	(a0),d0 
	beq.b 	.found 
	lea	2+4+4(a0),a0 
	bra.b	.find
.found
	movem.l	2(a0),d2/d6	* player offset, length
	move.l	d6,xlen(a5)	* pituus talteen

 if DEBUG
 	push	d2
 	ext.l	d0
	move.l	d2,d1
	move.l	d6,d2
	DPRINT	"Single rep type=%ld offs=%ld len=%ld"
	pop	d2
 endif

	move.l	d4,d1		* hyp‰t‰‰n oikeaan kohtaan
	moveq	#-1,d3
	lob	Seek

	move.l	d6,d0
	move.l	a4,d1
	jsr	getmem
	move.l	d0,xplayer(a5)	* muistia playerille
	beq.b	.error

	move.l	d4,d1		* file
	move.l	xplayer(a5),d2	* buffer
	move.l	d6,d3		* length
	lob	Read
	cmp.l	d6,d0
	beq.b	.ox

	move.l	d7,a0
	jsr	freemem
	bra.b	.error

.ox	moveq	#1,d7

.x	move.l	d4,d1
	beq.b	.xx
	lob	Close	


.xx	
;	bsr	inforivit_clear

	move.l	d7,d0
	move.l	xplayer(a5),a1
	move.l	d6,d7
	tst.l	d0

	popm	d1-d6/a0/a2-a6
	rts

.error	moveq	#0,d7
	clr		xtype(a5)
	bra.b	.x



*******************************************************************************
* Enabloidaan k‰ytetyt gadgetit ja disabloidaan k‰ytt‰m‰ttˆm‰t
* Scope kanssa
*******


* Disables a button gadget
* in:
*   a0 = button gadget
disableGadget:
disableButton:
	move	#GFLG_DISABLED,d0
	and	gg_Flags(a0),d0
	bne.b	.alreadyDisabled
	or	#GFLG_DISABLED,gg_Flags(a0)
	jsr	refreshGadgetInA0
.alreadyDisabled
	rts

* Enables a button gadget
* in:
*   a0 = button gadget
enableButton:
	move	#GFLG_DISABLED,d0
	and	gg_Flags(a0),d0
	beq.b	.alreadyEnabled
	and	 #~GFLG_DISABLED,gg_Flags(a0)
	* When re-enabling, need to draw the frame and clear
	* the disabled shadow
	move.l	a0,a3
	push	a0
	bsr	redrawButtonGadget	
	pop	a0
	moveq	#1,d0
.alreadyEnabled
	rts

* Enables a button gadget with RMB ear gfx
* in:
*   a0 = button gadget
enableButtonWithEar
	bsr.b	enableButton
	beq.b	.alreadyEnabled
	jsr	printkorva
.alreadyEnabled
	rts
	


whatgadgets2
	moveq	#0,d0
	bra.b	whag

whatgadgets
	moveq	#1,d0
whag	tst.b	win(a5)
	bne.b	.w
.ww	rts
.w

	tst.l	playerbase(a5)
	beq.b	.ww

	pushm	all

	move.l	playerbase(a5),a0
	move	p_liput(a0),d7

;	tst	d0
;	beq.b	.c

; In v2.50 and older scopes were shut down here if 
; active player didn't support it. 

* if usescope=1 then open scope if flag=1
* else
* if scope=open then close scope and set flag=1
* else
* clear flag

;	tst.b	scopeflag(a5)
;	beq.b	.c
;	btst	#pb_scope,d7
;	beq.b	.notopen
;	tst	quad_prosessi(a5)
;	bne.b	.c
;	bsr	start_quad2
;	bra.b	.c
;.notopen
;	tst	quad_prosessi(a5)
;	beq.b	.c
;	bsr	sulje_quad2

;.c

;	tst.l	keyfile+40(a5)	* datan v‰lilt‰ 38-50 pit‰‰ olla nollia
;	beq.b	.zz
;	move.l	tempexec(a5),a1
;	addq.l	#1,IVVERTB+IV_DATA(a1)
;.zz


	cmp	#pt_prot,playertype(a5)
	bne.b	.rep
	cmp.b	#$ff,ptsonglist+1(a5)	* jos vain yksi PT songi, sammutetaan 
	bne.b	.rep			* song-gadgetit!
	and	#~pf_song,d7
.rep
	lea	gadstate(pc),a4

	ror	#1,d7		* ei v‰litet‰ ekasta (joskus oli cont)

	moveq	#5-1,d6
.loop
	addq.l	#4,a4
	move.l	(a4)+,a0
	move.l	windowbase(a5),a1
	sub.l	a2,a2

	ror	#1,d7
	bpl.b	.off

	tst.b	-8(a4)		* oliko ennest‰‰n p‰‰ll‰?
	bne.b	.on

	move.l	a0,a3
	and	#~GFLG_DISABLED,gg_Flags(a3)
	bsr	redrawButtonGadget

	lea	kela2,a0
	cmp.l	a0,a3
	bne.b	.nokela
;	lea	kela2,a0		* >, forward
	jsr	printkorva
.nokela

	st	-8(a4)
	bra.b	.on

.off	tst.b	-8(a4)		* oliko pois p‰‰lt‰?
	beq.b	.on
	clr.b	-8(a4)
	move.l	a0,a3
	or	#GFLG_DISABLED,gg_Flags(a3)
	moveq	#1,d0
	lore	Intui,RefreshGList
	bsr.b	drawButtonFrameMainWindow

.on
	tst	2(a4)		* enemm‰n kuin yksi kerrallaan?
	bne.b	.l
	rol	#1,d7
	bra.b	.loop
.l
	dbf	d6,.loop

	popm	all
	rts

* Draws the button frame. 
* Check for gadgets that should be skipped so it is safe
* to call this with all gadgets.
* in:
*   a3 = gadget
drawButtonFrameMainWindow:
	* Skip file and volume sliders
    cmp     #GTYP_PROPGADGET,gg_GadgetType(a3)
    beq.b   .x
	* Invisible resize gadget
	cmp.l	#gadgetResize,a3
	beq.b	.x

	pushm	all				* varjostus kuntoon taas
	move.l	rastport(a5),a1
	bsr.b	doDrawButtonFrame
	popm	all
.x	rts


* in:
*   a3 = gadget
drawButtonFramePrefsWindow
	pushm	all				* varjostus kuntoon taas
	move.l	rastport2(a5),a1
	bsr.b	doDrawButtonFrame
	popm	all
	rts

* in:
*   a1 = rastport
*   a3 = gadget
doDrawButtonFrame
	movem	4(a3),plx1/ply1/plx2/ply2
	add	plx1,plx2
	add	ply1,ply2
	subq	#1,ply2
	subq	#1,plx1
	move.l	pen_2(a5),d3
	move.l	pen_1(a5),d2
	jmp	laatikko0


* Clear button area, refresh gadget, draw button frame
* in:
*   a3 = gadget
redrawButtonGadget
	movem	4(a3),d0/d1	* putsataan gadgetin alue..
	move	d0,d2
	move	d1,d3
	movem	8(a3),d4/d5
	move.l	rastport(a5),a0
	move.l	a0,a1
	push	d6
	moveq	#$0a,d6
	lore	GFX,ClipBlit
	pop	d6

	move.l	a3,a0
	jsr	refreshGadgetInA0

	bra	drawButtonFrameMainWindow



gadstate
	dc.l	$ff000001,button3	* stop/cont
	dc.l	$ff000001,button13	* prevsong
	dc.l	$ff000000,button12	* nextsong
	dc.l	$ff000001,kela2		* forwardd
	dc.l	$ff000001,kela1		* backward
	dc.l	$ff000001,slider1	* volume






********************************************************************************
*** SECTION ********************************************************************
*
* Favorite list handling
*
*****************************************************************************

toggleFavoriteStatusForCurrentModule:
	tst.b	favorites(a5)
	beq.b	.1
	cmp.b 	#LISTMODE_FAVORITES,listMode(a5)
	beq.b	.1
	move.l	chosenmodule(a5),d0
	bsr.b	toggleFavoriteStatus
	beq.b	.1
	jsr	forceRefreshList
.1	rts




* Toggle favorite status for list node
* in:
*   d0 = node index
* out:
*	d0 = 0 on failure, 1 on OK
toggleFavoriteStatus
    * Grab song number if favoriting the currently playing module
    moveq   #0,d1
    cmp.l   playingmodule(a5),d0
    bne     .1
    move    songnumber(a5),d1
.1
	* Get the actual node into a0
    push    d1
	bsr	    getListNode
    pop     d1
    tst.l   d0
	beq.b	.notFound

	tst.b	l_divider(a0)
	bne.b	.notFile

	* Toggle favorite status
	isFavoriteModule a0 
	bne.b	.wasFavorite
    * Store current song number or set to NULL
    move.b  d1,l_favSong(a0)
 if DEBUG
    moveq   #0,d0
    move.b  d1,d0
    DPRINT  "Storing favSong=%ld"
 endif
	bsr.b	addFavoriteModule
	bra.b	.wasNotFavorite
.wasFavorite
    clr.b   l_favSong(a0)
	bsr	removeFavoriteModule
.wasNotFavorite
	moveq	#1,d0
	rts
.notFound
.notFile
	moveq	#0,d0
	rts

* in:
*   a0 = module list node
addFavoriteModule:
	isFavoriteModule a0
	bne.b .exit

 if DEBUG
	pea	l_filename(a0)
	pop  d0
	DPRINT	"addFavoriteModule %s"
 endif
	* set favorite flag
	st	l_favorite(a0)
	
	* see if for some reason a0 is already in the favorite list
	bsr	findFavoriteModule
	tst.l	d0
	bne.b	.exit	* bail out if so
	
	* copy this node and add to favorite list
	bsr		cloneListNode
	* a4 = cloned node

	* Append to list
	move.l	a4,a1
	lea	favoriteListHeader(a5),a0
	lob	AddTail

	st	favoriteListChanged(a5)
 if DEBUG
	bsr	logFavoriteList
 endif
.noMem
.exit
	rts

* in: 
*   a0 = list nde
* out: 
*   a4 = new node
*   d0 = false: no mem, true: all ok
cloneListNode:
	move.l	a0,a3

	* copy this node and add to favorite list
	* get length of memory region, it's before the actual data
	move.l	-4(a3),d0
	move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
	jsr	getmem
	beq.b	.noMem
	move.l	d0,a4

	* Copy node contents
	move.l	a3,a0
	move.l	a4,a1
	move.l	-4(a3),d0
	lore 	Exec,CopyMem

	* Need to modify l_nameaddr pointer to point to the newly copied path.
	* Figure out the index to the name-without-path using the original node
	
	lea	l_filename(a3),a0	* this ptr is lower than
	move.l	l_nameaddr(a3),d0 	* ... this ptr
	sub.l	a0,d0	 * d0 is now an index 	

	* apply index to the new node
	lea	l_filename(a4,d0.l),a0
	move.l	a0,l_nameaddr(a4)

	moveq	#1,d0
	rts
.noMem	
	moveq	#0,d0
	rts

* in:
*  a0 = module list node
removeFavoriteModule
	isFavoriteModule a0
	beq.b	.exit
	clr.b	l_favorite(a0)

 if DEBUG
	pea	l_filename(a0)
	pop  d0
	DPRINT	"removeFavoriteModule %s"
	 endif

.loop
	* Find matching l_filename from favorite list
	* node is in a0
	bsr.b	findFavoriteModule
	beq.b	.exit
	* found matching one, in a1
	move.l	a1,d2
	* Remove a1 from list 
	* Destroys a0, a1
	push	a0
	REMOVE
	* Free associated memory
	move.l	d2,a0
	jsr 	freemem
	pop	a0
	st	favoriteListChanged(a5)
	* search again to find duplicates, although there shouldn't be 
	bra.b	.loop
.exit
 if DEBUG
	bsr	logFavoriteList
 endif
	rts

* in:
*   a0 = node to find by matching filename
* out:
*   a1 = favorite node that matches
*   d0 = 1 when match, 0 when no match
* destroys:
*   d0,a2,a3
findFavoriteModule:
	* Find matching l_filename from favorite list
	lea	favoriteListHeader(a5),a1
.loop
	TSTNODE	a1,a1
	beq.b	.notFound
	lea	l_filename(a0),a2
	lea	l_filename(a1),a3
.compare
	* if name differs get the next one
	cmpm.b	(a2)+,(a3)+
	bne.b	.loop
	* matches so far, loop until zero termination
	tst.b	(a2)
	bne.b	.compare
	* the counterpart must also have a zero here
	tst.b	(a3)
	bne.b	.notFound
* no differences found, it is a match
	moveq	#1,d0
	rts
.notFound
	moveq	#0,d0
	rts

freeFavoriteList
	move.l	(a5),a6		* execbase
	lea	favoriteListHeader(a5),a2
.loop
	* a0: list, a1: destroyed, d0: node, or zero
	move.l	a2,a0
	lob	RemHead
	beq.b	.listFreed
	move.l	d0,a0
	jsr	freemem
	bra.b	.loop

.listFreed
	st	favoriteListChanged(a5)
	cmp.b 	#LISTMODE_FAVORITES,listMode(a5)
	bne.b	.noFav
	* In favorite mode, no more modules to show
	clr.l	modamount(a5)
.noFav	
	rts

importFavoriteModulesFromDisk
	DPRINT	"importFavoriteModulesFromDisk"
	tst.b	favorites(a5)
	bne.b	.enabled
	DPRINT	"->disabled in prefs"
	rts
.enabled

	moveq	#0,d6
	lea	favoriteModuleFileName(pc),a0
	jsr	plainLoadFile
	move.l	d0,d6
	beq.b	.noData
	move.l	d1,d5

	lea favoriteListHeader(a5),a2
	move.l	d6,a3			* start of buffer	
	lea	(a3,d5.l),a4	* end of buffer
	jsr	importModuleProgramFromData
	DPRINT 	"Imported %ld favorite files"

	move.l	d6,a0
	jsr	freemem
.noData
	bra	logFavoriteList


exportFavoriteModulesWithMessage
	pushm	all
	tst.b	favorites(a5)
	beq	.x
	tst.b	favoriteListChanged(a5)
	beq	.x

	* storage for two intuitimes
	lea	-16(sp),sp
	lea	(sp),a0 		* secs
	lea	4(sp),a1		* micros
	lore	Intui,CurrentTime

	jsr	setMainWindowWaitPointer
	jsr	freezeMainWindowGadgets
	lea	.msg(pc),a0
	jsr	printbox
	bra.b	.c
.msg 	dc.b  	"Saving favorites...",0
 even
.c	bsr.b	exportFavoriteModulesToDisk
	* Wait a while so that user can see something happened
.wait
	lea	8(sp),a0		* secs
	lea	12(sp),a1		* micros
	lore	Intui,CurrentTime
	move.l	8(sp),d0
	sub.l	(sp),d0			* secs elapsed
	cmp.l	#1,d0			* this many secs at least
	bhs.b	.done
	moveq	#10,d1			* wait a bit
	lore	Dos,Delay
	bra.b	.wait
.done
	lea	16(sp),sp

	jsr	unfreezeMainWindowGadgets
	jsr	clearMainWindowWaitPointer
	* request full refresh of filebox:
	jsr	forceRefreshList
.x	popm	all
	rts
	
exportFavoriteModulesToDisk
	DPRINT	"exportFavoriteModulesToDisk"
	tst.b	favorites(a5)
	beq.b	.x

	* User is exiting while in fav mode?
	cmp.b 	#LISTMODE_FAVORITES,listMode(a5)
	bne.b	.normalMode
	move.b	moduleListChanged(a5),d0 
	clr.b	moduleListChanged(a5)
	or.b	d0,favoriteListChanged(a5)
.normalMode

	tst.b	favoriteListChanged(a5)
	beq.b	.x
	lea	favoriteModuleFileName(pc),a0
	lea	favoriteListHeader(a5),a1
	jsr 	exportModuleProgramToFileWithSongMetaData
	clr.b	favoriteListChanged(a5)
.x	rts

favoriteModuleFileName
	dc.b	"S:HippoFavorites.prg",0
 even

* Update list node favorite status.
* Used in other list views than the favorites list
* to indicate favorited tunes.
* in:
*  a0 = list node
updateFavoriteStatus:
	tst.b	l_divider(a0)
	bne.b	.skipDivs
	bsr	findFavoriteModule
	* a matching favorite module was found? set flag 
	sne	l_favorite(a0)
    beq.b   .notFav
    * a1 = favorite node

    * If the list item already had a subsong set,
    * do not overwrite it with the saved subsong from favorites.
    * This allows preparing a shared playlist with subsongs
    * that do not get mangled by favorites.
    tst.b   l_favSong(a0)
    bne.b   .notFav
    move.b  l_favSong(a1),l_favSong(a0)
.notFav
.skipDivs
	rts

logFavoriteList
; if DEBUG
;	DPRINT	"Favorite modules:"
;	lea	favoriteListHeader(a5),a0
;.l	TSTNODE	a0,a0
;	beq.b	.x
;	lea	l_filename(a0),a1
;	move.l	a1,d0
;	DPRINT	"%s"
;	bra.b	.l
;.x
; endif
	rts

handleFavoriteModuleConfigChange
	pushm	all

	tst.b	favorites(a5)
	beq.b	.noFavs
	DPRINT	"handleFavoriteModuleConfigChange: enabled"
	
* favorites are enabled.
* - they may have been enabled ealier, or
* - they became enabled just now

* if the list is not empty, this likely means favorites was enabled
* and there is stuff in the list, do nothing
	lea	favoriteListHeader(a5),a0
	IFNOTEMPTY a0,.exit

	DPRINT	"->populating"

* if list is empty, try importing data
	bsr	importFavoriteModulesFromDisk
* then the current list should be updated to contain favorite statuses
	lea	moduleListHeader(a5),a0
.loop
	TSTNODE	a0,a0
	beq.b	.end
	* find if node a0 is in favorite module list
	bsr	findFavoriteModule
	* Use the return status to update favorite status for this node 
	move.b	d0,l_favorite(a0)
	bra.b	.loop
.end
	* refresh list
	bra.b	.refresh

.noFavs
	DPRINT	"handleFavoriteModuleConfigChange: disabled"
	;bsr	disableListModeChangeButton
	cmp.b 	#LISTMODE_FAVORITES,listMode(a5)
	bne.b	.noFav
	* If disabled from prefs must toggle to normal mode
	;bsr.b	toggleListMode
	bsr 	engageNormalMode
.noFav
	
	* favorites are not enabled
	lea	favoriteListHeader(a5),a0
	IFEMPTY a0,.exit
	DPRINT	"->cleaning up"
	* there's some stuff in the list, free it and refresh view
	* l_favorite need not be cleaned since they won't be displayed
	* anyway if feature is disabled
	bsr	freeFavoriteList
.refresh
	jsr	forceRefreshList

.exit
	popm	all 
	rts

********************************************************************************
*** SECTION ********************************************************************
*
* List mode operations
* Layout for the bottom find/search bar 
*
******************************************************************************


storeListModeChosenModule:     
    moveq   #0,d0
    move.b  listMode(a5),d0
    lsl     #2,d0
    lea     normalModeChosenModule(a5),a0
    move.l  chosenmodule(a5),(a0,d0.w)
    rts



toggleListModePopup:
	DPRINT	"List mode"
	lea		toggleListModePopupOptions(pc),a4
	lea		gadgetListModeChangeButton,a0
	move	gg_LeftEdge(a0),d6
	moveq	#20,d7
	add		gg_TopEdge(a0),d7
    moveq   #0,d4
    moveq   #0,d0
    move.b  listMode(a5),d0
	jsr		listSelectorMainWindowPreselect
	bmi.b	.skip
	beq		engageNormalMode
    subq	#1,d0
	beq		engageFavoritesMode
    subq    #1,d0
    beq     engageFileBrowserMode
    subq    #1,d0
    beq     engageSearchResultsMode
.skip
	rts

toggleListModePopupOptions:
	* max width, rows
;	dc.b	12,5
;	dc.b	"Main list   ",0
;	dc.b	"Favorites   ",0
;    dc.b    "File browser",0
;    dc.b    "Search      ",0
;    dc.b    "Shared lists",0
	dc.b	15,4
	dc.b	" Main list    ",0
	dc.b	" Favorites    ",0
    dc.b    " File browser ",0
    dc.b    " Search view  ",0
    even



toggleListMode:
	cmp.b 	#LISTMODE_NORMAL,listMode(a5)
	beq 	engageFavoritesMode
	cmp.b	#LISTMODE_FAVORITES,listMode(a5)
	beq	    engageFileBrowserMode
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	beq		engageSearchResultsMode
	cmp.b	#LISTMODE_SEARCH,listMode(a5)
	beq.b	engageNormalMode	
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	beq 	engageNormalMode
	rts

engageNormalMode:
	DPRINT	"** engage normal"
    pushm	all
    bsr     storeListModeChosenModule
	
	cmp.b	#LISTMODE_NORMAL,listMode(a5)
	beq.b	.skip
	
	cmp.b	#LISTMODE_FAVORITES,listMode(a5)
	bne.b	.wasNotFav

	* List was in favorite mode.
	* Store list changed status, so changes will be saved.
	* Combine with favoritesListChanged, since that may also
	* indicate save status from edits in normal listview.
	move.b	moduleListChanged(a5),d0
	or.b	d0,favoriteListChanged(a5)
	clr.b	moduleListChanged(a5)

.wasNotFav
 	move.b	#LISTMODE_NORMAL,listMode(a5)
    bsr     switchToNormalLayout
	bsr 	engageListMode
.skip
;    bsr     switchToNormalLayout
    popm	all
	rts	

engageFavoritesMode:
	DPRINT	"** engage favorites"
	pushm	all
    bsr     storeListModeChosenModule
	* Moving to favorite mode
	* moduleListChanged must be cleared initially to catch
	* any subsequent user edits.
	clr.b	moduleListChanged(a5)
	move.b	#LISTMODE_FAVORITES,listMode(a5)
    bsr     switchToNormalLayout
	bsr     engageListMode
	popm	all
	rts	


engageSearchResultsMode:
	DPRINT	"** engage search results"
	pushm	all
    bsr     storeListModeChosenModule
	move.b	#LISTMODE_SEARCH,listMode(a5)

    bsr     switchToSearchLayout
	bsr 	engageListMode

    * Special case check
    * Trigger recent playlist fetch if needed.
    tst.l   modamount(a5)
    bne     .1
    cmp.b   #SEARCH_RECENT_PLAYLISTS,selectedSearch(a5)
    bne     .1
    * If last known attempt failed let's not automatically
    * do it here either. Keeps up from ending up in a refresh
    * loop.
 if DEBUG
    tst.b   recentPlaylistsLastSearchFailed(a5)
    beq     .2
    DPRINT  "Last recent playlists search failed!"
.2
 endif
    tst.b   recentPlaylistsLastSearchFailed(a5)
    bne     .1
    jsr     recentPlaylistsSearch
.1  
	popm	all
	rts	



* Common operations to be done after list mode change
engageListMode:
	bsr	setListModeChangeButtonIcon
	bsr	.setButtonStatesAccordingToListMode
	bsr.b	.setListState
	* Playing module should be invalidated,
	* it is not compatible between the two lists.
	tst.l	playingmodule(a5) 
	bmi.b	.not
	move.l	#PLAYING_MODULE_REMOVED,playingmodule(a5)
.not
    rts


.setListState
	* Remove previous list selection
	move.l	#PLAYING_MODULE_NONE,chosenmodule(a5)		

	jsr	obtainModuleList	
	jsr	clearRandomTable
	
	bsr	clearCachedNode
	bsr	getVisibleModuleListHeader
	move.l	a0,a4
	* set d1 to FF if list is in normal mode
	cmp.b	#LISTMODE_NORMAL,listMode(a5)
	seq 	d1
	* set d2 to FF if favorites changed
	tst.b	favoriteListChanged(a5)
	sne	d2
	and.b	d1,d2
	* d2 is now FF is both are true:
	* - list in normal mode
	* - favorites were changed
	* in this case, we must update the favorite status
	* of each list node

	* TODO: kick13 slider4 height is bad
	* TODO: profiling

	* Need to update modamount(a5) and check
	* favourite status if user has edited
	* favorites. Can take a while!
	jsr	setMainWindowWaitPointer
	
	moveq	#0,d3
.count
	TSTNODE a4,a4
	beq.b	.end
	tst.b	d2
	beq.b	.noChange
	move.l	a4,a0
	bsr	updateFavoriteStatus
.noChange
	addq.l	#1,d3
	bra.b	.count
.end
	move.l	d3,modamount(a5)
 if DEBUG
	move.l	d3,d0
	DPRINT	"Modamount=%ld"
 endif

    * Select the item that was chosen last time
    moveq   #0,d1
    move.b  listMode(a5),d1
    lsl     #2,d1
    lea     normalModeChosenModule(a5),a0
    move.l  (a0,d1.w),d1
    cmp.l   d0,d1
    bhi.b   .over
    move.l  d1,chosenmodule(a5)
.over

	jsr	releaseModuleList
	jsr	clearMainWindowWaitPointer
 	jmp	forceRefreshList

.setButtonStatesAccordingToListMode
	lea	gadgets,a4
	basereg	gadgets,a4
	cmp.b	#LISTMODE_NORMAL,listMode(a5)
	beq.b	.normalMode
	cmp.b	#LISTMODE_FAVORITES,listMode(a5)
	beq.b	.favoritesMode
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	beq.b	.browserMode
	cmp.b	#LISTMODE_SEARCH,listMode(a5)
	beq.b	.searchMode
	rts

.normalMode
	bsr		setNormalAddTooltip
	lea	gadgetDelButton(a4),a0
	bsr	enableButtonWithEar
	lea	gadgetNewButton(a4),a0
	bsr	enableButtonWithEar
	lea	gadgetSortButton(a4),a0
	bsr	enableButtonWithEar
	lea	gadgetMoveButton(a4),a0
	bsr	enableButtonWithEar
	lea	gadgetPrgButton(a4),a0
	bra	enableButtonWithEar

.favoritesMode
	;lea	gadgetPrgButton(a4),a0
	;bsr	disableButton
	bra		setNormalAddTooltip
	
.browserMode
	lea	gadgetDelButton(a4),a0
	bsr	disableButton
	lea	gadgetNewButton(a4),a0
	bsr	disableButton
	lea	gadgetMoveButton(a4),a0
	bsr	disableButton
	lea	gadgetPrgButton(a4),a0
	bsr	disableButton
	bra		setFileBrowserAddTooltip

.searchMode
	lea	gadgetNewButton(a4),a0
	bsr	disableButton
	lea	gadgetPrgButton(a4),a0
	bsr	disableButton
	lea	gadgetMoveButton(a4),a0
	bsr	disableButton
	lea	gadgetSortButton(a4),a0
	bsr	enableButtonWithEar
	lea	gadgetDelButton(a4),a0
	bsr	enableButtonWithEar
	bra		setFileBrowserAddTooltip

	endb	a4


setListModeChangeButtonIcon:
    bsr setListModeChangeButtonIconNoRefresh
	lea	gadgetListModeChangeButton,a0
	jmp refreshGadgetInA0

setListModeChangeButtonIconNoRefresh:
	lea	listImage,a0
    lea listImageBig,a1
	cmp.b 	#LISTMODE_NORMAL,listMode(a5)
	beq.b	.set
	lea	favoriteImage-listImage(a0),a0
	lea	favoriteImageBig-listImageBig(a1),a1
	cmp.b 	#LISTMODE_FAVORITES,listMode(a5)
	beq.b	.set
	lea	fileBrowserImage-favoriteImage(a0),a0
	lea	fileBrowserImageBig-favoriteImageBig(a1),a1
	cmp.b 	#LISTMODE_BROWSER,listMode(a5)
	beq.b	.set
	lea	searchImage-fileBrowserImage(a0),a0
	lea	searchImageBig-fileBrowserImageBig(a1),a1
    cmp.b 	#LISTMODE_SEARCH,listMode(a5)
	beq.b	.set
	rts
.set
	* Toggle listmode button icon
    move.w  #7,ig_Height+gadgetListModeChangeButtonImage
    tst.b   altbuttons(a5)
    beq     .66
    move.l  a1,a0
    move.w  #7*2,ig_Height+gadgetListModeChangeButtonImage
.66
	move.l	a0,gadgetListModeChangeButtonImagePtr
    rts

setNormalAddTooltip
	lea		tooltipList\.addButtonToolTipOffset,a0
	lea		tooltipList\.add,a1
	sub.l	a0,a1
	move	a1,(a0)
	rts

setFileBrowserAddTooltip
setSearchAddTooltip
	lea		tooltipList\.addButtonToolTipOffset,a0
	lea		tooltipList\.add2,a1
	sub.l	a0,a1
	move	a1,(a0)
	rts

switchToSearchLayoutIfNeeded:
    DPRINT  "switch to search layout if needed"
    cmp.b   #LISTMODE_SEARCH,listMode(a5)
    beq     switchToSearchLayout
    rts
    
switchToNormalLayoutIfPossible:
    cmp.b   #LISTMODE_SEARCH,listMode(a5)
    beq     .1
    tst.w   searchLayoutActive(a5)
    beq     .2
    DPRINT  "switchToNormalLayoutIfPossible"
    bsr     switchToNormalLayout   
    jmp     forceRefreshList
.1  
    * Search view + local search layout?  
    tst.b   localSearchLayoutActive(a5)
    beq     .2
    DPRINT  "switchToNormalLayoutIfPossible"
    bsr     switchToNormalLayoutNoRefresh
    bsr     switchToSearchLayout
.2  rts

getFontHeightForSearchLayout:
    move    listFontHeight(a5),d0
    tst.b   uusikick(a5)
    bne     .n
    * Kick 1.3 string gadgets use system default font.
    * Assume it is 8 pixels, which it might not be
    moveq   #8,d0
.n
  rts

* Remote search layout:
* search source button, search string gadget
switchToSearchLayout:
    tst.w   BOTTOM_MARGIN(a5)
    bne     .skip

    DPRINT  "switch to search layout"
    st      searchLayoutActive(a5)

    bsr     prepareSearchLayout
    * a2 = gadgetFileSlider

    ; search source gadget

    lea     gadgetSearchSource,a4
    basereg gadgetSearchSource,a4
    move.l  a4,a1

    tst.b   uhcAvailable(a5)
    bne.b   .u1
    or      #GFLG_DISABLED,gg_Flags(a1)
.u1

    move    gg_TopEdge(a2),d1
    add     gg_Height(a2),d1
    addq    #1,d1

    bsr     getFontHeightForSearchLayout
    lsr     #1,d0
    add     d0,d1
    move    d1,gg_TopEdge(a1)

    bsr     getFontHeightForSearchLayout
    addq    #4,d0
    move    d0,gg_Height(a1)

    move.w  gg_LeftEdge(a2),d0
    subq    #1,d0
    move    d0,gg_LeftEdge(a1)
    move    #130,gg_Width(a1)
    move.l  a1,a2

    moveq   #-1,d0 * last
    move.l  windowbase(a5),a0
    lore    Intui,AddGadget

    ; search string gadget

    lea     gadgetSearchString(a4),a1
    move.l  #gadgetSearchStringBuffer,gadgetSearchStringStringInfo(a4)
    move    #GADGET_ID_SEARCH_STRING,gg_GadgetID(a1)

    move    gg_TopEdge(a2),d0
    addq    #2,d0
    move    d0,gg_TopEdge(a1)
    move    WINSIZX(a5),d0
    sub     #146+7,d0
    move    d0,gg_Width(a1)

    bsr     getFontHeightForSearchLayout
    move    d0,gg_Height(a1)

    move    gg_LeftEdge(a2),d0
    add     gg_Width(a2),d0
    addq    #4+2-1,d0
    move    d0,gg_LeftEdge(a1)

    tst.b   uhcAvailable(a5)
    bne.b   .u2
    or      #GFLG_DISABLED,gg_Flags(a1)
.u2

    moveq   #-1,d0 * last
    move.l  windowbase(a5),a0
    lore    Intui,AddGadget

    lea     gadgetSearchSource(a4),a3
    bsr     clearGadgetInA3

    lea     gadgetSearchSource(a4),a0
    jsr     refreshGadgetInA0

    lea     gadgetSearchSource(a4),a3
    bsr     drawButtonFrameMainWindow

    bsr     prepareSearchLayout2

    ; boxin alin pikselirivi j‰‰ p‰ivitt‰m‰tt‰, jos ei tee t‰t‰
;    jsr forceRefreshList
.skip
    rts
    endb    a4

clearGadgetInA3:
	movem	4(a3),d0/d1/d4/d5
	move.l	rastport(a5),a1
    move.l  a1,a0
	move	d0,d2
	move	d1,d3
	moveq	#$0a,d6
	move.l	_GFXBase(a5),a6
	jmp	_LVOClipBlit(a6)

switchToNormalLayoutNoRefresh:
    moveq   #0,d0
    bra     doSwitchToNormalLayout

switchToNormalLayout:
    moveq   #1,d0

doSwitchToNormalLayout:
    pushm   all
    tst     BOTTOM_MARGIN(a5)
    beq     .skip
    DPRINT  "switch to normal layout"
    clr.w   searchLayoutActive(a5)   * .w!

    tst.b   d0
    bne.b   .refresh
    clr.w   BOTTOM_MARGIN(a5)
    bsr     getFontHeightForSearchLayout
    add     d0,d0
    add     d0,gg_Height+gadgetFileSlider
    bra     .1

.refresh
    jsr     drawTextureBottomMargin
    clr.w   BOTTOM_MARGIN(a5)
    jsr     drawFileBoxFrame
    ;;;;jsr     forceRefreshList
    jsr     refreshResizeGadget
 
    bsr     getFontHeightForSearchLayout
    add     d0,d0
    add     d0,gg_Height+gadgetFileSlider
    jsr     drawFileSlider
    clr     slider4oldheight(a5) ; force knob redraw
    jsr     reslider
.1
    bsr     removeSearchLayoutGadgets
.skip
    popm   all
    rts 

removeSearchLayoutGadgets:
    move.l  windowbase(a5),a0
    lea     gadgetSearchString,a1
    lore    Intui,RemoveGadget
    move.l  windowbase(a5),a0
    lea     gadgetSearchSource,a1
    lob     RemoveGadget
    rts


* Does some setup when preparing to switch to search layout
prepareSearchLayout:
    * Set margin to two list lines
    bsr     getFontHeightForSearchLayout
    add     d0,d0
;    tst.b   uusikick(a5)
;    bne.b   .1
;    * Kick 1.3 string gadgets use system default font.
;    * Assume it is 8 pixels, which it might not be
;    moveq   #8+8,d0
;.1
    move    d0,BOTTOM_MARGIN(a5)
    
    * Refresh some gfx accordinly
    jsr     clearBottomMargin
    jsr     drawTextureBottomMargin
    jsr     drawFileBoxFrame

    * File slider height and knob
    move    BOTTOM_MARGIN(a5),d0
    lea		gadgetFileSlider,a0
    push    a0
    sub     d0,gg_Height(a0)
    jsr     drawFileSlider
    clr     slider4oldheight(a5) ; force knob redraw
    jsr     reslider
    pop     a2
    rts

* Do some stuff to finish preparing search layout
prepareSearchLayout2:
    cmp.b   #LISTMODE_SEARCH,listMode(a5)
    bne     .1
    * Update the search source button contents
    bsr     refreshGadgetSearchSource
.1
    jsr     refreshResizeGadget

    lea     gadgetSearchString,a3
    basereg gadgetSearchString,a3
    move.l  a3,a0
    jsr     refreshGadgetInA0

    ; Set up frame for the string gadget

    tst.b   uusikick(a5)
    bne     .n
    * Adjust for kick 1.3
    subq    #1,gg_TopEdge+gadgetSearchString(a3)
.n
	movem	gadgetSearchString+4(a3),plx1/ply1/plx2/ply2

    tst.b   uusikick(a5)
    bne     .n2
    * Adjust for kick 1.3
    addq    #3-2,ply2
    subq    #2,plx2
.n2

	add	plx1,plx2
	add	ply1,ply2
	subq	#2,plx1
	addq	#1,plx2
	subq	#2,ply1
	addq	#1,ply2
	move.l	rastport(a5),a1
	jmp 	sliderlaatikko
    endb    a3

* Local search layout: one string gadget
switchToLocalSearchLayout:
    bsr     switchToNormalLayoutNoRefresh

    tst.w   BOTTOM_MARGIN(a5)
    bne     .skip

    DPRINT  "switch to local search layout"
    st      localSearchLayoutActive(a5)

    bsr     prepareSearchLayout
    * a2 = gadgetFileSlider

    lea     gadgetSearchSource,a4
    basereg gadgetSearchSource,a4

    ; search string gadget

    lea     gadgetSearchString(a4),a1
    move.l  #gadgetLocalSearchStringBuffer,gadgetSearchStringStringInfo(a4)
    move    #GADGET_ID_LOCAL_SEARCH_STRING,gg_GadgetID(a1)
    move    gg_TopEdge(a2),d1
    add     gg_Height(a2),d1
    addq    #3,d1
    
    bsr     getFontHeightForSearchLayout
    lsr     #1,d0
    add     d0,d1
    move    d1,gg_TopEdge(a1)
    
    move    WINSIZX(a5),d0
    sub     #20-1,d0
    move    d0,gg_Width(a1)
    tst.b   uusikick(a5)
    bne     .n
    * For kick 1.3 use a fixed width. There the full width is
    * not cleared, only the amount of characters that fit.
    move    #242+4,gg_Width(a1)
.n

    bsr     getFontHeightForSearchLayout
    move    d0,gg_Height(a1)

    move    gg_LeftEdge(a2),d0
    move    d0,gg_LeftEdge(a1)

    moveq   #-1,d0 * last
    move.l  windowbase(a5),a0
    lore    Intui,AddGadget

    bsr     prepareSearchLayout2
    jsr     activateSearchStringGadget

.skip
    rts
    endb    a4



refreshGadgetSearchSource:
    move.b  selectedSearch(a5),d0
    lea     gadgetSearchSourceOption1,a0
.find   
    tst.b   d0
    beq     .found
.ff tst.b   (a0)+
    bne.b   .ff
    subq.b  #1,d0
    bra     .find
.found
 if DEBUG
    move.l  a0,d0
    DPRINT  "selected=%s"
 endif

    lea     gadgetSearchSource,a4
    basereg gadgetSearchSource,a4

    move.l  a0,gadgetSearchSourceTextPtr(a4)    
    ; ---------------------------------
	move.l	rastport(a5),a1
	move.l	listfontbase(a5),a0
	lore	GFX,SetFont	

    move.l  a4,a1
    jsr     centerGadgetText

	move.l	rastport(a5),a1
	move.l	fontbase(a5),a0
	lore	GFX,SetFont	
    ; ---------------------------------
    lea     gadgetSearchSource(a4),a3
    jsr     clearGadgetInA3
    ; ---------------------------------
    lea     gadgetSearchSource(a4),a0
    jsr     refreshGadgetInA0

    lea     gadgetSearchSource(a4),a3
    jsr     drawButtonFrameMainWindow

    cmp.b   #SEARCH_RECENT_PLAYLISTS,selectedSearch(a5)
    bne     .1
    lea     gadgetSearchString(a4),a0
    jmp     disableGadget
   ;;; rts
    ;;;;;;;jmp     recentPlaylistsSearch
.1
    tst.b   uhcAvailable(a5)
    bne.b   .2
    rts
.2
    lea     gadgetSearchString(a4),a0
    and	    #~GFLG_DISABLED,gg_Flags(a0)
    jmp     refreshGadgetInA0
    endb    a4

activateSearchStringGadget:
    lea     gadgetSearchString,a0
    move.l  windowbase(a5),a1
    sub.l   a2,a2
    lore    Intui,ActivateGadget
    rts


; -------------------------------------

togglePlayMode:
    DPRINT  "togglePlayMode"
    move.b  playmode(a5),d0     * previous
    addq.b  #1,playmode(a5)
    cmp.b   #pm_max,playmode(a5)
    ble     .1
    move.b  #1,playmode(a5)
.1
    cmp.b   #pm_repeat,d0
    beq     .3
    cmp.b   #pm_repeat,playmode(a5)
    bne     .2
.3 
     jsr     forceRefreshList
.2

setPlayModeChangeButtonIcon:
    bsr setPlayModeChangeButtonIconNoRefresh
	lea	gadgetPlayModeChangeButton,a0
	jmp refreshGadgetInA0

setPlayModeChangeButtonIconNoRefresh:
    move.b  playmode(a5),d0
    lea     playModeRepeatListImage,a0
    subq.b  #1,d0
    beq     .set
    lea     playModePlayListImage-playModeRepeatListImage(a0),a0
    subq.b  #1,d0
    beq     .set
    lea     playModeRepeatModuleImage-playModePlayListImage(a0),a0
    subq.b  #1,d0
    beq     .set
    lea     playModePlayModuleImage-playModeRepeatModuleImage(a0),a0
    subq.b  #1,d0
    beq     .set
    lea     playModeRandomImage-playModePlayModuleImage(a0),a0
.set
	move.l	a0,gadgetPlayModeChangeButtonImagePtr
    rts


togglePlayModePopup:
	DPRINT	"Play mode"
	lea		togglePlayModePopupOptions,a4
	lea		gadgetPlayModeChangeButton,a0
	move	gg_LeftEdge(a0),d6
	moveq	#20,d7
	add		gg_TopEdge(a0),d7
    moveq   #0,d4
    moveq   #0,d0
    move.b  playmode(a5),d0
    subq.b  #1,d0
	jsr		listSelectorMainWindowPreselect
	bmi.b	.skip
	addq.b	#1,d0
	move.b	d0,playmode(a5)
    bsr     setPlayModeChangeButtonIcon
    jmp     forceRefreshList
.skip
	rts



********************************************************************************
*** SECTION ********************************************************************
*
* Save state operations
* - module list
* - list mode
* - chosen module
* - play status
*
*******************************************************************************

importSavedStateModulesFromDisk:
    tst.b   win(a5)  * do nothing if no window
    beq     .error
	tst.b	savestate(a5)
	bne.b	.enabled
.error	rts

.enabled
	DPRINT	"importSavedStateModulesFromDisk"
	lea	savedStateModuleFileName(pc),a0
 	jsr	plainLoadFile
	move.l	d0,d6	* address
	beq.b	.error
	move.l	d1,d7

	lea moduleListHeader(a5),a2
	move.l	d6,a3		* start of buffer	
	lea	(a3,d7.l),a4	* end of buffer
	jsr	importModuleProgramFromData
	DPRINT 	"Imported %ld files"

	move.l	d6,a0
	jsr	freemem

	* Can be zero
	move.l	d0,modamount(a5)
	
	pushpea	savedStateModuleFileName(pc),d1
	moveq	#ACCESS_READ,d2
	lore	Dos,Lock
	move.l	d0,d4
	beq.b	.noLock
	move.l	d4,d1
	pushpea	fileinfoblock(a5),d2
	lob	Examine
	move.l	d4,d1
	beq.b	.noLock
	lob	UnLock
	lea	fileinfoblock+fib_Comment(a5),a0
 if DEBUG
	move.l	a0,d0
	DPRINT	"State=%s"
 endif
	cmp.b	#" ",8(a0)
	beq.b	.parse
.noLock
.exit
.none
	* Avoid refreshing the box if nothing to be seen,
	* this will leave the "Registered..." text visible.
	tst.l	modamount(a5)
	beq.b	.0
	jsr	resh
.0	rts


.parse
* "00000000 00 abc"
* convert into number
	moveq	#0,d3
	moveq	#28,d1
	moveq	#8-1,d2
.loop
	moveq	#0,d0
	move.b	(a0)+,d0
	cmp.b	#"A",d0
	bhs.b	.hi 
	sub.b	#"0",d0
	bra.b	.lo
.hi
	sub.b	#"A"-10,d0
.lo
	lsl.l	d1,d0
	or.l	d0,d3
	subq.l	#4,d1
	dbf	d2,.loop

	* check play/no play
	cmp.b	#"1",1(a0)
	seq	d7

	* check list mode!
	* switch mode before setting chosen module
	* chosenmodule will be reset otherwise.
	cmp.b	#"1",2(a0)
	beq.b	.favMode
	cmp.b	#"2",2(a0)
	beq.b	.browserMode
	cmp.b	#"3",2(a0)
	beq.b	.searchMode
	* default
	bsr	engageNormalMode
	bra.b	.engaged
.favMode
	bsr	engageFavoritesMode
	bra.b	.engaged
.searchMode
    bsr     engageSearchResultsMode
    bra     .engaged
.browserMode
	bsr	engageFileBrowserMode
	cmp.b	#" ",3(a0)
	bne.b	.engaged
	tst.b	4(a0)
	beq.b	.engaged
	* Pass path into a0
	addq	#4,a0
	pushm	d3/d7
	bsr	fileBrowserDirWithPath	
	popm	d3/d7
	bra.b	.fbInit

.engaged

	cmp.b	#" ",3(a0)
	bne.b	.noPath
	tst.b	4(a0)
	beq.b	.noPath

	lea	4(a0),a1
	move.l	a1,a2
.fl	tst.b	(a2)+
	bne.b	.fl
	
	move.l	a2,d0
	sub.l	a1,d0 
	moveq	#MEMF_PUBLIC,d1
	jsr	getmem
	move.l	d0,lastStoredFileReqDirectory(a5) 
	beq.b	.noPath
	move.l	d0,a0
.copy
	move.b	(a1)+,(a0)+
	cmp.l	a2,a1
	bne.b	.copy

	DPRINT	"Saved filereq path=%s"

.noPath
.fbInit
	tst.l	d3
	bmi.b	.neg
	move.l	d3,chosenmodule(a5)
.neg

	* Finally, either just refresh or play.
	tst.b	d7
	beq	.exit
	jsr	resh
	tst.l	modamount(a5)
	beq.b	.empty
    * Special case: if there are mods from cli args do not
    * start the stored module, as user want to start the cli added mod.
    tst.l	sv_argvArray+4(a5)
    bne     .empty
	jmp	playButtonAction
.empty
	rts

exportSavedStateModulesToDisk
	DPRINT	"exportSavedStateModulesToDisk"
    tst.b   win(a5)
    beq     .x
	tst.b	savestate(a5)
	beq	.x

	lea	savedStateModuleFileName(pc),a0
	lea	moduleListHeader(a5),a1
	jsr 	exportModuleProgramToFile

	* Formatting parameters into d0,d1,d2,d3

	* Store current file browser dir, if
	* currently in browser mode
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	bne.b	.notBrowser
	move.l	fileBrowserCurrentDirLock(a5),d1
	beq.b	.notBrowser

	pushpea	probebuffer(a5),d2	* temp buffer
	move.l	#200,d3
	bsr		getNameFromLock
	tst.l	d0
	beq.b	.notBrowser
	pushpea	probebuffer(a5),d3
	bra.b	.yesDir
.notBrowser

	* Store last used dir as well
	* Try the reqtools dir first
	move.l	req_file(a5),d3
	beq.b	.doEmpty
	move.l	d3,a0
	move.l	rtfi_Dir(a0),d3
	bne.b	.yesDir
.doEmpty
	* ..then the previously stored one
	move.l	lastStoredFileReqDirectory(a5),d3
	bne.b	.yesDir
	pushpea	.empty(pc),d3
.yesDir

	* Store playing state and chosen module into comment
	move.l	chosenmodule(a5),d0

	moveq	#0,d1
	tst.l	playingmodule(a5)
	bmi.b	.no
	moveq	#1,d1
.no
	
* Store list mode
	moveq	#0,d2
	move.b	listMode(a5),d2

	lea	.comment(pc),a0
	lea	probebuffer(a5),a1 	* nice temp buffer
	jsr	desmsg

 if DEBUG 
	pushpea desbuf(a5),d0
	DPRINT	"->%s"
 endif

	pushpea	savedStateModuleFileName(pc),d1
	pushpea	desbuf(a5),d2
	lore	Dos,SetComment

.x	rts

* <chosenmodule< <play/noplay><listmode> <filereq path> 
.comment	dc.b	"%08lx %ld%ld %s"
.empty		dc.b	0
		even

savedStateModuleFileName
	dc.b	"S:HippoSavedList.prg",0
 even

********************************************************************************
*** SECTION ********************************************************************
*
* File browser mode operations
*
********************************************************************************

freeFileBrowserList
	push	a6
	move.l	(a5),a6		* execbase
	lea	fileBrowserListHeader(a5),a2
.loop
	* a0: list, a1: destroyed, d0: node, or zero
	move.l	a2,a0
	lob	RemHead
	beq.b	.listFreed
	move.l	d0,a0
	jsr	freemem
	bra.b	.loop
.listFreed
	cmp.b	#LISTMODE_BROWSER,listMode(a5)
	bne.b	.noB
	clr.l	modamount(a5)
.noB	pop	a6
	rts

countFileBrowserFiles
	jsr	obtainModuleList
	lea	fileBrowserListHeader(a5),a0
	moveq	#0,d0
.loop
	TSTNODE	a0,a0
	beq.b	.x
	addq.l	#1,d0
	bra.b	.loop
.x
	jmp	releaseModuleList

engageFileBrowserMode:
	DPRINT	"** engage file browser"
	pushm	all
    bsr     storeListModeChosenModule
	move.b	#LISTMODE_BROWSER,listMode(a5)
	bsr.b	countFileBrowserFiles
	move.l	d0,modamount(a5)
    bsr     switchToNormalLayout
	bsr	    engageListMode
	tst.l	modamount(a5)
	bne.b	.notRootView
	moveq	#0,d0	* initial chosen item
	bsr.b	fileBrowserRoot
.notRootView
	popm	all
	rts

* Fill root level entries with volume names
* in:
*   d0 = chosen item index
fileBrowserRoot
	DPRINT	"file browser root, select=%ld"
	push	d0
	jsr	setMainWindowWaitPointer
	jsr	obtainModuleList
	clr	fileBrowserSelectionHistoryIndex(a5)
	bsr	freeFileBrowserList

	* According to the Amiga Guru Book, access to dl_Root
	* should always be protected as it may change.
	lore	Exec,Forbid

	move.l	_DosBase(a5),a0
	move.l	dl_Root(a0),a0
	move.l	rn_Info(a0),d0
	lsl.l	#2,d0
	move.l	d0,a0
	move.l	di_DevInfo(a0),d5
.devloop
	lsl.l	#2,d5
	move.l	d5,a3
	
	* Only grab volumes
	cmp.l	#DLT_VOLUME,dl_Type(a3)
	bne.b	.next

	move.l	dl_Name(a3),d1
	lsl.l	#2,d1
	move.l	d1,a2
	moveq	#0,d2
	move.b	(a2)+,d2

	* Add extra space for ":" and NULL
	moveq	#l_size+2,d0	
	add.l	d2,d0
	move.l	#MEMF_CLEAR,d1
	jsr	getmem
	beq.b	.error

	move.l	d0,a1
	lea	l_filename(a1),a0
	move.l	a0,l_nameaddr(a1)
	st	l_divider(a1)
	subq	#1,d2
.copyName
	move.b	(a2)+,(a0)+
	dbf	d2,.copyName
	move.b	#":",(a0)+
	clr.b	(a0)

	jsr	getVisibleModuleListHeader
	ADDTAIL	* add node (a1)
	addq.l	#1,modamount(a5)
.next
	move.l	dl_Next(a3),d5
	bne.b	.devloop

.error

	lore	Exec,Permit

	* Does not do force refresh
	jsr	sortModuleList

	* Select item
	pop	d0
	move.l	d0,chosenmodule(a5)
	jsr	forceRefreshList
	
	jsr	releaseModuleList
	jmp	clearMainWindowWaitPointer


* Enters a given directory 
* in:
*    a0 = path
fileBrowserDirWithPath
	moveq	#-1,d4
	move.l	a0,d1
	bra.b	fileBrowserDir\.plainPath

* Enters a directory denoted by the given list node, which is a divider
* in:
*    a3 = parent node
fileBrowserDir
 if DEBUG
	pushpea	l_filename(a3),d0
	move.l	chosenmodule(a5),d1
	DPRINT	"fileBrowserDir %s at %ld"
 endif
	* Chosen module status in d4
	moveq	#-1,d4
	move.l	a3,a0
	bsr	isFileBrowserParentNode
	beq.b	.notParent
 if DEBUG
 	pushpea	l_filename(a3),d0
 	move.l	l_nameaddr(a3),d1
	DPRINT	"->ENTERING parent %s -> %s"
 endif
	* When entering parent pop the selection from history
	bsr	popFileBrowserSelectionHistoryItem
	move.l	d0,d4
.notParent

	* Path to d1
	pushpea	l_filename(a3),d1

	* Check if empty path, this means the root level
	tst.b	l_filename(a3)
	beq	fileBrowserRoot

.plainPath
	jsr	obtainModuleList
	jsr	setMainWindowWaitPointer
	jsr	tokenizepattern

	tst.l	d4
	bpl.b	.goingToParent
	* Entering a new dir, push previous selection,
	bsr	pushFileBrowserSelectionHistoryItem
	* ... then select first item.
	moveq	#0,d4
.goingToParent
	* d4 and d5 flow to the end
	moveq	#0,d5	* initial value

	* Start reading dir
	* path in d1
	moveq	#ACCESS_READ,d2
	lore	Dos,Lock
	move.l	d0,d6
	beq	.error0

	move.l	d6,d1
	pushpea	fileinfoblock(a5),d2
	lob	Examine
	tst.l	d0
	beq	.error0

	* Copy lock for state saving
	move.l	fileBrowserCurrentDirLock(a5),d1
	beq.b	.1
	lob	UnLock
.1 	move.l	d6,d1
	lob	DupLock
	move.l	d0,fileBrowserCurrentDirLock(a5)

	* Empty whatever we had previously
	bsr	freeFileBrowserList

	*********************************************
	* Construct "Parent"
	*********************************************
	
	* NULL lock means the "SYS:"
	move.l	d6,d1
	lore	Dos,ParentDir
	move.l	d0,d7
		
	lea	-200(sp),sp
	move.l	d0,d1		* lock
	bne.b	.notNull
	* NULL lock, clear the path to indicate this
	clr.b	(sp)
	bra.b	.ok
.notNull
	move.l	sp,d2		* buf
	move.l	#200,d3		* len
	bsr	getNameFromLock
	push	d0
	move.l	d7,d1
	lore 	Dos,UnLock
	pop	d0
	tst.l	d0
	bne.b	.ok
	lea	200(sp),sp
	bra	.error0

.ok
	* Create parent entry 

	move.l	sp,a0
	moveq	#createNode\.PARENT,d7	 * make parent node
	bsr	createNode
	lea	200(sp),sp
	tst.l	d0
	beq	.error0

	bsr	makeParentNode
	* store parent node into d5 for a while
	move.l	a0,d5
	
	*********************************************
	* Dir scan
	*********************************************

	* Build base path
	lea	-200(sp),sp
	move.l	d6,d1		* lock
	move.l	sp,d2		* buf
	move.l	#160,d3		* len, leave 40 for filename
	bsr	getNameFromLock
	tst.l	d0
	beq.b	.lockFail

	move.l	sp,a0
.findEnd
	tst.b	(a0)+
	bne.b	.findEnd
	subq	#1,a0		* back to NULL

	cmp.b	#":",-1(a0)
	beq.b	.isSep
	cmp.b	#"/",-1(a0)
	beq.b	.isSep
	move.b	#"/",(a0)+
.isSep
	* Path address
	move.l	sp,a3
	* Filename part start position
	move.l	a0,a4

.scan
	move.l	d6,d1
	pushpea	fileinfoblock(a5),d2
	lore	Dos,ExNext
	tst.l	d0
	beq.b	.scanDone

	move.l	fib_DirEntryType+fileinfoblock(a5),d0
	cmp.l	#ST_FILE,d0
	beq.b	.file
	cmp.l	#ST_LINKFILE,d0
	beq.b	.file
	cmp.l	#ST_USERDIR,d0
	bne.b	.scan
	moveq	#createNode\.DIR,d7	* dir
	bra.b	.plzDo

.file
	tst.b	uusikick(a5)
	beq.b	.oldKick
	pushpea	tokenizedpattern(a5),d1
	pushpea	fib_FileName+fileinfoblock(a5),d2
	lore	Dos,MatchPatternNoCase
	* 0 = did not match, skip this file if so
	tst.l	d0
	beq.b	.scan
.oldKick
	moveq	#createNode\.FILE,d7	* file
.plzDo
	bsr.b	.doEntry
	bne.b	.scan	* stop on error

.scanDone
.lockFail
	lea	200(sp),sp
.error0

	move.l	d6,d1
	beq.b	.noLock
	lore	Dos,UnLock
.noLock

	* HACK! If playmode(a5) is pm_random, this happens:
	* sortModuleList -> listChanged -> clear_random ->
	* showNames. The sorted list is updated, then
	* the header is added, and another refresh is done.
	* This causes flicker and also the selected item
	* focus can become off-by-one.
	* Temporarily disable the random mode to prevent this.
	 
	move.b	playmode(a5),d6
	move.b	#pm_repeat,playmode(a5)

	* All done. Sort it. 
	* Does not do force refresh.
	* Destroys every register known to man.
	pushm	d4/d5/d6
	jsr	sortModuleList
	popm	d4/d5/d6

	* Restore iiiiit	
	move.b	d6,playmode(a5)
	
	* Insert parent to the top
	tst.l	d5
	beq.b	.noParent
	jsr	getVisibleModuleListHeader
	* get parent node
	move.l	d5,a1
	* Insert a1 into a0
	lore	Exec,AddHead
	addq.l	#1,modamount(a5)
.noParent

	* Figure out if the chosen module.
	* Eg, returning from "parent" to a correct item.
 	move.l	d4,chosenmodule(a5)
	jsr	forceRefreshList
	
	jsr	releaseModuleList
	jmp	clearMainWindowWaitPointer

* Creates a list node and adds it to the list
* in:
*   a3 = Path start address
*   a4 = Filename start address in the path
*   d6 = parent lock
*   d7 = 0 = file, 1 = dir
*   fileinfoblock: File to add
* out:
*   d0: 1 = ok, 0 = error
.doEntry	
	* copy current filename part, from ExNext
	lea	fib_FileName+fileinfoblock(a5),a1
	move.l	a4,a2
.cp2
	move.b	(a1)+,(a2)+
	bne.b	.cp2

	move.l	a3,a0
	* Create node using path in a0
	bsr createNode
	beq.b	.error_

	pushm	a3/a4
	move.l	a0,a3
	pushpea	l_filename(a3),d0
	jsr	addfile
	popm	a3/a4
	moveq	#1,d0	* ok
	rts
.error_
	moveq	#0,d0 	* failboat
	rts


fileBrowserGoToParent
	DPRINT	"Go to parent"
	* Get the 1st node
	moveq	#0,d0
	jsr	getListNode
	beq.b	.x
	move.l	a0,a3	* save this
	bsr.b	isFileBrowserParentNode
	beq.b	.x
	* Enter into node a3
	bsr	fileBrowserDir
.x
	rts

* Checks if this node is a "Parent" node
* in:
*   a0 = node
* out:
*   d0 = 1 if was a parent node, 0 otherwise
isFileBrowserParentNode
	cmp.b	#$7f,l_divider(a0)
	bne.b	.not
	moveq	#1,d0	* true
	rts
.not
	moveq	#0,d0	* false
	rts

* Make node a parent directory node
* in:
*   a0 = node
makeParentNode
	push	a0
	pushpea	fib_FileName+fileinfoblock(a5),d0
	lea	.form(pc),a0
	jsr	desmsg
	pop	a0

	lea	l_filename(a0),a1
.end	tst.b	(a1)+
	bne.b	.end
	move.l	a1,l_nameaddr(a0)
	lea	desbuf(a5),a2
.cp	move.b	(a2)+,(a1)+
	bne.b	.cp
 
	* magic: indicate parent divider/dir with $7f,
	* normal divider/dir is $ff.
	move.b	#$7f,l_divider(a0)

 if DEBUG
	pushpea	l_filename(a0),d0
	move.l	l_nameaddr(a0),d1
	DPRINT	"makeParentNode path=%s->`%s`"
 endif
	rts

.form	dc.b	"´´´ %s",0
 even


* in:
*   a0: path
*   d7: 0 = file, 1 = dir, 2 = parent dir
* out:
*   a0: new node
*   d0: 1 on success, 0 on out-of-mem
createNode
.FILE = 0
.DIR = 1
.PARENT = 2

	move.l	a0,d1
	move.l	d7,d0

	move.l	a0,a2
.len
	tst.b	(a0)+
	bne.b	.len
	sub.l	a2,a0
	add	#l_size,a0
	cmp.b	#.PARENT,d7
	bne.b	.notPar
    * parent item, add
    * additional space for list item name, to be safe use maximum
    * based on what fileinfoblock can hold
	add     #108,a0	
.notPar
	move.l	a0,d0
	move.l	#MEMF_CLEAR,d1
	jsr	getmem
	beq.b	.memErr
	move.l	d0,a0

	* copy path
	lea	l_filename(a0),a1

	tst.b	d7
	beq.b	.notDiv
	st	l_divider(a0)
.notDiv

.copy	move.b	(a2)+,(a1)+
	bne.b	.copy

	* find file name
	lea	l_filename(a0),a2
.findFile
	cmp.b	#"/",-1(a1)
	beq.b	.found
	cmp.b	#":",-1(a1)
	beq.b	.found
	subq	#1,a1
	cmp.l	a2,a1
	bne.b	.findFile
.found	
	move.l	a1,l_nameaddr(a0)
	moveq	#1,d0
	rts
.memErr
	moveq	#0,d0
	rts

* Keeps track of indexes of entered directories.
pushFileBrowserSelectionHistoryItem
	move	fileBrowserSelectionHistoryIndex(a5),d0
 	cmp	#FILEBROWSER_HISTORY_SIZE,d0
	bhs.b	.full
	lea	fileBrowserSelectionHistory(a5),a0
 	lsl	#2,d0
	move.l	chosenmodule(a5),(a0,d0)
 	addq	#1,fileBrowserSelectionHistoryIndex(a5)
.full
	rts

* Pops the last item out.
popFileBrowserSelectionHistoryItem
	move	fileBrowserSelectionHistoryIndex(a5),d0
	subq	#1,d0
	bpl.b	.ok
	DPRINT	"Browser history underflow"
	moveq	#0,d0
	rts
.ok
	move	d0,fileBrowserSelectionHistoryIndex(a5)
 	lsl	#2,d0
	lea	fileBrowserSelectionHistory(a5),a0
	add	d0,a0
	move.l	(a0),d0
	clr.l	(a0)
 	rts


;parentNodeLabel
;	dc.b 	"  ´´´´´´´ Parent ªªªªªªªª  "
;		    ;0123456789123456789012345678
;	even

*******************************************************************************
* CreatePort
*******
createport
	movem.l	a0-a2,-(sp)
	lea	audioport(a5),a0
	move.l	a0,a2
	lea	MP_SIZE(a0),a1
.clr	clr	(a0)+
	cmp.l	a1,a0
	bne.b	.clr
	move.l	owntask(a5),MP_SIGTASK(a2)
	move.b	audioPortSignal(a5),MP_SIGBIT(a2)
	move.b	#NT_MSGPORT,LN_TYPE(a2)
	clr.l	LN_NAME(a2)
	move.b	#PA_SIGNAL,MP_FLAGS(a2)
	lea	MP_MSGLIST(a2),a0
	NEWLIST	a0
	movem.l	(sp)+,a0-a2
	rts

*******
* CreateIO
*******
createio
	movem.l	a0-a2,-(sp)
	lea	iorequest(a5),a0
	move.l	a0,a2
	lea	ioa_SIZEOF(a0),a1
.clr	clr	(a2)+
	cmp.l	a1,a2
	bne.b	.clr
	lea	audioport(a5),a1
	move.l	a1,MN_REPLYPORT(a0)
	move.b	#NT_MESSAGE,LN_TYPE(a0)
	move	#ioa_SIZEOF,MN_LENGTH(a0)
	movem.l	(sp)+,a0-a2
	rts

***************************************************************************
* getNameFromLock
* DOS library NameFromLock is originally a V36 function. 
* Here's a port ofthe  V40 implementation that works on older 
* kickstarts.
* in:
*   d1 = lock
*   d2 = output buffer
*   d3 = max length of output buffer, will fail if not enough
* out:
*   d0 = 1 success, 0 failure
*******
getNameFromLock:
.true		equ	1
.false		equ	0
.return		equr	d5
.fl_lock	equr	d6
.fl_lock2	equr	d7
.fib		equr	d4

	tst.l 	d1
	bne.b	.lockOk
	DPRINT	"NULL lock!"
	* A NULL lock is valid and will return "SYS:" or similar, but
	* it is not ok in Hippo context.
	moveq	#.false,d0
	rts
.lockOk

	pushm 	d1-a6
	* It's all DOS, baby
	move.l	_DosBase(a5),a6
	tst.b	uusikick(a5)
	beq.b	.old
	lob     NameFromLock
 if DEBUG
	bne.b	.ok_
	DPRINT	"NameFromLock FAILED!"
.ok_
 endif	
 	tst.l	d0
	popm	d1-a6
	rts
.old

	* Use this one as the working fib, probably fine.
	pushpea	fileinfoblock2(a5),.fib

	* save start of output buffer to a3 for later
	move.l	d2,a3	

	* initial return code status: false
	moveq	#.false,.return

	* clear output buffer
	move.l	d3,d0			
	subq.l	#1,d0	* dbf length
	move.l	a3,a4	
.clr
	clr.b	(a4)+
	dbf	d0,.clr
	subq.l	#1,a4	* leave one zero at the end for safety

	* start filling a4 from the end

	* First, copy the lock
	lob 	DupLock
	move.l	d0,.fl_lock
.loop	
	move.l	.fl_lock,d1
	lob  	ParentDir
	move.l	d0,.fl_lock2
	beq.b	.loopEnd

	move.l	.fl_lock,d1
	move.l	.fib,d2
	lob 	Examine
	tst.l	d0
	beq.b	.cleanup
	
	* add separator if needed
	tst.b	(a4)
	beq.b	.noSep
	cmp.l	a3,a4		* space check!
	beq.b	.noSpace
	move.b	#'/',-(a4)
.noSep
	move.l	.fib,a0
	lea	fib_FileName(a0),a0
	move.l	a0,a1
.findEnd
	tst.b	(a0)+
	bne.b	.findEnd
	subq.l	#1,a0	* backtrack to NULL
.copyPart
	cmp.l	a3,a4		* space check!
	beq.b	.noSpace
	move.b	-(a0),-(a4)
	cmp.l	a0,a1
	bne.b	.copyPart
	
	* done with this lock, go looping
	move.l	.fl_lock,d1
	lob UnLock

	move.l .fl_lock2,.fl_lock
	bra.b	.loop
.loopEnd
	* next comes the name for the device
	cmp.l	a3,a4		* space check!
	beq.b	.noSpace
	move.b	#':',-(a4)

	* Dig into the lock, first convert BPTR to APTR.
	move.l	.fl_lock,a0
	add.l	a0,a0 
	add.l 	a0,a0
	move.l 	fl_Volume(a0),a0
	* a0 = BPTR to DevList
	add.l	a0,a0 
	add.l 	a0,a0
	move.l	dl_Name(a0),a0
	* a0 = BPTR to name, should be null terminated.
	* Check if true also on V34? Use the BCPL
	* string length, that should be good.
	add.l	a0,a0 
	add.l 	a0,a0
	
	moveq	#0,d0
	move.b	(a0)+,d0 * read BCPL string length
	move.l	a0,a1 	* keep the start address for loop

	* Skip to end of string
	add.l	d0,a0

.copyPart2
	cmp.l	a3,a4		* space check!
	beq.b	.noSpace
	move.b	-(a0),-(a4)
	cmp.l	a0,a1
	bne.b	.copyPart2	

	* all done!
	* move the resulting string to the front of the buffer.
	* here a3 and a4 point to the same buffer 

.move
	move.b	(a4)+,(a3)+
	bne.b	.move


	* indicate success
	moveq 	#.true,.return
.noSpace
.cleanup
	move.l	.fl_lock,d1
	lob UnLock
	
	* return status
	move.l	.return,d0
 if DEBUG
	bne.b	.ok 
	DPRINT	"GetNameFromLock FAILED!"
.ok
 endif	

	popm 	d1-a6
	tst.l 	d0
	rts


***************************************************************************
* Takes a file path and normalizes it by replacing
* logical names/assigns with actual drive names.
* It will transform path parts such as "SYS:"
* into drive names like "A500-HD:".
* In case of error original path remains untouched. 
* in:
*   d1 = pointer to path
* out:
*   path given in d1 is replaced, should contain space for growing

normalizeFilePath
 	pushm	all
 if DEBUG
	move.l	d1,d0
	DPRINT	"Normalizing: %s"
 endif
	move.l	d1,d7

 	;pushpea	tempdir(a5),d1
	moveq	#ACCESS_READ,d2
	lore  	Dos,Lock
	move.l	d0,d4
	beq.b	.noLock1
	lea	-200(sp),sp
	move.l	d4,d1
	move.l	sp,d2
	move.l	#200,d3
	bsr  	getNameFromLock
	tst.l	d0 
	beq.b	.noName
	move.l	sp,a0
	;lea		tempdir(a5),a1
	move.l	d7,a1
.copyPath
	move.b	(a0)+,(a1)+
	bne.b	.copyPath
	cmp.b	#':',-2(a1)
	beq.b	.isDrive
	move.b	#'/',-1(a1)
	clr.b	(a1)
.isDrive
.noName
	lea	200(sp),sp
	move.l	d4,d1
	lob 	UnLock
 if DEBUG
	move.l	d7,d0
	DPRINT	"to: %s"
 endif
.noLock1
	popm	all
	rts

***************************************************************************
* Insertion sort of string pointer array 
*
* in:
*  a0 = array of string pointers
*  d0 = length of the array, unsigned 16-bit
* out:
*  a0 = sorted array
sortStringPtrArray
	cmp	#1,d0
	bls.b	.x
	pushm	d1/d2/d3/d6/d7/a1/a2
	moveq	#1,d1 
.sortLoopOuter
	move	d1,d2
.sortLoopInner
	move	d2,d3
	lsl	#2,d3
	movem.l	-4(a0,d3),a1/a2
.strCmp 
	move.b	(a1)+,d6
	move.b	(a2)+,d7
	cmp.b	d6,d7
	blo.b	.swap
	tst.b	d6
	beq.b	.exitLoop
	tst.b	d7
	beq.b	.exitLoop
	cmp.b	d6,d7
	beq.b	.strCmp
	cmp.b	d6,d7
	bhi.b	.exitLoop
.swap
	movem.l	-4(a0,d3),a1/a2
	exg	a1,a2
	movem.l	a1/a2,-4(a0,d3)
	
	subq	#1,d2
;	bra.b 	.sortLoopInner
	bne.b	.sortLoopInner	
.exitLoop
	addq	#1,d1
	cmp 	d0,d1
	bne.b 	.sortLoopOuter
	popm	d1/d2/d3/d6/d7/a1/a2
.x	rts


*******************************************************************************
*** SECTION *******************************************************************
*
* Replay routines
* Related support functions
*
*******************************************************************************



*******************************************************************************
* Audio allocation
*******************************************************************************

varaa_kanavat:
	tst.b	kanavatvarattu+var_b
	beq.b	.jee
	moveq	#0,d0
	rts
.jee	
	movem.l	d1-a6,-(sp)
	lea	var_b,a5

	move.l	playerbase(a5),a0
	move	p_liput(a0),d0
	btst	#pb_ahi,d0
	beq.b	.naa
	tst.b	ahi_use_nyt(a5)
	bne.b	.na
.naa

	bsr	createport
	bsr	createio

	lea	iorequest(a5),a1
	lea	.adname(pc),a0
	moveq	#0,d0
	moveq	#0,d1
	moveq	#100,d7
	tst.b	nastyaudio(a5)
	beq.b	.nona
	moveq	#127,d7
.nona	move.b	d7,LN_PRI(a1)
	lea	.allocmap(pc),a2
	move.l	a2,ioa_Data(a1)
* d2 = kanavalistan pituus
	moveq	#1,d2			* vain yksi vaihtoehto
	move.l	d2,ioa_Length(a1)
	move.l	(a5),a6
	lob	OpenDevice
	move.l	d0,d5
	move.l	d5,acou_deviceerr(a5)
	bne.b	acouscl
	st	kanavatvarattu(a5)
	DPRINT	"Audio open"
.na	movem.l	(sp)+,d1-a6
	moveq	#0,d0
	rts

.adname		dc.b	"audio.device",0
.allocmap	dc.b	$0f
 even

acouscl
	movem.l	(sp)+,d1-a6
	bsr.b	vapauta_kanavat
	moveq	#-1,d0
	rts

vapauta_kanavat:
	tst.b	kanavatvarattu+var_b
	bne.b	.eeo
	rts
.eeo	movem.l	d0-a6,-(sp)
	lea	var_b,a5

	tst.l	acou_deviceerr(a5)
	bne.b	acouscll
	lea	iorequest(a5),a1
	lore	Exec,CloseDevice
	DPRINT	"Audio close"
acouscll
	clr.l	acou_deviceerr(a5)
	clr.b	kanavatvarattu(a5)
	movem.l	(sp)+,d0-a6
	rts

*******************************************************************************
* CIA interrupt handling
*******************************************************************************

_ciaa	=	$bfe001
_ciab	=	$bfd000


	
* init with default tempo 
init_ciaint:
	moveq	#0,d0
* init with specified tempo in d0. 0 = default
init_ciaint_withTempo:
	tst.b	ciasaatu(a5)
	bne.b	.hm
.c	moveq	#0,d0
	rts

.hm	clr.b	vbtimeruse(a5)		* k‰ytet‰‰n ciaa
	tst.b	vbtimer(a5)		* onko vblank k‰ytˆss‰?
	beq.b	.ci
	st	vbtimeruse(a5)		* k‰ytet‰‰n vblankia
	bra.b	.c
.ci
	pushm	d1-a6

	move	#28419/2,d1
	tst	d0
	beq.b	.default
	move	d0,d1
.default
	move	d1,timerhi(a5)

** CIAA

	lea	_ciaa,a3
	lea	ciaserver(pc),a4
	moveq	#0,d6			* timer a
	move.l	ciabasea(a5),d0
	beq.b	.noa
	move.l	d0,a6
	lea	(a4),a1
	move.l	d6,d0
	lob	AddICRVector
	tst.l	d0
	beq.b	.gottimer		* Saatiinko?

	lea	(a4),a1
	moveq	#1,d6			* timer b
	move.l	d6,d0
	lob	AddICRVector
	tst.l	d0
	beq.b	.gottimer
.noa
** CIAB

	lea	_ciab,a3
	lea	ciaserver(pc),a4
	moveq	#0,d6			* timer a
	move.l	ciabaseb(a5),d0
	beq.b	.nob
	move.l	d0,a6
	lea	(a4),a1
	move.l	d6,d0
	lob	AddICRVector
	tst.l	d0
	beq.b	.gottimer		* Saatiinko?

	lea	(a4),a1
	moveq	#1,d6			* timer b
	move.l	d6,d0
	lob	AddICRVector
	tst.l	d0
	beq.b	.gottimer
.nob
	popm	d1-a6
	moveq	#-1,d0			* ERROR! Ei saatu varattua timeri‰.
	rts

.gottimer
	move.l	a3,ciaddr(a5)
	move.l	a6,ciabase(a5)
	move.b	d6,whichtimer(a5)	* 0: timer a, 1:timer b

 if DEBUG
	move.l a3,d0
	moveq	#0,d1
	move.b whichtimer(a5),d1
	DPRINT	"CIA Timer allocated %lx %ld"
 endif
	bsr.b	ciaint_setTempo

	lea	ciacra(a3),a2
	tst.b	d6
	beq.b	.tima
	lea	ciacrb(a3),a2
.tima
	clr.b	ciasaatu(a5)		* saatiin keskeytys

	move.b	#%00010001,(a2)		* Continuous, force load
	popm	d1-a6
	moveq	#0,d0
	rts


* Sets tempo value word from timerhi(a5) into currently
* active CIA timer.
* May be called from interrupt.
ciaint_setTempo
	pushm	a2/a3/a5
	lea		var_b,a5
	move.l 	ciaddr(a5),a3
	lea	ciatalo(a3),a2
	tst.b	whichtimer(a5)
	beq.b	.timera
	lea	ciatblo(a3),a2
.timera	
	move.b	timerlo(a5),(a2)
	move.b	timerhi(a5),$100(a2)
; Probaly not good idea to debug print here,
; can be called from interrupt (in case of DeliCustom).
	popm	a2/a3/a5
	rts

ciaint_setTempoFromD0
	move	d0,timerhi+var_b
	bra.b	ciaint_setTempo


rem_ciaint:
	tst.b	ciasaatu(a5)
	beq.b	.hm
	rts

.hm	pushm	all
	move.l	ciaddr(a5),a3

	moveq	#0,d0
	move.b	whichtimer(a5),d0	* RemICRVector
	bne.b	.b
	move.b	#%00000000,ciacra(a3)
	bra.b	.a
.b	move.b	#%00000000,ciacrb(a3)
.a
	move.l	ciabase(a5),a6
	lea	ciaserver(pc),a1
	lob	RemICRVector
	st	ciasaatu(a5)		* ei keskeytyst‰!
	DPRINT	"CIA Timer freed"
	popm	all
	rts


*******************************************************************************
*                                Soittorutiinit
*******************************************************************************

**********************************************
* Varaa muistia ja purkaa soittorutiinin
* a0 = osoitin paikkaan mihin laitetaan osoite

allocreplayer2:
	pushm	d1-a6
	DPRINT	"Alloc replayer to chip"
	moveq	#MEMF_CHIP,d6
	bra.b	are

allocreplayer:
	pushm	d1-a6
	DPRINT	"Alloc replayer to public mem"
	moveq	#MEMF_PUBLIC,d6
are	

	tst.l	(a0)			* onko jo ennest‰‰n?
	bne	.alreadyHaveIt

	jsr	setMainWindowWaitPointer

;	push 	a0
;	bsr	inforivit_group2
;	pop 	a0

	cmp.b	#GROUPMODE_LOAD_SINGLE,groupmode(a5)
	bne.b	.nah

** Ladataan yksi kipale replayereit‰ groupista
	bsr	loadreplayer
* a1 = replayeri pakattuna
* d7 = pakatun pituus
	bne.b	.contti
.xab	popm	d1-a6
	jsr	clearMainWindowWaitPointer
	moveq	#ier_grouperror,d0
	rts

.nah
	move	playertype(a5),d0

	* map player type into a position in the group header
	* table
	move.l	externalplayers(a5),a4
	addq	#8,a4			* skip header

.find
	tst	(a4) 			* end reached?
	beq.b 	.xab
	cmp	(a4),d0 
	beq.b	.found 
	lea	2+4+4(a4),a4
	bra.b	.find
.found
	movem.l 2(a4),d0/d7		* offset, length

	* get actual data address, relative to start
	move.l	externalplayers(a5),a1
	add.l	d0,a1
.contti
	move.l	a1,a4
	move.l	a0,a3
	cmp.l	#"IMP!",(a4)
	beq.b	.imp
	moveq	#1,d5		* type flag
	jsr	getDeshrinkledSize
	bra.b	.noImp
.imp
	moveq	#0,d5		* type flag
	move.l	4(a4),d0	* fimp decompressed size
.noImp
	* d0 = decompressed size
	move.l	d6,d1		* mem type
	jsr	getmem
	move.l	d0,(a3)		* store pointer
	bne.b	.ok2
	popm	d1-a6
	jsr	clearMainWindowWaitPointer
	moveq	#ier_nomem,d0
	rts

.ok2	
	move.l	d0,a1

	* a4 = compressed data
	* a1 = output buffer
	tst	d5
	bne.b	.shr

	move.l	a4,a0
	move.l	d7,d0
	lore	Exec,CopyMem	
	move.l	(a3),a0
	DPRINT	"Exploding"
	jsr	fimp_decr
	bra.b	.wasImp
.shr
	DPRINT	"Deshrinklering"
	jsr	deshrinkle
	
.wasImp
	cmp	#pt_eagle_start,playertype(a5)
	bhs.b 	.ok 
	
	* see if it needs to be relocated
	move.l	(a3),a0
	cmp.l	#$000003f3,(a0)
	bne.b	.ok
	DPRINT	"Relocating"
	bsr.b	reloc
.ok
	bsr.b	clearCpuCaches

 
.x	popm	d1-a6
	jsr	clearMainWindowWaitPointer
	moveq	#0,d0	
	rts

.alreadyHaveIt
	bra.b	.x

* Clear CPU caches
* Use after code has been modified.
* Can be called from deli support code.
clearCpuCaches
	pushm	all
	lea	var_b,a5
	move.l	(a5),a6
	cmp	#37,LIB_VERSION(a6)
	blo.b	.vanha
	lob	CacheClearU	* cachet tyhjix, ei gurua 68040:ll‰!
.vanha
	popm 	all
	rts

**
* Reloc rutiini ilmeisesti pelk‰lle ajettavalle code_hunkille
**
* a0 = hunkki
reloc	pushm	d0-d2/a0/a1
	lea	28(a0),a0		* Address of CODE hunk length in long words
	move.l	(a0)+,d2	* Read it
	lsl.l	#2,d2		* Convert to bytes
	move.l	a0,a1		* a0 = start of the actual code
	move.l	a0,d1		* also in d1 
	lea	4(a0,d2.l),a0	* skip over to HUNK_RELOC32 start + 4
						* skip over the hunk id, that is
	move.l	(a0)+,d2	* Number of offsets to handle
	subq.l	#1,d2
	bmi.b	.024c
	addq.w	#4,a0		* Skip over the target hunk number, assume we know it
.0242	move.l	(a0)+,d0 * read RELOC32 offset
	* Add start address of the code hunk to the 
	* address specified by the reloc offset
	add.l	d1,(a1,d0.l)
	dbf	d2,.0242
.024c	addq.w	#8,a0	* a0 points to next hunk likely
	popm	d0-d2/a0/a1
	rts	



***********************************
* Vapauttaa soittorutiinin muistista
* a0 = osoitin soittorutiinin osoittimeen
freereplayer
	tst.l	(a0)
	beq.b	.x
	push	a0
	move.l	(a0),a0
	jsr	freemem
	pop	a0
	clr.l	(a0)
.x
	cmp.b	#GROUPMODE_DISABLE,groupmode(a5)	* jos playerfile disabloitu,
	blo.b	.xx			* vapautetaan se ejectin yhteydess‰
					* tai load single moodina
	move.l	externalplayers(a5),a0		
	clr.l	externalplayers(a5)
	jsr	freemem
.xx	rts

*************
* Tarkistaa onko moduuli fastissa. Jos on, siirt‰‰ sen chippiin

moveModuleToChipMem
siirra_moduuli
	pushm	d1-a6

	move.l	moduleaddress(a5),a3

	move.l	a3,a1
	lore	Exec,TypeOfMem
	btst	#MEMB_CHIP,d0
	bne.b	sirchip

	moveq	#MEMF_CHIP,d1
sirmo	move.l	modulelength(a5),d0
	lob	AllocMem
	tst.l	d0
	beq.b	sirerro
	move.l	d0,moduleaddress(a5)

	move.l	a3,a0
	move.l	d0,a1
	move.l	modulelength(a5),d0
	lob	CopyMem

	move.l	a3,a1
	move.l	modulelength(a5),d0
	lob	FreeMem

sirchip	moveq	#0,d0
sirx	popm	d1-a6
	rts

sirerro	moveq	#ier_nomem,d0
	bra.b	sirx


*************
* Tarkistaa onko moduuli chipiss‰. Jos on, siirt‰‰ sen fastiin (jos on).

moveModuleToPublicMem
siirra_moduuli2
	pushm	d1-a6

	move.l	moduleaddress(a5),a3

	move.l	a3,a1
	lore	Exec,TypeOfMem
	btst	#MEMB_FAST,d0
	bne.b	sirx

	moveq	#MEMF_FAST,d1
	bra.b	sirmo
	
;	move.l	modulelength(a5),d0
;	lob	AllocMem
;	tst.l	d0
;	beq.b	.x

;	move.l	d0,moduleaddress(a5)

;	move.l	a3,a0
;	move.l	d0,a1
;	move.l	modulelength(a5),d0
;	lob	CopyMem

;	move.l	a3,a1
;	move.l	modulelength(a5),d0
;	lob	FreeMem

;.fast	moveq	#0,d0
;.x	popm	d1-a6
;	rts

	

*************

dmawait
	pushm	d0/d1
	moveq	#12-1,d1
.d	move.b	$dff006,d0
.k	cmp.b	$dff006,d0
	beq.b	.k
	dbf	d1,.d
	popm	d0/d1
	rts

;	pushm	d0/a0
;	moveq	#8-1,d0
;	lea.l	$bfe001,a0
;.e 	rept	23
;	tst.b	(a0)
;	endr
;	dbf	d0,.e
;	popm	d0/a0
;	rts


clearsound
	pushm	d0/a0
	lea	$dff096,a0
	move	#$f,(a0)
	moveq	#0,d0
	move	d0,$a8-$96(a0)
	move	d0,$b8-$96(a0)
	move	d0,$c8-$96(a0)
	move	d0,$d8-$96(a0)
	popm	d0/a0
	rts

* before: 150876
* after:  150044

generalReplayInitChipMem:
    moveq   #1,d1
    bra     generalReplayInitDo

generalReplayInitNoAlloc:
    moveq   #-1,d1
    bra     generalReplayInitDo

generalReplayInit:
    moveq   #0,d1

* In:
*   a0 = where to store allocated replay code
*   d1 = 0: allocate replayer in public mem 
*        1: to chip mem
*       -1: do not allocate replayer, a0 unused
* Out:
*   d0 = error code, 0 if no error

generalReplayInitDo:
    bsr	    varaa_kanavat       * d1-a6 preserved
    beq.b	.ok
    moveq	#ier_nochannels,d0
    rts
.ok	
    bsr     init_ciaint         * d1-a6 preserved
    beq.b   .ok2
    bsr     vapauta_kanavat
    moveq   #ier_nociaints,d0
    rts
.ok2
    * a0 = input address
    tst.b   d1
    bmi     .ok3
    beq     .normal
    bsr     allocreplayer2       * d1-a6 preserved
    bra     .chip
.normal
    bsr     allocreplayer       * d1-a6 preserved
.chip
    beq.b   .ok3
    * d0 preserved here:
    bsr     rem_ciaint
    bsr     vapauta_kanavat
.ok3
    tst.b   d0
    rts


;generalReplayUninit:
;	bsr	rem_ciaint
;	bsr	clearsound
;	bra	vapauta_kanavat
; 

******************************************************************************
* Music formats
******************************************************************************

* Formats
* - built-in replayers in hippo
* - replayer code is within modules
* - replayer code is in libraries
* - TFMX and ProTracker have special handling 
internalFormats:
	;dr.l	p_protracker 
	dr.l	p_med 
	dr.l 	p_mline 
	dr.l 	p_musicassembler 
	dr.l 	p_fred 
	dr.l	p_sidmon1 
	dr.l 	p_deltamusic 
	dr.l	p_markii 
	dr.l 	p_mon
	dr.l 	p_beathoven 
	dr.l	p_hippel	* very slow id 
	dr.l	p_vgm_tnt
	dc.l	0

* Formats
* - replayers are in the HippoPlayer.group
groupFormats:
	dr.l 	p_jamcracker 
	dr.l 	p_pumatracker 
	dr.l 	p_futurecomposer13
	dr.l 	p_futurecomposer14 
	dr.l 	p_oktalyzer
	;dr.l	p_tfmx
	dr.l	p_hippelcoso 
	dr.l	p_soundmon 
	dr.l	p_soundmon3 
	dr.l	p_digibooster 
	dr.l 	p_digiboosterpro 
	dr.l	p_thx 
	dr.l 	p_aon 
	dr.l	p_gamemusiccreator 
	dr.l	p_medley 
	dr.l	p_bendaglish 
	dr.l	p_sidmon2 
	dr.l	p_deltamusic1 
	dr.l	p_soundfx 
	dr.l	p_gluemon
	dr.l	p_pretracker 
	dr.l 	p_custommade 
	dr.l 	p_sonicarranger
	dr.l	p_startrekker
	dr.l	p_voodoosupremesynthesizer
 ifne FEATURE_P61A
	dr.l 	p_player
 endif
 	dr.l 	p_aon8
    dr.l    p_midistream
    dr.l    p_vgm
    dr.l    p_davelowe
    dr.l    p_futureplayer
    dr.l    p_delicustom
	dc.l 	0

eagleFormats:
	dr.l	p_synthesis
	dr.l	p_syntracker
	dr.l	p_robhubbard2
	dr.l	p_chiptracker
	dr.l	p_quartet
	dr.l	p_facethemusic
	dr.l	p_richardjoseph
	dr.l	p_instereo1 
	dr.l	p_instereo2
	dr.l	p_jasonbrooke
	dr.l	p_earache
	dr.l	p_krishatlelid
	dr.l	p_richardjoseph2
	dr.l	p_hippel7
	dr.l	p_aprosys
	dr.l	p_hippelst
	dr.l	p_tcbtracker
	dr.l	p_markcooksey 
	dr.l	p_maxtrax
	dr.l	p_wallybeben
	dr.l	p_synthpack
	dr.l	p_robhubbard 
	dr.l 	p_jeroentel
	dr.l	p_sonix
	dr.l	p_quartetst 
	; Hangs on privileged instruction?
	;dr.l	p_coredesign
	dr.l	p_digitalmugician2
	dr.l	p_musicmaker4
	dr.l	p_musicmaker8
	dr.l	p_soundcontrol
	dr.l	p_stonetracker
	dr.l	p_themusicalenlightenment
	dr.l	p_timfollin2
	dr.l	p_digitalmugician
	dr.l 	p_jasonpage
	dr.l	p_specialfx
	dr.l	p_steveturner
	dr.l 	p_davidwhittaker
    dr.l    p_soundmaster
    dr.l    p_soundprogramminglanguage
    dr.l    p_midiext
    dr.l	p_activisionpro  	* very slow id
	dc.l	0	


******************************************************************************
* Protracker
******************************************************************************

p_protracker:
	jmp	.proinit(pc)
	p_NOP
	jmp	.provb(pc)
	jmp	.proend(pc)
	jmp	.prostop(pc)
	jmp	.procont(pc)
	jmp	.provolume(pc)
	jmp	.prosong(pc)		* Song
	jmp	.eteen(pc)
	jmp	.taakse(pc)
	p_NOP
	jmp id_protracker(pc)
	p_NOP
	dc.w pt_prot 				* type
.flags	
 dc pf_cont!pf_stop!pf_volume!pf_song!pf_kelaus!pf_poslen!pf_end!pf_scope!pf_ciakelaus2!pf_quadscopePoke!pf_slidePos

	dc.b	"Protracker",0
 even


.proinit
    DPRINT  "Protracker init"
	bsr	varaa_kanavat
	beq.b	.ok
	moveq	#ier_nochannels,d0
	rts
.ok	movem.l	d1-d2/a0/a1,-(sp)

	move.l	moduleaddress(a5),a0	* Onko konvertattu?

	tst.b	950(a0)			* song len v‰h. 1
	bne.b	.ce
	move.b	#1,950(a0)
.ce
	cmp.b	#"K",951(a0)
	beq.b	.c
	move	#950/2-1,d0
	lea	ptheader,a1
.cl	move	(a0)+,(a1)+
	dbf	d0,.cl
.c

	bsr	.getsongs
    tst.w   maxsongs(a5)
    beq     .yesSs
    DPRINT  "reset time"
    * With subsongs reset the calculated time
    * as it should not be correct
    clr.l   kokonaisaika(a5)
.yesSs


	bsr	whatgadgets

	lea	kplbase(a5),a0
	move.l	moduleaddress(a5),a1

	moveq	#0,d0
	move.b	950(a1),d0
	move	d0,pos_maksimi(a5)

    * Start position, defaults to 0
    bsr     .getSongStartPosition

 if DEBUG
    and.l   #$ff,d0
    moveq   #0,d1
    move    songnumber(a5),d1
    DPRINT  "Start position=%ld song=%ld"
 endif
	bsr.b	.init1

	cmp	#-1,d0
	beq.b	.eok
	cmp	#-2,d0
	beq.b	.eok3
	bsr	.provolume
	moveq	#0,d0
.eok2	movem.l	(sp)+,d1-d2/a0/a1
	rts

.eok	bsr	vapauta_kanavat
	moveq	#ier_nociaints,d0
	bra.b	.eok2
.eok3	bsr	vapauta_kanavat
	moveq	#ier_nomem,d0
	bra.b	.eok2


.init
    * Start pattern
	moveq	#0,d0
.init1
	moveq	#1,d1			* cia
	move.b	vbtimer(a5),vbtimeruse(a5)
	beq.b	.cuse
	moveq	#0,d1			* vb
.cuse

	moveq	#0,d2

	tst.b	oldst(a5)		* onko old st?
	bne.b	.s
	tst.b	tempoflag(a5)
	bne.b	.s
	bset	#0,d2			* tempo flag
.s	
	movem.l	d0/d1/a0/a1/a6,-(sp)	* oobko modi tosiaan fastissa?
	move.l	moduleaddress(a5),a1
	lore	Exec,TypeOfMem
	btst	#MEMB_CHIP,d0	
	movem.l	(sp)+,d0/d1/a0/a1/a6
	bne.b	.ss
	bset	#1,d2			* fast flag
.ss
	lea	kplbase(a5),a0
	jmp	kplayer+kp_init
	

.proend	move.l	d0,-(sp)
	jsr	kplayer+kp_end
	move.l	(sp)+,d0
	bra	vapauta_kanavat

.prostop
	move.l	d0,-(Sp)
	moveq	#1,d0
	jsr	kplayer+kp_playstop
	jsr	kplayer+kp_clear
	move.l	(sp)+,d0
	rts

.procont
	move.l	d0,-(Sp)
	moveq	#0,d0
 	jsr	kplayer+kp_playstop
	move.l	(sp)+,d0
	rts	

.provolume
	move.l	d0,-(sp)
	move	mainvolume(a5),d0
	jsr	kplayer+kp_setmaster
	move.l	(sp)+,d0
	rts

* ei soittoa, tutkitaan vain onko kappale loppunut
.provb
	tst.b	vbtimeruse(a5)
	beq.b	.cus
	jsr	kplayer+kp_music
.cus
	move	kplbase+k_songpos(a5),pos_nykyinen(a5)
	tst.b	kplbase+k_songover(a5)
	sne	songover(a5)            * TODO: suspect
	clr.b	kplbase+k_songover(a5)
	rts

.eteen
	movem.l	d0/d1/a0,-(sp)
	move.l	moduleaddress(a5),a0
	moveq	#0,d0
	move.b	950(a0),d0		* songlength
	move	kplbase+k_songpos(a5),d1
	addq	#1,d1
	cmp	d0,d1
	blo.b	.a
	clr	d1
.a	move	d1,kplbase+k_songpos(a5)
	clr	kplbase+k_patternpos(a5)
	move	d1,pos_nykyinen(a5)
	movem.l	(sp)+,d0/d1/a0
	rts
.taakse
	move.l	d0,-(sp)
	move	kplbase+k_songpos(a5),d0
	subq	#1,d0
	bpl.b	.b
	clr	d0
.b	move	d0,kplbase+k_songpos(a5)
	clr	kplbase+k_patternpos(a5)
	move	d0,pos_nykyinen(a5)
	move.l	(sp)+,d0
.yee	rts


* Tutkii koko songin, ja kattoo jos olisi erillisi‰ songeja.
.getsongs:  
	move.l	moduleaddress(a5),a0
	cmp.b	#'K',951(a0)
	beq.b	.yee

	clr.l	kokonaisaika(a5)

    bsr     .detectSubsongs

    * Skip length detect for subsong mods,
    * these will get stuck in position jump loops
    * and would provide wrong total length anyway
    tst     maxsongs(a5)
    bne     .la

	;cmp	#TITLEBAR_TIMEDUR_POSLEN,lootamoodi(a5)
	;bne.b	.la
	pushm	d2-a6
	move.l	moduleaddress(a5),a0
	move.b	tempoflag(a5),d0
	not.b	d0
	bsr	modlen		* moduulin kesto ajallisesti
	popm	d2-a6
	move	d0,kokonaisaika(a5)	* mins
	move	d1,kokonaisaika+2(a5)	* secs
.la

    rts


.detectSubsongs:
    DPRINT  "+++ PT getsongs +++"

	move.l	a6,-(sp)
	move	#$0fff,d3
	moveq	#0,d0
	move.b	950(a0),d0		* songlength
	move	d0,a6
	subq	#1,d0
	moveq	#0,d1
	lea	1084(a0),a2		* eka patterni
	lea	952(a0),a3		* position-lista

	lea	ptsonglist(a5),a4
	moveq	#64-1,d2
.cc	move.b	#$ff,(a4)+
	dbf	d2,.cc
	lea	ptsonglist(a5),a4
	clr.b	(a4)+

.check
	moveq	#0,d2
	move.b	(a3)+,d2        * read position
	lsl.l	#5,d2			* d2*1024
	lsl.l	#5,d2	
	lea	(a2,d2.l),a1        * get pattern

************************ OPT
    * Loop rows of pattern
	moveq	#1024/4/4-1,d2
.look	
	movem.l	(a1)+,d4-d7 * ch1,ch2,ch3,ch4 notedata
    * Extract command column d4,d5,d6,d7
	and	d3,d4
	rol	#8,d4
	and	d3,d5
	rol	#8,d5
	and	d3,d6
	rol	#8,d6
	and	d3,d7
	rol	#8,d7

    * If any of the channels has a D then continue
    * A B+D combo indicates pattern scrambling
	cmp.b	#$d,d4
	beq.b	.next
	cmp.b	#$d,d5
	beq.b	.next
	cmp.b	#$d,d6
	beq.b	.next
	cmp.b	#$d,d7
	beq.b	.next

	cmp.b	#$b,d4
	beq.b	.jump1
	cmp.b	#$b,d5
	beq.b	.jump2
	cmp.b	#$b,d6
	beq.b	.jump3
	cmp.b	#$b,d7
	beq.b	.jump4

;	cmp.b	#$d,d4
;	beq.b	.next
;	cmp.b	#$d,d5
;	beq.b	.next
;	cmp.b	#$d,d6
;	beq.b	.next
;	cmp.b	#$d,d7
;	beq.b	.next 
;
	dbf	d2,.look        

.next	
    addq	#1,d1
	dbf	d0,.check       * loop song position

	move.b	#-1,(a4)
	lea	ptsonglist(a5),a0
	move.l	a0,a1
.f	cmp.b	#-1,(a0)+
	bne.b	.f
	sub.l	a1,a0
	subq	#1,a0
	move	a0,d0
	subq.b	#1,d0
	move.b	d0,maxsongs+1(a5)

  if DEBUG
    moveq   #0,d1
    move.b  ptsonglist(a5),d1
    DPRINT  "subsongs found=%ld first=%ld"
  endif

	move.l	(sp)+,a6
	rts

.jump4	move	d7,d4
	bra.b	.jump
.jump3	move	d6,d4
	bra.b	.jump
.jump2	move	d5,d4
.jump1	
.jump	rol	#8,d4
    * d4 = jump target position
    * if jump target >= current song position
    * we are jumping forward and this is
    * not a subsong delimiter
	cmp.b	d1,d4
	bhs.b	.next

 if DEBUG   
    pushm   d0/d1
    moveq   #0,d0
    move.b  d4,d0
    and.l   #$ff,d1
    DPRINT  "Backward jump to %ld at %ld"
    popm    d0/d1
 endif

    * store the following position as a
    * start of the next subsong
	moveq	#1,d4
	add.b	d1,d4


	cmp	a6,d4               * compare to song length in a6
	blo.b	.eoe
	moveq	#-1,d4			* Moduulin alkuun
.eoe	move.b	d4,(a4)+
	bra 	.next


* Out:
*   d0 = song start position or 0 
.getSongStartPosition
    moveq   #0,d0
	lea	ptsonglist(a5),a0
	cmp.b	#-1,1(a0)
	beq.b	.noSong_
	move	songnumber(a5),d0
    DPRINT  "songnumber=%ld"
	move.b	(a0,d0),d0
	bmi.b	.noSong_
    rts
.noSong_
    moveq   #0,d0
    rts

.prosong
	movem.l	d0-a1,-(Sp)

    bsr     .getSongStartPosition

    push    d0
	jsr	kplayer+kp_end
	
	lea	kplbase(a5),a0
	move.l	moduleaddress(a5),a1
    pop     d0
    
    DPRINT  "position=%ld"

    * Song start position is in d0
	bsr	.init1
	bsr	.provolume

.nosong	movem.l	(sp)+,d0-a1
	rts




nl_note		EQU	0  ; W
nl_cmd		EQU	2  ; W
nl_cmdlo	EQU	3  ; B
nl_pattpos	EQU	4 ; B
nl_loopcount	EQU	6	 ; B
nl_ts		=	8	* channeltempsize


* Out:
*   d0 = secs
*   d1 = minutes
* or null if cannot determine
modlen:
    DPRINT  "+++ PT modlen +++"

    rsreset
.songend	    rs.w	1
.Tempo		    rs.w	1
.tempoval	    rs.w	1
.tempoflag	    rs.w	1
.time		    rs.l	1

.mt_chan1temp	 rs.b  nl_ts
.mt_chan2temp	 rs.b  nl_ts
.mt_chan3temp	 rs.b  nl_ts
.mt_chan4temp	 rs.b  nl_ts

.varmistus	        rs.w 1
.mt_SongDataPtr	    rs.l 1
.mt_PatternPos	    rs.w 1
.mt_speed	        rs.b 1
.mt_counter	        rs.b 1
.mt_SongPos	        rs.b 1
.mt_PBreakPos	    rs.b 1
.mt_PosJumpFlag	    rs.b 1
.mt_PBreakFlag	    rs.b 1
.mt_PattDelTime	    rs.b 1
.mt_PattDelTime2    rs.b 1
.varsSize           rs.b 0
 even

    moveq   #.varsSize/2-1,d2
.sk clr.w   -(sp)
    dbf     d2,.sk
    move.l  sp,a5
    bsr     .do
    lea     .varsSize(sp),sp
    rts

.do
	MOVE.L	A0,.mt_SongDataPtr(a5)
	move.b	d0,.tempoflag(a5)

	move	#125,.Tempo(a5)
	move.b	#6,.mt_speed(a5)

;	CLR.B	.mt_counter(a5)
;	CLR.B	.mt_SongPos(a5)
;	CLR.W	.mt_PatternPos(a5)

	move.l	#1773447,d0
	divu	.Tempo(a5),d0
	move	d0,.tempoval(a5)

.loop	bsr.b	.mt_music
	tst	.songend(a5)
	beq.b	.loop

	cmp.b	#1,.songend(a5) * check for magic flag
	bne.b	.nod
	moveq	#0,d0
	moveq	#0,d1
	rts
.nod


	move.l	.time(a5),d0
	move.l	#709379,d1	* PAL

;	move.l	(a5),a0
;	cmp.b	#60,PowerSupplyFrequency(a0)
;	bne.b	.pal
;	move.l	#715909,d1	* NTSC
;.pal
	jsr	divu_32
				* d0 = kesto sekunteina
    DPRINT  "secs=%ld"
	divu	#60,d0
	move.l	d0,d1
	swap	d1
	rts


.mt_music


	addq	#1,.varmistus(a5)
;	cmp	#512,.varmistus(a5)
;	cmp	#2048,.varmistus(a5)
	cmp	#4096,.varmistus(a5)
	blo.b	.noy
    DPRINT  "safety trigger"
	clr	.mt_PatternPos(a5)
	CLR.B	.mt_PBreakPos(a5)
	CLR.B	.mt_PosJumpFlag(a5)
	clr.b	.mt_PattDelTime(a5)
	clr.b	.mt_PattDelTime2(a5)
	clr.b	.mt_counter(a5)
	move	#1024,.mt_PatternPos(a5)
	bra.b	.mt_GetNewNote
.noy

	moveq	#0,d0
	move	.tempoval(a5),d0
	add.l	d0,.time(a5)

	ADDQ.B	#1,.mt_counter(a5)
	MOVE.B	.mt_counter(a5),D0
	CMP.B	.mt_speed(a5),D0
	BLO.S	.mt_NoNewNote
	CLR.B	.mt_counter(a5)
	TST.B	.mt_PattDelTime2(a5)
	BEQ.S	.mt_GetNewNote
	BSR.S	.mt_NoNewAllChannels
	BRA 	.mt_dskip

.mt_NoNewNote
	pea	.mt_NoNewPosYet(pc)

.mt_NoNewAllChannels
	LEA	.mt_chan1temp(a5),A6
	BSR.B	.mt_CheckEfx
	addq	#nl_ts,a6
	BSR.B	.mt_CheckEfx
	addq	#nl_ts,a6
	BSR.B	.mt_CheckEfx
	addq	#nl_ts,a6

.mt_CheckEfx
	moveq	#$f,d0
	and.b	nl_cmd(A6),D0
	CMP.B	#$E,D0
	BEQ	.mt_E_Commands
.mt_Return
	RTS


.mt_GetNewNote

	MOVE.L	.mt_SongDataPtr(a5),A0
	LEA	12(A0),A3
	LEA	952(A0),A2	;pattpo
	LEA	1084(A0),A0	;patterndata
	MOVEQ	#0,D0
	MOVEQ	#0,D1
	mOVE.B	.mt_SongPos(a5),D0
	MOVE.B	(A2,D0.W),D1
	ASL.L	#8,D1
	ASL.L	#2,D1
	ADD.W	.mt_PatternPos(a5),D1

	LEA	.mt_chan1temp(a5),A6
	BSR 	.mt_PlayVoice
	addq	#nl_ts,a6
	BSR 	.mt_PlayVoice
	addq	#nl_ts,a6
	BSR 	.mt_PlayVoice
	addq	#nl_ts,a6
	pea	.mt_SetDMA(pc)

;	BSR.S	.mt_PlayVoice
;	BRA.B	.mt_SetDMA


.mt_PlayVoice
	MOVE.L	(A0,D1.L),(A6)
	ADDQ.L	#4,D1
	Bra	.mt_CheckMoreEfx


.mt_SetDMA
.mt_dskip
	tst.b	.songend(a5)
	bne	.mt_exit

	ADD.W	#16,.mt_PatternPos(a5)
	MOVE.B	.mt_PattDelTime(a5),D0
	BEQ.S	.mt_dskc
	MOVE.B	D0,.mt_PattDelTime2(a5)
	CLR.B	.mt_PattDelTime(a5)
.mt_dskc	TST.B	.mt_PattDelTime2(a5)
	BEQ.S	.mt_dska
	SUBQ.B	#1,.mt_PattDelTime2(a5)
	BEQ.S	.mt_dska
	SUB.W	#16,.mt_PatternPos(a5)
.mt_dska	TST.B	.mt_PBreakFlag(a5)
	BEQ.S	.mt_nnpysk
	SF	.mt_PBreakFlag(a5)
	MOVEQ	#0,D0
	MOVE.B	.mt_PBreakPos(a5),D0
	CLR.B	.mt_PBreakPos(a5)
	LSL.W	#4,D0
	MOVE.W	D0,.mt_PatternPos(a5)
.mt_nnpysk

	CMP.W	#1024,.mt_PatternPos(a5)
	BLO.S	.mt_NoNewPosYet
.mt_NextPosition	
	clr	.varmistus(a5)

	MOVEQ	#0,D0
	MOVE.B	.mt_PBreakPos(a5),D0
	LSL.W	#4,D0
	MOVE.W	D0,.mt_PatternPos(a5)
	CLR.B	.mt_PBreakPos(a5)
	CLR.B	.mt_PosJumpFlag(a5)
	ADDQ.B	#1,.mt_SongPos(a5)
	bpl.b	.jo
	st	.songend(a5)
.jo
	AND.B	#$7F,.mt_SongPos(a5)
	MOVE.B	.mt_SongPos(a5),d0
	MOVE.L	.mt_SongDataPtr(a5),A0
	CMP.B	950(A0),d0
	BLO.S	.mt_NoNewPosYet
	CLR.B	.mt_SongPos(a5)
	st	.songend(a5)

.mt_NoNewPosYet	
	TST.B	.mt_PosJumpFlag(a5)
	BNE.S	.mt_NextPosition
.mt_exit	
	RTS



.mt_PositionJump
    * Get jump position:
	MOVE.B	3(A6),D0
	MOVE.B	.mt_SongPos(a5),D2		* hyv‰ksyt‰‰n jos jumppi

	addq.b	#1,d2				    * viimeisess‰ patternissa
	MOVE.L	.mt_SongDataPtr(a5),a1  * a0 must be preserved
	cmp.b	950(a1),d2
	bne.b	.nre
    DPRINT  "Detect jump in the last position"
	st	.songend(a5)
	bra.b	.fine

.nre	
    ;DPRINT  "Detected jump NOT in the last position"
	;move.b	#1,.songend(a5)     
    
.fine
    * Set new song position, not really needed as 
    * the operation stops here.
	SUBQ.B	#1,D0
	MOVE.B	D0,.mt_SongPos(a5)

.mt_pj2	
    CLR.B	.mt_PBreakPos(a5)
	ST 	.mt_PosJumpFlag(a5)
	RTS


.mt_PatternBreak
	MOVEQ	#0,D0
	MOVE.B	nl_cmdlo(A6),D0
	MOVE.L	D0,D2
	LSR.B	#4,D0
	MULU	#10,D0
	AND.B	#$0F,D2
	ADD.B	D2,D0
	CMP.B	#63,D0
	BHI.S	.mt_pj2
	MOVE.B	D0,.mt_PBreakPos(a5)
	ST	.mt_PosJumpFlag(a5)
	RTS

.mt_SetSpeed
	MOVEQ	#0,D0
	MOVE.B	3(A6),D0
	Bne.b	.no0
	moveq	#31,d0
.no0
	tst	.tempoflag(a5)
	beq.b	.notempo
	CMP.B	#32,D0
	BHS.B	.SetTempo
.notempo
	CLR.B	.mt_counter(a5)
	MOVE.B	D0,.mt_speed(a5)
	RTS

.SetTempo
	move	d0,.Tempo(a5)

	move.l	#1773447,d0
	divu	.Tempo(a5),d0
	move	d0,.tempoval(a5)
	rts


.mt_CheckMoreEfx
	moveq	#$f,d0
	and.b	2(a6),d0
	CMP.B	#$B,D0
	BEQ	.mt_PositionJump
	CMP.B	#$D,D0
	BEQ 	.mt_PatternBreak
	CMP.B	#$E,D0
	BEQ 	.mt_E_Commands
	CMP.B	#$F,D0
	BEQ 	.mt_SetSpeed
	rts

.mt_E_Commands
	MOVE.B	nl_cmdlo(A6),D0
	AND.B	#$F0,D0
	CMP.B	#$60,D0
	BEQ.B	.mt_JumpLoop
	CMP.B	#$E0,D0
	BEQ.B	.mt_PatternDelay
	RTS


.mt_JumpLoop
	TST.B	.mt_counter(a5)
	BNE	.mt_Return
	moveq	#$f,d0
	and.b	nl_cmdlo(A6),D0
	BEQ.S	.mt_SetLoop
	TST.B	nl_loopcount(A6)
	BEQ.S	.mt_jumpcnt
	SUBQ.B	#1,nl_loopcount(A6)
	BEQ	.mt_Return
.mt_jmploop	MOVE.B	nl_pattpos(A6),.mt_PBreakPos(a5)
	ST	.mt_PBreakFlag(a5)
	RTS

.mt_jumpcnt
	MOVE.B	D0,nl_loopcount(A6)
	BRA.S	.mt_jmploop

.mt_SetLoop
	MOVE.W	.mt_PatternPos(a5),D0
	LSR.W	#4,D0
	MOVE.B	D0,nl_pattpos(A6)
	RTS


.mt_PatternDelay
	TST.B	.mt_counter(a5)
	BNE	.mt_Return
	MOVEQ	#$f,D0
	and.b	nl_cmdlo(A6),D0
	TST.B	.mt_PattDelTime2(a5)
	BNE	.mt_Return
	ADDQ.B	#1,D0
	MOVE.B	D0,.mt_PattDelTime(a5)
.qq	RTS



* TODO: also run id_oldst 
id_protracker
	cmp.l	#'M.K.',1080(a4)	* Protracker
	beq.b	.p	
	cmp.l	#'M!K!',1080(a4)	* Protracker 100 patterns
	beq.b	.p	
;	cmp.l	#'FLT4',1080(a4)	* Startrekker
;	bra	idtest
	moveq	#-1,d0 
	rts
	
.p	moveq	#0,d0
	rts


*******
* Tunnistetaan Old Soundtracker piisit (15 samplea). Tarttee n. 1700 byte‰
*******
id_oldst

*** Tarkistetaan onko samplejen arvot moduulille sopivat
	lea	20(a4),a0
	moveq	#0,d0
	move	#$7fff,d2
	moveq	#15-1,d1
.l1
	cmp	22(a0),d2	* samplelen
	blo	.fail
	cmp	#1,22(a0)
	bhi.b	.f0
	addq	#1,d0
.f0
	cmp.b	#64,25(a0)	* volume
	bhi	.fail	
	cmp	26(a0),d2	* repeat point
	blo.b	.fail
	cmp	28(a0),d2	* repeat length
	blo.b	.fail
	lea	30(a0),a0
	dbf	d1,.l1
	
	cmp	#15,d0
	beq.b	.fail


* a0 = songlen
	tst.b	(a0)
	beq.b	.fail
	cmp.b	#$7f,(a0)
	bhi.b	.fail
	addq	#2,a0	

***** Ovatko postablen arvot oikeita (0-63)?

	moveq	#128-1,d0
	moveq	#0,d1
.l2	tst.b	(a0)
	beq.b	.l22
	addq	#1,d1
.l22	cmp.b	#63,(a0)+
	bhi.b	.fail
	dbf	d0,.l2

	tst	d1
	beq.b	.fail


* a0 = patterndata

*** Tarkistetaan eka patterni

	move	#4*64-1,d3
.l3
	move	(a0)+,d0
	move	(a0)+,d1

	move	d0,d2
	and	#$f000,d2		* pit‰s olla tyhj‰‰
	bne.b	.fail

	move	d1,d2			* tutkaillaan komentoa
	and	#$0f00,d2		* sallittuja: 0-4, a-f
	cmp	#$0400,d2
	bls.b	.oks
	cmp	#$0a00,d2
	blo.b	.fail

.oks

	move	d1,d2			* onko samplea?
	and	#$f000,d2
	beq.b	.noper


	and	#$fff,d0		* period
	beq.b	.noper
	cmp	#856,d0
	bhi.b	.fail
	cmp	#113,d0
	blo.b	.fail	
.noper
	dbf	d3,.l3

	moveq	#0,d0
	rts

.fail	moveq	#-1,d0
	rts

convert_oldst

*******
* Muutetaan PT-formaattiin
* a4 <= moduuli

	move.l	modulelength(a5),d0
	add.l	#484,d0
	move.l	#MEMF_CHIP!MEMF_CLEAR,d1
	lore	Exec,AllocMem
	tst.l	d0
	beq.b	.fail
	move.l	d0,a3

	lea	(a4),a0
	lea	(a3),a1
	move	#470/2-1,d0
.c1	move	(a0)+,(a1)+
	dbf	d0,.c1

	lea	16*30(a1),a1		* 16 tyhj‰‰ samplee

	moveq	#(128+1+1)/2-1,d0
.c2	move	(a0)+,(a1)+
	dbf	d0,.c2
	move.l	#"M.K.",(a1)+

	move.l	a4,a2
	add.l	modulelength(a5),a2
.c3	move.b	(a0)+,(a1)+
	cmp.l	a2,a0
	bne.b	.c3

	move.b	#$7f,951(a3)

	lea	20(a3),a0		* repeat pointer jaetaan kahdella
	moveq	#$f-1,d0
.f	
	lsr	26(a0)
	lea	30(a0),a0
	dbf	d0,.f

	move.l	moduleaddress(a5),a1
	move.l	modulelength(a5),d0
	lore	Exec,FreeMem

	move.l	a3,moduleaddress(a5)
	add.l	#484,modulelength(a5)

	moveq	#0,d0			* on oikee moduuli
	rts

.fail	moveq	#-1,d0
	rts




******************************************************************************
* SID
******************************************************************************

p_psid:
p_sid:	jmp	.init(pc)
	p_NOP
	jmp 	sidVBlank(pc)
	jmp	.end(pc)
	jmp	.stop(pc)
	jmp	.cont(pc)
	jmp .volume(pc)
	jmp	.song(pc)
	jmp	.eteen(pc)
	p_NOP
	p_NOP
	jmp 	id_sid1(pc)
	p_NOP
	dc.w 	pt_sid 				* type
.flags 
	dc	pf_cont!pf_stop!pf_song!pf_kelauseteen!pf_volume!pf_scope!pf_quadscopePoke
.title0
	dc.b	"PSID "
.title
    dc.b    "           14-bit"
           ;"reSID 8580 14-bit"
           ;"SIDBlaster       "
.zero
    dc.b    0

* This is set when AllocEmulResource is called to avoid redoing it again.
.flag       dc.b	0
* Set when perf measurement has been done
.perfDone   dc.b    0
* reSID mode where the perf test was done
.perfMode   dc.b    0
 even

.init
    DPRINT  "+-+-+ PlaySID init +-+-+"
	bsr	get_sid
	bne.b	.ok
	moveq	#ier_nosid,d0
	rts


.ok
	movem.l	d1-a6,-(sp)

    * Read HVSC songlengths if possible
    jsr     loadSLIndex 
    * Read lengths for this SID and subsong
    bsr     sid_readSongLength  

	move.l	_SIDBase(a5),a6

    lea     p_sid(pc),a0
    basereg p_sid,a0
    and     #~pf_end,.flags(a0) * default: no end detection

    * Default title "PSID"
    move.b  #"P",.title0(a0)
    * No extra words
    clr.b   .title(a0)

	tst.b	.flag(a0)
	bne  	.plo

    endb    a0

	* Enable getting data for scopes.
    * Library wants to signal a given task when data is ready.
    * Provide task but null signal mask, so no signals will be sent.
    move.l  owntask(a5),a0
    moveq   #0,d0
    lob     SetDisplaySignal
	moveq	#1,d0
	lob	    SetDisplayEnable

    bsr     isPlaysidReSID
    beq     .skip
    DPRINT  "reSID"

    ; -----------------------
    ; Before AllocEmulResource set the operating mode
    ; These corrspond to playsid OM_RESID_6581, OM_RESID_8580, 
    ; OM_RESID_AUTO, OM_SIDBLATER_USB
    ; 0 = normal
    ; 1 = resid 6581
    ; 2 = resid 8580
    ; 3 = resid auto detect
    ; 4 = sidblaster
    ; 5 = zorrosid
    ; 6 = usbsid pico
    cmp.b   #1,sidmode(a5)
    beq     .m1
    cmp.b   #2,sidmode(a5)
    beq     .m2
    cmp.b   #3,sidmode(a5)
    beq     .m3
    cmp.b   #4,sidmode(a5)
    beq     .m4
    cmp.b   #5,sidmode(a5)
    beq     .m5
    cmp.b   #6,sidmode(a5)
    beq     .m6
    * Fallback default option
    move    #OM_NORMAL,d0
    lea     .zero(pc),a0
    bra     .mode
.m1
    *** reSID 6581
    lea     sidmode02,a0 
    moveq   #OM_RESID_6581,d0
    DPRINT  "OM_RESID_6581"
    bra     .cpuCheck
.m2
    *** reSID 8580
    lea     sidmode03,a0
    moveq   #OM_RESID_8580,d0
    DPRINT  "OM_RESID_8580"
    bra     .cpuCheck
.m3
    *** reSID AUTO
    lea     sidmode02,a0   * "6581"
    bsr     sid_getSidVersion
    * d0 = detected SID, 0: 6581, not 0: 8580
    beq     .m33
    lea     sidmode03,a0   * "8580"    
.m33
    moveq   #OM_RESID_AUTO,d0
    DPRINT  "OM_RESID_AUTO"
    bra     .cpuCheck
.m4
    *** SIDBlaster USB
    lea     sidmode05,a0
    moveq   #OM_SIDBLASTER_USB,d0
    DPRINT  "OM_SIDBLASTER_USB"
    bra     .mode
.m5
    *** ZorroSID
    lea     sidmode06,a0
    moveq   #OM_ZORROSID,d0
    DPRINT  "OM_ZORROSID"
    bra     .mode
.m6
    *** USBSID Pico
    lea     sidmode07,a0
    moveq   #OM_USBSID_PICO,d0
    DPRINT  "OM_USBSID_PICO"
    bra     .mode
    ; -----------------------
.cpuCheck
	move.l	(a5),a1
	btst	#AFB_68020,AttnFlags+1(a1)
	bne.b	.cpuOk
    moveq	#ier_hardware,d0
	bra     .er
.cpuOk
    ; -----------------------
    lea     .perfDone(pc),a2
    bsr     .getCombinedResidMode
    cmp.b   .perfMode(pc),d3
    beq.b   .modeSame
    ; Run perf test it mode has changed
    clr.b   (a2)
.modeSame
    tst.b   (a2)
    bne     .perfOk
    DPRINT  "Start perf test"
    pushm   d0/a0/a1/a2
    bsr     .getCombinedResidMode
    move.b  d3,.perfMode
    * reSID mode
    moveq   #0,d0
    move.b  residmode(a5),d0
    * Filter settings
    moveq   #1,d1   * int on
    moveq   #0,d2   * ext off
    * 0 = internal on
    move.b  residfilter(a5),d3
    beq.b   .goFilt_
    * 1 = int+ext
    moveq   #1,d2   * ext on
    subq.b  #1,d3
    beq.b   .goFilt_
    * 2 = off
    moveq   #0,d1   * int off
    moveq   #0,d2   * ext off
.goFilt_
    DPRINT  "mode=%ld infilt=%ld extfilt=%ld"
    lob     MeasureRESIDPerformance
    bsr     .sidIsStereo
    beq     .noSt2
    bsr     .sidIsThree
    beq     .no3sid
    * Divide by three to match the 3x cpu load
    divu    #3,d1
    ext.l   d1
    bra     .noSt2
.no3sid
    * Halve the reference value in case stereo sid to match
    * the double CPU load.
    lsr.l   #1,d1
.noSt2
    DPRINT  "measured=%ld ref=%ld"

 if DEBUG
    pushm   d0-d2
    move.l  d1,d2
    divu    #10,d2
    ext.l   d2
    divu    #10,d0
    move.l  d0,d1
    swap    d1
    ext.l   d0
    ext.l   d1
    DPRINT  "Perf test: %ld.%1.1ld/%ld ms"
    popm    d0-d2
 endif
    move.l  d0,d2
    cmp     d1,d2
    popm    d0/a0/a1/a2
    bls.b   .perfOk
    pushm   all
    move.l  d2,d0
    bsr     .performanceRequest
    tst.l   d0
    popm    all
    bne.b   .perfOk
    moveq   #ier_error_nomsg,d0 * fail withough extra msg
    bra     .er
    ; -----------------------

.perfOk
    ; Set flag so that perf test is not done again
    st      (a2)

    ; -----------------------
.mode
    * Copy infobox text into place
    lea     .title(pc),a1
.a  move.b  (a0)+,(a1)+
    bne.b   .a

    * Additional info in reSID mode
    cmp.b   #OM_RESID_6581,d0
    beq     .o1
    cmp.b   #OM_RESID_AUTO,d0
    beq     .o1
    cmp.b   #OM_RESID_8580,d0
    bne     .o2
.o1 
    printt "CHECK AHI MODE info"

    * Show additional "14-bit" or "AHI" with reSID.
    * 3SID is 14-bit for SID1, 8-bit for SID2, 3
    move.l  #"  8-",-1(a1)
    move.l  #"bit"<<8,-1+4(a1)
    bsr     .sidIsThree
    bne     .was3
    move.l  #" 14-",-1(a1)
    move.l  #"bit"<<8,-1+4(a1)
.was3
    move.l  #1,ps3m_sampleDataModulo(a5)
;    tst.b   ahi_use_nyt(a5)
    tst.b   ahi_use(a5)
    beq     .o2
    move.l  #" AHI",-1(a1)
    clr.b   -1+4(a1)
.o2
    ;tst.w   d0
    ;bne.b   .o3
    * Normal mode + stereo: not supported
    ;bsr     .sidIsStereo
    ;beq     .o3
    ;moveq   #ier_not_compatible,d0
    ;bra     .er
.o3

    DPRINT  "Operating mode=%ld" 
    lob     SetOperatingMode
    
    moveq   #0,d0
    move.b  residmode(a5),d0
    DPRINT  "Resid mode=%ld" 
    lob     SetRESIDMode
 
 if DEBUG
    moveq   #0,d0
    moveq   #0,d1
    move.b  ahi_use(a5),d0
    move.b  ahi_use_nyt(a5),d1
    DPRINT  "ahi_use=%lx ahi_use_nyt=%lx"
 endif
 
    * AHI mode, NULL to disable
    moveq   #0,d0    
    tst.b   ahi_use(a5)
    beq     .noAhi
    * Set up the AHI specific modulo for scopes
    move.l  #2,ps3m_sampleDataModulo(a5)
    move.l  ahi_mode(a5),d0
.noAhi
    DPRINT  "AHI mode=%lx" 
    lob     SetAHIMode
    
.skip
    ; -----------------------
    DPRINT  "Classic init"

	lob	AllocEmulResource
    DPRINT  "AllocEmulResource=%ld"
	tst.l	d0
	bne	.error1

    ; -----------------------

    move.l  moduleaddress(a5),a0
    cmp.l   #"PSID",(a0)
    bne     .noheader

    * Change title if stereo sid
    lea     .title0(pc),a1
    bsr     .sidIsStereo
    beq     .noSt
    move.b  #"2",(a1)
    * 3SID
    bsr     .sidIsThree
    beq     .noSt
    move.b  #"3",(a1)
.noSt

 if DEBUG
    moveq   #0,d0
    move    sidh_version(a0),d0
    move.l  d0,d2
    DPRINT  "SID header version=%ld"
    cmp     #2,d2
    blo     .v1
    ; Header v2 -----------------------
    move    sidh_flags(a0),d0
    DPRINT  "Flags=%lx"
    move.l  d0,d1
    lsr     #4,d0
    and     #%11,d0
    DPRINT  "SID version=%ld"
    cmp     #3,d2
    blo     .v2
    ; Header v3 -----------------------
    move.l  d1,d0
    lsr     #6,d0
    and     #%11,d0
    DPRINT  "2nd SID version=%ld"
    moveq   #0,d0
    move.b  $7a(a0),d0
    lsl     #4,d0
    add.l   #$d000,d0
    DPRINT  "2nd SID address=%lx"
    cmp     #4,d2
    blo     .v3
    ; Header v4 -----------------------
    move.l  d1,d0
    lsr     #8,d0
    and     #%11,d0
    DPRINT  "3rd SID version=%ld"
    moveq   #0,d0
    move.b  $7b(a0),d0
    lsl     #4,d0
    add.l   #$d000,d0
    DPRINT  "3rd SID address=%lx"
.v3
.v2
.v1    
 endif

	lea	sidheader(a5),a1
	moveq	#sidh_sizeof-1,d0
.co	move.b	(a0)+,(a1)+
	dbf	d0,.co
	bra.b	.h2

.noheader
	move.l	modulefilename(a5),a0
	lea	sidheader(a5),a1
	lob	ReadIcon	
	tst.l	d0
	bne 	.error2

.h2

    ; -----------------------
    * reSID Filter settings - after AllocEmulResource
    bsr     isPlaysidReSID
    beq     .nrsf
    cmp.b   #1,sidmode(a5)  * 6510
    beq     .rsf
    cmp.b   #2,sidmode(a5)  * 8580
    beq     .rsf
    cmp.b   #3,sidmode(a5)  * AUTO
    beq     .rsf
    bra     .nrsf
.rsf
    moveq   #1,d0   * int on
    moveq   #0,d1   * ext off
    * 0 = internal on
    move.b  residfilter(a5),d2
    beq.b   .goFilt
    * 1 = int+ext
    moveq   #1,d1   * ext on
    subq.b  #1,d2
    beq.b   .goFilt
    * 2 = off
    moveq   #0,d0   * int off
    moveq   #0,d1   * ext off
.goFilt
    DPRINT  "Filter=%ld ExtFilter=%ld"
    lob     SetRESIDFilter
    moveq   #0,d0
    move.b  residboost(a5),d0
    beq     .nb
    * 0 = off
    * 1 = 2x
    * 2 = 3x
    * 3 = 4x
    * 0 and 1 do nothing (multiply by 0 or 1), so add 1
    addq    #1,d0
.nb
    DPRINT  "boost=%ld"
    lob     SetRESIDBoost
.nrsf
    ; -----------------------


	lea	sidheader(a5),a0
	move.l	moduleaddress(a5),a1
	move.l	modulelength(a5),d0
	lob	SetModule


	lea	sidheader+sidh_name(a5),a0	* kappaleen nimi paikalleen
	moveq	#32-1,d0
	lea	modulename(a5),a1
.c	move.b	(a0)+,(a1)+
	dbeq	d0,.c

	st	.flag			* piisi initattu
	move	sidheader+sidh_number(a5),maxsongs(a5)
	subq	#1,maxsongs(a5)

	tst.b	sidflag(a5)
	bne.b	.plo
	st	    sidflag(a5)
    * See if there is a preset song number
    tst     songnumber(a5)
    bne     .plo
    * Otherwise use default provided by song
	move	sidh_defsong+sidheader(a5),songnumber(a5)
	subq	#1,songnumber(a5)
.plo


	bsr  	.sanko
	tst.l	d0
	bne 	.error3	

    * Fake PS3M scope variables
    bsr     playSidInRESIDMode
    beq.b   .skipz
    * Audio buffer is valid after song was started
    lob     GetRESIDAudioBuffer
    * a0 = buffer ptr 1
    * a1 = buffer ptr 2 (could be same as 1)
    * a2 = buffer ptr 3 (could be null)
    * d0 = buffer length, bytes or words
    * d1 = period value
    movem.l a0/a1/a2,residBufPtr1
 if DEBUG
    move.l  a0,d1
    DPRINT  "length=%ld buffer=%lx"
 endif
    pushpea residBufPtr1(pc),ps3m_buff1(a5)
    pushpea residBufPtr2(pc),ps3m_buff2(a5)
    pushpea residBufPos(pc),ps3m_playpos(a5)
    pushpea residPosMask(pc),ps3m_buffSizeMask(a5)
.skipz

	bset	#1,$bfe001

    * Wait a bit so that song speed data is available
    moveq   #2,d1
    lore    Dos,Delay

	moveq	#0,d0
.er	movem.l	(sp)+,d1-a6
	rts

.error1
    cmp     #SID_NOSIDBLASTER,d0
    bne.b   .sb
    lea     .blasterMsg(pc),a1
.msg
    jsr     request
    moveq   #ier_error,d0
    bra.b   .er
.sb
    cmp     #SID_ZORROSIDINVALID,d0
    bne.b   .zs
    lea     .zorroSidMsg(pc),a1
    bra     .msg
.zs
    cmp     #SID_NOUSBSIDPICO,d0
    bne.b   .zss
    lea     .usbsidpicoMsg(pc),a1
    bra     .msg
.zss
    moveq	#ier_nomem,d0
	bra.b	.er

.error2	bsr.b	.free
	moveq	#ier_sidicon,d0
	bra.b	.er

.error3
	bsr.b	.free
	moveq	#ier_sidinit,d0
	bra.b	.er


.free	
    DPRINT  "FreeEmulResource"
    lob	FreeEmulResource
    bsr     sid_freeSongLengthData
	clr.b	.flag
	rts

.sanko	moveq	#0,d1
	move	songnumber(a5),d1
	addq	#1,d1
	move.l	sidh_speed+sidheader(a5),d2
	moveq	#50,d0
	btst	d1,d2
	beq.b	.ok2
	moveq	#60,d0
.ok2	lore	SID,SetVertFreq

	moveq	#0,d0
	move	songnumber(a5),d0
	addq	#1,d0
	lob	StartSong
    ; This will return an error code in d0
    
    bsr     .volume
    bsr     sid_getSongLength
    clr.b   slEndDetect(a5)
    rts

.song	movem.l	d0/d1/a0/a1/a6,-(sp)
	bsr.b	.sanko
	movem.l	(sp)+,d0/d1/a0/a1/a6
	rts	

.end
	movem.l	d0/d1/a0/a1/a6,-(sp)
	lore	SID,StopSong
	bsr.b	.free
	movem.l	(sp)+,d0/d1/a0/a1/a6
	rts


.stop	movem.l	d0/d1/a0/a1/a6,-(sp)
	lore	SID,PauseSong
	movem.l	(sp)+,d0/d1/a0/a1/a6
	rts

.cont	movem.l	d0/d1/a0/a1/a6,-(sp)
	lore	SID,ContinueSong
    ; This will return an error code in d0
	movem.l	(sp)+,d0/d1/a0/a1/a6
	rts

.eteen
	movem.l	d0/d1/a0/a1/a6,-(sp)
    * Do not ffwd with special modes, they don't seem to work
    bsr     isPlaysidReSID
    beq     .1
    lore    SID,GetOperatingMode
    tst     d0
    bne.b   .2
.1
;	moveq	#4,d0
	moveq	#6,d0
	lore	SID,ForwardSong
.2
	movem.l	(sp)+,d0/d1/a0/a1/a6
	rts

.volume
    push    d0
    move.l	_SIDBase(a5),a0
    * Call this on kick 1.3 too even if not in "resid mode", if new enough lib
    cmp     #1,LIB_VERSION(a0)
    bne     .11
    cmp     #7,LIB_REVISION(a0)
    bhs     .22
    bsr     isPlaysidReSID
    beq.b   .11
.22
    move.l	_SIDBase(a5),a6
    move    mainvolume(a5),d0
    jsr     _LVOSetVolume(a6)
.11
    pop     d0
    rts


.blasterMsg
    dc.b    "Couldn't initialize SIDBlaster!",0
.zorroSidMsg
    dc.b    "Can't access ZorroSID, check MMU settings!",0
.usbsidpicoMsg
    dc.b    "Couldn't initialize USBSID-Pico!",0
    even

.performanceRequest
    * d0 = value
    * d1 = limit
    move.l  d1,d2
    divu    #10,d2
    ext.l   d2
    divu    #10,d0
    move.l  d0,d1
    ext.l   d0
    swap    d1
    ext.l   d1
    lea     .perfReqTxt(pc),a0
    jsr     desmsg
    lea     desbuf(a5),a1
    lea     .perfReqButtons(pc),a2
    jmp     rawrequest

.perfReqTxt
    dc.b    "Your Amiga could be too slow!",10
    dc.b    "The sound may become distorted and",10
    dc.b    "the system unesponsive.",10
    dc.b    "Performance: %ld.%1.1ld ms, need <= %ld ms",0

.perfReqButtons
    dc.b    "_Continue anyway|_Stop!",0
    even

* Combine resid mode, filter mode, mono/stereo into one for easy comparison
.getCombinedResidMode
    * 0,1,2
    move.b  residfilter(a5),d3
    lsl.b   #4,d3
    * 0,1,2,3
    or.b    residmode(a5),d3
    bsr     .sidIsStereo
    beq.b   .77
    or.b    #$80,d3
.77
    rts

.sidIsStereo:
    pushm   d0/a0
    move.l  moduleaddress(a5),a0
    cmp     #3,sidh_version(a0)
    blo.b   .no
     * SID2 base address should be non-zero
    tst.b   $7a(a0)
.x  popm    d0/a0
    rts
.no moveq   #0,d0
    bra.b   .x

.sidIsThree:
    pushm   d0/a0
    move.l  moduleaddress(a5),a0
    cmp     #4,sidh_version(a0)
    blo.b   .no3
     * SID3 base address should be non-zero
    tst.b   $7b(a0)
.x3  popm    d0/a0
    rts
.no3 moveq   #0,d0
    bra.b   .x3

* Detect SID version to use
* Out:
*   d0 = 0: 6581
*   d0 = non-zero: 8580
sid_getSidVersion:
    moveq   #0,d0
    push    a0    
    move.l  moduleaddress(a5),a0
    cmp.l   #"PSID",(a0)
    bne     .noheader
    cmp     #2,sidh_version(a0)
    blo     .v1
    ; Header v2
    ;Bits 4-5 specify the SID version (sidModel):
    ;00 = Unknown,
    ;01 = MOS6581,
    ;10 = MOS8580,
    ;11 = MOS6581 and MOS8580.
    moveq   #%11<<4,d0
    and     sidh_flags(a0),d0
    cmp     #%10<<4,d0
    seq     d0
.v1    
.noheader
    pop     a0
    tst     d0
    rts

* Calculate song speed and Hz
* Out:
*   d0 = song speed, 1..12
*   d1 = update rate in Hz
sid_getSongSpeed:
    move.l  _SIDBase(a5),a0
    move.w	262(a0),d1 ;psb_TimerConstB(a0),d1
    bne.b   .1
    move    #28419/2,d1
.1  move.l  #(709379+28419/4),d0
    divu    d1,d0
    ext.l   d0
    move.l  d0,d1
    divu    #50,d0
    ext.l   d0
    divu    #10,d1
    mulu    #10,d1
    rts

rem_sidpatch
    move.l  (a5),a0
    cmp     #34,LIB_VERSION(a0)
    bls     sid_remVolumePatch
    rts

init_sidpatch
    move.l  (a5),a0
    cmp     #34,LIB_VERSION(a0)
    bls     sid_addVolumePatch
    rts


sid_addVolumePatch
    DPRINT  "sid_addVolumePatch"

	move.l	_SIDBase(a5),a0
	cmp #1,LIB_VERSION(a0)
	bne.b	.q
	cmp	#2,LIB_REVISION(a0)
	bne.b	.q
	lea	_LVOAllocEmulResource(a0),a0
	move.l	2(a0),a0

 if DEBUG
    move.l  a0,d0
    DPRINT  "hax address=%lx"
 endif
   
	move	#$4eb9,8556(a0) ; jsr
	pushpea .setVol1(pc),8556+2(a0)
	move	#$4eb9,12+8556(a0)
	pushpea .setVol2(pc),12+8556+2(a0)
	move	#$4eb9,12+12+8556(a0)
	pushpea .setVol3(pc),12+12+8556+2(a0)
.q
	rts

.setVol1
	push	d0
	mulu	var_b+mainvolume,d0 
	lsr	#6,d0
	move	d0,$dff0a8
	pop 	d0
	rts
.setVol2
	push	d0
	mulu	var_b+mainvolume,d0 
	lsr	#6,d0
	move	d0,$dff0b8
	pop 	d0
	rts
.setVol3
	push	d0
	mulu	var_b+mainvolume,d0 
	lsr	#6,d0
	move	d0,$dff0c8
	pop 	d0
	rts

;.setVol4
;	push	d0
;	mulu	var_b+mainvolume,d0 
;	lsr	#6,d0
;	move	d0,$dff0d8
;	pop 	d0
;	rts


sid_remVolumePatch
    DPRINT  "sid_remVolumePatch"

	move.l	_SIDBase(a5),a0
	cmp #1,LIB_VERSION(a0)
	bne.b	.q
	cmp	#2,LIB_REVISION(a0)
	bne.b	.q
	lea	_LVOAllocEmulResource(a0),a0
	move.l	2(a0),a0
	move	.vol1orig(pc),8556(a0)
	move.l	.vol1orig+2(pc),8556+2(a0)
	move	.vol2orig(pc),12+8556(a0)
	move.l	.vol2orig+2(pc),12+8556+2(a0)
	move	.vol3orig(pc),12+12+8556(a0)
	move.l	.vol3orig+2(pc),12+12+8556+2(a0)
	bsr	clearCpuCaches
.q
	rts

.vol1orig	move	d0,$dff0a8
.vol2orig	move	d0,$dff0b8
.vol3orig	move	d0,$dff0c8


*******
* Tunnistetaan SID piisit
*******

id_sid1 
	bsr.b	.id_sid1_
	bne.b 	.no
	bsr	moveModuleToPublicMem		* siirret‰‰n fastiin jos mahdollista
	moveq	#0,d0 
.no 
    cmp.l   #"RSID",(a4)
    seq     moduleWasRSID(a5)
    tst.l   d0
	rts

.id_sid1_
	cmp.l	#"PSID",(a4)
	beq.b	.q
	moveq	#-1,d0
	rts
.q	moveq	#0,d0
	rts

id_sid
	bsr.b	id_sid1
	beq	.yea

	move.l	modulefilename(a5),a0
	lea	desbuf(a5),a1
	move.l	a1,a2
.c	move.b	(a0)+,(a1)+
	bne.b	.c
	subq.l	#1,a1
	move.b	#'.',(a1)+
	move.b	#'i',(a1)+
	move.b	#'n',(a1)+
	move.b	#'f',(a1)+
	move.b	#'o',(a1)+
	clr.b	(a1)

	move.l	a2,d1			* avataan_ikoni
	move.l	#1005,d2
	lore	Dos,Open
	move.l	d0,d5
	beq.b	.no

	lea	probebuffer(a5),a0	* luetaan ikoni
	move.l	a0,d2
	move.l	#1000,d3			* 1000 bytee
	move.l	d5,d1
	lob	Read
	move.l	d5,d1
	lob	Close

* tutkitaan onko playsidin ikoni.

	lea	probebuffer(a5),a0
	move	#1000,d2

.leep	lea	.id1(pc),a1
.luup	move.b	(a1)+,d1
	beq.b	.yea
	move.b	(a0)+,d0
	subq	#1,d2
	beq.b	.no
	btst	#5,d1
	beq.b	.cl
	bset	#5,d0
	bra.b	.cll
.cl	bclr	#5,d0
.cll	cmp.b	d1,d0
	bne.b	.leep
	bra.b	.luup

.no	moveq	#-1,d0
	rts
.yea	moveq	#0,d0
	rts

.id1	dc.b	"PLAYSID",0
.ide1
 even

;sidVBlank:
;    bsr     sidEndCheck
;    bra     sidScopeUpdate

* Based in info from Songlength database
sidEndCheck:
    tst.l   kokonaisaika(a5)
    beq     .x
    tst.b   slEndDetect(a5)         * prevent multiple triggers
    bne     .x

    move.l	aika2(a5),d0
	sub.l	aika1(a5),d0            * can be negative

    move.w  kokonaisaika(a5),d1     * mins
    mulu    #60,d1
    add.w   kokonaisaika+2(a5),d1   * secs
    cmp.l   d0,d1
    bge     .x
    st      slEndDetect(a5)
    st      songover(a5)
    ;DPRINT  "SONGOVER %ld %ld"
.x
    rts
    
* Scope data update and following
* This is emulates what the PlaySid pplication does.
sidVBlank:
sidScopeUpdate:

	* Skip this if not needed
	bsr	anyScopeRunning
	beq	.x

    tst.b   patternScopeRunning(a5)
    beq     .noP
    * Single SID patternscope
    * Get pattern scope task data area
    move.l  taskPatternScope+TC_Userdata(a5),d0
    beq		.noP
    move.l	d0,a4
    bsr     patternScopeSID1Update

    * Check if need to update SID2
    bsr     p_sid\.sidIsStereo
    beq     .noP

    * 2SID patternscope
    * Get pattern scope task data area
    move.l  taskPatternScope+TC_Userdata(a5),a4
    bsr     patternScopeSID2Update

    * Check if need to update SID3
    bsr     p_sid\.sidIsThree
    beq     .noP
    * 3SID patternscope
    * Get pattern scope task data area
    move.l  taskPatternScope+TC_Userdata(a5),a4
    bsr     patternScopeSID3Update
.noP
    bsr     playSidInRESIDMode
    beq     .1

    * reSID, update the buffer size as it may change 
	move.l	_SIDBase(a5),a6
    lob     GetRESIDAudioBuffer
    * a0 = buffer ptr 1
    * a1 = buffer ptr 2 (could be same as 1)
    * d0 = buffer length
    * d1 = period value

    tst.b   ahi_use_nyt(a5)
    beq     .notAhi
    * 16-bit samples, convert to bytes for scope limit checks
    add.l   d0,d0
.notAhi

    move.l  d0,residPosMask
    rts

    * Normal mode 
.1
	lea	scopeData+scope_ch1(a5),a0
	moveq	#0,d7
	move.l	_SIDBase(a5),a1
	* DisplayData:
	move.l	50(a1),a1
	lea	sid_followPositions(a5),a3
	lea	sid_followFractions(a5),a2
	moveq	#0,d4
.loop
	* WORD index d7
	moveq	#0,d1
	move	dd_Length1(a1,d7),d1
	move	dd_Period1(a1,d7),d2 
	move	dd_Enve1(a1,d7),d3

	move	d2,ns_period(a0)
	move	d3,ns_tempvol(a0)
	move	d1,d6
	* Elsewhere these are handled as words
	lsr	#1,d6
	move	d6,ns_length(a0)
	move	d6,ns_replen(a0)

	* APTR index d6
	move	d7,d6
	add	d6,d6
	* Set initial sample position
	move.l	dd_Sample1(a1,d6),d6
	move.l	d6,ns_start(a0)
	move.l	d6,ns_loopstart(a0)
	
.MIN_PERIOD = 123

	cmp	#.MIN_PERIOD,d2
	bhs.b	.notEmpty
	clr	ns_tempvol(a0)
	bra.b	.skip
.notEmpty
	move.l	#.MIN_PERIOD<<16,d5
	divu	d2,d5 * dd_Period1
	* d5 = fractional 16-bit step
	* Get follow position
	move.w	(a3,d7.w),d2
	* This many steps per frame
	moveq	#$40-1,d0
.step
	* Update fractions
	add.w	d5,(a2,d7.w)
	* Add bytes if enough fractions
	addx.w	d4,d2
.retry
	* Check if stepped over the end
	cmp.w	d1,d2
	blt.s	.ok
	sub.w	d1,d2
	bra.s	.retry
.ok
	dbf	d0,.step
	
	* Updated byte position
	move.w	d2,(a3,d7.w)

	* Set final sample position and length
	* for scopes
	ext.l	d2
	add.l	d2,ns_start(a0)
	lsr	#1,d2 * words
	sub	d2,ns_length(a0)
	
.skip
	lea	ns_size(a0),a0
	addq	#2,d7
	cmp	#4*2,d7
	bne.b	.loop
.x	rts


* Checks whether the opened playsid.library
* is the reSID variant
* Out:
*   d0 = 1 if reSID variant, 0 otherwise
isPlaysidReSID:
    push    a0
    move.l  _SIDBase(a5),d0
    beq.b   .noRESID
    move.l  d0,a0
	cmp     #1,LIB_VERSION(a0)
	bne.b   .noRESID
	cmp     #9,LIB_REVISION(a0)
	blo.b   .noRESID
    * Require 020 for reSID/SIDBlaster stuff
;    move.l  (a5),a0
;    btst	#AFB_68020,AttnFlags+1(a0)
;	beq.b   .noRESID
;
;    move.l  LIB_IDSTRING(a0),a0
;    cmp.b   #"1",16(a0)
;    bne.b   .noRESID
;    cmp.b   #"5",18(a0)
;    bne.b   .noRESID
;    cmp.b   #" ",19(a0)
;    bne.b   .noRESID
;    cmp.b   #"r",32(a0)
;    bne.b   .noRESID
;    cmp.b   #"e",33(a0)
;    bne.b   .noRESID
   ; "playsid.library 1.4 (11.2.2023) reSID+SIDBlaster"
    pop     a0
    moveq   #1,d0
    rts
.noRESID
    pop     a0
    moveq   #0,d0
    rts

* Checks whether playsid is operating in reSID mode
playSidInRESIDMode:
    movem.l d0/d1/a6,-(sp)
    cmp     #pt_sid,playertype(a5)
    bne.b   .no
    bsr     isPlaysidReSID
    beq     .no
    move.l  _SIDBase(a5),a6
    lob     GetOperatingMode * output in d0, d1
    tst     d0
    beq     .no
    cmp     #OM_RESID_AUTO,d0
    beq     .y
    cmp     #OM_RESID_6581,d0
    beq     .y
    cmp     #OM_RESID_8580,d0
    bne     .no
.y
    moveq   #1,d0
    movem.l (sp)+,d0/d1/a6
    rts
.no
    moveq   #0,d0
    movem.l (sp)+,d0/d1/a6
    rts


* Fake PS3M scope variables
* multiscope draws 160 per segment
* reSID 200Hz buffer size is 140 bytes
* it will repeat 20 bytes
residBufPos     dc.l    0
residBufPtr1    dc.l    0
residBufPtr2    dc.l    0
residBufPtr3    dc.l    0
residPosMask    dc.l    $7f 


*** SID monitor scope, running as a pattern scope

patternScopeSID1Update:
	move.l	_SIDBase(a5),a0
    move.l  346(a0),a0      * psb_C64Mem    
    add.l   #$d400,a0      * SID
    lea     s_sidScopeData(a4),a3
    * Grab envelope values from secret locations
    * psb_Envelope1,2,3
    move.l  _SIDBase(a5),a1
    move.w  448(a1),ss_voice1+sv_envelope(a3)
    move.w  450(a1),ss_voice2+sv_envelope(a3)
    move.w  452(a1),ss_voice3+sv_envelope(a3)
    bra     patternScopeSIDUpdate

patternScopeSID2Update:
	move.l	_SIDBase(a5),a0
    move.l  346(a0),a0      * psb_C64Mem    
    add.l   #$d420,a0      * SID
    lea     s_sid2ScopeData(a4),a3
    * Grab envelope values from secret locations
    * psb_Envelope4,5,6
    move.l  _SIDBase(a5),a1
    move.w  454(a1),ss_voice1+sv_envelope(a3)
    move.w  456(a1),ss_voice2+sv_envelope(a3)
    move.w  458(a1),ss_voice3+sv_envelope(a3)
    bra     patternScopeSIDUpdate

patternScopeSID3Update:
	move.l	_SIDBase(a5),a0
    move.l  346(a0),a0      * psb_C64Mem    
    add.l   #$d440,a0      * SID
    lea     s_sid3ScopeData(a4),a3
    * Grab envelope values from secret locations
    * psb_Envelope7,8,9
    move.l  _SIDBase(a5),a1
    move.w  460(a1),ss_voice1+sv_envelope(a3)
    move.w  462(a1),ss_voice2+sv_envelope(a3)
    move.w  464(a1),ss_voice3+sv_envelope(a3)
    bra     patternScopeSIDUpdate

* In:
*   a0 = SID data 
*   a3 = s_sidScopeData
patternScopeSIDUpdate
    ; ---------------------------------
    move.b  $17(a0),d0
    lsr.b   #4,d0
    move.b  d0,ss_filterRes(a3)
    ; ---------------------------------
    moveq   #7,d0
    and.b   $15(a0),d0      * low byte
    move.b  $16(a0),d1      * high byte
    lsl     #3,d1
    and     #$7f8,d1
    or.w    d1,d0
    move.w  d0,ss_filterCut(a3)
    ; ---------------------------------
    moveq   #1<<4,d0
    and.b   $18(a0),d0
    lea     ss_filterLp(a3),a2
    bsr     .updateValue
    ; ---------------------------------
    moveq   #1<<5,d0
    and.b   $18(a0),d0
    lea     ss_filterBp(a3),a2
    bsr     .updateValue
    ; ---------------------------------
    moveq   #1<<6,d0
    and.b   $18(a0),d0
    lea     ss_filterHp(a3),a2
    bsr     .updateValue
    ; ---------------------------------
    moveq   #1<<0,d0
    and.b   $17(a0),d0
    lea     ss_voice1+sv_filter(a3),a2
    bsr     .updateValue
    ; ---------------------------------
    moveq   #1<<1,d0
    and.b   $17(a0),d0
    lea     ss_voice2+sv_filter(a3),a2
    bsr     .updateValue
    ; ---------------------------------
    moveq   #1<<2,d0
    and.b   $17(a0),d0
    lea     ss_voice3+sv_filter(a3),a2
    bsr     .updateValue
    ; ---------------------------------
    lea     ss_voice1(a3),a1
    bsr     .updateVoice
    bsr     .updateVoice
;    bsr     .updateVoice
;    rts

.updateVoice
    moveq   #1<<0,d0       
    and.b   4(a0),d0
    lea     sv_gate(a1),a2
    bsr     .updateValue
    ; ---------------------------------
    moveq   #1<<1,d0       
    and.b   4(a0),d0
    lea     sv_sync(a1),a2
    bsr     .updateValue
    ; ---------------------------------
    moveq   #1<<2,d0       
    and.b   4(a0),d0
    lea     sv_ring(a1),a2
    bsr     .updateValue
    ; ---------------------------------
    moveq   #1<<3,d0       
    and.b   4(a0),d0
    lea     sv_test(a1),a2
    bsr     .updateValue
    ; ---------------------------------
    moveq   #1<<4,d0       
    and.b   4(a0),d0
    lea     sv_triangle(a1),a2
    bsr     .updateValue
    ; ---------------------------------
    moveq   #1<<5,d0       
    and.b   4(a0),d0
    lea     sv_saw(a1),a2
    bsr     .updateValue
    ; ---------------------------------
    moveq   #1<<6,d0       
    and.b   4(a0),d0
    lea     sv_pulse(a1),a2
    bsr     .updateValue
    ; ---------------------------------
    move.w  #1<<7,d0       
    and.b   4(a0),d0
    lea     sv_noise(a1),a2
    bsr     .updateValue
    ; ---------------------------------
    move.b  1(a0),d0
    ror     #8,d0
    move.b  (a0),d0
    cmp.w   #$3fff,d0   * $0000-$3fff -> $0000-$ffff
    bhs     .f1
    lsl.w   #2,d0       * low freq gets 4x
    bra     .f2
.f1
    cmp.w   #$7fff,d0   * $0000-$7fff -> $0000-$ffff
    bhs     .f2
    add.w   d0,d0       * med freq gets 2x
.f2
    move.w  d0,sv_freq(a1)
    ; ---------------------------------
    move.b  3(a0),d0
    ror     #8,d0
    move.b  2(a0),d0
    and     #$fff,d0
    move.w  d0,sv_pulseWidth(a1)
    ; ---------------------------------
    lea     sv_size(a1),a1 * next voice struct
    addq    #7,a0          * next SID voice
    rts

* In: 
*  d0 = new value
*  a2 = pointer to value
.updateValue
    move.b  (a2),d1 * stash old value
    move.b  d0,(a2) * store new value
    * is the new value zero?
    beq     .z
    * not zero, clear counter and exit.
    clr.b   1(a2)
    rts
.count
    * Countdown zero counter
    tst.b   1(a2)
    beq     .cz
    subq.b  #1,1(a2)
.cz rts
.z
    * new value is zero
    tst.b   d1 
    beq     .count
    * old was not zero, start counter
    move.b  #4,1(a2)
    rts
    

patternScopeSID:
    bsr     p_sid\.sidIsThree
    bne     .throuble
    bsr     p_sid\.sidIsStereo
    bne     .double

* 1SID
	move	#SCOPE_DRAW_AREA_HEIGHT_DEFAULT,d1
    bra     .change

* 3SID
.throuble
	move	#SCOPE_DRAW_AREA_HEIGHT_DEFAULT*3,d1
    bra     .change

* 2SID
.double
	move	#SCOPE_DRAW_AREA_HEIGHT_DOUBLE,d1
.change
	move	#SCOPE_DRAW_AREA_WIDTH_DEFAULT,d0
    bsr     patternScopeSizeAdjustDo
    bne     .sizeOk
    rts

.sizeOk
    push    a5
   
	bsr	noteScrollerGetFont * uses d4,a2
    * d4 = font modulo
    * a2 = font data

    moveq   #40,d7         * output buffer modulo
	move.l	s_draw1(a4),a5 * Draw here
    moveq   #8-1,d2        * rows to print
    lea     .row1(pc),a3   * 1st row
    ;----------------------------------
.loop
    moveq   #40-1,d3        * number of chars to print
    bsr     noteScroller2\.print
    lea     8*40-40(a5),a5
    dbf     d2,.loop
    ;----------------------------------
	move.l	s_draw1(a4),a6
    lea     s_sidScopeData(a4),a5
    bsr     .drawSid
    ;----------------------------------

    * Do 2nd SID if possible
    move.l  (sp),a5
    bsr     p_sid\.sidIsStereo
    beq     .x

	bsr	noteScrollerGetFont * uses d4,a2
    * d4 = font modulo
    * a2 = font data

    moveq   #40,d7         * output buffer modulo
	move.l	s_draw1(a4),a5 * Draw here
    lea     8*8*40(a5),a5
    lea     .row1b(pc),a3   * 1st row
    moveq   #40-1,d3        * number of chars to print
    bsr     noteScroller2\.print
    lea     8*40-40(a5),a5
    lea     .row2(pc),a3   * 1st row
    moveq   #7-1,d2        * rows to print
    ;----------------------------------
.loop2
    moveq   #40-1,d3        * number of chars to print
    bsr     noteScroller2\.print
    lea     8*40-40(a5),a5
    dbf     d2,.loop2
    ;----------------------------------
	move.l	s_draw1(a4),a6
    lea     8*8*40(a6),a6   
    lea     s_sid2ScopeData(a4),a5
    bsr     .drawSid
    ;----------------------------------

    ; Do 3SID if possible
    move.l  (sp),a5
    bsr     p_sid\.sidIsThree
    beq     .x

	bsr	noteScrollerGetFont * uses d4,a2
    * d4 = font modulo
    * a2 = font data

    moveq   #40,d7         * output buffer modulo
	move.l	s_draw1(a4),a5 * Draw here
    lea     16*8*40(a5),a5
    lea     .row1c(pc),a3   * 1st row
    moveq   #40-1,d3        * number of chars to print
    bsr     noteScroller2\.print
    lea     8*40-40(a5),a5
    lea     .row2(pc),a3   * 1st row
    moveq   #7-1,d2        * rows to print
    ;----------------------------------
.loop3
    moveq   #40-1,d3        * number of chars to print
    bsr     noteScroller2\.print
    lea     8*40-40(a5),a5
    dbf     d2,.loop3
    ;----------------------------------
	move.l	s_draw1(a4),a6
    lea     16*8*40(a6),a6   
    lea     s_sid3ScopeData(a4),a5
    bsr     .drawSid
    ;----------------------------------


.x
    pop     a5
    rts

* In:
*  a5 = s_sidScopeData
*  a6 = screen pointer
.drawSid:   
    lea     7*8*40+28(a6),a0   
    lea     ss_filterLp(a5),a1
    bsr     .drawBlock
    ;----------------------------------
    lea     7*8*40+33(a6),a0   
    lea     ss_filterBp(a5),a1
    bsr     .drawBlock
    ;----------------------------------
    lea     7*8*40+38(a6),a0   
    lea     ss_filterHp(a5),a1
    bsr     .drawBlock
    ;----------------------------------
    lea     7*8*40+7(a6),a0   
    move.w  ss_filterCut(a5),d0  * range 0..7f8
    lsr     #5,d0   * 0..63
    bsr     .drawBar64
    ;----------------------------------
	lea     7*8*40+21(a6),a0   
    move.b  ss_filterRes(a5),d0  * range 0..15
    bsr     .drawBar16
    ;----------------------------------
	move.l	a6,a2
    lea     ss_voice1(a5),a3
	bsr     .drawVoice
    ;----------------------------------
    lea     13(a6),a2
    lea     ss_voice2(a5),a3
	bsr     .drawVoice
    ;----------------------------------
    lea     26(a6),a2
    lea     ss_voice3(a5),a3
;	bsr     .drawVoice
;    rts


* In:
*   a2 = output screen ptr
*   a3 = voice data
.drawVoice:
    lea     0*8*40+11(a2),a0   
    lea     sv_filter(a3),a1
    bsr     .drawBlock
    ;----------------------------------
    lea     3*8*40+5(a2),a0   
    lea     sv_gate(a3),a1
    bsr     .drawBlock
    ;----------------------------------
    lea     4*8*40+5(a2),a0   
    lea     sv_sync(a3),a1
    bsr     .drawBlock
    ;----------------------------------
    lea     5*8*40+5(a2),a0   
    lea     sv_ring(a3),a1
    bsr     .drawBlock
    ;----------------------------------
    lea     6*8*40+5(a2),a0   
    lea     sv_test(a3),a1
    bsr     .drawBlock
    ;----------------------------------
    lea     3*8*40+11(a2),a0   
    lea     sv_triangle(a3),a1
    bsr     .drawBlock
    ;----------------------------------
    lea     4*8*40+11(a2),a0   
    lea     sv_saw(a3),a1
    bsr     .drawBlock
    ;----------------------------------
    lea     5*8*40+11(a2),a0   
    lea     sv_pulse(a3),a1
    bsr     .drawBlock
    ;----------------------------------
    lea     6*8*40+11(a2),a0   
    lea     sv_noise(a3),a1
    bsr     .drawBlock
    ;----------------------------------
    lea     1*8*40+3(a2),a0   
    move.w  sv_freq(a3),d0  * range 0..ffff
    lsr     #8,d0   
    lsr     #2,d0   * 0..63
    bsr     .drawBar64
    ;----------------------------------
    lea     2*8*40+3(a2),a0   
    move.w  sv_pulseWidth(a3),d0  * range 0..fff
    lsr     #6,d0   * 0..63
    bsr     .drawBar64
    ;----------------------------------
    lea     54*40+12(a2),a0   
    move.w  sv_envelope(a3),d0  * range 0..63
    * scale to 0..54
    mulu    #55,d0
    lsr     #6,d0   * div 64
    bra     .drawVBar64
    
* In:
*   a0 = output screen ptr
*   a1 = data
.drawBlock:
    tst.b   (a1)    * value on/off
    bne.b   .b1
    moveq   #0,d2
     * clear counter active?
    move.b  1(a1),d1 
    beq.b   .bz

    * d1 = 1-4
    subq.b  #1,d1
    beq.b   .b5
    subq.b  #1,d1
    beq.b   .b4
    subq.b  #1,d1
    beq     .b3
;    subq.b  #1,d1
;    beq     .b2
;    rts
;    bra     .b2

.b2
    move.b  d2,0*40(a0)
    moveq   #%01111110,d1
    move.b  d1,1*40(a0)
    move.b  d1,2*40(a0)
    move.b  d1,3*40(a0)
    move.b  d1,4*40(a0)
    move.b  d2,5*40(a0)
    rts

.bz
    * clear!
    move.b  d2,0*40(a0)
    move.b  d2,1*40(a0)
    move.b  d2,2*40(a0)
    move.b  d2,3*40(a0)
    move.b  d2,4*40(a0)
    move.b  d2,5*40(a0)
    rts

.b1
    moveq   #-1,d0
    move.b  d0,0*40(a0)
    move.b  d0,1*40(a0)
    move.b  d0,2*40(a0)
    move.b  d0,3*40(a0)
    move.b  d0,4*40(a0)
    move.b  d0,5*40(a0)
    rts
.b5
    move.b  d2,0*40(a0)
    move.b  d2,1*40(a0)
    move.b  #%00010000,2*40(a0)
    move.b  #%00001000,3*40(a0)
    move.b  d2,4*40(a0)
    move.b  d2,5*40(a0)
    rts
.b4
    move.b  d2,0*40(a0)
    move.b  d2,1*40(a0)
    moveq   #%00011000,d1
    move.b  d1,2*40(a0)
    move.b  d1,3*40(a0)
    move.b  d2,4*40(a0)
    move.b  d2,5*40(a0)
    rts
.b3
    move.b  d2,0*40(a0)
    move.b  d2,1*40(a0)
    moveq   #%00111100,d1
    move.b  d1,2*40(a0)
    move.b  d1,3*40(a0)
    move.b  d2,4*40(a0)
    move.b  d2,5*40(a0)
    rts


* In:
*   a0 = output screen ptr
*   d0 = value 0..63
.drawBar64
    moveq   #64-1,d2
.drawBarX
    moveq   #$ffffff80,d1 * mask
.dl1
    tst.b   d0
    blt     .dlx
    ;or.b    d1,0*40(a0)
    ;or.b    d1,1*40(a0)
    or.b    d1,2*40(a0)
    or.b    d1,3*40(a0)
    or.b    d1,4*40(a0)
;   or.b    d1,5*40(a0)
.dlx
   or.b    d1,5*40(a0)
;    or.b    d1,6*40(a0)
    ror.b   #1,d1
    bpl     .dl2
    addq    #1,a0
.dl2
    subq.b  #1,d0
    dbf     d2,.dl1 
    rts

* In:
*   a0 = output screen ptr
*   d0 = value 0..15
.drawBar16
    moveq   #16-1,d2
    bra     .drawBarX

* In:
*   a0 = output screen ptr
*   d0 = value 0..63
.drawVBar64
    moveq   #%00111110,d1
    moveq   #40,d3
.vl1
    or.b    d1,(a0)
    sub.w   d3,a0
    dbf     d0,.vl1
    rts

           ; 0123456789012345678901234567890123456789
;.row1  dc.b  "Voice1 Flt   Voice2 Flt   Voice3 Flt    "
;.row2  dc.b  "Fr           Fr           Fr            "
;       dc.b  "Pw           Pw           Pw            "
;       dc.b  "Gate   Tri   Gate   Tri   Gate   Tri    "
;       dc.b  "Sync   Saw   Sync   Saw   Sync   Saw    "
;       dc.b  "Ring   Pul   Ring   Pul   Ring   Pul    "
;       dc.b  "Test   Noi   Test   Noi   Test   Noi    "
;       dc.b  "Filter          Reso     LP   BP   HP   "
;.row1b dc.b "Voice4 Flt   Voice5 Flt   Voice6 Flt    "

; The above so that spaces are zeros, this speeds up the print phase
.row1  dc.b  "Voice1",0,"Flt",0,0,0,"Voice2",0,"Flt",0,0,0,"Voice3",0,"Flt",0,0,0,0
.row2  dc.b  "Fr",0,0,0,0,0,0,0,0,0,0,0,"Fr",0,0,0,0,0,0,0,0,0,0,0,"Fr",0,0,0,0,0,0,0,0,0,0,0,0
       dc.b  "Pw",0,0,0,0,0,0,0,0,0,0,0,"Pw",0,0,0,0,0,0,0,0,0,0,0,"Pw",0,0,0,0,0,0,0,0,0,0,0,0
       dc.b  "Gate",0,0,0,"Tri",0,0,0,"Gate",0,0,0,"Tri",0,0,0,"Gate",0,0,0,"Tri",0,0,0,0
       dc.b  "Sync",0,0,0,"Saw",0,0,0,"Sync",0,0,0,"Saw",0,0,0,"Sync",0,0,0,"Saw",0,0,0,0
       dc.b  "Ring",0,0,0,"Pul",0,0,0,"Ring",0,0,0,"Pul",0,0,0,"Ring",0,0,0,"Pul",0,0,0,0
       dc.b  "Test",0,0,0,"Noi",0,0,0,"Test",0,0,0,"Noi",0,0,0,"Test",0,0,0,"Noi",0,0,0,0
       dc.b  "Filter",0,0,0,0,0,0,0,0,0,0,"Reso",0,0,0,0,0,"LP",0,0,0,"BP",0,0,0,"HP",0,0,0
.row1b dc.b  "Voice4",0,"Flt",0,0,0,"Voice5",0,"Flt",0,0,0,"Voice6",0,"Flt",0,0,0,0
.row1c dc.b  "Voice7",0,"Flt",0,0,0,"Voice8",0,"Flt",0,0,0,"Voice9",0,"Flt",0,0,0,0
    even



* Read the HVSC provided simple song length data
* from the converted preloaded index.
* Store it into a buffer where it can be read later.
sid_readSongLength:
    DPRINT  "sid_readSongLength"
    bsr     sid_freeSongLengthData

    tst.l   slIndexPtr(a5)
    beq     .x

    move.l  modulefilename(a5),d0
    beq     .x
    move.l  d0,a0
    jsr     getStilHash
    * d0 = hash to find

    move.l  slIndexPtr(a5),a0
    move.l  -4(a0),d1
    lea     -4(a0,d1.l),a1  * end of buffer
    addq    #4,a0           * skip md5 file length
.find
    moveq   #0,d1
    move.l  a0,a2
    move.b  (a2)+,d1        * length
    bpl     .s1
    and.w   #$7f,d1         * clear top indicator bit
    lsl     #8,d1
    move.b  (a2)+,d1        * word length
.s1 add.l   d1,a0           * next entry

    move.b  (a2)+,d1        * read hash
    ror     #8,d1
    move.b  (a2)+,d1
    swap    d1
    move.b  (a2)+,d1
    ror     #8,d1
    move.b  (a2)+,d1

    cmp.l   d0,d1
    beq     .found

    cmp.l   a1,a0
    blo     .find
    DPRINT  "no match"
.x
    rts

.found
    DPRINT  "found it"
    * read lengths from a2 until a0
    pushm   a0/a2
    * Allocate some mem for unpacked lengths,
    * roughly.
    move.l  a0,d0
    sub.l   a2,d0
    DPRINT  "entry=%ld"
    add.l   d0,d0
    move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
    jsr     getmem
    popm    a0/a2
    move.l  d0,sidSongLengthData(a5)
    beq     .x
    move.l  d0,a1
.slop  
    moveq   #0,d0
    move.b  (a2)+,d0
    bpl     .1
    and     #$7f,d0
    lsl     #8,d0
    move.b  (a2)+,d0
.1  move    d0,(a1)+
    DPRINT  "len=%lds"
    cmp.l   a2,a0
    bne     .slop
    rts

sid_freeSongLengthData:
    move.l  sidSongLengthData(a5),a0
    clr.l   sidSongLengthData(a5)
    jmp     freemem

* Fetch and store song length for current SID song
* and store it in kokonaisaika(a5)
sid_getSongLength:
    push    d0
    clr.l   kokonaisaika(a5)

    move.l  sidSongLengthData(a5),d0
    beq     .x
    move.l  d0,a0
    moveq   #0,d0
    move    songnumber(a5),d0
    add     d0,d0
    move    (a0,d0),d0
    divu    #60,d0
    move    d0,kokonaisaika(a5)
    swap    d0
    move    d0,kokonaisaika+2(a5)

    * Update capability flags to match
    tst.l   kokonaisaika(a5)
    beq     .x
    lea     p_sid\.flags(pc),a0
    or.w    #pf_end,(a0)
    DPRINT  "sid_getSongLength=%08.8lx"
.x  pop     d0
    rts

* T‰nne v‰liin h‰m‰‰v‰sti

*******************************************************************************
* Tarkistaa keyfilen. Muuttaa rekisterˆij‰n nimen tekstiksi ja palauttaa
* keycheck(a5):ss‰ nollan, jos aito.
*******

check_keyfile
	tst.b	keyfilechecked(a5)
	beq.b	.not
	rts
.not	st	keyfilechecked(a5)

	lea	keyfile(a5),a4
	move.l	56(a4),d0
	swap	d0
	lsr.l	#1,d0
	divu	#1005,d0
	moveq	#0,d4

	move.l	a4,a0
	moveq	#38-1,d2
	moveq	#0,d1
.k	sub.b	(a0)+,d1
	dbf	d2,.k

	sub.l	d1,d0
	add.b	d0,d4

	move.l	a4,a0
	move	30(a0),d0		* %111
	lsr	#1,d0

	moveq	#0,d1			* %111
	move	34(a0),d1
	move	d1,d2
	subq.b	#1,d1
	lsl	#3,d1
	or.l	d1,d0

	moveq	#0,d1			* %11111
	move.b	32(a0),d1
	sub	d2,d1
	lsl.l	#6,d1
	or.l	d1,d0

	moveq	#0,d1
	move.b	36(a0),d1
	lsl.l	#8,d1
	lsl.l	#2,d1
	or.l	d1,d0

	clr.b	36(a0)
	clr.b	32(a0)
	clr	34(a0)
	clr	30(a0)

	move.l	a4,a0
	moveq	#32-1,d3
	moveq	#0,d2
.cle	moveq	#0,d1
	move.b	(a0)+,d1
	add	d1,d2
	dbf	d3,.cle

	sub.l	d2,d0
	add.b	d0,d4

	bra.b	.l
.ll	move.b	-2(a4),d0
	sub.b	d0,-1(a4)
.l	tst.b	(a4)+
	bne.b	.ll

	or.b	d4,keycheck(a5)
	bne.b	.hot

	lea	wreg1,a0
	clr.b	(a0)
	clr.b	wreg2-wreg1(a0)
	clr.b	wreg3-wreg1(a0)
.hot	rts	




******************************************************************************
* Delta music
******************************************************************************
p_deltamusic
	jmp	.deltainit(pc)
	jmp	.deltaplay(pc)
	p_NOP
	jmp	.deltaend(pc)
	jmp	.deltastop(pc)
	p_NOP
	jmp	.deltavolume(pc)
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp .id_deltamusic(pc)
	jmp	.author(pc)
	dc.w pt_delta2 				* type
	dc	pf_cont!pf_stop!pf_volume!pf_ciakelaus
	dc.b	"Delta Music 2",0
.a	dc.b	"Bent Nielsen",0
 even

.author
	pushpea	.a(pc),d0
	rts

.deltainit
    bsr     generalReplayInitNoAlloc
	beq.b	.ok2
	rts
.ok2
	movem.l	d0-a6,-(sp)
	moveq	#1,d0
.delt	move.l	moduleaddress(a5),a0
	jsr	(a0)
	movem.l	(sp)+,d0-a6
	moveq	#0,d0
	rts	

.deltaplay
	movem.l	d0-a6,-(sp)
	moveq	#0,d0	
	bra.b	.delt

.deltaend
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat
.deltastop
	bra	clearsound

.deltavolume
	movem.l	d0-a6,-(sp)
	move	mainvolume(a5),d1
	subq	#1,d1
	bpl.b	.err
	moveq	#0,d1
.err	moveq	#2,d0
	bra.b	.delt



.id_deltamusic
	lea	.delta_id(pc),a1	* Delta Music 2
	moveq	#.delend-.delta_id,d0
	bsr	search
	bra	idtest

.delta_id
	dc.b	"DELTA MUSIC"
.delend
 even


******************************************************************************
* Future Composer 1.0 - 1.3
******************************************************************************

fc_author
	pushpea	.a(pc),d0
	rts

.a	dc.b	"Supersero/Superions (based on Jochen Hippel replay)",0
	even 

p_futurecomposer13
	jmp	.fc10init(pc)
	jmp	.fc10play(pc)
	p_NOP
	jmp	.fc10end(pc)
	jmp	.fc10stop(pc)
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp .id_futurecomposer13(pc)
	jmp	fc_author(pc)
	dc.w pt_future10			* type
	dc	pf_cont!pf_stop!pf_volume!pf_end!pf_ciakelaus!pf_poslen!pf_scope!pf_quadscopePoke
	dc.b	"Future Composer v1.0-1.3",0
 even


.offset_init = $20+0
.offset_play = $20+4


.fc10init
	lea	fc10routines(a5),a0
    * Into CHIP, has waveforms in it
    bsr generalReplayInitChipMem
	beq.b	.ok3
    rts
.ok3
	pushm	d0-d7/a1-a6
	move.l	moduleaddress(a5),a0
	lea	mainvolume(a5),a1
	lea	songover(a5),a2
	lea	scopeData(a5),a3
	move.l	fc10routines(a5),a4
	jsr	.offset_init(a4)
	popm	d0-d7/a1-a6
	move.l	a0,deliPatternInfo(a5)
	moveq	#0,d0
	rts
.fc10play
	push	a5
	move.l	fc10routines(a5),a0
	jsr	.offset_play(a0)
	pop	a5
	move	d0,pos_nykyinen(a5)
	move	d1,pos_maksimi(a5)
	rts

.fc10end
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat
.fc10stop
	bra	clearsound

.id_futurecomposer13
	cmp.l	#'SMOD',(a4)		* Futurecomposer 1.0-1.3
	bra	idtest

******************************************************************************
* Future Composer 1.4
******************************************************************************


p_futurecomposer14
	jmp	.fc10init(pc)
	jmp	.fc10play(pc)
	p_NOP
	jmp	.fc10end(pc)
	jmp	.fc10stop(pc)
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp .id_futurecomposer14(pc)
	jmp	fc_author(pc)
	dc.w pt_future14	* type
	dc	pf_cont!pf_stop!pf_volume!pf_end!pf_ciakelaus!pf_poslen!pf_scope!pf_quadscopePoke
	dc.b	"Future Composer v1.4",0

 even

.offset_init = $20+0
.offset_play = $20+4
.offset_end = $20+8


.fc10init
	lea	fc14routines(a5),a0
    bsr generalReplayInitChipMem
	beq.b	.ok3
	rts
.ok3	
	pushm 	d0-d7/a1-a6
	move.l	moduleaddress(a5),a0
	lea	mainvolume(a5),a1
	lea	songover(a5),a2
	lea	scopeData(a5),a3
	move.l	fc14routines(a5),a4
	jsr	.offset_init(a4)
	popm	d0-d7/a1-a6
	move.l	a0,deliPatternInfo(a5)
	moveq	#0,d0
	rts
.fc10play
	move.l	fc14routines(a5),a0
	push	a5
	jsr	.offset_play(a0)
	pop 	a5 
	move	d0,pos_nykyinen(a5)
	move	d1,pos_maksimi(a5)
	rts

.fc10end
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat
.fc10stop
	bra	clearsound

.id_futurecomposer14
	cmp.l	#'FC14',(a4)		* Futurecomposer 1.4
	bra	idtest




******************************************************************************
* SoundMon
******************************************************************************

bp_author 
	pushpea	.a(pc),d0 
	rts

.a 	dc.b	"Brian Postma",0 
	even

p_soundmon
	jmp	.bpsminit(pc)
	jmp	.bpsmplay(pc)
	p_NOP
	jmp	.bpsmend(pc)
	jmp	.bpsmstop(pc)
	p_NOP
	p_NOP
	p_NOP
	jmp	.eteen(pc)
	jmp	.taakse(pc)
	p_NOP
	jmp .id_soundmon(pc)
	jmp	bp_author(pc)
	dc.w pt_soundmon2
 	dc pf_scope!pf_cont!pf_stop!pf_poslen!pf_kelaus!pf_volume!pf_end!pf_ciakelaus2!pf_scope!pf_quadscopePoke!pf_slidePos
	dc.b	"BP SoundMon v2.0",0
 even

.offset_init	= $20+0
.offset_play	= $20+4
.offset_forward	= $20+8
.offset_rewind	= $20+12


.bpsminit
	lea	bpsmroutines(a5),a0
    bsr generalReplayInit
    beq .ok3
    rts
.ok3


	move.l	moduleaddress(a5),a0
	lea	songover(a5),a1
	lea	pos_nykyinen(a5),a2
	lea	nullsample,a3
	clr.l	(a3)
	lea	mainvolume(a5),a4
	pushpea	dmawait(pc),d0
	pushpea	scopeData(a5),d1

	pushm	a5/a6
	move.l	bpsmroutines(a5),a6
	jsr	.offset_init(a6)
	popm	a5/a6
	move.l	a0,deliPatternInfo(a5)
	moveq	#0,d0
	rts
.bpsmplay
	move.l	bpsmroutines(a5),a0
	jmp	.offset_play(a0)
.bpsmend
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat

.bpsmstop
	bra	clearsound

.eteen
	move.l	bpsmroutines(a5),a0
	jmp	.offset_forward(a0)

.taakse
	move.l	bpsmroutines(a5),a0
	jmp	.offset_rewind(a0)



.id_soundmon 
	bsr.b 	.id_soundmon_
	bne.b 	.x 
	moveq	#25-1,d0
	bsr	copyNameFromModule
	moveq	#0,d0
.x	rts

.id_soundmon_
	move.l	26(a4),d0		* Soundmon
	lsr.l	#8,d0
	cmp.l	#'V.2',d0
	bra	idtest



******************************************************************************
* SoundMon 3
******************************************************************************

p_soundmon3
	jmp	.bpsminit(pc)
	jmp	.bpsmplay(pc)
	p_NOP
	jmp	.bpsmend(pc)
	jmp	.bpsmstop(pc)
	p_NOP
	p_NOP
	p_NOP
	jmp	.eteen(pc)
	jmp	.taakse(pc)
	p_NOP	
	jmp 	.id_soundmon3(pc)
	jmp	bp_author(pc)
	dc.w 	pt_soundmon3 	* type
 	dc pf_scope!pf_cont!pf_stop!pf_poslen!pf_kelaus!pf_volume!pf_end!pf_ciakelaus2!pf_scope!pf_quadscopePoke!pf_slidePos
	dc.b	"BP SoundMon 3 (v2.2)",0
 even

.bpsminit
	lea	bpsmroutines(a5),a0
    bsr generalReplayInit
	beq.b	.ok3
    rts
.ok3


	move.l	moduleaddress(a5),a0
	lea	songover(a5),a1
	lea	pos_nykyinen(a5),a2
	lea	nullsample,a3
	clr.l	(a3)
	lea	mainvolume(a5),a4
	pushpea	dmawait(pc),d0
	pushpea	scopeData(a5),d1

	pushm	a5/a6
	move.l	bpsmroutines(a5),a6
	jsr	$20(a6)
	popm	a5/a6
	move.l	a0,deliPatternInfo(a5)
	moveq	#0,d0
	rts
.bpsmplay
	move.l	bpsmroutines(a5),a0
	jmp	$20+4(a0)
.bpsmend
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat

.bpsmstop
	bra	clearsound

.taakse
	move.l	bpsmroutines(a5),a0
	jmp	12+$20(a0)

.eteen
	move.l	bpsmroutines(a5),a0
	jmp	8+$20(a0)


.id_soundmon3 
	bsr.b 	.id_soundmon3_
	bne.b 	.x 
	moveq	#25-1,d0
	bsr	copyNameFromModule
	moveq	#0,d0
.x	rts

.id_soundmon3_
	move.l	26(a4),d0		* Soundmon
	lsr.l	#8,d0
	cmp.l	#'V.3',d0
	beq.b	.y
	cmp.l	#'BPS',d0
	bra	idtest

.y	moveq	#0,d0
	rts


******************************************************************************
* Jamcracker
******************************************************************************

p_jamcracker
	jmp	.jaminit(pc)
	jmp	.jamplay(pc)
	p_NOP
	jmp	.jamend(pc)
	jmp	.jamstop(pc)
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp .id_jamcracker(pc)
	jmp	.author(pc)
	dc.w pt_jamcracker				* type
	dc	pf_cont!pf_stop!pf_end!pf_ciakelaus!pf_poslen!pf_volume!pf_scope!pf_quadscopePoke
	dc.b	"JamCracker",0
.a 	dc.b 	"Xag/Betrayal, Martin Kemmel",0
 even

.offset_init	= $20+0
.offset_play	= $20+4


.author
	pushpea	.a(pc),d0
	rts 

.jaminit
	lea	jamroutines(a5),a0
    bsr generalReplayInit
	beq.b	.ok3
    rts
.ok3	
	pushm 	a5/a6
	move.l	moduleaddress(a5),a0
	lea	dmawait(pc),a1
	lea	songover(a5),a2
	lea 	mainvolume(a5),a3 
	lea 	nullsample,a4
	move.l	jamroutines(a5),a6
	lea	scopeData(a5),a5
	jsr	.offset_init(a6)
	popm 	a5/a6
	move	d0,pos_maksimi(a5)
	move.l	a0,deliPatternInfo(a5)
	moveq	#0,d0
	rts	

.jamplay
	move.l	jamroutines(a5),a0
	jsr 	.offset_play(a0)
	move	d0,pos_nykyinen(a5)
	rts

.jamend
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat

.jamstop
	bra	clearsound


.id_jamcracker
	cmp.l	#'BeEp',(a4)		* JamCracker
	bra	idtest

******************************************************************************
* Music Assembler
******************************************************************************

p_musicassembler
	jmp	.massinit(pc)
	jmp	.massplay(pc)
	p_NOP
	jmp	.massend(pc)
	jmp	.massstop(pc)
	p_NOP
	jmp	.massvolume(pc)
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp .id_musicassembler(pc)
	jmp	.author(pc)
	dc.w pt_musicass				* type
	dc	pf_cont!pf_stop!pf_volume!pf_ciakelaus
	dc.b	"Music Assembler",0
.a 	dc.b	"Oscar Giesen, Marco Swagerman",0
 even

.author
	pushpea	.a(pc),d0
	rts

.massinit
    bsr     generalReplayInitNoAlloc
	beq.b	.ok2
	rts
.ok2

    * This one has a volume write bug similar with Imploder tunes
    * MOVE.B	D6,8(A3)  
    * will result silence on 68040/68060, should be:
    * MOVE.W	D6,8(A3)  
    * patch it:
    move.l  moduleaddress(a5),a0
    move.l  a0,a1
    add.l   modulelength(a0),a1
    subq.l  #8,a1
    move.l  .findPatch(pc),d1
.patch
    cmp.l   (a0),d1
    bne.b   .1
    cmp.w   #$4e75,8(a0) * also check for RTS to be sure
    bne     .1
    move.l  .replacePatch(pc),(a0)
    bra     .2
.1  addq.l  #2,a0
    cmp.l   a1,a0
    blo     .patch
.2  jsr     clearCpuCaches

    
	moveq	#0,d0
.minit	move.l	moduleaddress(a5),a0
	jsr	(a0)
	bsr.b	.massvolume
	moveq	#0,d0
	rts	

* Patch length: 4 bytes
.findPatch
    MOVE.B	D6,8(A3)  
.replacePatch
    MOVE.W	D6,8(A3)  

.massplay
	move.l	moduleaddress(a5),a0
	jmp	12(a0)

.massend
	bsr	rem_ciaint
	pushm	all
	move.l	moduleaddress(a5),a0
	jsr	4(a0)
	popm	all
	bra	vapauta_kanavat

.massstop
	bra	clearsound


.massvolume
	move	mainvolume(a5),d0
	moveq	#$f,d1
	move.l	moduleaddress(a5),a0
	jmp	8(a0)

;.masssong
;	move.l	moduleaddress(a5),a0
;	jsr	4(a0)		* end
;	moveq	#0,d0
;	move	songnumber(a5),d0
;	bra.b	.minit



.id_musicassembler
	lea	.muass_id(pc),a1	* Music Assembler
	moveq	#.muassend-.muass_id,d0
	bsr	search
	bra	idtest


.muass_id
	dc.b	"usa-team 89"
.muassend
 even

******************************************************************************
* Fred
******************************************************************************

p_fred
	jmp	.fredinit(pc)
	jmp	.fredplay(pc)
	p_NOP
	jmp	.fredend(pc)
	jmp	.fredstop(pc)
	p_NOP
	p_NOP
	jmp	.fredsong(pc)
	p_NOP
	p_NOP
	p_NOP
	jmp .id_fred(pc)
	jmp	.author(pc)
	dc.w pt_fred				* type
	dc	pf_cont!pf_stop!pf_song!pf_ciakelaus
	dc.b	"Fred",0
.a 	dc.b	"Frederic Hahn",0
 even

.author
	pushpea	.a(pc),d0
	rts
	
.fredinit
    bsr     generalReplayInitNoAlloc
	beq.b	.ok2
	rts
.ok2
	movem.l	d0-a6,-(sp)
	moveq	#0,d0
	bset	#1,$bfe001
.finit	move.l	moduleaddress(a5),a0
	jsr	(a0)
	movem.l	(sp)+,d0-a6
	moveq	#0,d0
	rts	

.fredplay
	move.l	moduleaddress(a5),a0
	jmp	4(a0)

.fredend
	bsr	rem_ciaint
	movem.l	d0-a6,-(sp)
	move.l	moduleaddress(a5),a0
	jsr	8(a0)
	movem.l	(sp)+,d0-a6
	bra	vapauta_kanavat

.fredstop
	bra	clearsound


.fredsong
	movem.l	d0-a6,-(sp)
	move.l	moduleaddress(a5),a0
	jsr	8(a0)		* end
	moveq	#0,d0
	move	songnumber(a5),d0
	bra.b	.finit


.id_fred
* d5 => maxsongs
	move.l	a4,a0
	moveq	#-1,d0				; Modul nicht erkannt (default)
	cmpi.w	#$4efa,(a0)
	bne.s	.ChkEnd
	cmpi.w	#$4efa,$04(a0)
	bne.s	.ChkEnd
	cmpi.w	#$4efa,$08(a0)
	bne.s	.ChkEnd
	cmpi.w	#$4efa,$0c(a0)
	bne.s	.ChkEnd
	add.w	2(a0),a0
	moveq	#4-1,d1
.ChkLoop cmpi.w	#$123a,2(a0)
	bne.s	.ChkNext
	cmpi.w	#$b001,6(a0)
	beq.s	.ChkSong
.ChkNext addq.l	#2,a0
	dbra	d1,.ChkLoop
	bra.s	.ChkEnd				; Modul nicht erkannt
.ChkSong add.w	4(a0),a0
	moveq	#0,d5
	move.b	4(a0),d5
	move	d5,maxsongs(a5)
	moveq	#0,d0				; Modul erkannt
.ChkEnd	tst.l	d0
	rts


******************************************************************************
* SonicArranger
******************************************************************************

p_sonicarranger
	jmp	.init(pc)
	jmp	 .play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	 .stop(pc)
	p_NOP
	p_NOP
	jmp 	.song(pc)
	jmp 	.forward(pc)
	jmp 	.backward(pc)
	p_NOP
	jmp .id_sonicarranger(pc)
	jmp	.author(pc)
	dc.w pt_sonicarranger				* type
	dc pf_cont!pf_stop!pf_poslen!pf_kelaus!pf_volume!pf_end!pf_ciakelaus2!pf_song
	dc.b	"Sonic Arranger",0
.a 	dc.b	"Carsten Schlote, Branko Mikic, Carsten Herbst",0
 even

.author
	pushpea	.a(pc),d0
	rts	

.offset_init 		= $20+0
.offset_play 		= $20+4
.offset_end		= $20+8
.offset_song 		= $20+12
.offset_forward 	= $20+16
.offset_backward 	= $20+20

.init
	lea	sonicroutines(a5),a0
    bsr generalReplayInit
	beq.b	.ok3
    rts
.ok3
	;bra	.skip

	move.l	moduleaddress(a5),a0
	move.l	modulelength(a5),d0
	lea	mainvolume(a5),a1
	lea	songover(a5),a2
	lea	pos_nykyinen(a5),a3
	move.l	sonicroutines(a5),a4
	push	a5
	jsr	.offset_init(a4)
	pop	a5
	cmp.b	#-1,d0
	beq.b	.memErr
	cmp.b	#-2,d0
	beq.b	.formatErr
	move	d1,pos_maksimi(a5)
	move	d3,maxsongs(a5)

	move	d2,d0
	bsr	ciaint_setTempoFromD0
.skip
	moveq	#0,d0
	rts	

.memErr	moveq	#ier_nomem,d0
	rts
.formatErr
	moveq	#ier_not_compatible,d0
	rts

.end
	bsr	rem_ciaint
	move.l	sonicroutines(a5),a0
	jsr	.offset_end(a0)
	bsr	clearsound
	bra	vapauta_kanavat

.stop
	bra	clearsound
	
.song
	move	songnumber(a5),d0
	move.l	sonicroutines(a5),a0
	push	a5
	jsr	.offset_song(a0)
	pop	a5
	move	d0,pos_maksimi(a5)
	rts

.forward
	move.l	sonicroutines(a5),a0
	push	a5
	jsr	.offset_forward(a0)
	pop	a5
	rts
.backward
	move.l	sonicroutines(a5),a0
	push	a5
	jsr	.offset_backward(a0)
	pop	a5
	rts

.play	
	move.l	sonicroutines(a5),a0
	jmp	.offset_play(a0)


; in: a4 = module
;     d7 = module length
; out: d0 = 0, valid valid
;      d0 = -1, not valid
.id_sonicarranger
	move.l	a4,a0
	move.l	d7,d3
	moveq	#-1,D0

	cmp.l	#'SOAR',(A0)
	bne.b	.NoSong
	addq.l	#4,A0
	cmp.l	#'V1.0',(A0)+
	bne	.Fault
	cmp.l	#'STBL',(A0)
	bne	.Fault
	bra	.Found
.NoSong
	cmp.w	#$4EFA,(A0)
	bne.b	.NoRepa
	move.w	2(A0),D1
	beq.b	.Fault
	bmi.b	.Fault
	btst	#0,D1
	bne.b	.Fault
	lea	6(A0,D1.W),A1
	cmp.w	#$41FA,(A1)+
	bne.b	.Fault
	moveq	#0,D1
	move.w	(A1),D1
	beq.b	.Fault
	bmi.b	.Fault
	btst	#0,D1
	bne.b	.Fault
	add.w	D1,A1
	subq.l	#8,D3
	sub.l	D1,D3
	bmi.b	.Fault
	move.l	A1,A0
.NoRepa
	move.l	A0,A1
	moveq	#$28,D1
	sub.l	D1,D3
	bmi.b	.Fault
	cmp.l	(A1)+,D1
	bne.b	.Fault
	moveq	#6,D1
.NextLong
	move.l	(A1)+,D2
	beq.b	.Fault
	bmi.b	.Fault
	btst	#0,D2
	bne.b	.Fault
	dbf	D1,.NextLong
	sub.l	D2,D3
	bmi.b	.Fault
	lea	(A0,D2.L),A1
	move.l	(A1)+,D1
	beq.b	.SynthOnly
	move.l	A1,A0
.NextSize
	sub.l	(A0),D3
	bmi.b	.Fault
	add.l	(A0)+,A1
	addq.l	#4,A1
	subq.l	#1,D1
	bne.b	.NextSize
.SynthOnly
	moveq	#12,D1
	sub.l	D1,D3
	bmi.b	.Fault
	lea	.Text(PC),A0
.CheckString
	cmpm.b	(A0)+,(A1)+
	bne.b	.Fault
	dbeq	D1,.CheckString
.Found
	moveq	#0,D0
.Fault
	tst.l	d0
	rts
.Text
	dc.b	'deadbeef'
	dc.l	0


******************************************************************************
* SidMon 1.0
******************************************************************************

p_sidmon1
	jmp	.sm10init(pc)
	jmp	.sm10play(pc)
	p_NOP
	jmp	.sm10end(pc)
	jmp	.sm10stop(pc)
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp 	.id_sidmon1(pc)
	jmp	author_vliet(pc)
	dc.w 	pt_sidmon1			* type
	dc	pf_stop!pf_cont!pf_ciakelaus
	dc.b	"SidMon 1",0
 even

.sm10init
    bsr     generalReplayInitNoAlloc
	beq.b	.ok2
	rts
.ok2
	movem.l	d0-a6,-(sp)
	; The id routine does code modification to the module
	; provided replay routine, for safety clear caches
	; before calling.
	bsr	clearCpuCaches
	move.l	sid10init(pc),a0
	jsr	(a0)
	movem.l	(sp)+,d0-a6
	moveq	#0,d0
	rts	

.sm10play
	move.l	sid10music(pc),a0
	jmp	(a0)

.sm10end
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat
.sm10stop
	bra	clearsound



.id_sidmon1
* d1 => sid10init
* d2 => sid10music
	move.l	a4,a0
	bsr.b	.do 
	tst.l	d0 
	bne.b 	.no
	move.l	d1,sid10init
	move.l	d2,sid10music
.no
	rts 
.do
	moveq	#-$01,d0
	cmpi.l	#$08f90001,(a0)
	bne.b	.l_f218
	cmpi.l	#$00bfe001,$0004(a0)
.l_f1f6	bne.b	.l_f218
	cmpi.w	#$4e75,$025c(a0)
	beq.b	.l_f20e
	cmpi.w	#$4ef9,$025c(a0)
	bne.b	.l_f218
	move.w	#$4e75,$025c(a0)
.l_f20e	moveq	#$2c,d1
	move.l	#$0000016a,d2
	bra.b	.l_f266
.l_f218	cmpi.w	#$41fa,(a0)
	bne.b	.l_f278
	cmpi.w	#$d1e8,$0004(a0)
	bne.b	.l_f278
	cmpi.w	#$4e75,$0230(a0)
	beq.b	.l_f23e
	cmpi.w	#$4ef9,$0230(a0)
	bne.b	.l_f248
	move.w	#$4e75,$0230(a0)
.l_f23e	moveq	#$00,d1
	move.l	#$0000013e,d2
	bra.b	.l_f266
.l_f248	cmpi.w	#$4e75,$029c(a0)
	beq.b	.l_f25e
	cmpi.w	#$4ef9,$029c(a0)
	bne.b	.l_f278
	move.w	#$4e75,$029c(a0)
.l_f25e	moveq	#$00,d1
	move.l	#$0000016a,d2
.l_f266	moveq	#$00,d0
	add.l	a0,d1		* init
	add.l	a0,d2		* music
;	movem.l	d1/d2,sid10init
.l_f278	
	rts	


sid10init	dc.l	0
sid10music	dc.l	0


******************************************************************************
* Oktalyzer (v1.56)
******************************************************************************

p_oktalyzer
	jmp	.okinit(pc)
	jmp	.okplay(pc)
	p_NOP
	jmp	.okend(pc)
	jmp	.okstop(pc)
	jmp	.okcont(pc)
	jmp	.okvolume(pc)
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp 	.id(pc)
	jmp	.author(pc)
	dc.w 	pt_oktalyzer * type
	dc	pf_volume!pf_end!pf_poslen!pf_stop!pf_cont!pf_scope!pf_quadscopePoke
	dc.b	"Oktalyzer",0
.a	dc.b	"Armin Sander",0
 even

.author
	pushpea	.a(pc),d0 
	rts

.offset_init = $20+0 
.offset_play = $20+4 
.offset_end  = $20+8 
.offset_vol  = $20+12 


.okstop	
	move	#$f,$dff096
	rts
.okcont
	move	#$800f,$dff096
	rts
	
.okinit	
	lea	oktaroutines(a5),a0
    bsr generalReplayInit
	beq.b	.ok3
    rts
.ok3	
	move.l	moduleaddress(a5),a0
	lea	songover(a5),a1
	lea	scopeData(a5),a2
	move.l	oktaroutines(a5),a3
	push	a5
	jsr	.offset_init(a3)
	pop	a5
	tst	d0
	bne.b	.mem
	
	move.l	a0,deliPatternInfo(a5)
 if DEBUG 
	moveq	#0,d0
	move	PI_Voices(a0),d0
	DPRINT	"Voices: %ld"
 endif 
	bsr.b	.okvolume
	moveq	#0,d0
	rts

.mem	moveq	#ier_nomem,d0
	rts

.okplay	
	push	a5
	move.l	oktaroutines(a5),a0
	jsr	.offset_play(a0)
	pop	a5
	move	d0,pos_nykyinen(a5)
	move	d1,pos_maksimi(a5)
	rts

.okend	
	bsr	rem_ciaint
	pushm	all
	move.l	oktaroutines(a5),a0
	jsr	.offset_end(a0)
	popm	all
.oke	bra	vapauta_kanavat

.okvolume
	moveq	#0,d0
	move	mainvolume(a5),d0
	move.l	oktaroutines(a5),a0
	jmp	.offset_vol(a0)


.id 
	bsr.b	id_oktalyzer8ch 
	bne.b	id_oktalyzer

	bsr	moveModuleToPublicMem
	moveq	#0,d0 
	rts

id_oktalyzer
	cmp.l	#'OKTA',(a4)		* Oktalyzer
	bne.b	.nok
	cmp.l	#'SONG',4(a4)
	bra	idtest

.nok	moveq	#-1,d0
	rts

id_oktalyzer8ch
	bsr.b  id_oktalyzer
	bne.b 	.no
	cmp.l	#$00010001,$10(a4)	* Onko 8 kanavaa?
	bne.b	.no
	cmp.l	#$00010001,$10+4(a4)
	beq.b	.go
.no 
	moveq	#-1,d0
	rts
.go 
	moveq	#0,d0
	rts
******************************************************************************
* TFMX
******************************************************************************

tfmx_author
	pushpea	.a(pc),d0 
	rts
.a 
	dc.b	"Chris Huelsbeck, Peter Thierolf",0
	even

p_tfmx
	jmp	.tfmxinit(pc)
	p_NOP
	jmp	.tfmxvb(pc)
	jmp	.tfmxend(pc)
	jmp	.tfmxstop(pc)
	jmp	.tfmxcont(pc)
	jmp	.tfmxvolume(pc)
	jmp	.tfmxsong(pc)
	jmp	.eteen(pc)
	jmp	.taakse(pc)
	p_NOP
	jmp id_tfmx(pc) 
	jmp	tfmx_author(pc)
	dc.w pt_tfmx				* type
	dc	pf_cont!pf_stop!pf_song!pf_volume!pf_kelaus!pf_poslen!pf_end
	dc.b	"TFMX",0
 even


.eteen
	pushm	d0/a0
	move.l	tfmxroutines(a5),a0
	move	7196(a0),d0
	addq	#2,d0
	cmp	7194(a0),d0
	bhi.b	.og
	subq	#1,d0
	move	d0,7196(a0)
.og	popm	d0/a0
	rts

.taakse
	push	a0
	move.l	tfmxroutines(a5),a0
	subq	#1,7196(a0)
	bpl.b	.gog
	clr	7196(a0)
.gog	pop	a0
	rts

.tfmxvb
	push	a0
	move.l	tfmxroutines(a5),a0
	move	7194(a0),pos_maksimi(a5)
	move	7196(a0),pos_nykyinen(a5)
	pop	a0
	rts

.tfmxinit
	bsr	varaa_kanavat
	beq.b	.ok
	moveq	#ier_nochannels,d0
	rts
.ok
	lea	tfmxroutines(a5),a0
	bsr	allocreplayer
	beq.b	.ok2
	bra	vapauta_kanavat
;	rts
.ok2
	move.l	tfmxroutines(a5),a0
	lea	5788(a0),a1
	lea	tfmxi1(pc),a2
;	move.l	a1,tfmxi1
	move.l	a1,(a2)
	lea	2092(a0),a0
;	move.l	a0,tfmxi2
;	move.l	a0,tfmxi3
;	move.l	a0,tfmxi4
;	move.l	a0,tfmxi5
	move.l	a0,tfmxi2-tfmxi1(a2)
	move.l	a0,tfmxi3-tfmxi1(a2)
	move.l	a0,tfmxi4-tfmxi1(a2)
	move.l	a0,tfmxi5-tfmxi1(a2)

	bsr	tfmx_varaa
	beq.b	.ok3
;	move.l	tfmxroutines(a5),a0
;	bsr	freereplayer
	bsr	vapauta_kanavat
	moveq	#ier_nociaints,d0
	rts

.ok3
	bsr	gettfmxsongs
	move	d0,maxsongs(a5)


	move.l	moduleaddress(a5),a0
	cmp.l	#"TFHD",(a0)
	bne.b	.noo

	move.l	a0,d0
	add.l	4(a0),d0		* MDAT
	move.l	d0,d1
	add.l	10(a0),d1		* SMPL
	btst	#0,d1		* onko parittomassa osoitteessa?
	beq.b	.un
	addq.l	#1,d1		* on, v‰‰nnet‰‰n se parilliseksi
	move.l	d1,a0
	clr.l	(a0)		* alusta nollaa tyhj‰ks
	bra.b	.un
.noo


	move.l	moduleaddress(a5),d0
	move.l	tfmxsamplesaddr(a5),d1

.un
	move.l	tfmxroutines(a5),A0
	jsr	$14(A0)
	moveq	#0,d0			* song number
	move	songnumber(a5),d0
	move.l	tfmxroutines(a5),A0
	jsr	12(A0)


	bsr.b	.tfmxvolume
	bsr.b	.tfmxcont
	moveq	#0,d0
	rts

.tfmxcont
	bset	#0,$bfdf00
	rts

.tfmxstop
	bclr	#0,$bfdf00
	bra	clearsound


.tfmxsong
	bsr.b	.tfmxe
	bra.b	.ok3

.tfmxvolume
	moveq	#0,d0
	move	mainvolume(a5),d0
	move.l	tfmxroutines(a5),A0
	jmp	$28(A0)

.tfmxend
	pushm	all
	bsr	tfmx_vapauta
	bsr.b	.tfmxe
	popm	all
	bra	vapauta_kanavat
	
.tfmxe	bsr.b	.tfmxstop
	move.l	tfmxroutines(a5),A0
	jsr	$1C(A0)
	moveq	#0,D0
	move.l	tfmxroutines(a5),A0
	jsr	$20(A0)
	moveq	#1,D0
	move.l	tfmxroutines(a5),A0
	jsr	$20(A0)
	moveq	#2,D0
	move.l	tfmxroutines(a5),A0
	jsr	$20(A0)
	moveq	#3,D0
	move.l	tfmxroutines(a5),A0
	jmp	$20(A0)



tfmx_varaa
	move.l	a6,-(sp)
	moveq	#7,D0
	lea	tfmx_L000106(PC),A1
	move.l	(a5),A6
	jsr	-$A2(A6)
	move.l	D0,tfmx_L0000E0(a5)
	moveq	#8,D0
	lea	tfmx_L00011C(PC),A1
	jsr	-$A2(A6)
	move.l	D0,tfmx_L0000E4(a5)
	moveq	#9,D0
	lea	tfmx_L000132(PC),A1
	jsr	-$A2(A6)
	move.l	D0,tfmx_L0000E8(a5)
	moveq	#10,D0
	lea	tfmx_L000148(PC),A1
	jsr	-$A2(A6)
	move.l	D0,tfmx_L0000EC(a5)
	lea	.n(pc),A1
	jsr	-$1F2(A6)
	move.l	D0,tfmx_L0000DC(a5)
	beq.b	tfmx_C000338
	moveq	#1,D0
	lea	tfmx_L0000F0(PC),A1
	move.l	tfmx_L0000DC(a5),A6
	jsr	-6(A6)
	tst.l	D0
	bne.b	tfmx_C000338
	moveq	#0,D0
	move.l	(sp)+,a6
	rts

.n	dc.b	"ciab.resource",0
 even

* vapautetaan kaikki
tfmx_vapauta
	move.l	a6,-(sp)
	moveq	#1,D0
	lea	tfmx_L0000F0(PC),A1
	move.l	tfmx_L0000DC(a5),A6
	jsr	-12(A6)
tfmx_C000338	moveq	#10,D0
	move.l	tfmx_L0000EC(a5),A1
	move.l	(a5),A6
	jsr	-$A2(A6)
	moveq	#9,D0
	move.l	tfmx_L0000E8(a5),A1
	jsr	-$A2(A6)
	moveq	#8,D0
	move.l	tfmx_L0000E4(a5),A1
	jsr	-$A2(A6)
	moveq	#7,D0
	move.l	tfmx_L0000E0(a5),A1
	jsr	-$A2(A6)
	move.l	(sp)+,a6
	rts


tfmx_L0000F0	dcb.l	$2,0
	dc.b	2,1			* nt_interrupt, prioriteetti 1
	dc.l	TFMX_Pro_MSG0
	dcb.w	$2,0
tfmxi1	dc.l	0
tfmx_L000106	dcb.l	$2,0
	dc.b	2,100
	dc.l	TFMX_Pro_MSG0
	dcb.w	$2,0
tfmxi2	dc.l	0
tfmx_L00011C	dcb.l	$2,0
	dc.b	2,100
	dc.l	TFMX_Pro_MSG0
	dcb.w	$2,0
tfmxi3	dc.l	0
tfmx_L000132	dcb.l	$2,0
	dc.b	2,100
	dc.l	TFMX_Pro_MSG0
	dcb.w	$2,0
tfmxi4	dc.l	0
tfmx_L000148	dcb.l	$2,0
	dc.b	2,100
	dc.l	TFMX_Pro_MSG0
	dcb.w	$2,0
tfmxi5	dc.l	0
TFMX_Pro_MSG0 dc.b "TFMX",0
 even


* palauttaa songien m‰‰r‰n d0:ssa
gettfmxsongs
	move.l	moduleaddress(a5),a0
	lea	$0100(a0),a0
	moveq.l	#-2,d0
	moveq.l	#2,d1
	moveq.l	#$1e,d2
.35a	addq.l	#1,d0
	tst.w	(a0)+
	bne.s	.362
	subq.l	#1,d1
.362	dbeq	d2,.35a
	rts	


* TODO: all variants

id_tfmxunion
	cmp.l	#'TFHD',(a4)		* Yhdistetty TFMX formaatti
	bra	idtest

id_tfmx
	cmp.l	#"TFMX",(a4)
	beq.b	.y
	cmp.l	#"tfmx",(a4)
	bra	idtest

.y	moveq	#0,d0
	rts
	


id_TFMX_PRO	
	move.l	a4,a1
	lea	TFMX_IDs(pc),a0
.id_loop
	tst.b	(a0)
	beq.b	.Not_TFMX_PRO
	move.l	a4,a1		;Module
.strloop
	tst.b	(a0)
	beq.s	.found
	cmpm.b	(a0)+,(a1)+
	beq.s	.strloop
.skiploop
	tst.b	(a0)+
	bne.s	.skiploop
	bra.s	.id_loop
.found
	move.l	a4,a0	;Module
	move.w	$100(a0),d0
	move.l	$1D0(a0),d1
	bne.s	.valid
	move.l	#$800,d1
.valid
	add.l	d1,a0	;Channel table
	moveq	#0,d1
	moveq	#0,d3	;Start as TFMX Pro
.chanloop
	move.w	d0,d2	;Channel number
	lsl.w	#4,d2
	move.l	a0,a2
	add.w	d2,a2	;Channel pointer
	move.w	(a2)+,d2	;Channel number
	cmp.w	#$EFFE,d2	;End mark
	bne.s	.done
	move.w	(a2)+,d2	;Channel type
	add.w	d2,d2
	cmp.w	#10,d2
	blo.s	.notover10
	moveq	#0,d2
	moveq	#0,d3	;Is TFMX Pro
.notover10
	jmp	.JTab(pc,d2.w)
.JTab
	bra.s	.done
	bra.s	.test
	bra.s	.next
	bra.s	.probably_not
	bra.s	.next
.test
	tst.w	d1	;Flip-flop?
	beq.s	.start
	bmi.s	.channum
	bra.s	.chan
.start
	move.w	#$FFFF,d1
	addq.w	#1,d0	;Next channel
	bra.s	.chanloop
.channum
	move.w	2(a2),d1
.chan
	subq.w	#1,d1
	move.w	(a2),d0	;Paired channel?
	bra.s	.chanloop
.probably_not
	moveq	#-1,d3
.next
	addq.w	#1,d0	;Next Channel
	bra.s	.chanloop
.done
	tst.l	d3
	bne.s	.Not_TFMX_PRO
	moveq	#0,d0	;Identified!
	bra.s	.exit
.Not_TFMX_PRO
	moveq	#-1,d0
.exit
	rts

TFMX_IDs
	dc.b	'tfmxsong',0
	dc.b	'TFMX-SONG',0
	dc.b	'TFMX_SONG',0,0


******************************************************************************
* TFMX 7 channels
******************************************************************************



p_tfmx7
	jmp	.tfmxinit(pc)
	p_NOP
	jmp	.vb(pc)
	jmp	.tfmxend(pc)
	jmp	.stop(pc)
	jmp	.cont(pc)
	jmp	.tfmxvol(pc)
	jmp	.tfmxsong(pc)
	jmp	.eteen(pc)
	jmp	.taakse(pc)
	p_NOP
	jmp 	id_TFMX7V(pc)
	jmp	tfmx_author(pc)
	dc.w 	pt_tfmx7 	* type
	dc	pf_volume!pf_song!pf_poslen!pf_kelaus!pf_end!pf_stop!pf_cont
	dc.b	"TFMX 7ch",0
 even

.OFFSET_INIT = 0+$20
.OFFSET_END = 4+$20
.OFFSET_VOL = 8+$20
.OFFSET_FORWARD = 12+$20
.OFFSET_BACKWARD = 16+$20
.OFFSET_STOP = 20+$20
.OFFSET_CONTINUE = 24+$20
.OFFSET_POSITION = 28+$20

.stop
	move.l	tfmx7routines(a5),a0
	jmp 	.OFFSET_STOP(a0)

.cont	
	move.l	tfmx7routines(a5),a0
	jmp 	.OFFSET_CONTINUE(a0)

.eteen
	move.l	tfmx7routines(a5),a0
	jmp	.OFFSET_FORWARD(a0)
	
.taakse
	move.l	tfmx7routines(a5),a0
	jmp 	.OFFSET_BACKWARD(a0)

.vb	push	a0
	move.l	tfmx7routines(a5),a0
	jsr	.OFFSET_POSITION(a0)
	move	d0,pos_nykyinen(a5)
	move	d1,pos_maksimi(a5)
	pop	a0
	rts

.tfmxend
	tst.l	tfmx7routines(a5)
	beq.b	.e
	move.l	tfmx7routines(a5),a4
	pushm	all
	jsr	.OFFSET_END(a4)
	popm	all
	bsr	vapauta_kanavat
	move.l	.tfmxbuf(pc),a0
	jsr	freemem
	clr.l	.tfmxbuf
.e	rts

.tfmxsong
	bsr.b	.tfmxend
;	bra	.tfmxinit

.tfmxinit
	bsr	varaa_kanavat
	beq.b	.okk
	moveq	#ier_nochannels,d0
	rts
.okk
	movem.l	d1-a6,-(sp)
	bsr.b	.eh
	movem.l	(sp)+,d1-a6
	rts

.eh
	lea	tfmx7routines(a5),a0
	bsr	allocreplayer
	beq.b	.ok
	rts
.ok
	move.l	#4096+1024,d0	* +turva-alue
	move.l	#MEMF_CHIP!MEMF_CLEAR,d1
	jsr	getmem
	move.l	d0,.tfmxbuf
	bne.b	.ok2
;	lea	tfmx7routines(a5),a0
;	bsr	freereplayer
	moveq	#ier_nomem,d0
	rts
.ok2	

	bsr	gettfmxsongs
	move	d0,maxsongs(a5)


	move.l	moduleaddress(a5),a0
	cmp.l	#"TFHD",(a0)
	bne.b	.noo

	move.l	a0,d0
	add.l	4(a0),d0		* MDAT
	move.l	d0,d1
	add.l	10(a0),d1		* SMPL
	bra.b	.un
.noo
	move.l	moduleaddress(a5),d0
	move.l	tfmxsamplesaddr(a5),d1

.un
	move.l	tfmxroutines(a5),a4
	moveq	#0,d3
	move	songnumber(a5),d3
	moveq	#0,d2
	move	tfmxmixingrate(a5),d2
	move.l	.tfmxbuf(pc),d4
	move.l	a5,-(sp)
	jsr	.OFFSET_INIT(a4)
	move.l	(sp)+,a5
	bsr.b	.tfmxvol
	moveq	#0,d0
	rts


.tfmxbuf dc.l	0	* koko 4096

.tfmxvol
	move	mainvolume(a5),d0
	move.l	tfmx7routines(a5),a4
	move.l	a5,-(sp)
	jsr	.OFFSET_VOL(a4)
	move.l	(sp)+,a5
	rts



id_TFMX7V
	move.l	a4,a1
	lea	TFMX_IDs(pc),a0
.idloop
	tst.b	(a0)
	beq.b	.Not_TFMX7V
	move.l	a4,a1
.strloop
	tst.b	(a0)
	beq.s	.validID
	cmpm.b	(a0)+,(a1)+
	beq.s	.strloop
.skiploop
	tst.b	(a0)+
	bne.s	.skiploop
	bra.s	.idloop
.validID
	move.l	a4,a0
	move.w	$100(a0),d0
	move.l	$1D0(a0),d1
	bne.s	.valid
	move.l	#$800,d1
.valid
	add.l	d1,a0
	moveq	#0,d1
	moveq	#0,d3
.chanloop
	move.w	d0,d2
	lsl.w	#4,d2
	move.l	a0,a2
	add.w	d2,a2
	move.w	(a2)+,d2
	cmp.w	#$EFFE,d2
	bne.s	.done
	move.w	(a2)+,d2
	add.w	d2,d2
	cmp.w	#10,d2
	blo.s	.intable
	moveq	#0,d2
	moveq	#0,d3
.intable
	jmp	.JTab(pc,d2.w)
.JTab
	bra.s	.done
	bra.s	.check
	bra.s	.next
	bra.s	.probably_not
	bra.s	.next
.check
	tst.w	d1
	beq.s	.norm
	bmi.s	.paired
	bra.s	.chan
.norm
	move.w	#$FFFF,d1
	addq.w	#1,d0
	bra.s	.chanloop
.paired
	move.w	2(a2),d1
.chan
	subq.w	#1,d1
	move.w	(a2),d0
	bra.s	.chanloop
.probably_not
	moveq	#-1,d3
.next
	addq.w	#1,d0
	bra.s	.chanloop
.done
	tst.l	d3
	beq.s	.Not_TFMX7V
	moveq	#0,d0	;Identified!
	bra.s	.exit
.Not_TFMX7V
	moveq	#-1,d0
.exit
	rts




******************************************************************************
* MED
******************************************************************************

p_med:
	jmp	.medinit(pc)
	p_NOP
	jmp	.medvb(pc)
	jmp	.medend(pc)
	jmp	.medstop(pc)
	jmp	.medcont(pc)
	jmp .medvol(pc)
	jmp	.medsong(pc)
	jmp	.eteen(pc)
	jmp	.taakse(pc)
	p_NOP
	jmp .id_med(pc)
	jmp	.author(pc)
	dc.w pt_med
.flgs	dc	pf_stop!pf_cont!pf_poslen!pf_kelaus!pf_song!pf_scope
	dc.b	"MED "
.nam1	dc.b	"     "
.nam2	dc.b	"        ",0
.pahk1  dc.b	"4ch",0
.pahk2  dc.b	"5-8ch",0
.pahk3	dc.b	"%ldch mix",0
.a_	dc.b	"Teijo Kinnunen",0

 even

.author
	pushpea	.a_(pc),d0
	rts

.medvb
	move.l	moduleaddress(a5),a0
	move	46(a0),pos_nykyinen(a5)

    bsr     getMEDLength
    move    d0,pos_maksimi(a5)
    bra     MEDPatternUpdate

.medvol
    * TODO
    rts


.eteen
	movem.l	d0/d1/a0,-(sp)
	move.l	moduleaddress(a5),a0
	move	pos_maksimi(a5),d0
	move	46(a0),d1
	addq	#1,d1
	cmp	d0,d1
	blo.b	.a
	clr	d1
.a	move	d1,46(a0)
 	;clr	44(a0)
    ;clr	48(a0)
	;clr.b	50(a0)
	move	d1,pos_nykyinen(a5)
	movem.l	(sp)+,d0/d1/a0
	rts
.taakse
	movem.l	d0/a0,-(sp)
	move.l	moduleaddress(a5),a0
	move	46(a0),d0
	subq	#1,d0
	bpl.b	.b
	clr	d0
.b	move	d0,46(a0)
;	clr	44(a0)
	move	d0,pos_nykyinen(a5)
	movem.l	(sp)+,d0/a0
.yee	rts



.medinit
	movem.l	d1-a6,-(sp)
    DPRINT  "MED init"

	move.l	_MedPlayerBase(a5),d0
	bne	.ook

;	move	#30,maxsongs(a5)


	lea	.flgs(pc),a1
	or	#pf_song!pf_kelaus!pf_poslen,(a1)
	move.l	moduleaddress(a5),a0
	move.l	(a0),.nam1
	cmp.l	#"MMD2",(a0)		* onko mmd2+? poistetaan kelaus..
	blo.b	.olde
	and	#~pf_kelaus,(a1)
.olde
	bsr	whatgadgets

	move.l	moduleaddress(a5),a0
	moveq	#0,d0
	move.b	51(a0),d0
	move	d0,maxsongs(a5)

	tst.b	medrelocced(a5)		* oliko jo relokatoitu??
	bne	.yeep


	move.l	moduleaddress(a5),a0
	move.l	32(a0),a1		* MMD0exp
	add.l	a0,a1
	move.l	44(a1),d0		* songname
	beq.b	.nonam
	add.l	d0,a0	

	lea	modulename(a5),a1	* nimi talteen
	moveq	#40-1,d0
.co	move.b	(a0)+,(a1)+
	dbeq	d0,.co
	clr.b	(a1)
	jsr	lootaan_nimi	
.nonam
	

	move.l	moduleaddress(a5),a0
	;move	506(a1),pos_maksimi(a5)

	move.l	8(a0),a1		* MMD0song *song
	add.l	a0,a1			* reloc

	btst	#6,767(a1)		* flags; 5-8 kanavaa?
	sne	d0
	btst	#7,768(a1)		* flags2; miksaus?
	sne	d1
	and	#%01,d0
	and	#%10,d1
	or	d1,d0

	move.b	d0,medtype(a5)

	cmp.b	#3,d0
	bhs 	.error2

    move    534(a1),d3      * MMD2song: mixing channels, 0 means 4

* d0:
* 0 = 4ch   medplayer
* 1 = 5-8ch octaplayer
* 2 = 1-64ch octamixplayer
* 3 = 1-64ch octamixplayer?


** katotaan onko midisampleja.
* a0 = 63 samplestructuree, 8 bytee kukin
	moveq	#63-1,d1
	moveq	#0,d7
.chmi	tst.b	4(a0)		* midich, 0 jos ei midi
	beq.b	.jep
	addq	#1,d7
;	jsr	flash
.jep	addq	#8,a0	
	dbf	d1,.chmi


	lea	.nam2(pc),a0
	lea	.pahk1(pc),a1
	tst.b	d0
	beq.b	.di
	lea	.pahk2(pc),a1
	subq.b	#1,d0
	beq.b	.di

    push    a0
	;lea	.pahk3(pc),a1
    lea     .pahk3(pc),a0
    moveq   #0,d0
    move    d3,d0
    jsr     desmsg
    lea     desbuf(a5),a1
    pop     a0

.di	move.b	(a1)+,(a0)+
	bne.b	.di

;	cmp.b	#2,medtype(a5)
;	bne.b	.yeep

    ;bsr     .fastmemplayrecommended
    ;DPRINT  "ee"
    ;tst.b   d0
    ;bne     .moveit


	move.l	moduleaddress(a5),a0	* pistet‰‰nkˆ fastiin?
	btst	#0,20(a0)		* mmdflags; MMD_LOADTOFASTMEM
	beq.b	.yeep

.moveit
** jos on octamixplayerill‰ soitettava ja sijaitsee chipiss‰, koitetaan
** siirt‰‰ fastiin:
	bsr	moveModuleToPublicMem


.yeep
	
	lea	get_med1(pc),a0		* medplayer
	move.b	medtype(a5),d0
	beq.b	.do
	lea	get_med2(pc),a0		* octaplayer
	subq.b	#1,d0
	beq.b	.do
	lea	get_med3(pc),a0		* octamixplayer
.do	jsr	(a0)
	
	move.l	d0,_MedPlayerBase(a5)
	bne.b	.ook
	moveq	#ier_nomedplayerlib,d0
.ee	movem.l	(sp)+,d1-a6
	rts

.error2
	moveq	#ier_mederr,d0
	bra.b	.ee


.ook
	move.l	d0,a6

	tst	d7
	beq.b	.nomidi		* onko midisampleja?

	moveq	#1,d0		* saadaanko seriali?
	bsr.b	.getplayer
	tst.l	d0
	beq.b	.gotserial
.nomidi	moveq	#0,d0		* jos ei, kokeillaan ilman.
	bsr.b	.getplayer
	tst.l	d0
	bne.b	.error2
.gotserial
	tst.b	medrelocced(a5)
	bne.b	.eek
	st	medrelocced(a5)
	move.l	moduleaddress(a5),a0
	bsr.b	.relocmodule
.eek	
    bsr     .setfastmemplay
	moveq	#0,d0
	move	songnumber(a5),d0
	bsr.b	.setmodnum
	move.l	moduleaddress(a5),a0
 	bsr 	.playmodule
    * Initial call
    bsr     MEDPatternUpdate
	movem.l	(sp)+,d1-a6
	moveq	#0,d0
	rts

.getplayer
	jsr	dela
	bsr.b	.G
	jmp	dela

.G
    DPRINT  "MEDGetPlayer"
	moveq	#_LVOMEDGetPlayer,d7
	move.b	medtype(a5),d6
	beq.b	.do2
	moveq	#_LVOMEDGetPlayer8,d7
	subq.b	#1,d6
	beq.b	.do2
	moveq	#_LVOMEDGetPlayerM,d7
.do2	jmp	(a6,d7)

.relocmodule
    DPRINT  "MEDRelocModule"
	moveq	#_LVOMEDRelocModule,d7
	move.b	medtype(a5),d6
	beq.b	.do3
	moveq	#_LVOMEDRelocModule8,d7
	subq.b	#1,d6
	beq.b	.do3
	moveq	#_LVOMEDRelocModuleM,d7
.do3	jmp	(a6,d7)

.setmodnum
    DPRINT  "MEMSetModNum"
	moveq	#_LVOMEDSetModnum,d7
	move.b	medtype(a5),d6
	beq.b	.do4
	moveq	#_LVOMEDSetModnum8,d7
	subq.b	#1,d6
	beq.b	.do4
	moveq	#_LVOMEDSetModnumM,d7
.do4	jmp	(a6,d7)

.setfastmemplay
    push    a6
	move.l	moduleaddress(a5),a1	* onko chipiss‰?
	lore	Exec,TypeOfMem
    pop     a6
	btst	#MEMB_CHIP,d0
	seq     d1
    moveq   #1,d0
    and.b   d1,d0
    move.l  #0,d1      * guess something for the buffer

    DPRINT  "SetFastMemPlay=%ld"

    * d0 = new state
    * d1 = buffer size
	moveq	#_LVOMEDSetFastMemPlay,d7
	move.b	medtype(a5),d6
	beq.b	.dof
	moveq	#_LVOMEDSetFastMemPlay8,d7
	subq.b	#1,d6
	beq.b	.dof
	rts
.dof 
    jmp	(a6,d7)

;.fastmemplayrecommended
;    
;    * a0 = module address
;    move.l  moduleaddress(a5),a0
;	moveq	#_LVOMEDFastMemPlayRecommended,d7
;	move.b	medtype(a5),d6
;	beq.b	.doff
;	moveq	#_LVOMEDFastMemPlayRecommended8,d7
;	subq.b	#1,d6
;	beq.b	.doff
;    moveq   #0,d0
;	rts
;.doff
;    jsr 	(a6,d7)
;    DPRINT  "MEDFastMemPlayRecommended=%ld"
;    rts


.playmodule
	jsr	dela
	bsr.b	.P
	jmp	dela
.P
    DPRINT  "MEDPlayModule"

	moveq	#_LVOMEDPlayModule,d7
	move.b	medtype(a5),d6
	beq.b	.do5
	moveq	#_LVOMEDPlayModule8,d7
	subq.b	#1,d6
	beq.b	.do5a

    DPRINT  "MEDSet14BitMode"
** octamixplayer
	moveq	#0,d0			* 8-bit
	move.b	medmode(a5),d0		* 1: 14-bit
	lob	MEDSet14BitMode
    DPRINT  "MEDSetMixingFrequency"
	moveq	#0,d0
	move	medrate(a5),d0		* mixingrate
	lob	MEDSetMixingFrequency

	moveq	#_LVOMEDPlayModuleM,d7
.do5	jmp	(a6,d7)


** octaplayer. asetetaan SetHQ() jos tarvis
.do5a
	moveq	#0,d0
	move.b	medmode(a5),d0
	lob	MEDSetHQ
	bra.b	.do5


.medend
	jsr	dela
	bsr.b	.E
	jmp	dela
.E
	movem.l	d0/d1/a0/a1/a6,-(sp)
	move.l	_MedPlayerBase(a5),a6
    DPRINT  "MEDFreePlayer"
	moveq	#_LVOMEDFreePlayer,d0
	move.b	medtype(a5),d1
	beq.b	.do6
	moveq	#_LVOMEDFreePlayer8,d0
	subq.b	#1,d1
	beq.b	.do6
	moveq	#_LVOMEDFreePlayerM,d0
.do6	jsr	(a6,d0)

	move.l	a6,d0
	jsr	closel
	clr.l	_MedPlayerBase(a5)

	movem.l	(sp)+,d0/d1/a0/a1/a6
	rts

.medstop
	movem.l	d0/d1/a0/a1/a6,-(sp)
	move.l	_MedPlayerBase(a5),a6
    DPRINT  "MEDStopPlayer"

	moveq	#_LVOMEDStopPlayer,d0
	move.b	medtype(a5),d1
	beq.b	.do7
	moveq	#_LVOMEDStopPlayer8,d0
	subq.b	#1,d1
	beq.b	.do7
	moveq	#_LVOMEDStopPlayerM,d0
.do7	jsr	(a6,d0)

    lea     MEDPatternInfoPtr(pc),a1
    move.l  (a1),a0
    clr.l   (a1)
    jsr     freemem
	movem.l	(sp)+,d0/d1/a0/a1/a6
	rts

.medcont
	movem.l	d0/d1/a0/a1/a6,-(sp)
	move.l	_MedPlayerBase(a5),a6
	move.l	moduleaddress(a5),a0

	moveq	#_LVOMEDContModule,d0
	move.b	medtype(a5),d1
	beq.b	.do8
	moveq	#_LVOMEDContModule8,d0
	subq.b	#1,d1
	beq.b	.do8
	moveq	#_LVOMEDContModuleM,d0
.do8	jsr	(a6,d0)

	movem.l	(sp)+,d0/d1/a0/a1/a6
	rts


.medsong
	bsr	.medend
	bra	.medinit

.id_med 	
	bsr.b 	.id_med_ 
	bne.b	.x 
	clr.b	medrelocced(a5)
.x	rts

.id_med_

	move.l	(a4),d0			* MED
	lsr.l	#8,d0
	cmp.l	#'MMD',d0
	bra	idtest


MEDPatternUpdate:
    tst.b   medrelocced(a5)
    beq     .no

    lea     MEDPatternInfoPtr(pc),a2
    tst.l   (a2)
    bne     .1
    move.l  #PI_Stripes+4*64,d0
    move.l  #MEMF_PUBLIC!MEMF_CLEAR,d1
    jsr     getmem
    move.l  d0,(a2)

.1
	move.l	moduleaddress(a5),a1

.mmd0
    move.l  MEDPatternInfoPtr(PC),a0
    move	#-1,PI_Speed(a0)	; Magic! Indicates notes, not periods
    move.l  a0,deliPatternInfo(a5)

    * Set current pattern position:
    * MMD0->pline
    move    44(a1),PI_Pattpos(a0)

    * Get current pattern:
    * MMD0->pblock
    move    42(a1),d0
    lsl     #2,d0

    * MMD0->blockarr
    move.l  16(a1),a2
    * Get MMD0Block corresponding to d0
    move.l  (a2,d0),a2

    cmp.l   #"MMD1",(a1)
    bhs     .mmd1

    pushpea .ConvertNoteMMD0(pc),PI_Convert(a0)

    * MMD0Block->numtracks    
    moveq   #0,d0
    move.b  (a2),d0
    move.w  d0,PI_Voices(a0)

    * Calc number of bytes to next row: 3 bytes per channel
    mulu    #3,d0
    move.l  d0,PI_Modulo(a0)

    * MMD0Block->lines
    moveq   #0,d0
    move.b  1(a2),d0
    addq    #1,d0   * 0 means 1
    move.w  d0,PI_Pattlength(a0)

    * Set stripes
    * Skip MMD0Block header
    addq    #2,a2
    lea     PI_Stripes(a0),a0
    move.l  a2,(a0)+
    addq    #3,a2
    move.l  a2,(a0)+
    addq    #3,a2
    move.l  a2,(a0)+
    addq    #3,a2
    move.l  a2,(a0)+



    rts

.mmd1
    pushpea .ConvertNoteMMD1(pc),PI_Convert(a0)

    * MMD1Block->numtracks    
    moveq   #0,d0
    move.w  (a2),d0
    move.w  d0,PI_Voices(a0)

    * Calc number of bytes to next row: 4 bytes per channel
    lsl.l   #2,d0
    move.l  d0,PI_Modulo(a0)

    * MMD0Block->lines
    move.w  2(a2),d0
    addq    #1,d0   * 0 means 1
    move.w  d0,PI_Pattlength(a0)

    ; Skip over MMD1Block header
    addq    #8,a2
    ; BlockInfo with additional command pages is ignored

    * Set stripes
    move    PI_Voices(a0),d0
    subq    #1,d0
    lea     PI_Stripes(a0),a0
.str
    move.l  a2,(a0)+
    addq    #4,a2
    dbf     d0,.str
    rts

.no
    clr.l   deliPatternInfo(a5)
    rts

* Called by the PI engine to get values for a particular row

* MMD0 block format
* The 3-byte structure looks like this (each letter corresponds to one bit):
*    xynnnnnn iiiicccc dddddddd
*
*    n = note number (0 - $3F). 0 = ---, 1 = C-1, 2 = C#1...
*    i = the low 4 bits of the instrument number
*    x = the 5th bit (#4) of the instrument number
*    y = the 6th bit (#5) of the instrument number
*    c = command number (0 - $F)
*    d = databyte ($00 - $FF)


.ConvertNoteMMD0
	moveq	#0,D1		; Sample number
	moveq	#0,D3		; Command argument
    
    * Note number
    moveq   #%00111111,d0
    and.b   (a0),d0
    
    move.b  1(a0),d1
    lsr.b   #4,d1
    
    moveq   #$f,d2
    and.b   1(a0),d2

    * 6th bit of sample numb
    moveq   #%01000000,d3
           ;#%00100000
    and.b   (a0),d3
    lsr.b   #1,d3
    or.b    d3,d1

    * 5th bit of sample numb
    move.w  #%10000000,d3
           ;#%00010000
    and.b   (a0),d3
    lsr.b   #3,d3
    or.b    d3,d1

    move.b  2(a0),d3

	rts

;    The note structures, which are 4 bytes long in MMD1 modules, are
;    arranged exactly as in MMD0 modules (i.e. L0T0, L0T1... L1T0, L1T1..).
;
;        xnnnnnnn xxiiiiii cccccccc dddddddd
;
;    n = note number (0 - $7F, 0 = ---, 1 = C-1...)
;    i = instrument number (0 - $3F)
;    c = command ($00 - $FF)
;    d = data byte ($00 - $FF)
;    x = undefined, reserved for future expansion. MUST BE SET TO ZERO,
;        AND MASKED OUT WHEN READING THE NOTE OR INSTRUMENT NUMBER.


.ConvertNoteMMD1
	moveq	#0,D2		; Command 
	moveq	#0,D3		; Command argument
    
    * Note number
    moveq   #$7f,d0
    and.b   (a0),d0
    
    moveq   #$3f,d1
    and.b   1(a0),d1

    move.b  2(a0),d2
    move.b  3(a0),d3
	rts

MEDPatternInfoPtr
        dc.l     0

* Out:
*   d0 = Length of MMD0/MMD2 module in positions
getMEDLength:
	move.l	moduleaddress(a5),a0
    tst.b   medrelocced(a5)
    beq     .no

    * MMD0song, MMD2song
	move.l	8(a0),a1
    * MMD0song: songlen
    * MMD2song: number of sections
	move	506(a1),d0

    cmp.l   #"MMD2",(a0)
    blo     .ok

    * safety check: assume at least one section
    cmp     #1,d0
    blo     .no

    ; **playseqtable
    move.l  508(a1),a1
    ; get pointer to first PlaySeq
    move.l  (a1),a1
    ; read the length
    move    40(a1),d0
.ok
    rts

.no
    moveq   #0,d0
    rts


******************************************************************************
* The Player v6.1a
******************************************************************************
guru_author
	pushpea	.a(pc),d0
	rts
.a	dc.b	"Jarno Paananen (Guru/Sahara Surfers)"
	even

  ifne FEATURE_P61A
p_player
	jmp	.p60init(pc)
	p_NOP
	p_NOP
	jmp	.p60end(pc)
	jmp	.p60stop(pc)
	jmp	.p60cont(pc)
	jmp	.p60volume(pc)
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp id_player(pc)
	jmp	guru_author(pc)
	dc.w pt_player
	dc	pf_stop!pf_cont!pf_volume
	dc.b	"The Player 6.1A",0
 even


.p60end
	movem.l	d0-a6,-(sp)
	lea	$dff000,a6
	move.l	p60routines(a5),a0
	jsr	P61_EndOffset(a0)

	bsr.b	.frees

	movem.l	(sp)+,d0-a6
	rts


.frees	move.l	player60samples(a5),d0
	beq.b	.eee
	move.l	d0,a0
	jsr	freemem
	clr.l	player60samples(a5)
.eee	rts

.p60stop
	move.l	p60routines(a5),a0
	clr	P61_PlayFlag(a0)
	bra	clearsound
.p60cont
	move.l	p60routines(a5),a0
	st	P61_PlayFlag+1(a0)
	rts

.p60volume
	push	a0
	move.l	p60routines(a5),a0
	move	mainvolume(a5),P61_MasterVolume(a0)
	pop	a0
	rts

.p60init
	lea	p60routines(a5),a0
	bsr	allocreplayer
	beq.b	.ok
	rts
.ok
	movem.l	d1-a6,-(sp)
	move.l	moduleaddress(a5),a0
	cmp.l	#'P61A',(a0)
	bne.b	.ee
	addq.l	#4,a0
.ee
	btst	#6,3(a0)
	beq.b	.nopacked

	tst.l	player60samples(a5)	* ei uusiks
	bne.b	.nopacked
	move.l	4(a0),d0
	addq.l	#8,d0
	moveq	#MEMF_CHIP,d1
	jsr	getmem
	move.l	d0,player60samples(a5)
	beq.b	.memerr
.nopacked

	move.l	p60routines(a5),a0
	move.b	tempoflag(a5),d0
	not.b	d0
	move.b	d0,P61_UseTempo+1(a0)
	st	P61_PlayFlag+1(a0)
	bsr.b	.p60volume

	move.l	moduleaddress(a5),a0
	moveq	#0,d0
	sub.l	a1,a1
	move.l	player60samples(a5),a2
	lea	$dff000,a6
	move.l	p60routines(a5),a3
	jsr	P61_InitOffset(a3)
	tst	d0
	beq.b	.ok2
;	lea	p60routines(a5),a0
;	bsr	freereplayer
	bsr	.frees
	moveq	#ier_playererr,d0
.ok2	movem.l	(sp)+,d1-a6
	rts

.memerr	
;	lea	p60routines(a5),a0
;	bsr	freereplayer
	moveq	#ier_nomem,d0
	bra.b	.ok2

 
* TODO: both
id_player
 	cmp.l	#'P61A',(a4)		* The player 6.1a
	bra	idtest

id_player2				* filename <= D0
	and.l	#$dfffffff,d0
	cmp.l	#'P61.',d0
	bra	idtest
  endif	; FEATURE_P61A


******************************************************************************
* Mark II
******************************************************************************

p_markii
	jmp	.markinit(pc)
	jmp	.markmusic(pc)
	p_NOP
	jmp	.markend(pc)
	jmp	clearsound(pc)
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp .id_markii(pc)
	jmp	.author(pc)
	dc.w pt_markii
	dc	pf_stop!pf_cont!pf_ciakelaus
	dc.b	"Mark II",0
.a	dc.b	"Darius Zendeh",0
 even

.author
	pushpea	.a(pc),d0
	rts

.markinit
    bsr     generalReplayInitNoAlloc
	beq.b	.ok2
	rts
.ok2

	pushm	all
	move.l	moduleaddress(a5),a0
	moveq.l	#-1,d0
	jsr	(a0)
	popm	all
	moveq	#0,d0
	rts	

.markmusic
	move.l	moduleaddress(a5),a0
	moveq.l	#0,d0
	moveq.l	#1,d1
	jmp	(a0)

.markend
	pushm	all
	move.l	moduleaddress(a5),a0
	moveq.l	#1,d0
	moveq.l	#1,d1
	jsr	(a0)
	bsr	rem_ciaint
	bsr	clearsound
	bsr	vapauta_kanavat
	popm	all
	rts


.id_markii
	moveq.l	#-1,d0

	cmp	#$48e7,(a4)
	bne.b	.eim
	cmp	#$41fa,4(a4)	
	bne.b	.eim
	cmp	#$4cd8,8(a4)
	bne.b	.eim
	cmp.l	#$0c0000ff,12(a4)
	beq.b	.joom
.eim

	lea	.lbw000106(pc),a1
.lbc0000ea
	move.w	(a1)+,d1
	beq.s	.lbc000104
	cmp.l	#$2e5a4144,$0000(a4,d1.w)
	bne.s	.lbc0000ea
	cmp.l	#$5338392e,$0004(a4,d1.w)
	bne.s	.lbc0000ea
.joom	moveq.l	#0,d0
.lbc000104
	tst.l	d0
	rts	
.lbw000106	dc.w	$02a0,$033c,$0348,0


******************************************************************************
* Maniacs of Noise
******************************************************************************


p_mon	jmp	.moninit(pc)
	jmp	.monmusic(pc)
	p_NOP
	jmp	.monend(pc)
	jmp	clearsound(pc)
	p_NOP
	jmp	.monvol(pc)
	jmp	.monsong(pc)
	p_NOP
	p_NOP
	p_NOP
	jmp .id_maniacsofnoise(pc)
	jmp	.author(pc)
	dc.w pt_mon
	dc	pf_stop!pf_cont!pf_song!pf_volume!pf_ciakelaus
	dc.b	"Maniacs of Noise",0
.a 	dc.b 	"Charles Deenen, Jeroen Tel",0
 even

.author
	pushpea	.a(pc),d0
	rts

.moninit
    bsr     generalReplayInitNoAlloc
	beq.b	.ok2
	rts
.ok2

.init	pushm	all
	moveq.l	#0,d0
	moveq	#0,d1
	move.l	moduleaddress(a5),a0
	push	a5
	jsr	(a0)
	pop	a5
	move.l	a1,.volu
	move	songnumber(a5),d0
	addq	#1,d0
	moveq.l	#0,d1
	move.l	moduleaddress(a5),a0
	push	a5
	jsr	8(a0)
	pop	a5
	bsr.b	.monvol
	popm	all
	moveq	#0,d0 
	rts	

.monvol	move.l	.volu(pc),a0
	move	mainvolume+var_b,(a0)
	rts

.volu	dc.l	0

.monmusic
	move.l	moduleaddress(a5),a0
	jmp	4(a0)

.monend	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat


.monsong
	bsr	clearsound
	bra	.init


.id_maniacsofnoise
	bsr.b 	.id_maniacsofnoise_
	bne.b 	.not 
	move	d5,maxsongs(a5)
	moveq	#0,d0
.not rts 

.id_maniacsofnoise_
* d5 => max songs

	move.l	a4,a0
;	move.l	modulelength(a5),d1
	move.l	d7,d1

	moveq.l	#-1,d0
	cmp.w	#$4efa,(a0)
	bne.s	.o0001a8
	cmp.w	#$4efa,4(a0)
	bne.s	.o0001a8
	cmp.w	#$4efa,8(a0)
	bne.s	.o0001a8
	cmp.w	#$4efa,12(a0)
	beq.s	.o0001a8
.o00015e	cmp.w	#$4bfa,0(a0)
	bne.s	.o000182
	cmp.w	#$0280,4(a0)
	bne.s	.o000182
	cmp.l	#$000000ff,6(a0)
	bne.s	.o000182
	cmp.l	#$5300b02d,$0014(a0)
	beq.s	.o00018a
.o000182	addq.l	#2,a0
	subq.l	#2,d1
	bpl.s	.o00015e
	bra.s	.o0001a8
 
.o00018a	move.w	2(a0),d1
	lea	0(a0,d1.w),a1
	move.w	$0018(a0),d1
	lea	0(a1,d1.w),a1
	moveq.l	#0,d0
	move.b	2(a1),d0
	subq	#1,d0
	move.w	d0,d5
	moveq.l	#0,d0
.o0001a8
	tst.l	d0
	rts	



******************************************************************************
* David Whittaker
******************************************************************************

p_davidwhittaker
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp 	.id(pc)
	jmp	deliAuthor(pc)
	dc  	pt_davidwhittaker
.flags	dc 	pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"David Whittaker [EP]",0
	        
.path 	dc.b "david whittaker",0
 	even

.init
	lea	.path(pc),a0 
	moveq	#0,d0
	bra		deliLoadAndInit

.id
	move.l	a4,a0
	MOVEQ	#-1,D0
	MOVE.L	A0,A1
	CMP.L	#$48E7F1FE,(A1)
	BNE.S	.lbC0003DC
	ADDQ.L	#4,A1
	CMP.W	#$6100,(A1)+
	BNE.S	.lbC000410
	ADD.W	(A1),A1
	MOVEQ	#9,D1
.lbC0003C4	CMP.W	#$47FA,(A1)+
	BEQ.S	.lbC0003D0
	DBRA	D1,.lbC0003C4
	RTS

.lbC0003D0	BSR.b	.lbC000424
	TST.L	D2
	BNE.S	.lbC000410
	BRA.S	.lbC00040E

.lbC0003DC	CMP.L	#$8F90001,(A1)
	BEQ.S	.lbC000412
	CMP.L	#$4E714E71,(A1)
	BEQ.S	.lbC000410
	CMP.W	#$47FA,(A1)+
	BEQ.S	.lbC000406
	MOVEQ	#3,D1
.lbC0003F4	CMP.W	#$47FA,(A1)+
	BEQ.S	.lbC000400
	DBRA	D1,.lbC0003F4
	RTS

.lbC000400	ADD.W	(A1),A1
	CMP.L	A0,A1
	BNE.S	.lbC000410
.lbC000406	
	BSR.S	.lbC000424
	TST.L	D2
	BNE.S	.lbC000410
.lbC00040C	
.lbC00040E	MOVEQ	#0,D0
.lbC000410	RTS

.lbC000412	ADDQ.L	#4,A1
	CMP.L	#$BFE001,(A1)+
	BNE.S	.lbC000410
	BSR.S	.lbC000424
	TST.L	D2
	BEQ.S	.lbC00040C
	RTS

.lbC000424	MOVEQ	#$7F,D1
.lbC000426	CMP.W	#$6100,(A1)+
	BEQ.S	.lbC000434
	DBRA	D1,.lbC000426
.lbC000430	MOVEQ	#-1,D2
	RTS

.lbC000434	ADD.W	(A1),A1
	MOVEQ	#$7F,D1
	CMP.L	#$48E7F1FE,(A0)
	BNE.S	.lbC00044A
	ADDQ.L	#4,A1
	CMP.W	#$6100,(A1)+
	BNE.S	.lbC000430
	ADD.W	(A1),A1
.lbC00044A	CMP.W	#$4E75,(A1)
	BEQ.S	.lbC000430
	CMP.W	#$2F0B,(A1)
	BEQ.S	.lbC000466
	CMP.L	#$DFF0C8,(A1)
	BEQ.S	.lbC000466
	ADDQ.L	#2,A1
	DBRA	D1,.lbC00044A
	BRA.S	.lbC000430

.lbC000466	MOVEQ	#0,D2
	RTS
 


******************************************************************************
* Hippel-COSO
******************************************************************************


;	jmp	ini(pc)
;	jmp	Int(pc)
;	jmp	end(pc)
;	jmp	SetVol(pc)
;	jmp	ahi_update(pc)
;	jmp	ahi_pause(pc)

hippel_author
	pushpea	.a(pc),d0
	rts
.a 	dc.b	"Jochen 'Mad Max' Hippel",0
 	even


p_hippelcoso
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	jmp	.cont(pc)
	jmp	.volume(pc)
	jmp	.song(pc)
	p_NOP
	p_NOP
	jmp	.ahiupdate(pc)
	jmp id_hippelcoso(pc)
	jmp	hippel_author(pc)
	dc.w pt_hippelcoso
.liput	dc pf_cont!pf_stop!pf_end!pf_volume!pf_song!pf_ciakelaus!pf_ahi!pf_scope!pf_quadscopePoke
	dc.b	"Hippel-COSO",0
 even

.stop
	tst.b	ahi_use_nyt(a5)
	beq	clearsound

.a	move.l	hippelcosoroutines(a5),a0
	jmp	$20+20(a0)

.cont
	tst.b	ahi_use_nyt(a5)
	bne.b	.a
	rts

.init
	tst.b	ahi_use(a5)
	bne.b	.ahi

	or	#pf_ciakelaus,.liput

	bsr	varaa_kanavat
	beq.b	.ok
	moveq	#ier_nochannels,d0
	rts
.ok	
	bsr	init_ciaint
	beq.b	.ok2
	bsr	vapauta_kanavat
	moveq	#ier_nociaints,d0
	rts
.ok2
	lea	hippelcosoroutines(a5),a0
	bsr	allocreplayer
	beq.b	.ok3
.gog	bsr	rem_ciaint
	bra	vapauta_kanavat
;	rts

.ahi	and	#~pf_ciakelaus,.liput

	lea	hippelcosoroutines(a5),a0
	bsr	allocreplayer
	beq.b	.ok4
	rts

.ok3	
	bsr	siirra_moduuli
	bne.b	.gog
.ok4

	move.l	moduleaddress(a5),a0
	lea	songover(a5),a1
	moveq	#0,d0
	move	songnumber(a5),d0
	addq	#1,d0
	lea	dmawait(pc),a2
	lea	scopeData(a5),a3

	move.l	modulelength(a5),d1
	move.b	ahi_use(a5),d2
	move.l	ahi_mode(a5),d3
	move.l	ahi_rate(a5),d4

* d0 = songnumber
* d1 = modulelength
* d2 = use ahi
* d3 = ahi mode
* d4 = ahi rate
* a0 = module
* a1 = songend
* a2 = dmawait
* a3 = scope

	move.l	hippelcosoroutines(a5),a4
	jsr	$20+0(a4)
	tst.l	d0
	bne.b	.ER

	bsr.b	.volume
	moveq	#0,d0
.ER	rts	


.play	move.l	hippelcosoroutines(a5),a0
	jmp	$20+4(a0)

.end
	tst.b	ahi_use_nyt(a5)
	bne.b	.ahien

	bsr	rem_ciaint
	pushm	all
	move.l	hippelcosoroutines(a5),a0
	jsr	$20+8(a0)
	popm	all
	bsr	clearsound
	bra	vapauta_kanavat

.ahien	move.l	hippelcosoroutines(a5),a0
	jmp	$20+8(a0)

.volume
	moveq	#64,d0
	sub	mainvolume(a5),d0
	move.l	hippelcosoroutines(a5),a0
	jmp	$20+12(a0)
	
.song
	move.l	hippelcosoroutines(a5),a0
	jsr	$20+8(a0)
	tst.b	ahi_use_nyt(a5)
	bne.b	.sa
	bsr	clearsound
.sa	bra	.ok3



.ahiupdate
	move.l	hippelcosoroutines(a5),a0
	jmp	$20+16(a0)




id_hippelcoso 
	bsr.b 	.id_hippelcoso_
	bne.b .x 
	move	d5,maxsongs(a5)
	moveq	#0,d0 
.x 	rts


; Testet, ob es sich um ein Hippel-COSO-Modul handelt

.id_hippelcoso_
* d5 => max songs

;	move.l	dtg_ChkData(a5),a0		; ^module
	move.l	a4,a0

	cmpi.l	#"COSO",$00(a0)			; test ID
	bne.b	.ChkFail
	cmpi.l	#"TFMX",$20(a0)			; test ID
	bne.s	.ChkFail

	move.l	$1c(a0),d0
	sub.l	$18(a0),d0
	bmi.s	.ChkFail				; table corrupt !
	divu	#10,d0
	swap	d0
	tst.w	d0				; multiple of 10 ?
	bne.s	.ChkFail				; no !
	swap	d0
	subq.w	#1,d0
	beq.s	.ChkFail				; sampletable is empty !
	move.l	a0,a1
	add.l	$18(a0),a1			; ^sampletable
	move.l	a1,a2
	moveq	#0,d2
.Chkoop move.l	(a1),d1				; ^samplestart
	cmp.l	d2,d1
	ble.b	.Chkext
	move.l	d1,d2
	move.l	a1,a2
.Chkext add.w	#10,a1				; next sample
	subq.l	#1,d0
	bne.s	.Chkoop

	move.l	$1c(a0),d0			; ^samples
	move.l	d0,d1
	add.l	(a2)+,d1			; get samplestart
	moveq	#0,d2
	move.w	(a2)+,d2			; get samplelength
	add.l	d2,d2
	add.l	d2,d1
	addq.l	#4,d1				; 4 bytes null-sample


;	move.l	modulelength(a5),d2

;	cmp.l	d1,d2
;;	slt	LoadSamp			; set load-samples flag
;	blt.b	.ChkFail		* ei hyv‰ksyt‰ modeja joissa erilliset samplet


;	add.l	#1024,d1
;	cmp.l	d0,d2				; test size of module
;	blt.s	.ChkFail				; too small
;	cmp.l	d1,d2				; test size of module
;	bgt.s	.ChkFail				; too big

	move.l	$18(a4),d0
	sub.l	$14(a4),d0
	divu	#6,d0
	subq.w	#2,d0
	move.w	d0,d5				; store MaxSong
	moveq	#0,d0				; Modul erkannt

	bra.s	.Chknd
.ChkFail
	moveq	#-1,d0				; Modul nicht erkannt
.Chknd
	tst.l	d0
	rts



******************************************************************************
* Hippel
******************************************************************************

p_hippel
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	clearsound(pc)
	p_NOP
	p_NOP
	jmp	.song(pc)
	p_NOP
	p_NOP
	p_NOP
	jmp id_hippel(pc)
	jmp	hippel_author(pc)
	dc.w pt_hippel
	dc	pf_cont!pf_stop!pf_song!pf_ciakelaus
	dc.b	"Hippel",0
 even

.init
    bsr     generalReplayInitNoAlloc
	beq.b	.ok2
	rts
.ok2

	move	songnumber(a5),d0
	addq	#1,d0
	move.l	moduleaddress(a5),a0
	jsr	(a0)
	moveq	#0,d0
	rts	


.play	
	move.l	hippelmusic(pc),a0
	jmp	(a0)

.end
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat



.song
	bsr	clearsound
	bra.b	.ok2


hippelmusic	dc.l	0





id_hippel 
	push	d7
	bsr.b 	.id_hippel_
	pop	d7
	tst.l	d0
	bne.b .x 
	move.l	d4,hippelmusic
	move	d5,maxsongs(a5)
	moveq	#0,d0 
.x 	rts



.id_hippel_
* d7 <= modlen
* a4 <= mod
* d4 => hippel music 
* d5 => max songs

	* check some data, not all, too slow otherwise
	cmp.l	#1024*4,d7
	blo.b	.ok
	move.l	#1024*4,d7
.ok
	move.l	d7,d0

	cmp.l	#100,d0
	blo	.lbC000288

	move.l	a4,a0
	move.l	a4,a1
	add.l	d0,a1
	lea	$10(a0),a0
.loop	addq	#1,a0	
	cmp.l	a0,a1
	beq	.ChkFail
	cmp.b	#"T",(a0)
	bne.b	.loop
	cmp.b	#"F",1(a0)
	bne.b	.loop
	cmp.b	#"M",2(a0)
	bne.b	.loop
	cmp.b	#"X",3(a0)
	bne.b	.loop

	move.l	a4,a1
	move.l	a1,a0
	move.l	d7,d0

	cmp.w	#$6000,(a1)
	bne.s	.lbC000156
	addq.w	#2,a1
	move.w	(a1),d1
	bmi.s	.lbC0001B6
	btst	#0,d1
	bne.s	.lbC0001B6
	add.w	d1,a1
	bra.s	.lbC00016E
 
.lbC000156	cmp.b	#$60,(a1)
	bne.s	.lbC0001B6
	move.b	1(a1),d1
	ext.w	d1
	bmi.s	.lbC0001B6
	btst	#0,d1
	bne.s	.lbC0001B6
	add.w	d1,a1
	addq.w	#2,a1
.lbC00016E	addq.w	#4,a1
	cmp.w	#$6100,(a1)
	bne.s	.lbC000186
	addq.w	#2,a1
	move.w	(a1),d1
	bmi.s	.lbC0001B6
	btst	#0,d1
	bne.s	.lbC0001B6
	add.w	d1,a1
	bra.s	.lbC00018E
 
.lbC000186	cmp.w	#$41FA,(a1)
	bne.s	.lbC0001B6
	addq.w	#4,a1
.lbC00018E	addq.w	#2,a1
	cmp.w	#$6100,(a1)+
	bne.s	.lbC0001B6
	move.w	(a1),d1
	bmi.s	.lbC0001B6
	btst	#0,d1
	bne.s	.lbC0001B6
	add.w	d1,a1
	cmp.w	#$41FA,(a1)+
	bne.s	.lbC0001B6
	move.w	(a1),d1
	bmi.s	.lbC0001B6
	btst	#0,d1
	bne.s	.lbC0001B6
	add.w	d1,a1
	clr.w	(a1)
.lbC0001B6	cmp.b	#$60,(a0)
	bne.s	.lbC0001D0
	cmp.b	#$60,2(a0)
	bne.s	.lbC0001D0
	cmp.w	#$48E7,4(a0)
	bne.s	.lbC0001D0
	addq.l	#2,a0
	bra.s	.lbC00022C
 
.lbC0001D0	cmp.b	#$60,(a0)
	bne.s	.lbC0001EA
	cmp.b	#$60,2(a0)
	bne.s	.lbC0001EA
	cmp.w	#$41FA,4(a0)
	bne.s	.lbC0001EA
	addq.l	#2,a0
	bra.s	.lbC00022C
 
.lbC0001EA	cmp.w	#$6000,(a0)
	bne.s	.lbC000204
	cmp.w	#$6000,4(a0)
	bne.s	.lbC000204
	cmp.w	#$48E7,8(a0)
	bne.s	.lbC000204
	addq.l	#4,a0
	bra.s	.lbC00022C
 
.lbC000204	cmp.w	#$6000,(a0)
	bne.s	.lbC000288
	cmp.w	#$6000,4(a0)
	bne.s	.lbC000288
	cmp.w	#$6000,8(a0)
	bne.s	.lbC000288
	cmp.w	#$6000,12(a0)
	bne.s	.lbC000288
	cmp.w	#$48E7,$0010(a0)
	bne.s	.lbC000288
	addq.l	#4,a0
.lbC00022C	move.l	a0,d4
	move.w	#$007F,d1
.lbC000236	cmp.w	#$41FA,(a0)+
	bne.s	.lbC00026C
	move.w	(a0),d2
	bmi.s	.lbC00026C
	btst	#0,d2
	bne.s	.lbC00026C
	cmp.w	#$4000,d2
	bcc.s	.lbC00026C
	cmp.l	#'TFMX',$0000(a0,d2.w)
	bne.s	.lbC00025C
	move.w	$0010(a0,d2.w),d3
	bra.s	.lbC000274
 
.lbC00025C	cmp.l	#'COSO',$0000(a0,d2.w)
	bne.s	.lbC00026C
	move.w	#$00FF,d3
	bra.s	.lbC000274
 
.lbC00026C	subq.l	#2,d0
	dbmi	d1,.lbC000236
	bra.s	.lbC000288
 
.lbC000274
	subq.b	#1,d3
	move.w	d3,d5
	moveq	#0,d0
	rts	

.lbC000288
.ChkFail
	moveq.l	#-1,d0
	rts	




******************************************************************************
* Digibooster
******************************************************************************

db_author
	pushpea	.a(pc),d0
	rts
.a 	dc.b 	"Tomasz & Waldemar Piasta",0
	even

p_digibooster
	jmp	.init(pc)
	p_NOP
	jmp	.vb(pc)
	jmp	.end(pc)
	jmp	.stop(pc)
	jmp	.cont(pc)
	jmp	.volu(pc)
	p_NOP
	jmp	.eteen(pc)
	jmp	.taakse(pc)
	p_NOP
	jmp .id_digibooster(pc)
	jmp	db_author(pc)
	dc.w pt_digibooster
	dc	pf_poslen!pf_kelaus!pf_volume!pf_stop!pf_cont!pf_end
	dc.b	"DIGI Booster",0
 even

.stop
	clr.b	.stopcont
	move	#$f,$dff096
	rts

.cont
	st	.stopcont
	move	#$800f,$dff096
	rts


.volu
	move.l	.vol(pc),a0
	move	mainvolume(a5),(a0)
	rts

.vb
	move.l	.pos(pc),a0
	move.b	(a0),pos_nykyinen+1(a5)
	move.l	.maxpos(pc),a0
	move.b	(a0),pos_maksimi+1(a5)
	rts



.eteen
	move	pos_maksimi(a5),d0
	move	pos_nykyinen(a5),d1
	addq	#1,d1
	cmp	d0,d1
	blo.b	.a
	clr	d1
.a
	move.l	.pos(pc),a0
	move.b	d1,(a0)
	move.l	.pattpos(pc),a0
	clr.b	(a0)

	rts
.taakse
	move.l	.pos(pc),a0
	move.b	(a0),d0
	subq.b	#1,d0
	bpl.b	.b
	clr.b	d0
.b	move.b	d0,(a0)
	move.l	.pattpos(pc),a0
	clr.b	(a0)
	move.b	d0,pos_nykyinen+1(a5)
	rts




.init
	bsr	varaa_kanavat
	beq.b	.ok
	moveq	#ier_nochannels,d0
	rts
.ok	

	lea	digiboosterroutines(a5),a0
	bsr	allocreplayer
	beq.b	.ok3
	bra	vapauta_kanavat
;	rts

.ok3	

	push	a5
	move.l	moduleaddress(a5),a0
	lea	songover(a5),a1
	lea	.stopcont(pc),a2
	st	(a2)

	DPRINT	"DIGIBooster init"
	move.l	digiboosterroutines(a5),a3
	jsr	$20+0(a3)
	pop	a5
	tst.l	d0
	bne.b	.er


;	lea	songpos(pc),a0
;	move.l	moddigi(pc),a1
;	lea	ordnum(a1),a1
;	lea	pattpos(pc),a2
* 	a3 = vol

	movem.l	a0-a3,.pos
	bsr	.volu

	DPRINT	"ok"

	moveq	#0,d0
	rts	

.stopcont dc	0
.pos	dc.l	0
.maxpos	dc.l	0
.pattpos dc.l	0
.vol	dc.l	0



; d7 =  0  all right
; d7 = -1  not enough memory for mixbuffers
; d7 = -2  cant alloc cia timers


.er	bsr	vapauta_kanavat

	addq	#1,d0
	bne.b	.cia
	moveq	#ier_nomem,d0
	rts

.cia	moveq	#ier_nociaints,d0
	rts



.end	pushm	all
	move.l	digiboosterroutines(a5),a0
	jsr	$20+4(a0)
	popm	all
	bra	vapauta_kanavat


.id_digibooster
	bsr.b 	id_digibooster_
	bne.b 	.x 
	bsr	moveModuleToPublicMem		* siirret‰‰n fastiin jos mahdollista
	lea	610(a4),a1
	moveq	#30-1,d0
	bsr	copyNameFromA1
	moveq	#0,d0
.x 	rts

id_digibooster_
	cmp.l	#'DIGI',(a4)
	bne.b	.nd
	cmp.l	#' Boo',4(a4)
	bne.b	.nd
	cmp.l	#'ster',8(a4)
	bra	idtest

.nd	moveq	#-1,d0
	rts

******************************************************************************
* Digibooster PRO
******************************************************************************


p_digiboosterpro
	jmp	.init(pc)
	p_NOP
	jmp	.vb(pc)
	jmp	.end(pc)
	jmp	.stop(pc)
	jmp	.cont(pc)
	p_NOP
	p_NOP
	jmp	.eteen(pc)
	jmp	.taakse(pc)
	jmp	.ahiupdate(pc)
	jmp .id_digiboosterpro(pc)
	jmp	db_author(pc)
	dc.w pt_digiboosterpro
	dc	pf_volume!pf_stop!pf_cont!pf_ahi!pf_poslen!pf_kelaus!pf_end
	dc.b	"DIGI Booster Pro",0
 even

.stop
.cont
	move.l	digiboosterproroutines(a5),a0
	jmp	8+$20(a0)

.ahiupdate
	rts	* omat pannaukset ja autoboostit
	
;	move.l	digiboosterproroutines(a5),a0
;	jmp	12+$20(a0)

.vb

	move.l	.songp(pc),a0
	move	(a0),pos_nykyinen(a5)
	move.l	.ordn(pc),a0
	move	(a0),pos_maksimi(a5)
	rts


.init
	move.l	(a5),a0
	btst	#AFB_68020,AttnFlags+1(a0)
	bne.b	.okk
	moveq	#ier_hardware,d0
	rts
.okk


	lea	digiboosterproroutines(a5),a0
	bsr	allocreplayer
	bne.b	.x

	move.l	moduleaddress(a5),a0
	move.l	modulelength(a5),d4
	
	move.l	ahi_rate(a5),d0
	move	ahi_mastervol(a5),d1
	move	ahi_stereolev(a5),d2
	move.l	ahi_mode(a5),d3
	move.l	digiboosterproroutines(a5),a1
	lea	mainvolume(a5),a2
	lea	songover(a5),a3

	st	ahi_use_nyt(a5)

	pushm	d1-a6
	jsr	$20+0(a1)

	movem.l	a0/a1/a2,.songp

	popm	d1-a6

	DPRINT	"DIGIBooster pro init: %ld"
	
	tst.l	d0
	beq.b	.x
	moveq	#ier_error,d0

;	moveq	#0,d0
.x	rts	

.end
	pushm	all
	clr.b	ahi_use_nyt(a5)
	move.l	digiboosterproroutines(a5),a1
	jsr	$20+4(a1)
	popm	all
	rts




.eteen
	move	pos_maksimi(a5),d0
	move	pos_nykyinen(a5),d1
	addq	#1,d1
	cmp	d0,d1
	blo.b	.a
	clr	d1
.a
	move.l	.songp(pc),a0
	move	d1,(a0)
	move.l	.pattpos(pc),a0
	clr	(a0)

	rts
.taakse
	move.l	.songp(pc),a0
	move	(a0),d0
	subq	#1,d0
	bpl.b	.b
	clr	d0
.b	move	d0,(a0)
	move.l	.pattpos(pc),a0
	clr	(a0)
	move	d0,pos_nykyinen(a5)
	rts




.songp	dc.l	0
.ordn	dc.l	0
.pattpos dc.l	0


.id_digiboosterpro
	bsr.b 	id_digiboosterpro_
	bne.b 	.y 
	bsr	moveModuleToPublicMem		* siirret‰‰n fastiin jos mahdollista
	move.l	moduleaddress(a5),a1
	lea	16(a4),a1
	moveq	#42-1,d0	
	bsr	copyNameFromA1
	moveq	#0,d0
.y 	rts

id_digiboosterpro_
	cmp.l	#'DBM0',(a4)
	bra	idtest

******************************************************************************
* THX
******************************************************************************

thx_author
	pushpea	.a(pc),d0
	rts
.a 	dc.b	"Dexter & Pink/aBYSs",0
	even 

p_thx:
	jmp	.init(pc)
	jmp .ahxCIAInterrupt(pc)
	p_NOP   ; vb not used
	jmp	.end(pc)
	jmp	.stop(pc)
	jmp	.cont(pc)
	jmp	.volu(pc)
	jmp	.song(pc)
	jmp	.eteen(pc)
	jmp	.taakse(pc)
	p_NOP
	jmp 	.id_thx(pc)
	jmp	thx_author(pc)
	dc.w 	pt_thx
	dc	pf_cont!pf_stop!pf_volume!pf_end!pf_song!pf_kelaus!pf_poslen!pf_scope!pf_quadscopePoke
	dc.b	"AHX Sound System",0
 even


.ahxInitCIA          = 0*4
.ahxInitPlayer       = 1*4
.ahxInitModule       = 2*4
.ahxInitSubSong      = 3*4
.ahxInterrupt        = 4*4
.ahxStopSong         = 5*4
.ahxKillPlayer       = 6*4
.ahxKillCIA          = 7*4
.ahxNextPattern      = 8*4   ;implemented, although no-one requested it :-)
.ahxPrevPattern      = 9*4   ;implemented, although no-one requested it :-)

.ahxBSS_P            = 10*4  ;pointer to ahx's public (fast) memory block
.ahxBSS_C            = 11*4  ;pointer to ahx's explicit chip memory block
.ahxBSS_Psize        = 12*4  ;size of public memory (intern use only!)
.ahxBSS_Csize        = 13*4  ;size of chip memory (intern use only!)
.ahxModule           = 14*4  ;pointer to ahxModule after InitModule
.ahxIsCIA            = 15*4  ;byte flag (using ANY (intern/own) cia?)
.ahxTempo            = 16*4  ;word to cia tempo (normally NOT needed to xs)

.ahx_pExternalTiming = 0         ;byte, offset to public memory block
.ahx_pMainVolume     = 1         ;byte, offset to public memory block
.ahx_pSubsongs       = 2         ;byte, offset to public memory block
.ahx_pSongEnd        = 3         ;flag, offset to public memory block
.ahx_pPlaying        = 4         ;flag, offset to public memory block
.ahx_pVoice0Temp     = 14        ;struct, current Voice 0 values
.ahx_pVoice1Temp     = 246       ;struct, current Voice 1 values
.ahx_pVoice2Temp     = 478       ;struct, current Voice 2 values
.ahx_pVoice3Temp     = 710       ;struct, current Voice 3 values

.ahx_currentSongPos	= $448+4
.ahx_maxSongPos 	= $44c+4
.ahx_currentPattPos 	= $44a

.ahx_pvtTrack        = 0         ;byte          (relative to ahx_pVoiceXTemp!)
.ahx_pvtTranspose    = 1         ;byte          (relative to ahx_pVoiceXTemp!)
.ahx_pvtNextTrack    = 2         ;byte          (relative to ahx_pVoiceXTemp!)
.ahx_pvtNextTranspose= 3         ;byte          (relative to ahx_pVoiceXTemp!)
.ahx_pvtADSRVolume   = 4         ;word, 0..64:8 (relative to ahx_pVoiceXTemp!)
.ahx_pvtAudioPointer = 92        ;pointer       (relative to ahx_pVoiceXTemp!)
.ahx_pvtAudioPeriod  = 100       ;word          (relative to ahx_pVoiceXTemp!)
.ahx_pvtAudioVolume  = 102       ;word          (relative to ahx_pVoiceXTemp!)

; current ADSR Volume (0..64) = ahx_pvtADSR.w >> 8        (I use 24:8 32-Bit)
; ahx_pvtAudioXXX are the REAL Values passed to the hardware!



.eteen	move.l	thxroutines(a5),a0
	jmp	.ahxNextPattern(a0)

.taakse	move.l	thxroutines(a5),a0
	jmp	.ahxPrevPattern(a0)


.stop
	move	#$f,$dff096
	bra.b	.sc

.cont	move	#$800f,$dff096
.sc	move.l	thxroutines(a5),a0
	move.l	.ahxBSS_P(a0),a0
	not.b	.ahx_pPlaying(a0)
	rts

	

.volu	move.l	thxroutines(a5),a0
	move.l	.ahxBSS_P(a0),a0
	move.b	mainvolume+1(a5),.ahx_pMainVolume(a0)
	rts

.updateInfo
	move.l	thxroutines(a5),a0
	move.l	.ahxBSS_P(a0),a0

	move	.ahx_currentSongPos(a0),pos_nykyinen(a5)
	move	.ahx_maxSongPos(a0),pos_maksimi(a5)

	tst.b	.ahx_pSongEnd(a0)
	beq.b	.x
	clr.b	.ahx_pSongEnd(a0)
	st	songover(a5)
.x	rts




.init
	lea	thxroutines(a5),a0
    bsr generalReplayInit
	beq.b	.ok3
    rts
.ok3	
	DPRINT	"AHX init"
	pushm	d1-a6

;	lea	.ahxCIAInterrupt(pc),a0
;	moveq	#0,d0
;	move.l	thxroutines(a5),a2
;	jsr	.ahxInitCIA(a2)
;	tst	d0
;	bne	.thxInitFailed2

	moveq	#0,d0	* loadwavesfile if possible
	moveq	#0,d1	* calculate filters (ei thx v 1.xx!!)

	move.l	moduleaddress(a5),a0
	tst.b	3(a0)
	bne.b	.new
	moveq	#1,d1	* ei filttereit‰!
.new

	sub.l   a0,a0	* auto alloc fast mem
	sub.l   a1,a1	* auto alloc chip
	lea	ciaint_setTempoFromD0(pc),a2 * pass CIA timer poke routine
	move.l	thxroutines(a5),a3
	jsr	setMainWindowWaitPointer
	jsr	.ahxInitPlayer(a3)
	jsr	clearMainWindowWaitPointer
	tst	d0
	beq.b	.ok4

;	move.l	thxroutines(a5),a3
;	jsr	.ahxKillCIA(a3)
	bsr	vapauta_kanavat
	moveq	#ier_nomem,d0
	bra.b	.xxx
.ok4
	
	moveq	#0,d0			* normal speed
	move.l	moduleaddress(a5),a0
	jsr	.ahxInitModule(a3)
	tst	d0
	bne.b	.thxInitFailed

	move.l	.ahxBSS_P(a3),a0
	clr	maxsongs(a5)
	move.b	.ahx_pSubsongs(a0),maxsongs+1(a5)

	moveq	#0,d0
	move	songnumber(a5),d0
	moveq   #0,d1
	jsr	.ahxInitSubSong(a3)

	bsr	.volu
	bsr	.patternInit

	popm	d1-a6

	pushpea	.PatternInfo(pc),deliPatternInfo(a5)
	moveq	#0,d0
	rts	

.thxInitFailed
;	move.l	thxroutines(a5),a2
;	jsr	.ahxKillCIA(a2)
.thxInitFailed2
	
	bsr	vapauta_kanavat
	moveq	#ier_nociaints,d0
.xxx
	popm	d1-a6
	rts


.ahxCIAInterrupt
	move.l	thxroutines(a5),a0
	* All regs preserved:
	jsr	.ahxInterrupt(a0)
	bsr		.updateInfo
	bra	.updateStripes

.end	DPRINT	"AHX end"
	bsr	rem_ciaint
	bsr.b	.halt
	bra	vapauta_kanavat

.song	bsr.b	.halt
	bra	.ok3

.halt	
;	pushm	all
;	move.l	thxroutines(a5),a2
;	jsr	.ahxKillCIA(a2)
;	popm	all
.halt2	move.l	thxroutines(a5),a2
	jsr	.ahxStopSong(a2)
	jsr	.ahxKillPlayer(a2)
	
	bra	clearsound

* Scope support
* Update scope data once per vblank
.updateScope
	lea	scopeData+scope_ch1(a4),a0
	move.l	thxroutines(a4),a1
	move.l	.ahxBSS_P(a1),a1
	lea	.ahx_pVoice0Temp(a1),a1

	moveq	#4-1,d0
.scope
	tst.l	ns_start(a0)
	bne.b	.same
	* This needs tobe done only once it seems
	move.l	.ahx_pvtAudioPointer(a1),ns_start(a0)
	move.l	.ahx_pvtAudioPointer(a1),ns_loopstart(a0)
	move	#$140,ns_length(a0)
	move	#$140,ns_replen(a0)
.same
	move	.ahx_pvtAudioPeriod(a1),ns_period(a0)
	move	.ahx_pvtAudioVolume(a1),ns_tempvol(a0)
	move	.ahx_pvtAudioVolume(a1),d1
	CLAMPVOL d1
	move	d1,ns_tempvol(a0)

	lea	232(a1),a1	* Next channel data 
	lea	ns_size(a0),a0
	dbf	d0,.scope
.xx	rts


* Pattern scope support

.updateStripes
	pushm	d0-d1/a0-a4
	move.l	a5,a4
	bsr.b	.updateScope

	* Skip if not needed
	tst.b	patternScopeRunning(a4)
	beq.b	.noUpd

	move.l	thxroutines(a4),a0
	move.l	.ahxBSS_P(a0),a0

	tst.b	.ahx_pPlaying(a0)
	beq.b	.noUpd
	
	move	.ahx_currentPattPos(a0),.PatternInfo+PI_Pattpos
	lea	.ahx_pVoice0Temp(a0),a0

	move.l	moduleaddress(a4),a1
	lea	.PatternInfo+PI_NoteTranspose1(pc),a2
	lea	.Stripe1(pc),a3

	* Get SS, number of subsongs
	moveq	#0,d1
	move.b	13(a1),d1
	* Subsong list length in bytes:
	add	d1,d1
	* Skip over subsong list 
	lea	14(a1,d1),a4
	* Get LEN, length of the position list
	move	6(a1),d1
	and	#$fff,d1
	* Position list length in bytes:
	lsl	#3,d1
	* Skip over position list,
	* A4 now points to the 1st track data
	add	d1,a4
	* Get TRL, track length
	moveq	#0,d0
	move.b	10(a1),d0
	* Track length in bytes
	mulu	#3,d0

	bsr.b	.doStripe
	bsr.b	.doStripe
	bsr.b	.doStripe
	bsr.b	.doStripe
.noUpd
	popm	d0-d1/a0-a4
	rts

.doStripe
	move.b	.ahx_pvtTranspose(a0),(a2)+
	moveq	#0,d1
	move.b	.ahx_pvtTrack(a0),d1
	lea	232(a0),a0	* Next channel data 

	* If bit 7 of byte 6 is 0, track 0 is included. 
	* If it is 1, track 0 was empty, and is
    * therefore not saved with the module, to save space.
	tst.b	6(a1)
	bmi.b	.trackZeroEmpty
	* Track 0 is included.
	tst.b	d1
    bpl     .1
	* Track 0 is an empty stripe
.goZero	clr.l	(a3)+
	rts
.trackZeroEmpty
    * Subtract one as track 0 is not there.
	subq.b	#1,d1
	bmi.b	.goZero
.1
	* Get current track offset
	mulu	d0,d1
	* Address of current track
	add.l 	a4,d1
	* Into the stripe array
	move.l	d1,(a3)+
	rts

.patternInit
	lea	.PatternInfo(PC),A0
	move.w	#4,PI_Voices(A0)	; Number of stripes (MUST be at least 4)
	pea	.ConvertNote(pc) 
	move.l	(sp)+,PI_Convert(a0)
	moveq	#3,D0
	move.l	D0,PI_Modulo(A0)	; Number of bytes to next row
	move.l	moduleaddress(a5),a1
	move.b	10(a1),d0 		* TRL, track length 1-64
	move.w	d0,PI_Pattlength(A0)	; Length of each stripe in rows
	clr.w	PI_Pattpos(A0)		; Current Position in Pattern (from 0)
	move	#-1,PI_Speed(a0)	; Magic! Indicates notes, not periods
	rts

* Called by the PI engine to get values for a particular row
* Each entry is 24 bits (3 bytes) long, and consists of
* bits 23-18 (6 bits): The note. This ranges from 0 (no note) to 60 (B-5)
* bits 17-12 (6 bits): The sample. This ranges from 0 to 63.
* bits 11-8  (4 bits): The command. See list below
* bits 7-0   (8 bits): The command's data. See list below

.ConvertNote
	moveq	#0,D0		; Period, Note
	moveq	#0,D1		; Sample number
	moveq	#0,D2		; Command 
	moveq	#0,D3		; Command argument
	
	* 01234567 01234567 01234567
	* nnnnnnSS SSSScccc PPPPPPPP

	move.b	(a0),d0
	rol	#8,d0
	move.b	1(a0),d0

	moveq	#$f,d2
	and.b	d0,d2 	* cmd
	
	lsr	#4,d0
	moveq	#%111111,d1
	and.b	d0,d1	* sample

	lsr	#6,d0	* note
	beq.b 	.noNote


	lea	PI_NoteTranspose1(a1),a3
	add	PI_CurrentChannelNumber(a1),a3
	add.b	(a3),d0
	ext	d0

	* Up one octaves to allow negative transpose
	add	#1*12,d0

.noNote

	move.b	2(a0),d3	* arg
	rts

.PatternInfo 		ds.b	PI_Stripes	
.Stripe1		dc.l	1
.Stripe2		dc.l	1
.Stripe3		dc.l	1
.Stripe4		dc.l	1

.id_thx 
	bsr.b id_thx_
	bne.b	.y
	move.l	moduleaddress(a5),a1
	add	4(a1),a1		* modulename
	moveq	#25-1,d0
	bsr	copyNameFromA1
	moveq	#0,d0
.y 	rts

id_thx_
	move.l	(a4),d0			* THX
	lsr.l	#8,d0
	cmp.l	#"THX",d0
	bra	idtest


******************************************************************************
* MusiclineEditor
******************************************************************************

p_mline
	jmp	.init(pc)
	p_NOP
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	jmp	.cont(pc)
	jmp	.volume(pc)
	jmp	.song(pc)
	p_NOP
	p_NOP
	p_NOP
	jmp id_mline(pc)
	jmp	.author(pc)
	dc.w pt_mline
	dc	pf_cont!pf_stop!pf_volume!pf_song
	dc.b	"MusiclineEditor",0
.a 	dc.b	"Conny Cyreus, Christian Cyreus, Jimmy Fredriksson, John Carehag",0
 even
	
.author
	pushpea	.a(pc),d0
	rts

._LVOInitPlayer		=	-30
._LVOEndPlayer		=	-36
._LVOStartPlay		=	-42
._LVOStopPlay		=	-48
._LVOInitTune		=	-54
._LVOMasterVol		=	-60
._LVOSubTuneRange	=	-66
._LVOSelectTune		=	-72
._LVONextTune		=	-78
._LVOPrevTune		=	-84
._LVOCheckModule	=	-90


.init
	lea	-200(sp),sp
	move.l	sp,a4

	lea	arcdir(a5),a0
	move.l	a4,a1
.c	move.b	(a0)+,(a1)+
	bne.b	.c
	subq	#1,a1
	cmp.b	#':',-1(a1)
	beq.b	.cc
	cmp.b	#'/',-1(a1)
	beq.b	.cc
	move.b	#'/',(a1)+
.cc
	lea	.foo(pc),a0
.c2	move.b	(a0)+,(a1)+
	bne.b	.c2

	move.l	a4,a0
	move.l	moduleaddress(a5),a1
	move.l	modulelength(a5),d0
	bsr	plainSaveFile
	bmi.b	.orr

	bsr	get_mline
	bne.b	.ok0
	lea	200(sp),sp
	moveq	#ier_nomled,d0
	rts
.ok0
	move.l	a4,a0
	move.l	_MlineBase(a5),a6
	jsr	._LVOInitPlayer(a6)
	tst.l	d0
	beq.b	.ok

	bsr.b	.del
.orr	lea	200(sp),sp
	moveq	#ier_mlederr,d0
	rts
.ok
	jsr	._LVOSubTuneRange(a6)
	move	d1,maxsongs(a5)

	jsr	._LVOInitTune(a6)
	jsr	._LVOStartPlay(a6)
	bsr.b	.volume

	bsr.b	.del

	lea	200(sp),sp
	moveq	#0,d0
	rts

.del	move.l	a4,d1
	move.l	_DosBase(a5),a6
	jmp	_LVODeleteFile(a6)

.end
	move.l	_MlineBase(a5),a6
	jmp	._LVOEndPlayer(a6)

.cont
	move.l	_MlineBase(a5),a6
	jmp	._LVOStartPlay(a6)
	
.stop
	move.l	_MlineBase(a5),a6
	jmp	._LVOStopPlay(a6)

.volume
	moveq	#0,d0
	move	mainvolume(a5),d0
	move.l	_MlineBase(a5),a6
	jmp	._LVOMasterVol(a6)

.song
	moveq	#0,d0
	move	songnumber(a5),d0
	move.l	_MlineBase(a5),a6
	jmp	._LVOSelectTune(a6)

.foo	dc.b	"∞∞HiP-MLine",0
 even



id_mline
	cmp.l	#"MLED",(a4)		* musicline editor
	bne.b	.nd
	cmp.l	#"MODL",4(a4)
	bra	idtest

.nd	moveq	#-1,d0
	rts
	



******************************************************************************
* Artofnoise
******************************************************************************

p_aon
	jmp	.init(pc)
	jmp 	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	jmp	.cont(pc)
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp 	.id_aon(pc)
	jmp	author_twice(pc)
	dc.w 	pt_aon
	dc      pf_cont!pf_stop!pf_end!pf_ciakelaus!pf_poslen!pf_volume!pf_scope!pf_quadscopePoke
	dc.b	"Art Of Noise 4ch",0
 even

.OFFSET_INIT = $20+0
.OFFSET_PLAY = $20+4
.OFFSET_END  = $20+8
.OFFSET_STOP = $20+12
.OFFSET_CONT = $20+16

.init
	lea	    aonroutines(a5),a0
    bsr     generalReplayInit
    beq     .ok3
    rts
.ok3
	pushm	d1-a6

	move.l	moduleaddress(a5),a0
	lea	mainvolume(a5),a1
	lea	songover(a5),a2 
	lea	ciaint_setTempoFromD0(pc),a3
	lea	scopeData(a5),a4
	move.l	aonroutines(a5),a6
	jsr	.OFFSET_INIT(a6)
	tst.l	d0
	bne.b	.noMem
	move.l	a0,deliPatternInfo(a5)

.x	popm	d1-a6
	rts

.noMem
	moveq	#ier_nomem,d0
	bra.b	.x

.end
	bsr	rem_ciaint
	move.l	aonroutines(a5),a0
	jsr	.OFFSET_END(a0)
	bsr	clearsound
	bra	vapauta_kanavat

.play
	move.l	aonroutines(a5),a0
	jsr	.OFFSET_PLAY(a0)
	move	d0,pos_nykyinen(a5) 
	move	d1,pos_maksimi(a5)
	rts

.stop
	move.l	aonroutines(a5),a0
	jmp		.OFFSET_STOP(a0)
	
.cont	
	move.l	aonroutines(a5),a0
	jmp		.OFFSET_CONT(a0)

.id_aon
	cmp.l	#"AON4",(a4)		* aon 4 channel
	bra	idtest



******************************************************************************
* Artofnoise 8ch
******************************************************************************

author_twice	
	pushpea	.a(pc),d0
	rts
.a	dc.b	"Bastian Spiegel (Twice/Lego)",0
 even

p_aon8
	jmp	.init(pc)
	jmp 	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	jmp	.cont(pc)
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp 	.id(pc)
	jmp	author_twice(pc)
	dc.w 	pt_aon8
	dc      pf_cont!pf_stop!pf_end!pf_ciakelaus!pf_poslen!pf_volume!pf_scope!pf_quadscopePoke
	dc.b	"Art Of Noise 8ch",0
 even

.OFFSET_INIT = $20+0
.OFFSET_PLAY = $20+4
.OFFSET_END  = $20+8
.OFFSET_STOP = $20+12
.OFFSET_CONT = $20+16

.init
	move.l	(a5),a0
	btst	#AFB_68020,AttnFlags+1(a0)
	bne.b	.okk
	moveq	#ier_hardware,d0
	rts
.okk
	lea	aonroutines(a5),a0
    bsr generalReplayInit
	beq.b	.ok3
    rts
.ok3
	pushm	d1-a6

	move.l	moduleaddress(a5),a0
	lea	mainvolume(a5),a1
	lea	songover(a5),a2 
	lea	ciaint_setTempoFromD0(pc),a3
	lea	scopeData(a5),a4
	move.l	aonroutines(a5),a6
	jsr	.OFFSET_INIT(a6)
	tst.l	d0
	bne.b	.noMem
	; Provides patterninfo but there is a visual delay due
	; to the mix buffer mechanism, so disabled for now.
	;move.l	a0,deliPatternInfo(a5)

.x	popm	d1-a6
	rts

.noMem
	moveq	#ier_nomem,d0
	bra.b	.x

.end
	bsr	rem_ciaint
	move.l	aonroutines(a5),a0
	jsr	.OFFSET_END(a0)
	bsr	clearsound
	bra	vapauta_kanavat

.play
	move.l	aonroutines(a5),a0
	jsr	.OFFSET_PLAY(a0)
	move	d0,pos_nykyinen(a5) 
	move	d1,pos_maksimi(a5)
	rts

.stop
	move.l	aonroutines(a5),a0
	jmp		.OFFSET_STOP(a0)
	
.cont	
	move.l	aonroutines(a5),a0
	jmp		.OFFSET_CONT(a0)

.id
	bsr.b	id_aon8
	bne.b	.no
	bsr	moveModuleToPublicMem
	moveq	#0,d0
.no	rts

id_aon8
	cmp.l	#"AON8",(a4)		* aon 8 channel
	bra	idtest



******************************************************************************
* PS3M
******************************************************************************


	rsset	14+32
init1j		rs.l	1
init2j		rs.l	1
init0j		rs.l	1
poslenj		rs.l	1
endj		rs.l	1
stopj		rs.l	1
contj		rs.l	1
eteenj		rs.l	1
taaksej		rs.l	1
volj		rs.l	1
boostj		rs.l	1

* Sets Z if PS3M+ImpulseTracker is active
isImpulseTrackerActive
	pushm	d0/a0
	cmp	#pt_multi,playertype(a5)
	bne.b	.no
	move.l	ps3m_mtype(a5),d0
	beq.b	.no
	move.l	d0,a0
	cmp	#mtIT,(a0)
	beq.b	.yes
.no	moveq	#-1,d0
.x	popm	d0/a0
	rts
.yes	moveq	#0,d0
	bra.b	.x

p_multi:
    jmp	.s3init(pc)
	p_NOP		* CIA
	jmp	.s3poslen(pc)		* VB
	jmp	.s3end(pc)
	jmp	.s3stop(pc)
	jmp	.s3cont(pc)
	jmp	.s3vol(pc)
	p_NOP		* Song
	jmp	.eteen(pc)
	jmp	.taakse(pc)
	jmp	ps3m_boost(pc)		* ahiupdate
	jmp id_ps3m(pc)
	jmp	.author(pc)
	dc.w pt_multi
.flags
 dc pf_cont!pf_stop!pf_volume!pf_kelaus!pf_poslen!pf_end!pf_scope!pf_ahi!pf_quadscopePoke!pf_slidePos
	dc.b	"PS3M",0
.itPath
	dc.b	"impulse",0
 even

.author
	move.l	ps3m_mtype(a5),a0
	cmp	#mtIT,(a0)
	bne	guru_author
	bra	deliAuthor


;init1j	jmp	init1r(pc)
;init2j	jmp	init2r(pc)
;init0j	jmp	s3init(pc)
;poslenj	jmp	s3poslen(pc)
;endj	jmp	s3end(pc)
;stopj	jmp	s3stop(pc)
;contj	jmp	s3cont(pc)
;eteenj	jmp	eteen(pc)
;taaksej	jmp	taakse(pc)

* This does test resource allocation and frees them right after.
.s3init
	bsr	varaa_kanavat
	beq.b	.ok
	moveq	#ier_nochannels,d0
	rts
.ok	bsr	vapauta_kanavat

	bsr	init_ciaint
	beq.b	.ok2
	moveq	#ier_nociaints,d0
	rts
.ok2	bsr	rem_ciaint

	lea	ps3mroutines(a5),a0
	bsr	allocreplayer
	beq.b	.ok3
	rts

.ok3	
	pushm	d1-a6
    DPRINT  "ps3m init 1"

	* IT deliplayer will clear the "poslen" flag, so make sure
	* it is available for other formats.
	lea	.flags(pc),a0
	or	#pf_poslen,(a0)

	move.l	moduleaddress(a5),a0
	bsr 	id_it
	bne 	.notIt
	DPRINT "IT detected"

    cmp.w   #$1402,$2A(A0)  * v2.14 module?
    bne     .noConv
    bsr     convertIT214
    tst.l   d0
    bne     .conv
    moveq   #ier_not_compatible,d0
    bra     .itError
.conv
.noConv

	move.l	(a5),a0
	btst	#AFB_68020,AttnFlags+1(a0)
	bne.b	.cpuOk
	moveq	#ier_hardware,d0
	bra	.itError
.cpuOk

	moveq	#$62,d0	* version
	lea	.itPath(pc),a0 
	* Distract the loader so that it will not try to
	* load PS3M from player group, instead it will
	* try eagleplayer loading from filesystem.
	move	playertype(a5),-(sp)
	move	#-1,playertype(a5)
	jsr	setMainWindowWaitPointer
	bsr	loadDeliPlayer 
	move	(sp)+,playertype(a5)
	tst.l 	d0
	bmi 	.itError
    DPRINT  "impulse=%lx"
    bsr     patchIt
	bsr	deliInit
	jsr 	clearMainWindowWaitPointer
	tst.l	d0
	bne	.itError
.notIt


	addq	#1,ps3minitcount

    move.l  #1,ps3m_sampleDataModulo(a5)
	move	mixirate+2(a5),hip_ps3mrate+hippoport(a5)

	* This will clear ps3mamigus if for some reason
	* it is set and the card is missing.
	bsr		checkAmiGUSAvailability

* v‰litet‰‰n tietoa ps3m:lle ja hankitaan sit‰ silt‰

;	move.b	cybercalibration(a5),d0
;	move.l	calibrationaddr(a5),d1
    moveq   #0,d0
    moveq   #0,d1

	* Select mode: normal, AHI, AmiGUS
	moveq	#-1,d2			* d2 = ahi_use
	cmp.b	#1,ps3mamigus(a5)
	beq     .gogo
	moveq	#-2,d2
	cmp.b	#2,ps3mamigus(a5)
	beq     .gogo
	moveq	#1,d2
	tst.b	ahi_use(a5)
	bne		.gogo
	moveq	#0,d2
.gogo

	move.l	ahi_rate(a5),d3
	move	ahi_mastervol(a5),d4
	move	ahi_stereolev(a5),d5
	move.l	ahi_mode(a5),d6
	move.l	modulelength(a5),d7

 if DEBUG
    push    d0
    move.l  d6,d0
    DPRINT  "AHI mode=%lx"
    pop     d0
 endif

	lea	ps3m_mname(a5),a0
	lea	ps3m_numchans(a5),a1
	lea	ps3m_mtype(a5),a2
	lea	ps3m_samples(a5),a3
	lea	ps3m_xm_insts(a5),a4
	move.l	ps3mroutines(a5),a6
	jsr	init1j(a6)

    DPRINT  "ps3m init 2"

	;pushpea	CHECKSTART,d0		* tarkistussummaa varten
	lea	ps3m_buff1(a5),a0
	lea	ps3m_buff2(a5),a1
	lea	ps3m_mixingperiod(a5),a2
	lea	ps3m_playpos(a5),a3
	lea	ps3m_buffSizeMask(a5),a4
	move.l	ps3mroutines(a5),a6
	move.l	deliPlayer(a5),d0
	move.l	deliBase(a5),d1
    pushpea	scopeData(a5),d2
	jsr	init2j(a6)
	move.l	d0,ps3mchannels(a5)

    DPRINT  "ps3m init 3"

	move.l	mixirate(a5),d0	
	move.b	s3mmode3(a5),d1		* volumeboost
	moveq	#0,d3
	move.b	s3mmode2(a5),d3		* mono/stereo/surround
	move.b	s3mmode1(a5),d4		* priority/killer

	move.l	moduleaddress(a5),d2	* moduuli

	move.b	ps3mb(a5),d5		* mixing buffer size
	lea	playing(a5),a0		* stop/cont-lippu
	lea	inforivit_killerps3m,a1	* killer ps3m viesti
	lea	mainvolume(a5),a2	* voluumi
	move.l	_DosBase(a5),a3
	lea	songover(a5),a4		* kappale loppuu-lippu
	move.l	_GFXBase(a5),a6
	pushpea	pos_nykyinen(a5),d6	* songpos -osoite
	pushpea	.adjustroutine(pc),d7	* asetusten s‰‰tˆrutiini
	move.l	ps3mroutines(a5),a5
	pea	.updateps3m3(pc)	* updaterutiini, surroundin stereo
	jsr	init0j(a5)
	addq	#4,sp			* pop pea

	lea	var_b,a5

	bsr	isImpulseTrackerActive
	bne.b	.notIT
	* No patternscope for this one	
	sub.l	a0,a0
	sub.l	a1,a1

	* TODO: in case of PS3M init error, do some
	* deli uninitializing?

.notIT

	move.l	a0,deliPatternInfo(a5)
	move.l	a1,ps3mUnpackedPattern(a5)
 if DEBUG
	tst.l	deliPatternInfo(a5)
	beq.b	.noPatInfo
	push	d0
	moveq	#0,d0
	move	PI_Voices(a0),d0
	move.l	PI_Modulo(a0),d1
	DPRINT	"Voices=%ld modulo=%ld"
	pop 	d0
.noPatInfo
 endif

	popm	d1-a6
	cmp	#333,d0		* killermoden koodi
	bne.b	.e
	addq	#4,sp		* killer: hyp‰t‰‰n play-aliohjelman 'ohi'
.e	rts

* Failed to init eagleplayer
.itError
	popm	d1-a6
	rts


.updateps3m3
	pushm	d1/a5
	lea	var_b,a5
	cmp.b	#1,s3mmode2(a5)		* onko surround?
	bne.b	.nd
	moveq	#64,d1
	sub.b	stereofactor(a5),d1
	move	d1,$dff0c8
	move	d1,$dff0d8
.nd	popm	d1/a5
	rts

* VBLANK routine
* Updates:
* - position and lenght info
* - patternscope information, if needed
.s3poslen
	tst.b	patternScopeRunning(a5)
	* Inform PS3M, set to zero to skip patternscope routines
	sne	d0
.noScope
	move.l	ps3mroutines(a5),a0
	jmp	poslenj(a0)

.s3end	clr.l	ps3mUnpackedPattern(a5)
	move.l	ps3mroutines(a5),a0
	jmp	endj(a0)
	

.s3stop	move.l	ps3mroutines(a5),a0
	jmp	stopj(a0)

.s3cont	move.l	ps3mroutines(a5),a0
	jmp	contj(a0)

.s3vol	move.l	ps3mroutines(a5),a0
	jmp	volj(a0)

.eteen	move.l	ps3mroutines(a5),a0
	jmp	eteenj(a0)

.taakse	move.l	ps3mroutines(a5),a0
	jmp	taaksej(a0)


******** Asetukset kanavam‰‰r‰n mukaan
* t‰nne hyp‰t‰‰n initin j‰lkeen. d0:ssa on kanavien m‰‰r‰.

.adjustroutine
	pushm	d2/d6-a6
	lea	var_b,a5
	moveq	#0,d6			* -1: vaikuttaa, 0: ei vaikuta
	cmp	#1,ps3minitcount	* asetustiedosto vaikuttaa vain
	bne	.xei			* ensimm‰iseen inittiin latauksen
					* j‰lkeen

	tst.b	ps3msettings(a5)	* k‰ytet‰‰nkˆ vai ei?
	beq	.xei

	move	d0,d7			* kanavien m‰‰r‰

	move.l	ps3msettingsfile(a5),d0
	beq	.xei
	move.l	d0,a0
	bsr	.tah

	moveq	#-1,d6

	lea	32*13(a0),a1		* file asetukset t‰‰ll‰

	move	d7,d0			* ensin asetukset kanavataulukosta
	subq	#1,d0
	mulu	#13,d0
	add	d0,a0
	addq	#3,a0
	bsr	.gets

	move.l	a1,a0			* t‰htirivien ohi
	bsr	.tah

	move.l	solename(a5),a1
.fine	tst.b	(a1)+
	bne.b	.fine
	sub.l	solename(a5),a1
	subq	#1,a1
	move	a1,d2

.filel
	addq	#1,a0
	cmp.b	#'¯',(a0)		* loppumerkki?
	beq.b	.golly
	move	d2,d5
	subq	#1,d5

	move.l	solename(a5),a1
.fid	cmpm.b	(a0)+,(a1)+
	bne.b	.fe
	dbf	d5,.fid
	addq	#2,a0
	bsr.b	.gets
	bra.b	.golly

.fe	cmp.b	#10,(a0)+
	bne.b	.fe
	bra.b	.filel

.golly



***** nappulat prefsiss‰
	pushm	all
	move.l	mixirate(a5),d0
	sub.l	#5000,d0
	divu	#100,d0
	mulu	#65535,d0
	divu	#580-50,d0
	lea	pslider1,a0
	jsr	setknob2
	lea	juusto,a0
	moveq	#0,d0
	move.b	s3mmode3(a5),d0
	mulu	#65535,d0
	divu	#16,d0
	jsr	setknob2
	popm	all


	move.l	mixirate(a5),d0		* mixingrate
	move.b	s3mmode3(a5),d1		* volumeboost
	moveq	#0,d3
	move.b	s3mmode2(a5),d3		* mono/stereo/surround/jne..
	move.b	s3mmode1(a5),d4		* pri/killer

.xei	tst.l	d6
	popm	d2/d6-a6
	rts

.find0	cmp.b	#10,(a0)+
	bne.b	.find0

.tah
.f0
	cmp.b	#'"',(a0)
	beq.b	.ofk
	cmp.b	#'0',(a0)
	bne.b	.find0	
.ofk	rts


.gets	move.b	(a0),d0
	cmp.b	#'?',d0
	beq.b	.sk0
	and	#$f,d0
	move.b	d0,s3mmode1(a5)	
	move.b	d0,s3mmode1_new(a5)
.sk0
	move.b	2(a0),d0
	cmp.b	#'?',d0
	beq.b	.sk1
	and	#$f,d0
	move.b	d0,s3mmode2(a5)
	move.b	d0,s3mmode2_new(a5)
.sk1
	move.b	4(a0),d0
	cmp.b	#'?',d0
	beq.b	.sk2
	and	#$f,d0
	move.b	d0,s3mmode3(a5)
	move.b	d0,s3mmode3_new(a5)
.sk2

	moveq	#0,d0
	move.b	6(a0),d1
	cmp.b	#'?',d1
	beq.b	.sk3
	and	#$f,d1
	mulu	#10000,d1
	add.l	d1,d0
	move.b	7(a0),d1
	and	#$f,d1
	mulu	#1000,d1
	add.l	d1,d0
	move.b	8(a0),d1
	and	#$f,d1
	mulu	#100,d1
	add.l	d1,d0
	move.l	d0,mixirate(a5)
	move.l	d0,mixingrate_new(a5)
.sk3
	cmp	#4,prefsivu(a5)
	bne.b	.re
	jsr	updateprefs
.re	rts



ps3m_boost
.ahiupdate
	move.l	ps3mroutines(a5),a0
	jmp	boostj(a0)




mtS3M = 1
mtMOD = 2
mtMTM = 3
mtXM  = 4
mtIT  = 5


* Initti vaihe 1. Jos d0<>0, moduuli ei kelpaa.
id_ps3m:
	pushm	d1-a6
;	clr	PS3M_reinit
;	clr	ps3minitcount

	move.l	a4,a0
;	move.l	moduleaddress(a5),a0

	bsr	id_it
	beq	.it

	cmp.l	#"SCRM",44(a0)
	beq.b	.s3m

	move.l	(a0),d0
	lsr.l	#8,d0
	cmp.l	#"MTM",d0
	beq.b	.mtm

    bsr     id_xm
    bne     .xm

.j
    move.l	1080(a0),d0
	cmp.l	#"OCTA",d0
	beq.b	.fast8
	cmp.l	#"M.K.",d0
	beq.b	.pro4
	cmp.l	#"M!K!",d0
	beq.b	.pro4
	cmp.l	#"FLT4",d0
	beq.b	.pro4

	move.l	d0,d1
	and.l	#$ffffff,d1
	cmp.l	#"CHN",d1
	beq.b	.chn

	and.l	#$ffff,d1
	cmp.l	#"CH",d1
	beq.b	.ch

	move.l	d0,d1
	and.l	#$ffffff00,d1
	cmp.l   #"TDZ"<<8,d1
	beq.b	.tdz
	moveq	#1,d0
	bra.b	.init

.xm	cmp	#$401,xmVersion(a0)		; Kool turbo-optimizin'...
	bne.b	.j
.it
.chn
.ch
.tdz
.fast8
.pro4
.mtm
.s3m	moveq	#0,d0

.init	tst.l	d0
	popm	d1-a6
	rts

* In:
*   a0 = data 
* Out:
*   d0 = 0: not XM, 1: yes XM
id_xm:
	move.l	a0,a1
	lea	.xmsign(pc),a2
	moveq	#3,d0
.l	cmpm.l	(a1)+,(a2)+
	bne.b	.j
	dbf	d0,.l
	moveq   #1,d0
    rts
.j  moveq   #0,d0
    rts
.xmsign		dc.b	"Extended Module:"
 even

ps3minitcount	dc	0

* ID from A0
id_it:
	push	d1
	MOVEQ	#0,D0
	CMP.L	#$494D504D,(A0)
	BNE.S	.itFail
    *  Cmwt:     Compatible with tracker with version greater than value.
    *             (ie. format version)
	MOVE.W	$2A(A0),D1
	ROR.W	#8,D1
 if DEBUG
	push	d0
	moveq	#0,d0
	move	d1,d0
	DPRINT	"IT version: %lx"
	pop	d0
 endif
	CMP.W	#$100,D1
	BEQ.S	.itYes
	CMP.W	#$200,D1
	BEQ.S	.itYes
	CMP.W	#$214,D1
	BEQ.S	.itYes
.itFail
	MOVEQ	#-1,D0
.itYes
	pop	d1
	tst.l	d0
	RTS

* Converts IT v2.14 module into v2.00 format
* Out:
*  d0 = true: success, false: failed
convertIT214:
    DPRINT  "convertIT214"
    pushm   d1-a6
    moveq   #0,d7  * FAIL

    pushpea .converter(pc),d1
    lore    Dos,LoadSeg
    DPRINT  "LoadSeg=%lx"
    move.l  d0,d6
    lsl.l   #2,d6
    beq     .x

    bsr     buildDeliBase
	tst.l	d0
    beq     .x

    jsr     setMainWindowWaitPointer

    pushm   d6/d7

    DPRINT  "DTP_DeliBase"
	move.l	#DTP_DeliBase,d0
    move.l  d6,a0
    bsr     deliGetTagFromA0
	move.l	d0,a0 
	move.l	deliBase(a5),(a0)

    DPRINT  "DTP_Config"
	move.l	#DTP_Config,d0
    move.l  d6,a0
    bsr     deliGetTagFromA0
    bsr     deliCallFunc

    st      deliForceAllocPublicMem(a5)

    * Find the convert function from seglist    
    move.l  d6,a0
    move.l  #DTP_Convert,d0
    bsr     deliGetTagFromA0
    bsr     deliCallFunc    
    DPRINT  "DTP_Convert=%lx"
    * Returns 0 on success    
    popm    d6/d7

    sf      deliForceAllocPublicMem(a5)
    jsr     clearMainWindowWaitPointer
    
    tst.l   d0
    bne     .x
    
 if DEBUG
    move.l  moduleaddress(a5),d0
    move.l  modulelength(a5),d1
    DPRINT  "Free old module=%lx,%ld"
 endif

    move.l  moduleaddress(a5),a1
    move.l  modulelength(a5),d0
    lore    Exec,FreeMem

    move.l  deliLoadFileArray(a5),a0
    movem.l (a0),d0/d1
    clr.l   (a0)+
    clr.l   (a0)+
    move.l  d0,moduleaddress(a5)
    move.l  d1,modulelength(a5)
    DPRINT  "IT module converted=%lx,%ld"

    moveq   #1,d7   * status: ok
    
.x
    bsr     freeDeliBase
    move.l  d6,d1
    beq     .xx
    lsr.l   #2,d1
    lore    Dos,UnLoadSeg
.xx
    move.l  d7,d0
    popm    d1-a6
    rts

.converter  dc.b    "PROGDIR:ImpulseDecruncher",0
    even

* Checks if AHI is active and there are max 4 voices in use.
* In this case the scopes can be used in AHI mode.
* Out:
*   Z: set if false, clear if true
ahiOrGusWith4ChannelsActive:
	tst.b	ps3mamigus(a5)	* Cheat! AmiGUS should also work.
	bne		.gus
    tst.b   ahi_use_nyt(a5)
    beq     .no
.gus
    * Check if more than 4 voices, bail out if so
    tst.l   deliPatternInfo(a5)
    beq     .no
    push    a0
    move.l  deliPatternInfo(a5),a0
    cmp     #4,PI_Voices(a0)
    popm    a0
    bhi     .no
    * Ok: clear Z
    and.b	#~(1<<2),ccr
    rts
.no
    * Error: set Z
    or.b	#(1<<2),ccr
    rts

* This patches the "impulse" deliplayer DTP_Config
* function so that it will no longer belligerently
* poke the exec base.
patchIt:
    push    d0
    move.l  d0,a0
    move.l	#DTP_Config,d0  
	bsr	    deliGetTagFromA0
    beq     .x
    move.l  d0,a0
    move.w  #$4e71,d0
    cmp.w   22(a0),d0
    bne     .x
    cmp.w   26(a0),d0
    bne     .x
    DPRINT  "Patch Impulse"
    move.w  d0,34(a0)
    move.w  d0,36(a0)
    move.w  d0,38(a0)
    jsr     clearCpuCaches
.x  pop     d0
    rts

checkAmiGUSAvailability:
.AMIGUS_HAGEN_PRODUCT_ID	= 17
.AMIGUS_MANUFACTURER_ID		= 2782
    move.l  _ExpansionBase(a5),d0
    beq     .x
    move.l  d0,a6
    sub.l   a0,a0
    move.l  #.AMIGUS_MANUFACTURER_ID,d0
    moveq   #.AMIGUS_HAGEN_PRODUCT_ID,d1
    lob     FindConfigDev
.x  
	tst.l  	d0
	bne		.yes
	clr.b	ps3mamigus(a5)	* for safety clear setting
	rts
.yes 
	st      d0
	rts


******************************************************************************
* Sampleplayer
******************************************************************************

p_sample:
	jmp	.init(pc)
	p_NOP	* CIA
	p_NOP	* VB
	jmp	.end(pc)		* end
	jmp	.dostop(pc)		* Stop
	jmp	.docont(pc)		* Cont
	jmp	.vol(pc)		* volume
	p_NOP	* Song
	p_NOP	* Eteen
	p_NOP	* Taakse
	jmp	.ahiup(pc)		* AHI Update
	jmp 	id_sample(pc)
	p_NOP	* author
	dc.w 	pt_sample
.flags
	dc	pf_volume!pf_scope!pf_stop!pf_cont!pf_end!pf_ahi!pf_quadscopePoke
.name	dc.b	"                        ",0
        ds.b    8 * safety
 even

                   rsset    $20
.s_init            rs.l     1
.s_end             rs.l     1
.s_stop            rs.l     1
.s_cont            rs.l     1
.s_vol             rs.l     1
.s_ahiup           rs.l     1
.s_ahinfo          rs.l     1
.s_hasMp3Text      rs.l     1
.s_getMp3Text      rs.l     1
.s_getMp3Duration  rs.l     1    
.s_mp3Seek         rs.l     1


.init:
    DPRINT  "sample init"
	lea	sampleroutines(a5),a0
	bsr	allocreplayer
	beq.b	.ok
	rts
.ok
	pushm	a5/a6

    ; By default end can be detected
    lea     .flags(pc),a0
    or      #pf_end,(a0)

** v‰litet‰‰n infoa

	move.b	ahi_use(a5),d0
	move.l	ahi_rate(a5),d1
	move	ahi_mastervol(a5),d2
	move	ahi_stereolev(a5),d3
	move.l	ahi_mode(a5),d4
	move.l	sampleroutines(a5),a0

*** lis‰‰‰
	move.b	mpegaqua(a5),d5
	move.b	mpegadiv(a5),d6

	jsr	.s_ahinfo(a0)

** lis‰‰
	moveq	#0,d0
	cmp	#16000,horizfreq(a5)
	slo	d0
 if DEBUG
    push    d1
    moveq   #0,d1
    move    horizfreq(a5),d1
    DPRINT  "resample needed: %ld (horizfreq=%ld)"
    pop     d1
 endif
	move	d0,-(sp)
	pea	songover(a5)
	move.l	colordiv(a5),-(sp)
	move.l	_XPKBase(a5),-(sp)
    jsr     streamGetContentLength
    move.l  d0,-(sp)
    moveq   #0,d1
    move.b  mhiEnable(a5),d1
    move.w  d1,-(sp)
    pushpea mhiLib(a5),-(sp)


    * Content length zero and stream active? it's a radio station
 REM
    tst.l   d0
    bne     .cl1
    bsr     streamIsAlive
    beq     .cl1
    * 0 = 4k
    * 1 = 8k
    * 2 = 16k
    * 3 = 32k
    * 4 = 64k
    * 5 = 128k
    ; Buffer can't be too large for throttled stations
    move.b	samplebufsiz0(a5),d0
    cmp.b   #2,d0
    bls     .cl2
    moveq   #2,d0
    DPRINT  "stream is radio, enforcer buffer"
    bra     .cl2
.cl1
 EREM
    move.b	samplebufsiz0(a5),d0
.cl2
	move.b	sampleformat(a5),d1

	move.l	_DosBase(a5),a1
	move.l	_GFXBase(a5),a2
	lea	.name(pc),a3
	move.l	modulefilename(a5),a4

    tst.b   lastLoadedModuleWasRemote(a5)
    beq     .notRemote
    pushm   d0-d7/a1-a6
    * If stream is alive, startStreaming will just return the pipe path
    jsr     streamIsAlive
    bne     .alive
    DPRINT  "stream not alive"
    * If stream is not alive, a valid url should be provided.
    jsr     getcurrent
    beq     .noCurrent
    lea     l_filename(a3),a4
 if DEBUG
    move.l  a4,d0
    DPRINT  "current filename=%s"
 endif
    bra     .notAlive
.alive
    jsr     inforivit_connecting
.notAlive
    move.l  a4,a0
    jsr     startStreaming
.noCurrent
    * a0 = filename to read from
    tst.l   d0
    popm    d0-d7/a1-a6
    bne.b   .streamOk
    * Exiting, align stack to avoid mayhem
    DPRINT  "startStreaming failed" 
    jsr     showStreamerError
    moveq   #-1,d0
	add     #18,sp
	popm	a5/a6
    bra     .xx
.streamOk
    move.l  a0,a4
.notRemote

 if DEBUG
    push    d0
    move.l  a4,d0
    DPRINT  "sample file: %s"
    pop     d0
 endif

	pushpea	varaa_kanavat(pc),d2
	pushpea	vapauta_kanavat(pc),d3
;	pushpea	probebuffer(a5),d4
	pushpea	kokonaisaika(a5),d5

    * 14-bit out or not
	move.b	samplecyber(a5),d6
;	move.b	cybercalibration(a5),d6 
;	move.l	calibrationaddr(a5),d7

	move	sampleforcerate(a5),a6

	move.l	sampleroutines(a5),a0
	jsr	.s_init(a0)
   
	add     #24,sp

	popm	a5/a6

	move.l	d1,sampleadd(a5)
	move.l	a0,samplefollow(a5)
	move.l	a1,samplepointer(a5)
	move.l	a2,samplepointer2(a5)
	move.b	d2,samplestereo(a5)
	move.l	d3,samplebufsiz(a5)
    ; d4 = sample bits 8 or 16, convert to 1 and 2
    lsr     #3,d4
    move    d4,ahiSampleModulo(a5)
    move.l  d5,sampleOutputInfoText(a5)

 if DEBUG
	pushm	d0-d3
	move.l	d3,d0
    move.l  d4,d2
	DPRINT	"Bufsize=%ld add=%ld mod=%ld"
	popm	d0-d3
 endif

.xx
	tst	d0
	bne 	.x

	bsr 	.vol

    move.l  streamHeaderIcyName(a5),d0
    beq     .no1
    move.l  d0,a1
 	move.l  #INFO_MODULE_NAME_LEN-1,d1
	bsr     copyNameFromA1
.no1   

    jsr     streamIsRadioStation
    beq     .notRadio
    * End can't be detected from radio streams
    lea     .flags(pc),a0
    and.w   #~pf_end,(a0)
    DPRINT  "Disable end detect"
.notRadio

    ; -------------------------------------
    ; Finished
    ; -------------------------------------
    DPRINT  "sample init ok"
 	moveq	#0,d0
    rts

.x	
    DPRINT  "sample init failed %ld"
    push    d0
    jsr     stopStreaming
    pop     d0
    rts

.end:
    DPRINT  "sample end"
    jsr     setMainWindowWaitPointer
    jsr     stopStreaming
    move.l	sampleroutines(a5),a0
	jsr 	.s_end(a0)
    jsr     clearMainWindowWaitPointer
    jmp     awaitStreamer
    
.dostop:
    DPRINT  "sample stop"
    move.l	sampleroutines(a5),a0
	jmp 	.s_stop(a0)

.docont	
    DPRINT  "sample continue"
    move.l	sampleroutines(a5),a0
	jmp	.s_cont(a0)

.vol	move	mainvolume(a5),d0
	move.l	sampleroutines(a5),a0
	jmp	.s_vol(a0)

.ahiup	move.l	sampleroutines(a5),a0
	jmp	.s_ahiup(a0)

id_sample
	rts

hasMp3TagText
	move.l	sampleroutines(a5),a0
	jsr 	p_sample\.s_hasMp3Text(a0)
    tst.l   d0
    rts


* in: 
*  a0 = buffer to write to
getMp3TagText 
	move.l	sampleroutines(a5),a1
	jmp     p_sample\.s_getMp3Text(a1)
    

* In:
*   a0 = probebuffer, size 2048
* Out:
*  d0 = 0 = recognized, -1 = not
id_mp3
	* Check for ID3v2 header
	move.l	(a0),d0
	lsr.l	#8,d0
	cmp.l	#"ID3",d0
	bne.b	.not

	cmp.b	#$ff,3(a0)
	beq.b	.not
	cmp.b	#$ff,4(a0)
	beq.b	.not
	* Low flag nybble should be zero
	moveq	#$0f,d0
	and.b	5(a0),d0
	bne.b	.not
	* synchsafe integer bytes are all 7 bits
	cmp.b	#$80,6(a0)
	bhs.b	.not
	cmp.b	#$80,7(a0)
	bhs.b	.not
	cmp.b	#$80,8(a0)
	bhs.b	.not
	cmp.b	#$80,9(a0)
	bhs.b	.not
	bra.b	.yepID3v2
.not

.nope
	moveq	#-1,d0
	rts

.yepID3v2
	DPRINT	"MP3 ID3v2 tag found"
	moveq	#0,d0
	rts
.yepSyncWord
	DPRINT	"MP3 sync word found"
	moveq	#0,d0
	rts

* in:
*   a0 = file path
* out:
*   d0 = -1: not mp3 filename, 0: yes mp3 filename
id_mp3filename:
	* Check file suffix
    move.l  a0,a1
;	move.l	modulefilename(a5),a1
.zu	tst.b	(a1)+
	bne.b	.zu
	subq.l	#1,a1
	move.b	-(a1),d0
	ror.l	#8,d0
	move.b	-(a1),d0
	ror.l	#8,d0
	move.b	-(a1),d0
	ror.l	#8,d0
	move.b	-(a1),d0
	ror.l	#8,d0
	and.l	#$ffdfdfff,d0
	cmp.l	#".MP1",d0
	beq.b	.sampl
	cmp.l	#".MP2",d0
	beq.b	.sampl
	cmp.l	#".MP3",d0
	beq.b	.sampl

	* Check file prefix
;	move.l	modulefilename(a5),a1
    move.l  a0,a1
	move.l	a1,a2
.zu2	tst.b	(a1)+
	bne.b	.zu2
	subq.l	#1,a1
.zu3	cmp.l	a1,a2
	beq.b	.zu4
	cmp.b	#":",-1(a1)
	beq.b	.zu4
	cmp.b	#"/",-1(a1)
	beq.b	.zu4
	subq	#1,a1
	bra.b	.zu3
.zu4
	move.l	a1,d0

	move.b	(a1)+,d0
	rol.l	#8,d0
	move.b	(a1)+,d0
	rol.l	#8,d0
	move.b	(a1)+,d0
	rol.l	#8,d0
	move.b	(a1)+,d0
	and.l	#$dfdfffff,d0
	cmp.l	#"MP1.",d0
	beq.b	.sampl
	cmp.l	#"MP2.",d0
	beq.b	.sampl
	cmp.l	#"MP3.",d0
	beq.b	.sampl
    moveq   #-1,d0
    rts
.sampl
    moveq   #0,d0
    rts

* Returns the modulo to advance in sample data for scopes.
* This is needed when accessing AHI sample buffers
* which can be either 8-bit or 16-bit data.
* Out:
*   d0 = 1 if 8-bit, 2 if 16-bit
getSampleDataModulo:
    moveq   #1,d0
    tst.b   ahi_use_nyt(a5)
    beq     .1
    move    ahiSampleModulo(a5),d0
.1
    rts

* Returns the step in bytes to advance in sample data
* each VBlank frame. Special case check for AHI
* 16-bit buffers.
getSampleDataAdd:
    move.l	sampleadd(a5),d0
    tst.b   ahi_use_nyt(a5)
    beq     .1
    cmp     #2,ahiSampleModulo(a5)
    bne     .1
    add.l   d0,d0
.1  rts

* In: 
*  d0 = position in secs
pleaseMp3Seek:
    push    a5
    move.l	sampleroutines(a5),a0
    jsr     p_sample\.s_mp3Seek(a0)
    pop     a5
    rts

getMp3DurationInSeconds:
    moveq   #0,d0
    moveq   #0,d1
    ;tst.b   playing(a5)
    ;beq     .x
    push    a5
    move.l	sampleroutines(a5),a0
    jsr     p_sample\.s_getMp3Duration(a0)
    pop     a5
.x
    rts


******************************************************************************
* PumaTracker
******************************************************************************

p_pumatracker
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp .id_pumatracker(pc)
	jmp	.author(pc)
	dc.w pt_pumatracker
	dc	pf_stop!pf_cont!pf_ciakelaus
	dc.b	"PumaTracker",0
.a  dc.b "Jean-Charles Meyrignac, Pierre-Eric Loriaux",0
 even

.author
	pushpea	.a(pc),d0
	rts

.init
	lea	pumatrackerroutines(a5),a0
    bsr generalReplayInitChipMem
	beq.b	.ok3
	rts
.ok3
	pushm	all
	move.l	moduleaddress(a5),a0
	move.l	pumatrackerroutines(a5),a3
	jsr	$20+0(a3)
	popm	all
	moveq	#0,d0
	rts	

.play
	move.l	pumatrackerroutines(a5),a0
	jmp	$20+4(a0)
	rts
.end
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat

.stop
	bra	clearsound


.id_pumatracker 
	bsr.b .id_pumatracker_
	bne.b .x 
	moveq	#12-1,d0
	bsr	copyNameFromModule
	moveq	#0,d0
.x 	rts

.id_pumatracker_
	* test some attributes
	* positive song length
	tst		$c(a4)
	bmi.b	.notPuma
	* positive num of patterns
	tst		$e(a4)
	bmi.b	.notPuma
	* positive num of sound data
	tst		$10(a4)
	bmi.b	.notPuma

	* sample 1 start offset
	tst.l	$14(a4)
	bmi.b	.notPuma

	* sample 2 start offset
	tst.l	$18(a4)
	bmi.b	.notPuma

	* Find some magic words that should be there
	lea		.patt(pc),a1
	moveq	#.patte-.patt,d0
	bsr	search
	bne.b	.notPuma

	* search "patt" again after the first instance
	push	a4
	move.l	a0,a4
	lea		.patt(pc),a1
	moveq	#.patte-.patt,d0
	bsr	search
	pop 	a4
	tst.l	d0 
	bne.b	.notPuma

	moveq	#0,d0
	rts
.notPuma	
	moveq	#-1,d0 
	rts

.patt 	dc.b	"patt"
.patte
 even


******************************************************************************
* Beathoven Synthesizer
******************************************************************************

p_beathoven
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP
	p_NOP
	jmp	.song(pc)
	p_NOP
	p_NOP
	p_NOP
	jmp .id_beathoven(pc)
	jmp	.author(pc)
	dc.w pt_beathoven
	dc	pf_cont!pf_stop!pf_ciakelaus!pf_song
	dc.b	"Beathoven Synthesizer",0
.a  	dc.b "Thomas Lopatic (Dr.Nobody/HQC), adapted by Wanted Team",0
 even

.author 
	pushpea	.a(pc),d0 
	rts 

* play
.BEAT_PLAY = 16+$20
* init, song in d0
.BEAT_INIT = 20+$20
* num of subsongs
.BEAT_SUBSONGS = 24+$20 
* optional end 
.BEAT_END = 28+$20
* optional init player
.BEAT_OPT_INIT = 32+$20
* module name
.BEAT_NAME = 36+$20
* author name
.BEAT_AUTHOR = 40+$20

.init
    bsr     generalReplayInitNoAlloc
	beq.b	.ok2
	rts
.ok2

	bsr.b 	.doInit
	moveq	#0,d0
	rts

.doInit
	pushm	all

	move.l	moduleaddress(a5),a0
    cmp.l   #$3f3,(a0)
    bne     .1
    DPRINT  "Relocate module"
	* clear the hunk id for safety to avoid reloccing again
	clr.l	(a0)
    bsr reloc
	bsr	clearCpuCaches
	move.l	moduleaddress(a5),a1
	move.l	$20+36(a1),a1
	moveq	#30-1,d0
	bsr	copyNameFromA1
.1

	move.l	moduleaddress(a5),a2
	move.l	.BEAT_SUBSONGS(a2),d0 
	DPRINT	"Beathoven init, subsongs=%ld"
	subq	#1,d0
	move	d0,maxsongs(a5)
	push 	a2
	move.l	.BEAT_INIT(a2),a0
	moveq	#0,d0	* subsong
	move	songnumber(a5),d0	
	DPRINT	"Subsong=%ld"
	jsr		(a0)
	pop 	a2
	move.l	.BEAT_OPT_INIT(a2),d0 
	beq.b  .noOpt
	move.l	d0,a0
	jsr		(a0)
.noOpt	popm	all
	rts	

.deInit
	pushm	all
	move.l	moduleaddress(a5),a0
	move.l	.BEAT_END(a0),d0
	beq.b	.noEnd
	move.l	d0,a0
	jsr	(a0)
.noEnd	popm	all
	rts

.play
	move.l	moduleaddress(a5),a0
	move.l	.BEAT_PLAY(a0),a0
	jmp		(a0)
	

.end
	bsr	rem_ciaint
	bsr.b	.deInit
	bra	vapauta_kanavat

.stop
	bra	clearsound

.song
	bsr.b	.deInit
	bra	.doInit

.id_beathoven
	bsr.b .id_beathoven_
	bne.b .x 
;	move.l	moduleaddress(a5),a1
;	move.l	$20+36(a1),a1
;	moveq	#30-1,d0
;	bsr	copyNameFromA1
	moveq	#0,d0
.x 	rts

* in: a4 = module
* out: 
*   d0 = 0, is beathoven
*   do = -1, is not beathoven
.id_beathoven_
    * these seem to be executables, so check for hunk
    cmp.l   #$3f3,(a4)
    bne.b   .notBeat
    * skip hunk header
    lea     $20(a4),a0
    cmp.l   #$70ff4e75,(a0)
    bne.b   .notBeat
    cmp.l   #'BEAT',4(a0)
    bne.b   .notBeat
    cmp.l   #'HOVE',8(a0)
    bne.b   .notBeat
;    * looks good, relocate it
    move.l  a4,a0
;    bsr reloc
;	* clear the hunk id for safety to avoid reloccing again
;	clr.l	(a4)
	bsr	clearCpuCaches
    moveq   #0,d0
    rts
.notBeat    
    moveq   #-1,d0 
    rts




******************************************************************************
* Game Music Creator
******************************************************************************

p_gamemusiccreator
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp id_gamemusiccreator(pc)
	jmp	.author(pc)
	dc.w pt_gamemusiccreator
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_end!pf_poslen!pf_volume!pf_scope!pf_quadscopePoke
	dc.b	"Game Music Creator",0
.a 	dc.b "Andreas Tadic",0
 even

.author
	pushpea	.a(pc),d0 
	rts

.GMC_INIT  = $20+0
.GMC_PLAY  = $20+4
.GMC_END   = $20+8

.init
	lea	gamemusiccreatorroutines(a5),a0
    bsr generalReplayInitChipMem
	beq.b	.ok3
	rts
.ok3
	pushm	d0-d7/a1-a6
	move.l	moduleaddress(a5),a0
	lea	mainvolume(a5),a1
	lea	songover(a5),a2
	lea	pos_nykyinen(a5),a3
	lea	pos_maksimi(a5),a4
	move.l	gamemusiccreatorroutines(a5),a6
	lea	scopeData(a5),a5
	move.l	#nullsample,d0
	jsr	.GMC_INIT(a6)
	popm	d0-d7/a1-a6
	move.l	a0,deliPatternInfo(a5)
	moveq	#0,d0
	rts	

.play
	move.l	gamemusiccreatorroutines(a5),a0
	jmp	.GMC_PLAY(a0)

.end
	bsr	rem_ciaint
	move.l	gamemusiccreatorroutines(a5),a0
	jsr	.GMC_END(a0)
	bsr	clearsound
	bra	vapauta_kanavat

.stop
	bra	clearsound

; in: a4 = module
; out: d0 = 0, valid GMC
;      d0 = -1, not GMC
id_gamemusiccreator
	pushm 	d1-a6
	bsr.b	.do
	popm 	d1-a6 
	rts
.do
	moveq   #15-1,d0
	move.l  a4,a0
.sampleLoop
	* sample vol check probably
	cmp.b   #$40,7(a0)
    	bhi   .notGmc

    * sample len
 	move    4(a0),d1 
    	cmp     #$7fff,d1
    	bhi   .notGmc

    	add     d1,d1
    * loop length (?), must be less than total length
    	move    12(a0),d2 
    	cmp     d1,d2
    	bhi.b   .notGmc

    	add     #16,a0
    	dbf d0,.sampleLoop

    * pattern table size
    	cmp.b   #$64,243(a4)
    	bhi.b   .notGmc
    	tst.b   243(a4)
    	beq.b   .notGmc

    * pattern order table
	* contains offsets to patterns, each pattern is $400 bytes long,
	* 4 channels * 64 rows * 4 bytes
	* Possible to have 100 individual patterns
 	moveq   #100-1,d7
	lea     244(a4),a0
    	moveq   #0,d2 * numpat
.pattLoop
	* offsets should be divisible by $400
    	move    (a0),d0
    	and     #$3ff,d0
    	bne.b   .notGmc

	* store the highest pattern index	
	move    (a0),d0
	lsr     #8,d0
    	lsr     #2,d0
   	cmp     d2,d0
    	blo.b   .numpat
    	move    d0,d2
.numpat
    	addq.l    #2,a0
    	dbf d7,.pattLoop

	; check how many patterns are there
    	addq    #1,d2

	; high bound
    	cmp     #100,d2
    	bhi.b   .notGmc
 * validate the first pattern, it's apparently
 * a bit difficult to correctly determine the real amount
 * of patterns in a module. Thre should at least be one!

.patterns
    	lea     444(a4),a0
     * traverse a pattern
    * four bytes per channel per row,
    * so 16 bytes per row
    * pattern lenght is then 64 rows.
    * go through all 4 byte note slots in one pattern.

    move    #256-1,d5		* 64 rows x 4 channels
.rows  
    * first two bytes are contain note
    * and sample info.
    * 3rd is command
    * 4th is command parameter

    * get command code.
    * 0 = no command
    * 1 = slide up
    * 2 = slide down
    * 3 = set volume
    * 4 = pattern break 
    * 5 = pos jump
    * 6 = filter clear
    * 7 = filter set 
    * 8 = song step
    *   = rest are ignored

	moveq	#$f,d0
	and.b	2(a0),d0

    * set volume. could check for max volume
	* but some modules have over the max of 64 here
	* check for max volume parameter
;    cmp.b   #3,d0
;    bne.b   .c3
;    cmp.b   #$40,3(a0)
;	bhi   .notGmc3
;.c3

	move.l  (a0),d0
    	and     #$f000,d0
    	beq.b   .noSample
	clr	d0
	swap    d0
	tst	d0
	beq.b	.okP
	* d0 is now the period
	* 0 is allowed
	lea	periods,a1
	moveq	#(periodsEnd-periods)/2-1,d1
.perLoop
	cmp	(a1)+,d0
	beq.b	.okP
	dbf	d1,.perLoop
	* BAD PERIOD, BAD!
	bra.b	.notGmc
.okP
.noSample
    	addq.l  #4,a0
    	dbf     d5,.rows
   	moveq   #0,d0
    	rts
.notGmc
   	moveq  #-1,d0 
	rts


******************************************************************************
* Digital Mugician
******************************************************************************

author_vliet
	pushpea	.a(pc),d0
	rts
.a dc.b "Reinier van Vliet (Rhino/Team Hoi)",0
 even

p_digitalmugician
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id_digitalmugician(pc)
	jmp	deliAuthor(pc)
	dc  pt_digitalmugician
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_kelauseteen!pf_kelaustaakse!pf_scope!pf_quadscopePoke
	dc.b	"Digital Mugician [EP]",0
.path	dc.b	"mugician.amp",0
 even
 
.init
	lea	.path(pc),a0 
	moveq	#0,d0
	bra		deliLoadAndInit 

; in: a4 = module
; out: d0 = 0, valid DMU
;      d0 = -1, not DMU
.id_digitalmugician
	lea	.id_start(pc),a1	
	moveq	#.id_end-.id_start,d0
	jsr	search
	bra	idtest

.id_start
	dc.b	' MUGICIAN/SOFTEYES 1990 '
.id_end
 even

******************************************************************************
* Delitracker CUSTOM
******************************************************************************

p_delicustom
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	p_NOP
	p_NOP
	p_NOP
	jmp id_delicustom(pc)
	jmp	deliAuthor(pc)
	dc.w pt_delicustom
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_song!pf_end
	dc.b	"DeliTracker Custom",0
.tempFile
    dc.b    "t:hippo-delicustom",0
 even

.init
    DPRINT  "DeliCustom init"
    lea     .tempFile(pc),a0
	move.l	moduleaddress(a5),a1
    
    * Special case for XPK, exact decompressed length
    * is not the allocated mem length. LoadSeg() will freak
    * out if the length is not exact
    move.l  lod_xpkOutLen(a5),d0
    bne     .1
    move.l  modulelength(a5),d0
.1
	bsr 	plainSaveFile
	bmi 	.saveError

    jsr     justFreeModuleData

    pushpea .tempFile(pc),d1
	lore	Dos,LoadSeg
    DPRINT  "LoadSeg=%lx"
    move.l  d0,moduleAddressLoadSeg(a5)

    pushpea .tempFile(pc),d1
    lore    Dos,DeleteFile

    move.l  moduleAddressLoadSeg(a5),d0
    beq     .loadError

	lsl.l	#2,d0
	bra	deliInit

.saveError
.loadError
    moveq   #ier_nomem,d0
    rts

id_delicustom
	lea	.id1_start(pc),a1	
	moveq	#.id1_end-.id1_start,d0
	jsr	search
	bne.b	.notDeli
	lea	.id2_start(pc),a1	
	moveq	#.id2_end-.id2_start,d0
	jsr	search
	bne.b	.notDeli
	lea	.id3_start(pc),a1	
	moveq	#.id3_end-.id3_start,d0
	jsr	search
	bne.b	.notDeli

	* search() leaves with a0 pointing
	* to the next byte to be searched,
	* get the value for DTP_CustomPlayer,
	* it must be non-zero
	tst.l	(a0)
	beq.b	.notDeli

    DPRINT  "found delicustom"
	moveq	#0,d0
	rts
	
.notDeli
	moveq	#-1,d0 
	rts

.id1_start
	moveq	#-1,d0
	rts
.id1_end

.id2_start
	dc.b	"DELIRIUM"
.id2_end

; Seems that the parameter for this that can be anything but 0
.id3_start
	dc.l DTP_CustomPlayer
.id3_end


******************************************************************************
*
* EP formats
* - replayers provided in eagleplayer plugins
*
******************************************************************************


******************************************************************************
* Synthesis
******************************************************************************

p_synthesis
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	p_NOP
	p_NOP
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_synthesis 
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_end!pf_song
	dc.b	"Synthesis [EP]",0

.path dc.b "synth 4.0",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|11,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0 
	MOVEQ	#1,D0
	CMP.L	#$53796E74,(A0)
	BNE.S	.lbC000436
	MOVE.L	4(A0),D0
	LSR.L	#8,D0
	CMP.L	#$68342E,D0
	BEQ.S	.lbC000424
	CMP.L	#$682E5063,4(A0)
	BNE.S	.lbC000436
	MOVEQ	#$64,D0
.lbC0003F0	CMP.L	#$D1FC0000,(A0)
	BNE.S	.lbC00040C
	CMP.L	#$CC22C8,4(A0)
	BNE.S	.lbC00040C
	CMP.L	#$7200123A,8(A0)
	BEQ.S	.lbC000414
.lbC00040C	ADDQ.L	#4,A0
	DBRA	D0,.lbC0003F0
	RTS

.lbC000414	MOVEQ	#-1,D0
	SUBQ.L	#4,A0
	CMP.W	#$41FA,(A0)+
	BNE.S	.lbC000436
	MOVEQ	#0,D1
	MOVE.W	(A0),D1
	ADD.L	D1,A0
.lbC000424	
	MOVEQ	#0,D0
.lbC000436	
	rts


******************************************************************************
* SynTracker
******************************************************************************

p_syntracker
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	p_NOP
	p_NOP
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc pt_syntracker
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_end
	dc.b	"SynTracker [EP]",0
.path dc.b "syntracker",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|2,d0
	bra		deliLoadAndInit 

.id
	move.l 	a4,a0
	LEA	.SYNTRACKERSONMSG(PC),A1
	MOVEQ	#-1,D0
	MOVEQ	#15,D1
.lbC0001E0	CMPM.B	(A1)+,(A0)+
	BNE.S	.lbC0001EA
	DBRA	D1,.lbC0001E0
	MOVEQ	#0,D0
.lbC0001EA	
	RTS

.SYNTRACKERSONMSG	dc.b	'SYNTRACKER-SONG:',0,0


******************************************************************************
* Rob Hubbard 2
******************************************************************************

p_robhubbard2
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	p_NOP
	p_NOP
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_robhubbard2
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_end!pf_scope!pf_quadscopePoke
	dc.b	"R.Hubbard 2/Infogra.[EP]",0
.path dc.b "rob hubbard 2",0
 even

.init
	lea	.path(pc),a0 
	move.l	#2<<16|0,d0
	bra		deliLoadAndInit 

; in: a4 = module
;     d7 = module length
; out: d0 = 0, valid valid
;      d0 = -1, not valid
.id
	move.l	a4,a0 
	SUB.W	$10(A0),D7
	SUBQ.L	#2,D7
	BNE.S	.lbC000336
	MOVE.W	(A0),D0
	LEA	0(A0,D0.W),A0
	TST.W	(A0)
	BMI.S	.lbC000336
	MOVEQ	#0,D0
	MOVEQ	#0,D1
	MOVE.W	2(A0),D1
	MOVE.W	12(A0),D2
	MOVE.W	6(A0),D3
	MOVEQ	#$10,D4
.lbC000320	MOVE.W	0(A0,D4.W),D0
	CMP.W	D1,D0
	BGT.S	.lbC000336
	CMP.W	D2,D0
	BLT.S	.lbC000336
	ADDQ.W	#2,D4
	CMP.W	D4,D3
	BLT.S	.lbC000320
	MOVEQ	#0,D0
	RTS
.lbC000336	MOVEQ	#-1,D0
	RTS


******************************************************************************
* ChipTracker
******************************************************************************


p_chiptracker
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_chiptracker 
 dc pf_scope!pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_poslen!pf_kelauseteen!pf_kelaustaakse!pf_ciakelaus2!pf_quadscopeUps
	dc.b	"ChipTracker [EP]",0

.path dc.b "chiptracker",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|3,d0
	bra		deliLoadAndInit 

.id
	cmp.l   #'KRIS',952(A4)
	sne	d0
	rts

******************************************************************************
* Medley Sound System
******************************************************************************

p_medley
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP 	
	p_NOP
	jmp	.song(pc) 
	p_NOP
	p_NOP
	p_NOP
	jmp .id_medley(pc)
	jmp	.author(pc)
	dc.w pt_medley
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_song
	dc.b	"Medley Sound",0
.a 	dc.b	"Paul van der Valk",0
 even

.author
	pushpea	.a(pc),d0 
	rts

.MEDLEY_INIT  = 0+$20
.MEDLEY_PLAY  = 4+$20
.MEDLEY_END   = 8+$20
.MEDLEY_SONG  = 12+$20

.init
	lea	    medleyroutines(a5),a0
    bsr     generalReplayInit
	beq.b	.ok3
	rts
.ok3
	pushm	d1-a6
	move.l	moduleaddress(a5),a0
	lea	mainvolume(a5),a1
	lea	maxsongs(a5),a2
	lea	ciaint_setTempoFromD0(pc),a3
	move	songnumber(a5),d0 	* song number
	;moveq	#8,d0
	addq	#1,d0
	move.l	medleyroutines(a5),a6
	jsr	.MEDLEY_INIT(a6)
	popm	d1-a6
	* INIT returns 0 on success
	rts	

.play
	move.l	medleyroutines(a5),a0
	jmp	.MEDLEY_PLAY(a0)

.stop
	bra	clearsound

.song
 if DEBUG
	moveq	#0,d0
	move	songnumber(a5),d0
	DPRINT	"Song %ld"
 endif
 	move.l	medleyroutines(a5),a0
	jmp	.MEDLEY_SONG(a0)

.end
	bsr	rem_ciaint
	pushm	all
	move.l	medleyroutines(a5),a0
	jsr	.MEDLEY_END(a0)
	popm	all
	bsr	clearsound
	bra	vapauta_kanavat



; in: a4 = module
;     d7 = module lenght
; out: d0 = 0, valid valid
;      d0 = -1, not valid
.id_medley
	cmp.l 	#"MSOB",(a4)
	bne.b	.invalid
	* next, three offsets, should point to inside module
	* first byte should be zero since mods are small
	tst.b	4(a4)
	bne.b	.invalid
	tst.b	8(a4)
	bne.b	.invalid
	tst.b	12(a4)
	bne.b	.invalid

	move.l	4(a4),d0
	add.l	a4,d0
	cmp.l	d0,a4
	bhs.b	.invalid
	move.l	8(a4),d0
	add.l	a4,d0
	cmp.l	d0,a4
	bhs.b	.invalid
	move.l	12(a4),d0
	add.l	a4,d0
	cmp.l	d0,a4
	bhs.b	.invalid

	moveq	#0,d0
	rts

.invalid
	moveq	#-1,d0
	rts


******************************************************************************
* Future Player
******************************************************************************

p_futureplayer
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP 	
	p_NOP
	jmp	.song(pc) 
	p_NOP
	p_NOP
	p_NOP
	jmp id_futureplayer(pc)
	jmp	.author(pc)
	dc.w pt_futureplayer
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_song
	dc.b	"Future Player",0
.a 	dc.b	"Paul van der Valk, adapted by Wanted Team",0
 even

.author
	pushpea	.a(pc),d0 
	rts


.FP_INIT  = 0+$20
.FP_PLAY  = 4+$20
.FP_END   = 8+$20
.FP_SONG  = 12+$20

.init
	lea	futureplayerroutines(a5),a0
    bsr generalReplayInit
	beq.b	.ok3
	rts
.ok3
	pushm	d1-a6

	move.l	moduleaddress(a5),a0
    cmp.l   #$3f3,(a0)
    bne     .1
    DPRINT  "Relocate module"
	* clear the hunk id for safety to avoid reloccing again
	clr.l	(a0)
    bsr reloc
.1

    moveq   #$20-4,d0
	add.l	moduleaddress(a5),d0

	lea	nullsample,a1
	lea	mainvolume(a5),a2
	lea	maxsongs(a5),a3
	lea	ciaint_setTempoFromD0(pc),a4
	move	songnumber(a5),d1 	* song number, starts from 0
	move.l	futureplayerroutines(a5),a6
	push	a5
	jsr	.FP_INIT(a6)
	pop	a5
	tst.l	d0
	bne.b	.inifail
	* song name is in a0
 if DEBUG
	move.l 	a0,d0
	DPRINT	"Song name: %s"
 endif
	lea	modulename(a5),a1
.c	move.b	(a0)+,(a1)+
	bne.b	.c

	moveq	#0,d0
.inifail
	popm	d1-a6
	* INIT returns 0 on success
	rts	

.play
	move.l	futureplayerroutines(a5),a0
	jmp	.FP_PLAY(a0)

.stop
	bra	clearsound

.song
 if DEBUG
	moveq	#0,d0
	move	songnumber(a5),d0
	DPRINT	"Song %ld"
 endif
	move.l	futureplayerroutines(a5),a0
	jmp	.FP_SONG(a0)

.end
	bsr	rem_ciaint
	pushm	all
	move.l	futureplayerroutines(a5),a0
	jsr	.FP_END(a0)
	popm	all
	bsr	clearsound
	bra	vapauta_kanavat


; in: a4 = module
;     d7 = module length
; out: d0 = 0, valid valid
;      d0 = -1, not valid
id_futureplayer
	cmp.l	#$000003F3,(A4)
	bne.b	.fail
	tst.b	20(A4)				; loading into chip check
	beq.b	.fail
	lea	32(A4),A0
	cmp.l	#$70FF4E75,(A0)+
	bne.b	.fail
	cmp.l	#'F.PL',(A0)+
	bne.b	.fail
	cmp.l	#'AYER',(A0)+
	bne.b	.fail
	tst.l	20(A0)				; Song pointer check
	beq.b	.fail

	moveq	#0,D0
	rts
.fail
	moveq	#-1,D0
	rts



******************************************************************************
* Ben Daglish
******************************************************************************

p_bendaglish
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP 	
	p_NOP
	jmp	.song(pc) 
	p_NOP
	p_NOP
	p_NOP
	jmp .id_bendaglish(pc)
	jmp	.author(pc)
	dc.w pt_bendaglish
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_song
	dc.b	"Ben Daglish",0
.a 	dc.b	"Ben Daglish, adapted by Wanted Team",0
 even

.author
	pushpea	.a(pc),d0 
	rts

.BD_INIT  = 0+$20
.BD_PLAY  = 4+$20
.BD_END   = 8+$20
.BD_SONG  = 12+$20

.init
	lea	bendaglishroutines(a5),a0
    bsr generalReplayInit
	beq.b	.ok3
	rts
.ok3
	pushm	d1-a6
	move.l	moduleaddress(a5),a0
	lea	mainvolume(a5),a1
	lea	maxsongs(a5),a2
	move	songnumber(a5),d0 	* song number, starts from 0
	move.l	bendaglishroutines(a5),a6
	jsr	.BD_INIT(a6)
	popm	d1-a6
	* INIT returns 0 on success
	rts	

.play
	move.l	bendaglishroutines(a5),a0
	jmp	.BD_PLAY(a0)

.stop
	bra	clearsound

.song
 if DEBUG
	moveq	#0,d0
	move	songnumber(a5),d0
	DPRINT	"Song %ld"
 endif
	pushm	all
	* Safety:
 	move.l  #$07800780,$dff09a
	move.l	bendaglishroutines(a5),a0
	jsr	.BD_SONG(a0)
	popm	all
	rts

.end
	bsr	rem_ciaint
	pushm	all
	* Safety: disable audio interrupts and clear requests
	* which this replayer uses. Pending interrupts
	* may trigger after code is in wrong state or deallocated.
 	move.l  #$07800780,$dff09a
	move.l	bendaglishroutines(a5),a0
	jsr	.BD_END(a0)
	popm	all
	bsr	clearsound
	bra	vapauta_kanavat


; in: a4 = module
;     d7 = module length
; out: d0 = 0, valid valid
;      d0 = -1, not valid
.id_bendaglish
	move.l	a4,a0
	cmp.w	#$6000,(A0)+
	bne.s	.fail
	move.l	A0,A1
	move.w	(A0)+,D1
	beq.b	.fail
	bmi.b	.fail
	btst	#0,D1
	bne.b	.fail
	cmp.w	#$6000,(A0)+
	bne.s	.fail
	move.w	(A0)+,D1
	beq.b	.fail
	bmi.b	.fail
	btst	#0,D1
	bne.b	.fail
	addq.l	#2,A0
	cmp.w	#$6000,(A0)+
	bne.s	.fail
	move.w	(A0),D1
	beq.b	.fail
	bmi.b	.fail
	btst	#0,D1
	bne.b	.fail
	add.w	(A1),A1
	cmp.l	#$3F006100,(A1)
	bne.s	.fail
	cmpi.w	#$3D7C,6(A1)
	bne.s	.fail
	cmpi.w	#$41FA,12(A1)
	bne.s	.fail
	moveq	#0,D0
	rts

.fail	moveq	#-1,d0
	rts


******************************************************************************
* Sidmon v2
******************************************************************************

p_sidmon2
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP 	
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp .id_sidmon2(pc)
	jmp	.author(pc)
	dc.w pt_sidmon2
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume
	dc.b	"SidMon 2",0
.a	dc.b	"Michael Kleps (Unknown/DOC 1990)",0
 even

.author
	pushpea	.a(pc),d0 
	rts


.INIT  = 0+$20
.PLAY  = 4+$20

.init
	lea	sidmon2routines(a5),a0
    bsr generalReplayInit
	beq.b	.ok3
	rts
.ok3
	pushm	d1-a6
	move.l	moduleaddress(a5),a0
	lea	mainvolume(a5),a1
	lea	dmawait(pc),a2
	move.l	sidmon2routines(a5),a6
	jsr	.INIT(a6)
	popm	d1-a6
	moveq	#0,d0
	rts	

.play
	move.l	sidmon2routines(a5),a0
	jmp	.PLAY(a0)

.stop
	bra	clearsound

.end
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat


; in: a4 = module
;     d7 = module length
; out: d0 = 0, valid valid
;      d0 = -1, not valid
.id_sidmon2
	lea		.idStart(pc),a1
	moveq	#.idEnd-.idStart,d0
	jmp 	search

.idStart	dc.b	'SIDMON II - THE MIDI VERSION'
.idEnd 
 even 


******************************************************************************
* Delta Music 1
******************************************************************************

p_deltamusic1
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP 	
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp .id_deltamusic1(pc)
	jmp	.author(pc)
	dc.w pt_deltamusic1
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume
	dc.b	"Delta Music 1",0
.a 	dc.b	"Bent Nielsen",0
 even

.author
	pushpea	.a(pc),d0 
	rts

.INIT  = 0+$20
.PLAY  = 4+$20

.init
	lea	deltamusic1routines(a5),a0
    bsr generalReplayInit
	beq.b	.ok3
	rts
.ok3
	pushm	d1-a6
	move.l	moduleaddress(a5),a0
	lea	mainvolume(a5),a1
	lea	dmawait(pc),a2
	move.l	deltamusic1routines(a5),a6
	jsr	.INIT(a6)
	popm	d1-a6
	moveq	#0,d0
	rts	

.play
	move.l	deltamusic1routines(a5),a0
	jmp	.PLAY(a0)

.stop
	bra	clearsound

.end
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat


; in: a4 = module
;     d7 = module length
; out: d0 = 0, valid valid
;      d0 = -1, not valid
.id_deltamusic1
	move.l 	a4,a0
	move.l  d7,d0
	cmp.l	#"ALL ",(a0)
	bne.b	.no
	moveq	#104,d1
	lea	4(a0),a1
	moveq	#24,d2
.l	cmp.l	(a1)+,d1
	dbf	d2,.l
	cmp.l 	d1,d0
	blo.b 	.no
	moveq	#0,d0
	rts
.no	moveq	#-1,d0 
	rts

******************************************************************************
* SoundFX
******************************************************************************

p_soundfx
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP 	
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp .id_soundfx(pc)
	jmp	.author(pc)
	dc.w pt_soundfx
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_poslen!pf_scope!pf_quadscopePoke
	dc.b	"SoundFX",0
.a 	dc.b	"Christian Haller, Christian A. Webber",0
 even

.author
	pushpea	.a(pc),d0 
	rts

.INIT  = 0+$20
.PLAY  = 4+$20

.init
	lea	soundfxroutines(a5),a0
    bsr generalReplayInit
	beq.b	.ok3
	rts
.ok3
	pushm	d1-d7/a1-a6
	move.l	moduleaddress(a5),a0
	lea	mainvolume(a5),a1
	lea	dmawait(pc),a2
	lea	pos_nykyinen(a5),a3
	lea 	pos_maksimi(a5),a4
	move.l	soundfxroutines(a5),a6
	lea	scopeData(a5),a5
	jsr	.INIT(a6)
	popm	d1-d7/a1-a6
	move.l	a0,deliPatternInfo(a5)
	moveq	#0,d0
	rts	

.play
	move.l	soundfxroutines(a5),a0
	jmp	.PLAY(a0)

.stop
	bra	clearsound

.end
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat


; in: a4 = module
;     d7 = module length
; out: d0 = 0, valid valid
;      d0 = -1, not valid
.id_soundfx
	cmp.l	#"SONG",60(a4)
	bne.b	.no
	moveq	#0,d0
	rts
.no	moveq	#-1,d0 
	rts

******************************************************************************
* GlueMon
******************************************************************************

p_gluemon
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP 	
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp .id_gluemon(pc)
	jmp	.author(pc)
	dc.w pt_gluemon
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_end!pf_poslen!pf_scope!pf_quadscopePoke
	dc.b	"GlueMon",0
.a	dc.b	"Lars Malmborg (GlueMaster/North Star)",0
 even

.author
	pushpea	.a(pc),d0 
	rts

.INIT  = 0+$20
.PLAY  = 4+$20
.END   = 8+$20

.init
	lea 	gluemonroutines(a5),a0
    bsr     generalReplayInit
	beq.b	.ok3
	rts
.ok3
	pushm	d1-a6
	move.l	moduleaddress(a5),a0
	lea	mainvolume(a5),a1
	lea	songover(a5),a2
	lea 	pos_maksimi(a5),a3
	lea	pos_nykyinen(a5),a4
	move.l	gluemonroutines(a5),a6
    pushpea scopeData(a5),d0
	jsr	.INIT(a6)
	popm	d1-a6
	moveq	#0,d0
	rts	

.play
	move.l	gluemonroutines(a5),a0
	jmp	.PLAY(a0)

.stop
	lea	$dff096,a0
	moveq	#0,d0
	move	d0,$a8-$96(a0)
	move	d0,$b8-$96(a0)
	move	d0,$c8-$96(a0)
	move	d0,$d8-$96(a0)
	;bra	clearsound
	rts

.end
	move.l	gluemonroutines(a5),a0
	jsr	.END(a0)
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat


; in: a4 = module
;     d7 = module length
; out: d0 = 0, valid valid
;      d0 = -1, not valid
.id_gluemon
	cmp.l	#"GLUE",(a4)
	bne.b	.no
	cmp.l	#~"GLUE",4(a4)
	bne.b	.no
	moveq	#0,d0
	rts
.no	moveq	#-1,d0 
	rts

******************************************************************************
* PreTracker
******************************************************************************

p_pretracker
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP 	
	p_NOP
	jmp	.song(pc)
	p_NOP
	p_NOP
	p_NOP
	jmp .id_pretracker(pc)
	jmp	.pre_author(pc)
	dc.w pt_pretracker
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_scope!pf_quadscopePoke!pf_poslen!pf_end!pf_song
	dc.b	"PreTracker by Pink/aBYSs",0
.author = *-11
 even

.offset_init = $20+0
.offset_play = $20+4
.offset_stop = $20+8
.offset_song = $20+12

.pre_author
	pushpea	.author(pc),d0
	rts

.init
	lea 	pretrackerroutines(a5),a0
    bsr     generalReplayInit
	beq.b	.ok3
	rts
.ok3
	jsr	setMainWindowWaitPointer
	pushm	d2-d7/a1-a6
	move.l	moduleaddress(a5),a0
	lea	scopeData(a5),a1
	lea	mainvolume(a5),a2
	lea	songover(a5),a3
	move.l pretrackerroutines(a5),a4
	jsr	.offset_init(a4)
	popm	d2-d7/a1-a6
	jsr	clearMainWindowWaitPointer
	tst.l	d0
	beq.b 	.noMem
	bmi.b	.initErr
;	move.l	a0,deliPatternInfo(a5)
	subq	#1,d1
	move	d1,maxsongs(a5)

 if DEBUG
 	moveq	#0,d0
	move	d1,d0
	DPRINT	"Songs %ld"
 endif
	moveq	#0,d0
	rts	

.noMem
	moveq #ier_nomem,d0
	rts

.initErr
	moveq #ier_not_compatible,d0
	rts

.play
	push	a5
	move.l	pretrackerroutines(a5),a0
	jsr	.offset_play(a0)
	pop	a5
	move	d0,pos_nykyinen(a5)
	move	d1,pos_maksimi(a5)
	rts
	
.stop
	bra	clearsound

.end
	bsr	rem_ciaint
	bsr	clearsound
	move.l pretrackerroutines(a5),a0
	jsr	.offset_stop(a0)
	bra	vapauta_kanavat

.song
	moveq	#0,d0
	move	songnumber(a5),d0
	DPRINT	"Setting subsong %ld"
	move.l pretrackerroutines(a5),a0
	jmp	.offset_song(a0)

.id_pretracker 
	bsr.b 	id_pretracker_
	bne.b .x
	lea	$14(a4),a1
	moveq	#20-1,d0
    jsr	copyNameFromA1
	moveq	#0,d0
.x  rts

; in: a4 = module
;     d7 = module length
; out: d0 = 0, valid valid
;      d0 = -1, not valid
id_pretracker_
	move.l	(a4),d0
	lsr.l	#8,d0
	cmp.l	#"PRT",d0
	bne.b	.no
	tst	4(a4)
	bne.b	.no
	tst	8(a4)
	bne.b	.no
	tst	$c(a4)
	bne.b	.no
	moveq	#0,d0
	rts
.no	moveq	#-1,d0 
	rts

******************************************************************************
* CustomMade
******************************************************************************

p_custommade
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP 	
	p_NOP
	jmp	.song(pc) 
	p_NOP
	p_NOP
	p_NOP
	jmp .id_custommade(pc)
	jmp	.author(pc)
	dc.w pt_custommade
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_song
	dc.b	"CustomMade",0
.a 	dc.b	"Ivo Zoer & Ron Klaren, adapted by Andy Silva & Wanted Team",0
 even

.author
	pushpea	.a(pc),d0 
	rts

 even

.INIT  = 0+$20
.PLAY  = 4+$20
.SONG  = 8+$20

.init
	lea	    custommaderoutines(a5),a0
    bsr     generalReplayInit
	beq.b	.ok3
	rts
.ok3
	pushm	d1-a6
	move.l	moduleaddress(a5),a0
	lea	mainvolume(a5),a1
	lea 	songover(a5),a2
	move.l	custommaderoutines(a5),a3
	jsr	.INIT(a3)

*   d1 = min song, always 1
*   d2 = max song
*   d3 = timer value

	subq	#1,d2 
;	clr	songnumber(a5)
	move	d2,maxsongs(a5)

	move	d3,d0 
	bsr	ciaint_setTempoFromD0

    bsr     .song

	popm	d1-a6
	* INIT returns 0 on success
	moveq	#0,d0
	rts	

.play
	move.l	custommaderoutines(a5),a0
	jmp	.PLAY(a0)

.stop
	bra	clearsound

.song
	moveq	#0,d0
	move	songnumber(a5),d0
	DPRINT	"Song %ld"

	* starts from 1, not 0
	addq	#1,d0
	move.l	custommaderoutines(a5),a0
	jmp	.SONG(a0)

.end
	bsr	rem_ciaint
	bsr	clearsound
	bra	vapauta_kanavat


; in: a4 = module
;     d7 = module length
; out: d0 = 0, valid valid
;      d0 = -1, not valid
.id_custommade
	move.l	a4,a0
	moveq	#-1,D0
	
	cmp.w	#$4EF9,(A0)		; jmp
	beq.b	.Later
	cmp.w	#$4EB9,(A0)		; jsr
	beq.b	.Later
	cmp.w	#$6000,(A0)		; bra
	bne.b	.Fault
	cmp.w	#$6000,4(A0)
	beq.b	.More
.Fault
	rts
.Later
	cmp.w	#$4EF9,6(A0)
	bne.b	.Fault
.More
	lea	8(A0),A1
	lea	400(A1),A2
.Last
	cmp.l	#$42280030,(A1)
	bne.b	.NOM
	cmp.l	#$42280031,4(A1)
	bne.b	.NOM
	cmp.l	#$42280032,8(A1)
	beq.b	.Found
.NOM
	addq.l	#2,A1
	cmp.l	A1,A2
	bne.b	.Last
	rts
.Found
	moveq	#0,D0
	rts



******************************************************************************
* Dave Lowe
******************************************************************************

p_davelowe
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP 	
	p_NOP
	jmp	.song(pc) 
	p_NOP
	p_NOP
	p_NOP
	jmp id_davelowe(pc)
	jmp	.author(pc)
	dc.w pt_davelowe
	dc pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_song!pf_end
	dc.b	"Dave Lowe",0
.a 	dc.b	"Dave Lowe, adapted by Wanted Team",0
 even

.author
	pushpea	.a(pc),d0 
	rts

.INIT  = 0+$20
.PLAY  = 4+$20
.END   = 8+$20
.SONG  = 12+$20

.init
	lea	daveloweroutines(a5),a0
    bsr generalReplayInit
	beq.b	.ok3
	rts
.ok3
	pushm	d1-a6


	move.l	moduleaddress(a5),a0
    cmp.l   #$3f3,(a0)
    bne     .1
    DPRINT  "Relocate module"
	* clear the hunk id for safety to avoid reloccing again
	clr.l	(a0)
    bsr     reloc
	bsr	    clearCpuCaches
.1
    DPRINT  "init"

	move.l	moduleaddress(a5),a0 
    lea     $20-4(a0),a0  * skip hunk header

	* LoadSeg BPTR->APTR
	;add.l	a0,a0
	;add.l	a0,a0
	lea	mainvolume(a5),a1 
	lea	songover(a5),a2
	move.l	daveloweroutines(a5),a3
	jsr	.INIT(a3)
	subq	#1,d2
	move	d2,maxsongs(a5)

 if DEBUG
 	push	d0
	move.l	d1,d0
	move.l	d2,d1
	move.l	d3,d2
	DPRINT	"Range %ld-%ld %s"
	pop	d0
 endif
	tst.l	d3
	beq.b	.x
	move.l	d3,a0
	lea	modulename(a5),a1
.c	move.b	(a0)+,(a1)+
	bne.b	.c
.x
	popm	d1-a6
	* INIT returns 0 on success
	rts	

.play
	move.l	daveloweroutines(a5),a0
	jmp	.PLAY(a0)

.stop
	bra	clearsound

.song
 if DEBUG
	moveq	#0,d0
	move	songnumber(a5),d0
	addq	#1,d0
	DPRINT	"Song %ld"
 endif
	move.l	daveloweroutines(a5),a0
	jmp .SONG(a0)

.end
	bsr	rem_ciaint
	pushm	all
	move.l	daveloweroutines(a5),a0
	jsr	.END(a0)
	popm	all
	bsr	clearsound
	bra	vapauta_kanavat


; in: a4 = module
;     d7 = module length
; out: d0 = 0, valid valid
;      d0 = -1, not valid
id_davelowe
	move.l	a4,a0
	cmp.l	#$000003F3,(A0)
	bne.b	.fail
	tst.b	20(A0)				; loading into chip check
	beq.b	.fail
	lea	32(A0),A0
	cmp.l	#$70FF4E75,(A0)+
	bne.b	.fail
	cmp.l	#'UNCL',(A0)+
	bne.b	.fail
	cmp.l	#'EART',(A0)+
	bne.b	.fail
	tst.l	(A0)+				; InitSound pointer check
	beq.b	.fail
	tst.l	(A0)+				; Interrupt pointer check
	beq.b	.fail
	addq.l	#4,A0
	tst.l	(A0)				; Subsong Counter label check
	beq.b	.fail
	moveq	#0,D0
	rts
.fail
	moveq	#-1,D0
	rts


******************************************************************************
* StarTrekker AM
******************************************************************************

p_startrekker
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	p_NOP 	
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	p_NOP
	jmp 	.id(pc)
	jmp	.author(pc)
	dc.w 	pt_startrekker
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_poslen!pf_scope!pf_quadscopePoke
	dc.b	"StarTrekker AM",0
.a 	dc.b "Bjoern Wesen/Exolon of Fairlight",0
 even

.author
	pushpea	.a(pc),d0 
	rts
	
.INIT  = 0+$20
.PLAY  = 4+$20
.END   = 8+$20


.init
	lea	startrekkerroutines(a5),a0
    bsr generalReplayInitChipMem
	beq.b	.ok3
	rts
.ok3
	pushm	d1-a6

	move.l	moduleaddress(a5),a0
	move	#950/2-1,d0
	lea	ptheader,a1
.cl	move	(a0)+,(a1)+
	dbf	d0,.cl


	* Load extra data file ".nt"
	jsr	getcurrent 
	* a3 = node
	lea	-200(sp),sp
	lea	l_filename(a3),a0 
	move.l	sp,a1
.c	move.b	(a0)+,(a1)+
	bne.b	.c
	subq	#1,a1
	move.b	#".",(a1)+
	move.b	#"n",(a1)+
	move.b	#"t",(a1)+
	clr.b	(a1)

    * These data files are optional, so let's not
    * show error dialogs if they are not found.
    st      disableShowStreamerError(a5)

	move.l	sp,a0
	bsr.b	.loadExtraFile
	* d0 = 0 if success
 	lea	200(sp),sp

	tst.l	d0 
	beq.b 	.gotNt
	
	* Load extra data file ".as"
	* Audio Sculpture
	jsr	getcurrent 
	* a3 = node
	lea	-200(sp),sp
	lea	l_filename(a3),a0 
	move.l	sp,a1
.c2	move.b	(a0)+,(a1)+
	bne.b	.c2
	subq	#1,a1
	move.b	#".",(a1)+
	move.b	#"a",(a1)+
	move.b	#"s",(a1)+
	clr.b	(a1)

	move.l	sp,a0
	bsr.b	.loadExtraFile
	* d0 = 0 if success
 	lea	200(sp),sp

	tst.l	d0 
	bne.b 	.fileErr

.gotNt
	move.l	moduleaddress(a5),a0
	move.l	startrekkerdataaddr(a5),a1
	lea	mainvolume(a5),a2
	lea	songover(a5),a3
	lea	dmawait(pc),a4
	move.l	modulelength(a5),d0
	pushm	a5/a6
	move.l	startrekkerroutines(a5),a6
	lea	scopeData(a5),a5
	jsr	.INIT(a6)
	moveq	#0,d0
	popm 	a5/a6
	move.l	a0,deliPatternInfo(a5)
	move	d1,pos_maksimi(a5)
.x
    clr.b   disableShowStreamerError(a5)
	popm	d1-a6
	tst.l	d0
	* INIT returns 0 on success
	rts	

.loadExtraFile	
 if DEBUG
	move.l	a0,d0
	DPRINT	"Loading %ls"
 endif
    * HACK! Eensure new stream job will be started
    move    #-1,streamReturnCode(a5)

	move.l	#MEMF_CHIP!MEMF_CLEAR,d0
	lea	startrekkerdataaddr(a5),a1
	lea 	startrekkerdatalen(a5),a2
	jmp 	loadfileStraight

.fileErr 
	* No extra data file tound. Proceed as Protracker
	DPRINT	"Revert to Protracker"
	bsr	rem_ciaint
	bsr	vapauta_kanavat
	pushpea	p_protracker(pc),playerbase(a5)
	move	#pt_prot,playertype(a5)
	moveq	#0,d0 
	move.l	playerbase(a5),a0 
	jsr	p_init(a0)
	bra.b 	.x

.play
	push	a5
	move.l	startrekkerroutines(a5),a0
	jsr	.PLAY(a0)
	pop 	a5
	move	d0,pos_nykyinen(a5)
	rts

.stop
	bra	clearsound

.end
	bsr	rem_ciaint
	move.l	startrekkerroutines(a5),a0
	jsr	.END(a0)
	bsr	clearsound
	bra	vapauta_kanavat

.id
	bsr.b	.id_
	bne.b 	.nok
	moveq	#20-1,d0
	jsr	copyNameFromModule
	moveq	#0,d0	
.nok	rts

; in: a4 = module
;     d7 = module lenght
; out: d0 = 0, valid valid
;      d0 = -1, not valid
.id_
	cmp.l	#"FLT4",$438(a4)
	beq.s	.k
	cmp.l	#"EXO4",$438(a4)
	beq.s	.k
	moveq	#-1,d0
	rts 
.k
	moveq	#0,d0
	rts


******************************************************************************
* Voodoo Supreme Synthesizer
******************************************************************************

p_voodoosupremesynthesizer
	jmp	.init(pc)
	jmp	.play(pc)
	p_NOP
	jmp	.end(pc)
	jmp	.stop(pc)
	jmp	.cont(pc)
	jmp	.vol(pc)
	jmp	.song(pc)
	p_NOP
	p_NOP
	p_NOP
	jmp 	.id(pc)
	jmp	.author(pc)
	dc.w 	pt_voodoosupremesynthesizer
	dc	pf_stop!pf_cont!pf_ciakelaus!pf_volume!pf_song
	dc.b	"VoodooSupremeSynthesizer",0
.a 	dc.b "Thomas Partl",0
 even

.author
	pushpea	.a(pc),d0 
	rts

.INIT  = 0+$20
.PLAY  = 4+$20
.END   = 8+$20
.VOL   = 12+$20
.SONG  = 16+$20

.init
	lea	voodooroutines(a5),a0
    bsr generalReplayInit
	beq.b	.ok3
	rts
.ok3
	move.l	moduleaddress(a5),a0
	move.l	modulelength(a5),d0
	lea	songover(a5),a1
	move.l	voodooroutines(a5),a2
	jsr	.INIT(a2)
	tst.l	d0
	bne.b	.noMem

	* min song = d1
	* max song = d2
	move	d2,maxsongs(a5)

	bsr.b	.vol
	moveq	#0,d0
	rts

.noMem
	moveq	#ier_nomem,d0
	rts
.end
	bsr	rem_ciaint
	move.l	voodooroutines(a5),a0
	jsr	.END(a0)
	bsr	clearsound
	bra	vapauta_kanavat

.play
	move.l	voodooroutines(a5),a0
	jmp	.PLAY(a0)
.stop
	bra	clearsound
.cont
	rts
.vol
	move	mainvolume(a5),d0
	move.l	voodooroutines(a5),a0
	jmp	.VOL(a0)
.song	
	move	songnumber(a5),d0
	move.l	voodooroutines(a5),a0
	jmp	.SONG(a0)
	
.id
	move.l	a4,a0
	move.l	d7,d0
	ADDQ.L	#1,D0
	AND.L	#$FFFFFFFE,D0
	ADD.L	D0,A0
	MOVEQ	#-1,D0
	SUB.W	#$40,A0
	MOVEQ	#$1F,D1
.lbC000360	
	CMP.L	#$56535330,(A0)
	BEQ.B	.lbC000372
	ADDQ.L	#2,A0
	DBRA	D1,.lbC000360
	RTS
.lbC000372	
	CMP.L	#$100,4(A0)
	BHS.B	.no
	MOVEQ	#0,D0
.no
	RTS

******************************************************************************
* Quartet
******************************************************************************

p_quartet
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp 	.id(pc)
	jmp	deliAuthor(pc)
	dc  	pt_quartet 
 	dc 	pf_stop!pf_cont!pf_volume!pf_end!pf_poslen!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"Quartet [EP]",0

.path dc.b "quartet",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|1,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0
        cmp.b   #$50,1(A0)
        bne.b   .Fault
        cmp.b   #30,(A0)
        bhi.b   .Fault
        moveq   #0,D1
        move.b  (A0),D1
        beq.b   .Fault
        move.l  #3000,D2                        ; max. tempo
        divu.w  D1,D2
        swap    D2
        tst.w   D2
        bne.b   .Fault
     move.l  d7,D2
        bclr    #0,D2
        add.l   D2,A0
        moveq   #15,D2
        moveq   #-1,D3
.NextEnd
        move.w  -(A0),D1
        beq.b   .Zero
        cmp.w   D3,D1
        beq.b   .CheckEnd
.Fault
        moveq   #-1,D0
        rts
.Zero
        dbf     D2,.NextEnd
        bra.b   .Fault
.CheckEnd
        cmp.l   -2(A0),D3
        bne.b   .Fault
        cmp.l   -6(A0),D3
        bne.b   .Fault
        moveq   #0,D0
	rts

******************************************************************************
* Face The Music
******************************************************************************

p_facethemusic
	jmp	.init(pc)
	jmp	deliPlay(pc)
	jmp	.ftmVBlank(pc)
	jmp	.end(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_facethemusic 
.flags 	dc pf_stop!pf_cont!pf_volume!pf_end	
	dc.b	"Face The Music [EP]",0

.path dc.b "face the music",0
 even


.init
	lea	.path(pc),a0 
	moveq	#0<<16|7,d0
	bsr	deliLoadAndInit
	bne.b	.error

	* Some tunes seem to end prematurely, try this
	lea	.flags(pc),a0
	and	#~pf_end,(a0)
	moveq	#0,d0
.error	
	rts


.end
	bsr	deliEnd
	* Extra safety:
	move.l  #$07800780,$dff09a
	rts

.id
	bsr.b	.do
	bne.b	.not 
	bsr 	moveModuleToPublicMem
	moveq	#0,d0
.not		
	rts

.do
	MOVEQ	#0,D0
	MOVE.L	(A4),D1
	AND.L	#$FFFFFF00,D1
	CMP.L	#$46544D00,D1
	SNE	D0
	rts

.ftmVBlank
	* Need to call this so that volume and voices are updated.
	* FTM uses it's own interrupt otherwise.
	bra	deliInterrupt

******************************************************************************
* Richard Joseph
******************************************************************************

p_richardjoseph
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_richardjoseph
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_poslen!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"R.Joseph/VectorDean [EP]",0
.path dc.b "richard joseph player",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|2,d0
	bsr	deliLoadAndInit
	bne.b	.error

	* Some tunes seem to end prematurely, try this
	lea	.flags(pc),a0
	and	#~pf_end,(a0)
	moveq	#0,d0
.error	
	rts

.id
        movea.l a4,A0
        moveq   #-1,D0
        move.l  (A0)+,D1
        clr.b   D1
        cmp.l   #$524A5000,D1
        bne.b   .Fault
        cmp.l   #'SMOD',(A0)+
        bne.b   .Fault
        addq.l  #4,A0
        tst.l   (A0)
        bne.b   .Fault
        moveq   #0,D0
.Fault
        rts


******************************************************************************
* In Stereo 1
******************************************************************************

p_instereo1
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp 	.id(pc)
	jmp	deliAuthor(pc)
	dc 	pt_instereo1
	dc 	pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus
	dc.b	"In Stereo! 1.0 [EP]",0

.path dc.b "in stereo 1.0",0
 even

* Let's bend over backwards for this one.
* It is an amplifier eagleplayer, so it can run
* with data in fast ram. The replay code contains waveform
* buffers. They need to be in chip. Therefore,
* patch the eagleplayer to load into chip ram before loading it.

.init	pushm	d1-a6	

	* First, find it.
	lea	.path(pc),a3
	bsr	findDeliPlayer
	beq	.error 
	move.l d0,d7 	* lock

	* Get the path
	lea	-100(sp),sp
	move.l 	d7,d1
	move.l	sp,d2
	moveq	#100,d3 
	bsr	getNameFromLock
	move.l  d0,d6 

	move.l	d7,d1
	lore  Dos,UnLock

	tst.l	d6 
	beq 	.nameFromLockErr
	
	* Read it
	move.l	sp,a0
	bsr	plainLoadFile 
	lea	100(sp),sp 
	tst.l  d0 
	beq.b  .fileError 

	* Grab the 1st entry from the hunk size table and set
	* 31th bit to 0, 30th bit to 1, to indicate hunk should be loaded
	* into chip.
	move.l	d0,a1
	move.l	d0,d3
	move.l 	20(a1),d0 
	and.l	#%00111111111111111111111111111111,d0 
	or.l	#%01000000000000000000000000000000,d0 
	move.l	d0,20(a1)

	move.l	d1,d0
	lea	-100(sp),sp 
	move.l	sp,a0
	move.b	#'R',(a0)+
	move.b	#'A',(a0)+
	move.b	#'M',(a0)+
	move.b	#':',(a0)+
	lea	.path(pc),a2 
.c	move.b	(a2)+,(a0)+
	bne.b	.c
	move.l	sp,a0
	bsr	plainSaveFile 
	lea	100(sp),sp

	move.l	d3,a0 
	jsr	freemem

	tst.l	d0 
	bmi.b 	.fileError

	lea	.path(pc),a0 
	move.l	#5<<16|0,d0

	* Camouflage playertype so that the group lookup 
	* will fail and loader will look into 
	* filesystem, finding the above patched player.
	move	playertype(a5),-(sp)
	move	#-1,playertype(a5)
	bsr	deliLoadAndInit
	move	(sp)+,playertype(a5)
	tst.l	d0

.error	popm	d1-a6
	rts

.fileError 
	lea	100(sp),sp
	moveq	#-1,d0
	bra.b  .error 	

.nameFromLockErr
	lea	100(sp),sp 
	moveq	#-1,d0 
	bra.b 	.error


.id
	MOVEQ	#1,D0
	CMP.L	#$49534D21,(A4)
	BNE.b .f 
	CMP.L	#$56312E32,4(A4)
	BNE.b .f
	MOVEQ	#0,D0
.f	rts

******************************************************************************
* In Stereo 2
******************************************************************************

p_instereo2
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp 	.id(pc)
	jmp	deliAuthor(pc)
	dc 	pt_instereo2
	dc 	pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus
	dc.b	"In Stereo! 2.0 [EP]",0

.path dc.b "in stereo 2.0",0
 even

.init
	lea	.path(pc),a0 
	move.l	#2<<16|1,d0
	bra		deliLoadAndInit 

.id
 	MOVEQ	#1,D0
	CMP.L	#$49533230,(A4)
	BNE.S	.f
	CMP.L	#$44463130,4(A4)
	BNE.S	.f
	CMP.L	#$5354424C,8(A4)
	BNE.S	.f
	MOVEQ	#0,D0
.f  
	rts



******************************************************************************
* Jason Brooke
******************************************************************************

p_jasonbrooke
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_jasonbrooke
	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_poslen!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"Jason Brooke [EP]",0
	        
.path dc.b "jason brooke",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|1,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0

	MOVEQ	#-1,D0
	;LEA	lbW000166(PC),A1
	MOVE.L	A0,A2
	CMP.L	#$48E7F0F0,(A0)+
	BNE.S	.lbC00058C
	CMP.L	#$424047FA,(A0)+
	BNE.S	.lbC00058A
	CMP.L	#$FFF84A2B,(A0)
	BNE.S	.lbC00058A
	;ST	(A1)
.lbC000588	MOVEQ	#0,D0
.lbC00058A	RTS

.lbC00058C	LEA	$AC(A2),A0
	MOVEQ	#$19,D1
.lbC000592	CMP.W	#$48E7,(A0)+
	BEQ.S	.lbC00059E
	DBRA	D1,.lbC000592
	BRA.S	.lbC00058A

.lbC00059E	CMP.W	#$F8FC,(A0)
	BEQ.S	.lbC0005AA
	CMP.W	#$F8F8,(A0)
	BNE.S	.lbC00058A
.lbC0005AA	ADDQ.L	#2,A0
	CMP.L	#$8F90001,(A0)+
	BNE.S	.lbC00058A
	CMP.L	#$BFE001,(A0)+
	BNE.S	.lbC00058A
	CMP.L	#$33FC0780,(A0)+
	BNE.S	.lbC00058A
	CMP.L	#$DFF09A,(A0)+
	BNE.S	.lbC00058A
	CMP.W	#$47FA,(A0)+
	BNE.S	.lbC00058A
	MOVEQ	#1,D1
	SWAP	D1
	MOVEQ	#0,D2
	MOVE.W	(A0),D2
	SUB.L	D2,D1
	SUB.L	D1,A0
	CMP.L	A2,A0
	BNE.S	.lbC00058A
	;CLR.W	(A1)
	BRA.S	.lbC000588


******************************************************************************
* EarAche
******************************************************************************

p_earache
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_earache
	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_poslen!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"EarAche [EP]",0
	        
.path dc.b "earache",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|1,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0
	bsr.b 	.id_ 
	tst.l d0
	rts

.id_
	moveq	#-1,D0

	tst.w	(A0)
	beq.b	.CheckRout
	cmp.l	#'EASO',(A0)
	bne.b	.NoHead
	addq.l	#4,A0
	bra.b	.CheckRout
.NoHead
	cmp.w	#$6000,(A0)+
	bne.b	.Fault
	move.l	A0,A1
	move.w	(A0)+,D1
	beq.b	.Fault
	bmi.b	.Fault
	btst	#0,D1
	bne.b	.Fault
	cmp.w	#$6000,(A0)+
	bne.b	.Fault
	move.w	(A0)+,D2
	beq.b	.Fault
	bmi.b	.Fault
	btst	#0,D2
	bne.b	.Fault
	add.w	D1,A1
	cmp.l	#$33FC000F,(A1)+
	bne.b	.Fault
	cmp.l	#$00DFF096,(A1)+
	bne.b	.Fault
	cmp.w	#$43FA,(A1)+
	bne.b	.Fault
	move.w	(A1),D1
	beq.b	.Fault
	bmi.b	.Fault
	btst	#0,D1
	bne.b	.Fault
	add.w	D1,A1
	move.l	A1,A0
.CheckRout
	cmp.l	#$18,(A0)		; check routine taken from EarAche editor
	bne.b	.Fault
	move.l	4(A0),D2
	sub.l	(A0),D2
	ble.b	.Fault
	and.w	#7,D2
	bne.b	.Fault
	move.l	$10(A0),D2
	sub.l	8(A0),D2
	ble.b	.Fault
	and.w	#15,D2
	bne.b	.Fault
	moveq	#0,D0
.Fault
	rts



******************************************************************************
* Kris Hatlelid
******************************************************************************

p_krishatlelid
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	.end(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_krishatlelid
	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_poslen!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"Kris Hatlelid [EP]",0
	        
.path dc.b "kris hatlelid",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|1,d0
	bra		deliLoadAndInit 

.end
	* Safety: disable audio interrupts and clear requests
	* which this replayer uses. Pending interrupts
	* may trigger after code is in wrong state or deallocated.
	move.l  #$07800780,$dff09a
	bra	deliEnd

.id
	move.l	a4,a0
	CMP.L	#$3F3,(A0)+
	BNE.S	.lbC000506
	TST.L	(A0)+
	BNE.S	.lbC000506
	CMP.L	#3,(A0)+
	BNE.S	.lbC000506
	TST.L	(A0)+
	BNE.S	.lbC000506
	CMP.L	#2,(A0)+
	BNE.S	.lbC000506
	MOVE.L	(A0)+,D1
	BCLR	#$1E,D1
	CMP.B	#$40,(A0)
	BNE.S	.lbC000506
	ADDQ.L	#4,A0
	CMP.L	#1,(A0)+
	BNE.S	.lbC000506
	CMP.L	#$3E9,(A0)+
	BNE.S	.lbC000506
	CMP.L	(A0)+,D1
	BNE.S	.lbC000506
	CMP.L	#$60000016,(A0)+
	BNE.S	.lbC00050A
	CMP.L	#$ABCD,(A0)+
	BNE.S	.lbC000506
	CMP.L	#$B07C0000,$10(A0)
	BNE.S	.lbC00050E
	BRA.S	.lbC000524

.lbC000506	MOVEQ	#-1,D0
	RTS

.lbC00050A	LEA	-$14(A0),A0
.lbC00050E	CMP.L	#$41F90000,$10(A0)
	BNE.S	.lbC000506
	CMP.L	#$4E75,$14(A0)
	BNE.S	.lbC000506
.lbC000524	MOVEQ	#0,D0
	RTS



******************************************************************************
* Richard Joseph
******************************************************************************

p_richardjoseph2
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_richardjoseph2
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_poslen!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"Richard Joseph [EP]",0
	
	        
.path dc.b "richard joseph",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|2,d0
	bra		deliLoadAndInit 

.id
	MOVE.L	a4,A0
	CMP.L	#$3F3,(A0)
	BNE.S	.lbC00043E
	TST.B	$14(A0)
	BEQ.S	.lbC00043E
	LEA	$20(A0),A0
	CMP.L	#$70FF4E75,(A0)+
	BNE.S	.lbC00043E
	CMP.L	#$522E4A4F,(A0)+
	BNE.S	.lbC00043E
	CMP.L	#$53455048,(A0)+
	BNE.S	.lbC00043E
	TST.L	(A0)+
	BEQ.S	.lbC00043E
	TST.L	(A0)+
	BEQ.S	.lbC00043E
	TST.L	(A0)+
	BEQ.S	.lbC00043E
	TST.L	(A0)
	BEQ.S	.lbC00043E
	MOVEQ	#0,D0
	RTS

.lbC00043E	MOVEQ	#-1,D0
	RTS



******************************************************************************
* Hippel 7ch
******************************************************************************

p_hippel7
	jmp	.init(pc)
	jmp	deliPlay(pc)
	jmp	deliInterrupt(pc) ; handle position and vol updates
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	p_NOP
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp id_hippel7(pc)
	jmp	deliAuthor(pc)
	dc  pt_hippel7
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_poslen
	dc.b	"Jochen Hippel 7v [EP]",0
		        
.path dc.b "jochen hippel 7v",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|4,d0
	bra		deliLoadAndInit 

id_hippel7
	bsr.b	.id
	bne.b	.not
	* This is identified as TFMX song data which goes into
	* public mem, fix it.
	bsr	moveModuleToChipMem
	moveq	#0,d0
.not
	rts
.id
	move.l	a4,a0
	moveq	#-1,D0

	cmp.w	#$6000,(A0)
	bne.b	.Song
	addq.l	#2,A0
	move.w	(A0),D1
	beq.b	.Fault
	bmi.b	.Fault
	btst	#0,D1
	bne.b	.Fault
	lea	(A0,D1.W),A0
	moveq	#10,D1
.Find_1
	cmp.l	#$308141FA,(A0)
	beq.b	.OK_1
	addq.l	#2,A0
	dbf	D1,.Find_1
	rts
.OK_1
	addq.l	#4,A0
	move.w	(A0),D1
	beq.b	.Fault
	bmi.b	.Fault
	btst	#0,D1
	bne.b	.Fault
	lea	(A0,D1.W),A0
.Song
	cmp.l	#'TFMX',(A0)+
	bne.b	.Fault
	tst.b	(A0)
	bne.b	.Fault
	moveq	#2,D1
	add.w	(A0)+,D1
	add.w	(A0)+,D1
	lsl.l	#6,D1
	moveq	#1,D2
	add.w	(A0)+,D2
	moveq	#1,D3
	add.w	(A0)+,D3
	mulu.w	#28,D3
	mulu.w	(A0)+,D2
	add.l	D2,D1
	add.l	D3,D1
	addq.l	#2,A0
	moveq	#1,D2
	add.w	(A0)+,D2
	lsl.l	#3,D2
	add.l	D2,D1
	moveq	#32,D2
	add.l	D2,D1
	add.l	D1,A0
	tst.l	(A0)+
	bne.b	.Fault
	move.w	(A0),D2
	beq.b	.Fault
	add.l	D2,D2
	cmp.l	26(A0),D2
	bne.b	.Fault
	moveq	#0,D0
.Fault
	tst.l	d0
	rts

******************************************************************************
* AProSys
******************************************************************************

p_aprosys
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_aprosys
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"AProSys [EP]",0
		        
.path dc.b "aprosys",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|1,d0
	bra		deliLoadAndInit 

.id
	CMP.L	#$41445256,(A4)
	BNE.S	.f
	CMP.L	#$5041434B,4(A4)
	BNE.S	.f
	MOVEQ	#0,D0
	rts
.f	
	MOVEQ	#-1,D0
	RTS



******************************************************************************
* Jochen Hippel ST (also Jochen Hippel COSO ST)
******************************************************************************

p_hippelst
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_hippelst
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_poslen!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"Jochen Hippel ST [EP]",0	        
.path dc.b "jochen hippel st",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|4,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0
	move.l	d7,d0

        ;move.l  dtg_ChkData(A5),A0
        ;move.l  dtg_ChkSize(A5),D0
        move.l  A0,A4
        bsr.b   .Check
        cmp.w   #2,D0
        bne.b   .Fault
        moveq   #0,D1
        cmp.l   #'LSMP',$1C(A0)
        bne.b   .OneFile
        moveq   #1,D1
.OneFile
        ;lea     TwoFiles(PC),A1
        ;move.l  D1,(A1)+
        ;sub.l   A4,A0
        ;move.l  A0,(A1)
        moveq   #0,D0
        bra.b   .Found

.Fault   moveq   #-1,D0
.Found   rts

.Check
.lbC0001C0	MOVEA.L	A0,A1
	MOVEQ	#$7F,D1
	BRA.S	.lbC0001DA

.lbC0001C6	CMPI.W	#$41FA,(A1)+
	BNE.S	.lbC0001F2
	MOVE.W	(A1),D2
	BMI.S	.lbC0001F2
	BTST	#0,D2
	BNE.S	.lbC0001F2
	LEA	0(A1,D2.W),A0
.lbC0001DA	CMPI.L	#'MMME',(A0)
	BEQ.S	.lbC0001FC
	CMPI.L	#'TFMX',(A0)
	BEQ.S	.lbC000204
	CMPI.L	#'COSO',(A0)
	BEQ.S	.lbC000262
.lbC0001F2	SUBQ.L	#2,D0
	DBMI	D1,.lbC0001C6
.lbC0001F8	MOVEQ	#0,D0
	RTS

.lbC0001FC
;	MOVEQ	#1,D0
;	RTS

.lbC000200	MOVEQ	#2,D0
	RTS

.lbC000204	CMPI.W	#$200,4(A0)
	BGE.S	.lbC0001F8

	tst.w	16(A0)				; FX Check
	beq.b	.lbC0001F8

	BSR.S	.lbC000216
	CMP.L	D6,D7
	BLT.S	.lbC000230
	MOVEQ	#1+1,D0
	RTS

.lbC000216	MOVE.W	4(A0),D0
	LEA	$20(A0),A1
	MOVEQ	#0,D6
	MOVEQ	#0,D7
.lbC000222	BSR.B	.lbC0002B6
	LEA	$40(A1),A1
	DBRA	D0,.lbC000222
	RTS

.lbC000230
;	MOVEQ	#2,D0
;	ADD.W	4(A0),D0
;	ADD.W	6(A0),D0
;	MULU.W	#$40,D0
;	LEA	$20(A0,D0.W),A1
;	MOVE.W	8(A0),D0
;	MOVE.W	12(A0),D1
;	ADDQ.W	#1,D0
;	MULU.W	D0,D1
;	ADDA.L	D1,A1
;	MOVE.B	3(A1),D1
;	CMP.B	#$FF,D1
;	BNE.S	lbC00025E
	MOVEQ	#5,D0
	RTS

;lbC00025E	MOVEQ	#3,D0
;	RTS

.lbC000262
	tst.w	48(A0)				; FX Check
	beq.b	.lbC0001F8
	tst.l	24(A0)
	beq.b	.lbC0001F8

	CMPI.L	#'TFMX',$20(A0)
	BEQ.S	.lbC00027A
	CMPI.L	#'MMME',$20(A0)
	BEQ.b	.lbC000200
	MOVEQ	#0,D0
	RTS

.lbC00027A	BSR.S	.lbC000284
	CMP.L	D6,D7
	BLT.S	.lbC00029E
	MOVEQ	#2,D0
	RTS

.lbC000284	MOVEA.L	A0,A2
	ADDA.L	4(A0),A2
	MOVEQ	#0,D6
	MOVEQ	#0,D7
	MOVE.W	$24(A0),D0
.lbC000292
	tst.w	64(A0)
	beq.b	.Longer

	MOVEA.W	(A2)+,A1

	bra.b .SkipLon
.Longer
	move.l	(A2)+,A1
.SkipLon
	ADDA.L	A0,A1
	BSR.S	.lbC0002B6
	DBRA	D0,.lbC000292
	RTS

.lbC00029E
;	MOVE.L	$10(A0),D0
;	LEA	0(A0,D0.W),A1
;	CMPI.B	#$FF,3(A1)
;	BEQ.S	lbC0002B2
	MOVEQ	#4,D0
	RTS


.lbC0002B6	MOVEA.L	A1,A3
	MOVEQ	#0,D1
	MOVE.B	(A3)+,D1
	CMP.B	#$E2,D1
	BNE.S	.lbC0002CC
	TST.B	(A3)
	BMI.S	.lbC0002CA
	ADDQ.W	#1,D6
	BRA.S	.lbC0002CC

.lbC0002CA	ADDQ.W	#1,D7
.lbC0002CC	RTS



******************************************************************************
* TCBTracker
******************************************************************************

p_tcbtracker
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_tcbtracker
.flags	dc pf_scope!pf_stop!pf_cont!pf_volume!pf_end!pf_poslen!pf_ciakelaus2!pf_kelauseteen!pf_kelaustaakse!pf_quadscopeUps
	dc.b	"TCBTracker (ST) [EP]",0	        
.path dc.b "tcb tracker",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|3,d0
	bra		deliLoadAndInit 


.id
	move.l	a4,a0 
	move.l	d7,d0
	
	lea	(a0,d0.l),a2		; pour tests ultÈrieurs
	cmpi.l	 #$132,d0
	blo.b	.ohno			; trop petit
	cmpi.l	#"AN C",(a0)
	bne.b	.ohno
	moveq	#0,d3
	move.l	#"OOL!",d1		; marque avec "!"
	move.l	4(a0),d2
	cmp.l	d1,d2
	beq.s	.hm
	moveq	#1,d3
	move.b	#".",d1			; ou marque avec "."
	cmp.l	d1,d2
	bne.s	.ohno
.hm
	move.l	8(a0),d1
	cmpi.l	#127,d1			; nb patt : pas plus de 127, quand mÍme ?
	bhi.s	.ohno
	cmpi.b	#15,12(a0)		; speed en 16-n donc <16
	bhi.s	.ohno
	tst.b	13(a0)			; ‡ priori toujours 0
	bne.s	.ohno
	tst.b	$8e(a0)			; taille seq (peut pas Ítre 0 ou >7f)
	ble.s	.ohno
	lea	$110(a0),a1		; patt
	tst.b	d3
	beq.s	.fmt1
;	tst.w	$128(a0)		; faut que ce soit 0
;	bne.s	.ohno			; or 2 too, like TCB.MDemo4 5
	lea	$132(a0),a1
.fmt1
	mulu.w	#$200,d1		; taille patt (on avait encore d1=nbr)
	add.l	d1,a1			; et adr suite
	lea	$d4(a1),a3
	cmp.l	a2,a3			; regarder qu'il ne manque pas qqch...
	bhs.s	.ohno
;	move.l	(a1),d3			; taille totale d'ici
;	add.l	d3,a1
;	cmp.l	a2,a1			; tronquÈ !
;	bhi.s	.ohno
	cmpi.l	#-1,-8(a3)		; FFFFFFFF
	bne.s	.ohno
	tst.l	-4(a3)			; 00000000 (juste avant spl)
	bne.s	.ohno
	cmpi.l	#$d4,-$90(a3)		; 1er spl toujours en +$d4
	bne.s	.ohno
; todo : vÈrifier que les effets <>0 ou <>13 ne sont pas utilisÈs
;.loop

; bon, Áa devrait suffire...
; ok
	moveq	#0,d0
	rts
.ohno
	moveq	#-1,d0
	rts
;forswap				; pour calculer chklen




******************************************************************************
* Mark Cooksey
******************************************************************************

p_markcooksey
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp 	.id(pc)
	jmp	deliAuthor(pc)
	dc  	pt_markcooksey
.flags	dc 	pf_stop!pf_cont!pf_volume!pf_end!pf_poslen!pf_ciakelaus!pf_song!pf_quadscopeUps!pf_scope
	dc.b	"Mark Cooksey [EP]",0	        
.path 	dc.b 	"mark cooksey",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0,d0
	bra	deliLoadAndInit

.id
	move.l	a4,a0
	moveq	#-1,D0

	;lea	Format(PC),A1
	cmp.l	#$D040D040,(A0)
	bne.b	.NextCheck
	cmp.w	#$4EFB,4(A0)
	bne.b	.fail
	move.w	#$6000,D1
	cmp.w	8(A0),D1
	bne.b	.fail
	cmp.w	12(A0),D1
	bne.b	.fail
	cmp.w	16(A0),D1
	bne.b	.fail
	cmp.w	20(A0),D1
	bne.b	.fail
	cmp.w	#$43FA,40(A0)
	beq.b	.Old
	cmp.w	24(A0),D1
	bne.b	.fail
	cmp.w	#$43FA,150(A0)
	bne.b	.fail
.Old
;	clr.b	(A1)
.Older
	moveq	#0,D0
.fail
	rts

.NextCheck
	cmp.w	#$601A,(A0)
	bne.b	.Third
	addq.l	#2,A0
	move.l	(A0)+,D1
	bmi.b	.fail
	btst	#0,D1
	bne.b	.fail
	tst.w	(A0)+
	bne.b	.fail
	moveq	#4,D2
.ZeroCheck
	tst.l	(A0)+
	bne.b	.fail
	dbf	D2,.ZeroCheck
	lea	2(A0),A2
	moveq	#3,D2
.BranchCheck
	cmp.w	#$6000,(A0)+
	bne.b	.fail
	move.w	(A0)+,D1
	bmi.b	.fail
	btst	#0,D1
	bne.b	.fail
	dbf	D2,.BranchCheck
	add.w	(A2),A2
	cmp.l	#$48E780F0,(A2)
	bne.b	.fail

	;st	(A1)
	bra.b	.Older

.Third
	moveq	#1,D2
.BranchCheck2
	cmp.w	#$6000,(A0)+
	bne.b	.fail2
	move.w	(A0)+,D1
	bmi.b	.fail2
	btst	#0,D1
	bne.b	.fail2
	dbf	D2,.BranchCheck2
	cmp.w	#$4DFA,(A0)+
	bne.b	.fail2
	addq.l	#2,A0
	cmp.w	#$4A56,(A0)
	beq.b	.Later
	cmp.w	#$4A16,(A0)
	bne.b	.fail2
.Later
	addq.l	#6,A0
	cmp.w	#$41F9,(A0)+
	bne.b	.fail2
	cmp.l	#$DFF000,(A0)+
	bne.b	.fail2
	;move.b	#1,(A1)
	moveq	#0,D0
.fail2
	rts
; EREM **************************

******************************************************************************
* Activision Pro
******************************************************************************

p_activisionpro
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_activisionpro
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus
	dc.b	"Activision Pro [EP]",0
	        
.path dc.b "activision pro",0
 even

.init
	lea	.path(pc),a0 
	move.l	#1<<16|8,d0
	bra		deliLoadAndInit 

.id

	move.l	a4,a0 
	move.l	d7,d0

	* check smaller area, otherwise can be slooow
	cmp.l	#1024*4,d0
	blo.b	.ok
	move.l	#1024*4,d0
.ok

.lbC0004CA	MOVE.L	A0,A4
	MOVE.L	D0,D4
	MOVE.L	D0,D2
	MOVE.L	A0,A2
	LEA	.lbB000624(PC),A1
	MOVEq	#3,D1
	BSR	.lbC0005EE
	BNE.S	.lbC000518
	;MOVE.L	A0,lbL0000BA
	LEA	.lbB00062C(PC),A1
	MOVEq	#12,D1
	BSR	.lbC0005EE
	BNE	.lbC0005EC
	;MOVE.L	A0,lbL0000BE
	MOVEQ	#0,D1
	CMP.W	#$4E75,$28(A2)
	BNE.S	.lbC00050C
	MOVEQ	#2,D1
.lbC00050C	
	;MOVE.L	D1,lbL0000C2
	MOVEQ	#0,D0
	BRA	.lbC0005EC

.lbC000518	MOVE.L	A4,A0
	MOVE.L	D4,D2
	LEA	.lbB000646(PC),A1
	MOVEq	#9,D1
	BSR	.lbC0005EE
	BNE.S	.lbC00055A
	;MOVE.L	A0,lbL0000BA
	LEA	.lbB00065A(PC),A1
	MOVEq	#10,D1
	BSR.B	.lbC0005EE
	BNE.B	.lbC0005EC
	;MOVE.L	A0,lbL0000BE
	;MOVE.L	#2,lbL0000C2
	MOVEQ	#0,D0
	BRA.B	.lbC0005EC

.lbC00055A	MOVE.L	A4,A0
	MOVE.L	D4,D2
	CMP.W	#$6000,(A0)
	BNE.B	.lbC0005EA
	CMP.W	#$6000,4(A0)
	BNE.B	.lbC0005EA
	CMP.W	#$6000,8(A0)
	BNE.S	.lbC0005EA
	CMP.W	#$6000,12(A0)
	BNE.S	.lbC0005EA
	CMP.W	#$6000,$10(A0)
	BNE.S	.lbC0005EA
	CMP.W	#$6000,$14(A0)
	BNE.S	.lbC0005EA
	CMP.W	#$6000,$18(A0)
	BNE.B	.lbC0005EA
	CMP.W	#$6000,$1C(A0)
	BNE.B	.lbC0005EA
	CMP.W	#$6000,$20(A0)
	BNE.B	.lbC0005EA
	CMP.W	#$6000,$20(A0)
	BNE.B	.lbC0005EA
	MOVE.W	$16(A0),D0
	LEA	$16(A0,D0.W),A1
	CMP.L	#$2F0841FA,(A1)
	BNE.S	.lbC0005EA
	;MOVE.L	A1,lbL0000BA
	MOVE.W	$1A(A0),D0
	LEA	$1A(A0,D0.W),A1
	;MOVE.L	A1,lbL0000BE
	;MOVE.L	#2,lbL0000C2
	MOVEQ	#0,D0
	BRA.S	.lbC0005EC

.lbC0005EA	MOVEQ	#-1,D0
.lbC0005EC	RTS

.lbC0005EE	MOVE.L	D1,D3
	BSR.B	.lbC000604
	BEQ.S	.lbC000600
	ADDQ.L	#2,A0
	SUBQ.L	#2,D2
	BGT.S	.lbC0005EE
	MOVEQ	#-1,D0
	RTS

.lbC000600	MOVEQ	#0,D0
	RTS

.lbC000604
	MOVEM.L	D1/D3/A0/A1,-(SP)
	MOVEQ	#-1,D0
.lbC00060A	MOVE.W	(A1)+,D1
	CMP.W	#$FFFF,D1
	BEQ.S	.lbC000616
	CMP.W	(A0),D1
	BNE.S	.lbC00061E
.lbC000616	ADDQ.L	#2,A0
	DBRA	D3,.lbC00060A
	MOVEQ	#0,D0
.lbC00061E	MOVEM.L	(SP)+,D1/D3/A0/A1
	RTS

.lbB000624	dc.b	$48
	dc.b	$E7
	dc.b	$FC
	dc.b	$FE
	dc.b	$E9
	dc.b	$41
	dc.b	$70
	dc.b	0
.lbB00062C	dc.b	$48
	dc.b	$E7
	dc.b	$FC
	dc.b	$FE
	dc.b	$41
.lbB000631	dc.b	$FA
	dc.b	$FF
	dc.b	$FF
	dc.b	$43
.lbB000635	dc.b	$FA
	dc.b	$FF
	dc.b	$FF
	dc.b	$47
.lbB000639	dc.b	$FA
	dc.b	$FF
	dc.b	$FF
	dc.b	$4B
.lbB00063D	dc.b	$FA
	dc.b	$FF
	dc.b	$FF
	dc.b	$2C
	dc.b	$7C
	dc.b	0
	dc.b	$DF
	dc.b	$F0
	dc.b	$A0
.lbB000646	dc.b	$48
	dc.b	$E7
	dc.b	0
	dc.b	$C0
	dc.b	$41
.lbB00064B	dc.b	$FA
	dc.b	$FF
	dc.b	$FF
	dc.b	$43
.lbB00064F	dc.b	$FA
	dc.b	$FF
	dc.b	$FF
	dc.b	2
	dc.b	$80
	dc.b	0
	dc.b	0
	dc.b	0
	dc.b	$FF
	dc.b	$E5
	dc.b	$40
.lbB00065A
	dc.b	$48
	dc.b	$E7
	dc.b	$FC
	dc.b	$FE
	dc.b	$41

* This bit is needed to recognize "d-generation-sfx.avp":

.lbB00065F
	dc.b	$FA
	dc.b	$FF
	dc.b	$FF
	dc.b	$43
.lbB000663	dc.b	$FA
	dc.b	$FF
	dc.b	$FF
	dc.b	$4B

.lbB000667	dc.b	$FA
	dc.b	$FF
	dc.b	$FF
	dc.b	$2C
	dc.b	$7C
	dc.b	0
	dc.b	$DF
	dc.b	$F0
	dc.b	$A0
	dc.b	$48
	dc.b	$E7
	dc.b	$C0
	dc.b	4
	dc.b	$2A
	dc.b	$7A
	dc.b	$FA
	dc.b	$66
	dc.b	$70
	dc.b	1
	dc.b	$72
	dc.b	0
	dc.b	$4E
	dc.b	$AD
	dc.b	$FE
	dc.b	$EC
	dc.b	$4C
	dc.b	$DF
	dc.b	$20
	dc.b	3
	dc.b	$4E
	dc.b	$75
 even

******************************************************************************
* MaxTrax
******************************************************************************

p_maxtrax
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_maxtrax
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"MaxTrax [EP]",0
	        
.path dc.b "maxtrax",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|2,d0
	bra		deliLoadAndInit 

.id
	movea.l	a4,A0
	moveq	#-1,D0

	move.l	d7,D1
	lea	(A0,D1.L),A1
	cmp.l	#'MXTX',(A0)+
	bne.b	.Fault
	tst.w	(A0)+
	beq.b	.Fault
	bmi.b	.Fault
	tst.w	(A0)+
	bpl.b	.NoMicro				; no microtonal?
	lea	256(A0),A0
.NoMicro
	move.w	(A0)+,D1			; songs number
	beq.b	.Fault
	cmp.w	#256,D1
	bhi.b	.Fault
	subq.w	#1,D1
.SongCheck
	move.l	(A0)+,D2
	beq.b	.Fault
	bmi.b	.Fault
	mulu.w	#6,D2
	add.l	D2,A0
	cmp.l	A0,A1
	ble.b	.Fault
	dbf	D1,.SongCheck
	cmp.w	#64,(A0)
	bhi.b	.Fault
	;lea	.TwoFiles(PC),A1
	;move.w	(A0),(A1)
	moveq	#0,D0
.Fault
	rts


******************************************************************************
* Wally Beben
******************************************************************************

p_wallybeben
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_wallybeben
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"Wally Beben [EP]",0
	        
.path dc.b "wally beben",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|1,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0
	moveq	#-1,D0

	cmp.w	#$6000,(A0)+
	bne.b	.Fault
	move.w	(A0)+,D1
	beq.b	.Fault
	bmi.b	.Fault
	btst	#0,D1
	bne.b	.Fault
	lea	-2(A0,D1.W),A1
	cmp.b	#$61,(A1)+
	bne.b	.Fault
	tst.b	(A1)+
	bne.b	.Short
	addq.l	#2,A1
.Short
	cmp.w	#$4239,(A1)
	bne.b	.Fault
	addq.l	#6,A1
	cmp.w	#$4239,(A1)
	bne.b	.Fault
	addq.l	#6,A1
	cmp.w	#$4E75,(A1)
	bne.b	.Fault
	cmp.l	#$48E7FFFE,(A0)+
	bne.b	.Fault
	cmp.w	#$6100,(A0)+
	bne.b	.Fault
	add.w	(A0),A0
	cmp.l	#$4CF900FF,(A0)+
	beq.b	.Found
	cmp.w	#$1039,(A0)
	bne.b	.Fault
.Found
	moveq	#0,D0
.Fault
	rts

******************************************************************************
* Synth Pack by Karsten Obarski
******************************************************************************

p_synthpack
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_synthpack
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"Synth Pack [EP]",0
	        
.path dc.b "synth pack",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|2,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0
	MOVEQ	#-1,D0
	CMP.L	#$4F424953,(A0)+
	BNE.S	.lbC0004FC
	CMP.L	#$594E5448,(A0)+
	BNE.S	.lbC0004FC
	CMP.L	#$5041434B,(A0)+
	BNE.S	.lbC0004FC
	CMP.W	#$100,$500(A0)
	BEQ.S	.lbC0004F8
	TST.L	$500(A0)
	BNE.S	.lbC0004FC
	;BRA.S	.lbC0004FA
.lbC0004F8	
.lbC0004FA	MOVEQ	#0,D0
.lbC0004FC	RTS


******************************************************************************
* Rob Hubbard
******************************************************************************

p_robhubbard
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_robhubbard
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"Rob Hubbard [EP]",0
.path dc.b "rob hubbard",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|6,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0
	moveq	#-1,D0
	move.w	#$6000,D1
	cmp.w	(A0),D1
	bne.s	.Return
	cmp.w	4(A0),D1
	bne.s	.Return
	cmp.w	8(A0),D1
	bne.s	.Return
	cmp.w	12(A0),D1
	bne.s	.Return
	cmp.w	16(A0),D1
	bne.s	.Return
	cmp.w	#$41FA,20(A0)
	bne.s	.Return
	cmp.l	#$4E7541FA,28(A0)
	bne.s	.Return
	moveq	#0,D0
.Return
	rts			



******************************************************************************
* Jeroen Tel
******************************************************************************

p_jeroentel
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_jeroentel
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"Jeroen Tel [EP]",0
.path dc.b "jeroen tel",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|1,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0 
	moveq	#-1,D0
	cmp.l	#1700,d7
	ble.b	.Fault

	lea	40(A0),A1
.Check
	cmp.l	#$02390001,(A0)
	beq.b	.More
	addq.l	#2,A0
	cmp.l	A0,A1
	bne.b	.Check
	rts
.More
	addq.l	#8,A0
	cmp.b	#$66,(A0)+
	bne.b	.Fault
	move.b	(A0)+,D1
	bmi.b	.Fault
	beq.b	.Fault
	cmp.w	#$4E75,(A0)
	bne.b	.Fault
	ext.w	D1
	add.w	D1,A0
	cmp.w	#$4A39,(A0)
	bne.b	.NoOne
	moveq	#3,D1
.NextOne
	cmp.w	#$4A39,(A0)
	bne.b	.Fault
	lea	18(A0),A0
	dbf	D1,.NextOne
.NoOne
	cmp.l	#$78001839,(A0)
	bne.b	.Fault
	moveq	#0,D0
.Fault
	rts



******************************************************************************
* Sonix Music Driver
* Prefixes: SMUS, TINY, SNX
******************************************************************************

p_sonix
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_sonix
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"Sonix Music Driver [EP]",0
.path dc.b "sonix music driver",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|1,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0
	moveq	#-1,D0

	move.l	d7,d4
	move.l	A0,A1
	cmp.l	#'FORM',(A0)
	beq	.SmusCheck
	move.w	(A0),D1
	and.w	#$00F0,D1
	bne.b	.TinyCheck
	moveq	#20,D3
	moveq	#3,D1
.NextPos
	move.l	(A0)+,D2
	beq.b	.fault
	bmi.b	.fault
	btst	#0,D2
	bne.b	.fault
	add.l	D2,D3
	dbf	D1,.NextPos
	cmp.l	D4,D3
	bge.b	.fault
	addq.l	#4,A0
	moveq	#3,D1
.SecPass
	tst.b	(A0)
	bpl.b	.fault
	cmp.w	#-1,(A0)
	beq.b	.OK1
	cmp.b	#$84,(A0)
	bhi.b	.fault
.OK1
	add.l	(A1)+,A0
	dbf	D1,.SecPass
	tst.b	(A0)
	beq.b	.fault
.found
	moveq	#0,D0
.fault
	rts


.TinyCheck
	cmp.l	#332,D4
	ble.b	.fault
	lea	48(A0),A1
	cmp.l	#$140,(A1)+
	bne.b	.fault
	moveq	#2,D1
.NextPos2
	move.l	(A1)+,D2
	beq.b	.fault
	bmi.b	.fault
	btst	#0,D2
	bne.b	.fault
	cmp.l	D2,D4
	ble.b	.fault
	lea	(A0,D2.L),A2
	cmp.w	#-1,(A2)
	beq.b	.OK2
	tst.l	(A2)+
	bne.b	.fault
	tst.w	(A2)+
	bne.b	.fault
	tst.b	(A2)
	bpl.b	.fault
	cmp.b	#$82,(A2)
	bhi.b	.fault
.OK2
	dbf	D1,.NextPos2
	bra.b	.found

.SmusCheck
	cmp.l	#'SMUS',8(A0)
	bne.b	.fault
	cmp.l	#'SHDR',12(A0)
	tst.b	23(A0)
	beq.b	.fault
	lea	24(A0),A1
	cmp.l	#'NAME',(A1)+
	bne.b	.fault
	move.l	(A1)+,D1
	bmi.b	.fault
	addq.l	#1,D1
	bclr	#0,D1
	add.l	D1,A1
	cmp.l	#'SNX1',(A1)+
	bne	.fault
	move.l	(A1)+,D1
	bmi	.fault
	addq.l	#1,D1
	bclr	#0,D1
	add.l	D1,A1
.MoreIns
	cmp.l	#'INS1',(A1)+
	bne	.fault
	move.l	(A1)+,D1
	bmi	.fault
	addq.l	#1,D1
	bclr	#0,D1
	cmp.b	#63,(A1)			; real sample number
	bhi	.fault
	tst.b	1(A1)				; MIDI check
	bne	.fault
	add.l	D1,A1
	cmp.l	#'TRAK',(A1)
	bne.b	.MoreIns
	bra	.found



******************************************************************************
* Quartet ST
******************************************************************************

p_quartetst
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id_quartet_st(pc)
	jmp	deliAuthor(pc)
	dc  pt_quartetst
.flags	dc pf_stop!pf_cont!pf_volume!pf_ciakelaus!pf_scope!pf_quadscopeUps
	dc.b	"Quartet ST [EP]",0
.path dc.b "quartet st",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|3,d0
	bra		deliLoadAndInit 

* Quartet ST
.id_quartet_st
	move.l	a4,a0
	move.w	(A0),D1
	beq.b	.Fault
	cmp.w	#$10,D1
	bhi.b	.Fault
	cmp.b	#4,7(A0)
	bne.b	.Fault
	cmp.b	#4,6(A0)
	bhi.b	.Fault
	tst.l	8(A0)
	bne.b	.Fault
	cmp.w	#'WT',12(A0)
	beq.b	.Skippy
.NoSpec
	tst.l	12(A0)
	bne.b	.Fault
.Skippy
	cmp.l	#$4C,24(A0)
	bhi.b	.Fault
	move.l	24(A0),D1
	and.w	#3,D1
	bne.b	.Fault
	cmp.w	#$0056,16(A0)
	beq.b	.Oki
.Fault
	moveq	#-1,D0
	rts
.Oki
	moveq	#0,D0
	rts




******************************************************************************
* Core Design
* NOT USED
******************************************************************************
 
 REM **********************************

p_coredesign
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id_core_design(pc)
	jmp	deliAuthor(pc)
	dc  pt_coredesign
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_ciakelaus
	dc.b	"Core Design [EP]",0
.path dc.b "core design",0
 even

.init
	lea	.path(pc),a0 
	move.l	#10<<16|10,d0
	bra		deliLoadAndInit 

* Core Design
.id_core_design
	move.l a4,a0
	cmp.l	#$000003F3,(A0)
	bne.b	.fail
	tst.b	20(A0)				; loading into chip check
	beq.b	.fail
	lea	32(A0),A0
	cmp.l	#$70FF4E75,(A0)+
	bne.b	.fail
	cmp.l	#'S.PH',(A0)+
	bne.b	.fail
	cmp.l	#'IPPS',(A0)+
	bne.b	.fail
	tst.l	(A0)+				; Interrupt pointer check
	beq.b	.fail
	tst.l	(A0)+				; Audio Interrupt pointer check
	beq.b	.fail
	tst.l	(A0)+				; InitSong pointer check
	beq.b	.fail
	tst.l	(A0)+				; EndSong pointer check
	beq.b	.fail
	tst.l	(A0)				; Subsongs check
	beq.b	.fail

	moveq	#0,D0
	rts
.fail
	moveq	#-1,D0
	rts

* Sierra AGI
* DTP_UserConfig

;Check2
;	movea.l	dtg_ChkData(A5),A0
;	moveq	#-1,D0
;
;	cmp.w	#$800,(A0)
;	bne.b	Fault
;	move.l	dtg_ChkSize(A5),D2
;	move.l	A0,A1
;	moveq	#0,D1
;	moveq	#2,D3
;NextInfo
;	addq.l	#2,A1
;	move.b	1(A1),D1
;	lsl.w	#8,D1
;	move.b	(A1),D1
;	cmp.l	D1,D2
;	ble.b	Fault
;	tst.w	D1
;	beq.b	Fault
;	lea	(A0,D1.L),A2
;	cmp.b	#-1,-1(A2)
;	bne.b	Fault
;	cmp.b	#-1,-2(A2)
;	bne.b	Fault
;	dbf	D3,NextInfo
;
;	moveq	#0,D0
;Fault
;	rts

 EREM **********************************


******************************************************************************
* Music Maker V8
******************************************************************************

p_musicmaker8
	jmp	.init(pc)
	jmp	deliPlay(pc)
	jmp	deliInterrupt(pc) ; Vol + voices
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp	.id_musicmaker8(pc)
	jmp	deliAuthor(pc)
	dc 	 pt_musicmaker8
.flags	dc 	pf_stop!pf_cont!pf_volume!pf_end
	dc.b	"MusicMaker V8 8ch [EP]",0
.path 	dc.b "musicmaker8",0
 even

.init
	lea	.path(pc),a0 
	move.l	#8<<16|5,d0
	bra		deliLoadAndInit 


.id_musicmaker8
	bsr.b	id_musicmaker8_
	bne.b	.no
	jsr	moveModuleToPublicMem
	moveq	#0,d0
.no
	rts
	
* Check
id_musicmaker8_
.lbC00046E	MOVEm.L	d6/D7,-(SP)
	;MOVE.L	$24(A5),A0		* dtg_ChkData
	move.l	a4,a0
	move.l	a4,d6			* end bound
	add.l	d7,d6
	MOVEQ	#0,D7
	CMP.L	#$464F524D,(A0)		; FORM
	BNE.S	.lbC00049C
	CMP.L	#$4D4D5638,8(A0)	; MMV8
	BNE.S	.lbC00049C
	MOVE.L	#$53444154,D0		; SDAT
	BSR.b	MM_SearchLongWord
	TST.L	D0
	BMI.b	.NotRecognized
	ADDQ.L	#4,A0
	MOVEQ	#-1,D7
.lbC00049C	CMP.W	#$5345,(A0)	; SE
	BNE.b	.NotRecognized
	bsr.b	MM4_8_ExtraCheck
	BNE.b	.NotRecognized
	TST.L	D7
	;BEQ.S	OldFormatCheck
	beq.b	.NotRecognized
	;MOVE.L	$24(A5),A0			* dtg_ChkData
	move.l	a4,a0
	MOVE.L	#$494E5354,D0		; INST
	BSR.b	MM_SearchLongWord
	TST.L	D0
	BPL.b	.CheckEnd
	;MOVE.L	$24(A5),A0
	move.l	a4,a0
	MOVE.L	#$50494E53,D0		; PINS
	BSR.b	MM_SearchLongWord
	TST.L	D0
	BPL.b	.CheckEnd
	BRA.b	.NotRecognized

.CheckEnd	MOVEm.L	(SP)+,d6/D7
	MOVEQ	#0,D0
	RTS

.NotRecognized	MOVEm.L	(SP)+,d6/D7
	MOVEQ	#-1,D0
	RTS

MM_SearchLongWord	MOVEM.L	D1/A2,-(SP)
	ADDQ.L	#4,A0
	MOVE.L	(A0)+,A2
	ADD.L	A0,A2
	ADDQ.L	#4,A0
.lbC000308	
	cmp.l	d6,a0
	bhs.b	.nope
	CMP.L	(A0)+,D0
	BEQ.S	.lbC000318
	MOVE.L	(A0)+,D1
	ADD.L	D1,A0
	CMP.L	A2,A0
	BLO.S	.lbC000308
.nope
	MOVEQ	#-1,D0
	BRA.S	.lbC00031A

.lbC000318	MOVE.L	(A0)+,D0
.lbC00031A	MOVEM.L	(SP)+,D1/A2
	RTS

MM4_8_ExtraCheck
.lbC000CB4	CMP.W	#$5345,(A0)	; ST
	BEQ.S	.lbC000CC0
	CMP.B	#$FF,(A0)
	BRA.S	.lbC000CC6

.lbC000CC0	CMP.B	#$FF,$16(A0)
.lbC000CC6	SNE	D0
	EXT.W	D0
	EXT.L	D0
	RTS
	

******************************************************************************
* Music Maker V4
******************************************************************************

p_musicmaker4
	jmp	.init(pc)
	jmp	deliPlay(pc)
	jmp	deliInterrupt(pc) ; Vol + voices
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp	 id_musicmaker4(pc)
	jmp	deliAuthor(pc)
	dc  pt_musicmaker4
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_ciakelaus
	dc.b	"MusicMaker V8 4ch [EP]",0
.path dc.b "musicmaker4",0
 even

.init
	lea	.path(pc),a0 
	move.l	#8<<16|5,d0
	bra		deliLoadAndInit 

;EP_Check5 (FPTR) - same as DTP_Check2 but module is loaded into public

id_musicmaker4
	bsr.b	.Check2
	beq.b	.ok
	bsr.b	.Check5
.ok	tst.l	d0
	rts

.Check2	MOVEQ	#1,D0
	BRA.S	.lbC000466

.Check5	MOVEQ	#0,D0
.lbC000466	MOVEM.L	d5/D6/D7,-(SP)
	MOVE.L	D0,D5
	;MOVE.L	$24(A5),A0		* dtg_ChkData
	move.l	a4,a0
	move.l	a4,d6			* end bound
	add.l	d7,d6
	MOVEQ	#0,D7
	CMP.L	#$464F524D,(A0)		; FORM
	BNE.S	.lbC000498
	CMP.L	#$4D4D5638,8(A0)	; MMV8
	BNE.S	.lbC000498
	MOVE.L	#$53444154,D0
	BSR	MM_SearchLongWord
	TST.L	D0
	BMI.b	.lbC0005BA
	ADDQ.L	#4,A0
	MOVEQ	#-1,D7
.lbC000498	CMP.W	#$5345,(A0)	; SE
	BNE.B	.lbC0005BA
	bSR	MM4_8_ExtraCheck
	BEQ.B	.lbC0005BA
	MOVE.B	$17(A0),D0
	CMP.B	#$10,D0
	BLO.b	.lbC0005BA
	CMP.B	#$40,D0
	BHI.b .lbC0005BA
	TST.L	D7
	;BEQ.S	lbC0004FC
	beq.b	.NotRecognized
;	MOVE.L	$24(A5),A0
	move.l	a4,a0
	MOVE.L	#$494E5354,D0		; INST
	BSR MM_SearchLongWord
	TST.L	D0
	BMI.S	.lbC0004DE
	TST.L	D5
	BNE.b	.lbC0005B2
	BRA.b	.lbC0005BA

.lbC0004DE	
;	MOVE.L	$24(A5),A0
	move.l	a4,a0
	MOVE.L	#$50494E53,D0		; PINS
	BSR	MM_SearchLongWord
	TST.L	D0
	BMI.b	.lbC0005BA
	TST.L	D5
	BNE.b	.lbC0005BA
	BRA	.lbC0005B2

.Ok
.lbC0005B2	MOVEM.L	(SP)+,d5/D6/D7
	MOVEQ	#0,D0
	RTS

.NotRecognized
.lbC0005BA	MOVEM.L	(SP)+,d5/D6/D7
	MOVEQ	#-1,D0
	RTS

******************************************************************************
* Digital Mugician 2
******************************************************************************

p_digitalmugician2
	jmp	.init(pc)
	jmp	deliPlay(pc)
	jmp	deliInterrupt(pc) ; for position updates
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp id_digitalmugician2(pc)
	jmp	deliAuthor(pc)
	dc  pt_digitalmugician2
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_kelauseteen!pf_kelaustaakse!pf_scope
	dc.b	"Digital Mugician II [EP]",0
.path dc.b "mugician ii",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|8,d0
	bra		deliLoadAndInit 

* digital mugician ii ("mugician ii")
* DTP_UserConfig
id_digitalmugician2
;	bsr.b 	.do
;	tst.l	d0
;	bne.b	.no
;	bsr	moveModuleToPublicMem
;	moveq	#0,d0
;.no 
;	rts
;.do	
	move.l	a4,a0
	moveq	#-1,D0
	lea	.text(PC),A1
	moveq	#$19,D6
.test	cmpm.b	(A0)+,(A1)+
	bne.b	.Fault
	dbra	D6,.test	
	moveq	#0,D0
.Fault
	rts
.text
	dc.b	' MUGICIAN2/SOFTEYES 1990'
	dc.w	1
 even  

******************************************************************************
* StoneTracker
******************************************************************************

p_stonetracker
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP ;jmp	deliInterrupt(pc) ; for position updates
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp id_stonetracker(pc)
	jmp	deliAuthor(pc)
	dc  pt_stonetracker
.flags	dc pf_stop!pf_cont!pf_volume!pf_song!pf_kelaus!pf_end
	dc.b	"StoneTracker [EP]",0
.path dc.b "eaglestone",0
 even
 
.init
	lea	.path(pc),a0 
	moveq	#0<<16|1,d0
	bsr	deliLoadAndInit
	bmi.b	.not
.MHD_Name = 4
	move.l	moduleaddress(a5),a0
	lea	.MHD_Name(a0),a0
 	lea	modulename(a5),a1
 	moveq	#31-1,d0
.name	move.b	(a0)+,(a1)+
 	dbeq	d0,.name

	moveq	#0,d0
.not
	rts 


id_stonetracker
	push	a4
	bsr.b	.id_stonetracker_
	pop	a4
	tst.l 	d0 
	bne.b .not 
	jsr	moveModuleToPublicMem
	moveq	#0,d0
.not
	rts
	
.id_stonetracker_
	move.l	a4,a0
	MOVEQ	#-1,D0
	;MOVE.L	$24(A5),A0
	;MOVE.L	$28(A5),D7
	MOVE.L	(A0)+,D1
	MOVE.W	D1,D2
	CMP.L	#$53504D02,D1
	BNE.b	.lbC00327A
	LEA	(A0),A3
	MOVEQ	#$1F,D6
	BSR.b	.lbC00327E
	BNE.b	.lbC00327A
	LEA	$20(A0),A0
	MOVEM.W	(A0)+,D3-D6
	LEA	(A0),A1
	MOVEM.L	D3/D4,-(SP)
	ADD.L	D3,D3
	ADD.L	D3,D3
	ADD.L	D4,D4
	ADD.L	D4,D4
	LEA	0(A1,D3.L),A2
	LEA	0(A2,D4.L),A3
	MOVEM.L	(SP)+,D3/D4
	MOVE.W	D3,D2
	SUBQ.W	#1,D2
	BMI.b	.lbC00327A
	LEA	(A1),A4
.lbC003250	CMP.L	(A4)+,D7
	BLS.S	.lbC00327A
	DBRA	D2,.lbC003250
	MOVE.W	D4,D2
	SUBQ.W	#1,D2
	BMI.S	.lbC00327A
	LEA	(A2),A4
.lbC003260	CMP.L	(A4)+,D7
	BLS.S	.lbC00327A
	DBRA	D2,.lbC003260
	MOVE.W	D5,D2
	SUBQ.W	#1,D2
	BMI.S	.lbC003278
	LEA	(A3),A4
.lbC003270	CMP.L	(A4)+,D7
	BLS.S	.lbC00327A
	DBRA	D2,.lbC003270
.lbC003278	MOVEQ	#0,D0
.lbC00327A	TST.L	D0
	RTS

.lbC00327E	MOVE.B	(A3)+,D0
	BEQ.S	.lbC003290
	AND.B	#$7F,D0
	CMP.B	#$20,D0
	BLT.S	.lbC003294
	SUBQ.L	#1,D6
	BGT.S	.lbC00327E
.lbC003290	MOVEQ	#0,D0
	BRA.S	.lbC003296

.lbC003294	MOVEQ	#-1,D0
.lbC003296	RTS

******************************************************************************
* Soundcontrol
******************************************************************************

p_soundcontrol
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_soundcontrol
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus2!pf_kelaustaakse!pf_scope!pf_quadscopeUps
	dc.b	"SoundControl [EP]",0
	        
.path dc.b "soundcontrol",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|3,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0
	MOVEQ	#-1,D0
	CMP.W	#3,$20(A0)
	BEQ.S	.lbC000466
	CMP.W	#2,$20(A0)
	BNE.S	.lbC00048E
	TST.L	$1C(A0)
	BNE.S	.lbC00048E
.lbC000466	TST.W	$10(A0)
	BNE.S	.lbC00048E
	MOVE.W	$12(A0),D1
	BMI.S	.lbC00048E
	BTST	#0,D1
	BNE.S	.lbC00048E
	ADD.W	D1,A0
	CMP.W	#$FFFF,$3E(A0)
	BNE.S	.lbC00048E
	CMP.L	#$400,$40(A0)
	BNE.S	.lbC00048E
	MOVEQ	#0,D0
.lbC00048E
	rts

******************************************************************************
* Sound Master
******************************************************************************

p_soundmaster
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_soundmaster
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus2!pf_kelaustaakse!pf_scope!pf_quadscopeUps
	dc.b	"Sound Master [EP]",0
	        
.path dc.b "sound master",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0

.lbC0002CC
        MOVEQ   #-1,D0
        MOVE.W  #$6000,D1
        CMP.W   (A0)+,D1
        BNE.S   .lbC000338
        MOVE.L  A0,A1
        MOVE.W  (A0)+,D2
        BMI.S   .lbC000338
        BEQ.S   .lbC000338
        BTST    #0,D2
        BNE.S   .lbC000338
        CMP.W   (A0)+,D1
        BNE.S   .lbC000338
        MOVE.W  (A0)+,D3
        BMI.S   .lbC000338
        BEQ.S   .lbC000338
        BTST    #0,D3
        BNE.S   .lbC000338
        CMP.W   (A0),D1
        BNE.S   .lbC000338
        ADD.W   D2,A1
        LEA     $1E(A1),A0
.lbC000302       CMP.W   #$47FA,(A1)
        BEQ.S   .lbC000310
        ADDQ.L  #2,A1
        CMP.L   A0,A1
        BNE.S   .lbC000302
        RTS

.lbC000310       CMP.W   #$4E75,(A1)+
        BNE.S   .lbC000310
        MOVEQ   #0,D1
        CMP.L   #$177C0000,-8(A1)
        BNE.S   .lbC000326
        MOVEQ   #-1,D1
        SUBQ.L  #6,A1
.lbC000326       CMP.L   #$BFE001,-6(A1)
        BNE.S   .lbC000338
        MOVEQ   #0,D0
.lbC000338       RTS

******************************************************************************
* Sound Programming Language
******************************************************************************

p_soundprogramminglanguage
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_soundprogramminglanguage
.flags	dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus2!pf_kelaustaakse!pf_scope!pf_quadscopeUps
	dc.b	"Sound Prg. Language [EP]",0
	        
.path dc.b "soprol",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0
.lbC00040C
        CMP.L   #$3F3,(A0)
        BNE.S   .lbC00044A
        TST.B   $14(A0)
        BEQ.S   .lbC00044A
        LEA     $20(A0),A0
        CMP.L   #$70FF4E75,(A0)+
        BNE.S   .lbC00044A
        CMP.L   #$21534F50,(A0)+
        BNE.S   .lbC00044A
        CMP.L   #$524F4C21,(A0)+
        BNE.S   .lbC00044A
        TST.L   (A0)+
        BEQ.S   .lbC00044A
        TST.L   (A0)+
        BEQ.S   .lbC00044A
        TST.L   (A0)
        BEQ.S   .lbC00044A
        MOVEQ   #0,D0
        RTS
.lbC00044A       MOVEQ   #-1,D0
        RTS


******************************************************************************
* The Musical Enlightenment
******************************************************************************

p_themusicalenlightenment
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp .id(pc)
	jmp	deliAuthor(pc)
	dc  pt_themusicalenlightenment
.flags	dc pf_scope!pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus2!pf_kelaustaakse!pf_quadscopeUps
	dc.b	"The Musical Enlighte[EP]",0
	        
.path dc.b "tme",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|3,d0
	bra		deliLoadAndInit 

.id
	movea.l	a4,A0
	lea	(a4,d7.l),a3	* upper bound

	moveq	#-1,D0

	tst.b	(A0)
	bne.b	.Fault
	move.l	d7,D1
	cmp.l	#7000,D1
	blt.b	.Fault
	move.l	(A0),D2
	beq.b	.Fault

	cmp.l	#$0000050F,$3C(A0)
	bne.s	.CheckAnother
	cmp.l	#$0000050F,$40(A0)
	bne.s	.CheckAnother
	bra.b	.TME_OK

.CheckAnother
	* Range check

	pea	$1284(a0)
	cmp.l	(sp)+,a3
	bhs.b	.Fault

	cmp.l	#$00040B11,$1284(A0)
	bne.s	.CheckSize

	pea	$1188(a0)
	cmp.l	(sp)+,a3
	bhs.b	.Fault

	cmp.l	#$181E2329,$1188(A0)
	bne.s	.CheckSize

	pea	$128c(a0)
	cmp.l	(sp)+,a3
	bhs.b	.Fault

	cmp.l	#$2F363C41,$128C(A0)
	bne.s	.CheckSize
.TME_OK
	moveq	#0,D0
.Fault
	rts

.CheckSize
	bsr.b	.GetSize
	cmp.l	D2,A2
	beq.b	.TME_OK
	bra.b	.Fault
.GetSize
	move.l	A0,A1
	move.l	A0,A2

	pea	$1aaa(a2)
	cmp.l	(sp)+,a3
	bhs.b	.X
	
	pea	$1a84(a1)
	cmp.l	(sp)+,a3
	bhs.b	.X

	lea	$1AAA(A2),A2
	move.w	$1A84(A1),D3
	mulu.w	#12,D3
	add.l	D3,A2

	pea	$1a86(a1)
	cmp.l	(sp)+,a3
	bhs.b	.X	

	move.w	$1A86(A1),D3
	mulu.w	#6,D3
	add.l	D3,A2
	moveq	#0,D1
.NextInuc
	addq.l	#4,A2
	tst.b	-4(A2)
	bne.b	.NextInuc
	addq.l	#4,D1
	cmp.l	#$400,D1
	blt.b	.NextInuc
	moveq	#0,D1

	lea	$44(A1),A1
.NextSamp
	pea	$18(A1,D1.L)
	cmp.l	(sp)+,a3
	bhs.b	.X

	tst.b	$18(A1,D1.L)
	beq.b	.NoSample
	add.l	4(A1,D1.L),A2
.NoSample	add.l	#$80,D1
	cmp.l	#$1000,D1
	blt.b	.NextSamp
	sub.l	A0,A2
.X	rts



******************************************************************************
* Tim Follin
******************************************************************************

p_timfollin2
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp 	.id(pc)
	jmp	deliAuthor(pc)
	dc  	pt_timfollin2
 dc pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus2!pf_scope!pf_quadscopePoke
	dc.b	"Tim Follin [EP]",0
	        
.path dc.b "tim follin ii",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|0,d0
	bra		deliLoadAndInit 

.id
	MOVEQ	#-1,D0
	MOVE.L	a4,A0
	MOVE.W	#$4EF9,D1
	CMP.W	(A0),D1
	BNE.S	.lbC00057C
	CMP.W	6(A0),D1
	BNE.S	.lbC00057A
	CMP.W	12(A0),D1
	BNE.S	.lbC00057A
	CMP.W	$12(A0),D1
	BNE.S	.lbC00057A
	CMP.W	$18(A0),D1
	BNE.S	.lbC00057A
	CMP.W	$1E(A0),D1
	BNE.S	.lbC00057A
	MOVE.L	$2C(A0),D1
	SUB.L	2(A0),D1
	CMP.W	#$A0,D1
	MOVEQ	#0,D0
.lbC00057A	
	RTS

.lbC00057C
	CMP.W	#$601A,(A0)
	BNE.S	.lbC000586
	LEA	$1C(A0),A0
.lbC000586	
	CMP.W	#$1010,(A0)
	BEQ.S	.lbC000592
	CMP.W	#$1012,(A0)
	BNE.S	.lbC00057A
.lbC000592
	ADDQ.L	#2,A0
	MOVE.L	4(A0),D1
	CMP.L	8(A0),D1
	BNE.S	.lbC00057A
	CMP.L	12(A0),D1
	BNE.S	.lbC00057A
	CMP.L	$10(A0),D1
	BNE.S	.lbC00057A
	MOVEQ	#0,D0
	RTS

******************************************************************************
* Jason Page
******************************************************************************

p_jasonpage
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp 	.id(pc)
	jmp	deliAuthor(pc)
	dc  	pt_jasonpage
	dc 	pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus2!pf_scope!pf_quadscopeUps
	dc.b	"Jason Page [EP]",0
	        
.path dc.b "jason page",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|0,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0

	MOVEQ	#-1,D0
	CMP.W	#2,(A0)
	BNE.S	.lbC000382
	BTST	#0,3(A0)
	BNE.S	.lbC000382
	MOVE.W	4(A0),D1
	BTST	#0,D1
	BNE.S	.lbC000382
	TST.W	0(A0,D1.W)
	BNE.S	.lbC000382
	MOVE.W	$30(A0),D0
	LEA	2(A0),A1
	MOVEQ	#$16,D1
.lbC00034E	TST.W	(A1)
	BEQ.S	.lbC000382
	BTST	#0,1(A1)
	BNE.S	.lbC000382
	CMP.W	(A1)+,D0
	BLE.S	.lbC000382
	DBRA	D1,.lbC00034E
	MOVEQ	#0,D0
	MOVE.W	$2E(A0),D0
	ADD.L	D0,A0
	MOVE.W	(A0),D0
	AND.W	#$F00,D0
	CMP.W	#$F00,D0
	BNE.S	.lbC00037C
	BRA.W	.lbC000380

.lbC00037C
.lbC000380	BRA.S	.lbC0003AE

.lbC000382	TST.W	(A0)
	BNE.S	.lbC0003B0
	TST.L	$80(A0)
	BNE.S	.lbC0003B0
	CMP.L	#$CBE,$84(A0)
	BNE.S	.lbC0003B0
	CMP.L	#$308BE,$CB6(A0)
	BNE.S	.lbC0003B0
	CMP.L	#$309BE,$CBA(A0)
	BNE.S	.lbC0003B0
.lbC0003AE	MOVEQ	#0,D0
.lbC0003B0	RTS
	RTS


******************************************************************************
* Steve Turner
******************************************************************************

p_steveturner
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp 	.id(pc)
	jmp	deliAuthor(pc)
	dc  	pt_steveturner
	dc 	pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus2!pf_scope!pf_quadscopeUps
	dc.b	"Steve Turner [EP]",0
	        
.path dc.b "steve turner",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|0,d0
	bra		deliLoadAndInit 

.id
	move.l	a4,a0
	MOVEQ	#-1,D0
	CMP.W	#$2B7C,(A0)
	BNE.S	.no
	CMP.W	#$2B7C,8(A0)
	BNE.S	.no
	CMP.W	#$2B7C,$10(A0)
	BNE.S	.no
	CMP.W	#$2B7C,$18(A0)
	BNE.S	.no
	CMP.L	#$303C00FF,$20(A0)
	BNE.S	.no
	CMP.L	#$32004EB9,$24(A0)
	BNE.S	.no
	CMP.W	#$4E75,$2C(A0)
	BNE.S	.no
	MOVEQ	#0,D0
.no
	rts

******************************************************************************
* SpecialFX
******************************************************************************

p_specialfx
	jmp	.init(pc)
	jmp	deliPlay(pc)
	p_NOP
	jmp	deliEnd(pc)
	jmp	deliStop(pc)
	jmp	deliCont(pc)
	jmp	deliVolume(pc)
	jmp	deliSong(pc)
	jmp	deliForward(pc)
	jmp	deliBackward(pc)
	p_NOP
	jmp 	.id(pc)
	jmp	deliAuthor(pc)
	dc  	pt_specialfx
	dc 	pf_stop!pf_cont!pf_volume!pf_end!pf_song!pf_ciakelaus2!pf_scope!pf_quadscopeUps
	dc.b	"Special FX [EP]",0
	        
.path dc.b "special fx",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|0,d0
	bra		deliLoadAndInit
	
.id
	move.l	a4,a0
	MOVEQ	#-1,D0
	MOVE.W	#$6000,D1
	CMP.W	(A0)+,D1
	BNE.S	.lbC0003C6
	MOVE.L	A0,A1
	MOVE.W	(A0)+,D2
	BMI.S	.lbC0003C6
	BEQ.S	.lbC0003C6
	BTST	#0,D2
	BNE.S	.lbC0003C6
	MOVEQ	#2,D4
.lbC000378	CMP.W	(A0)+,D1
	BNE.S	.lbC0003C6
	MOVE.W	(A0)+,D3
	BMI.S	.lbC0003C6
	BEQ.S	.lbC0003C6
	BTST	#0,D3
	BNE.S	.lbC0003C6
	DBRA	D4,.lbC000378
	ADD.W	D2,A1
	CMP.W	(A0),D1
	BNE.S	.lbC0003AE
	MOVEQ	#2,D4
.lbC000394	CMP.W	(A0)+,D1
	BNE.S	.lbC0003C6
	MOVE.W	(A0)+,D3
	BMI.S	.lbC0003C6
	BEQ.S	.lbC0003C6
	BTST	#0,D3
	BNE.S	.lbC0003C6
	DBRA	D4,.lbC000394
	CMP.W	(A0),D1
	BEQ.S	.lbC0003C6
	BRA.S	.lbC0003B6

.lbC0003AE	CMP.W	#$6100,(A1)
	BNE.S	.lbC0003C6
	ADDQ.L	#4,A1
.lbC0003B6	CMP.W	#$41F9,(A1)
	BNE.S	.lbC0003C6
	ADDQ.L	#6,A1
	CMP.W	#$43F9,(A1)
	BNE.S	.lbC0003C6
	MOVEQ	#0,D0
.lbC0003C6	RTS


******************************************************************************
* MIDI (serial output)
******************************************************************************

p_midiext:
  jmp      .init(pc)
  jmp      deliPlay(pc)
  p_NOP
  jmp      deliEnd(pc)
  jmp      deliStop(pc)
  jmp      deliCont(pc)
  jmp      deliVolume(pc)
  jmp      deliSong(pc)
  jmp      deliForward(pc)
  jmp      deliBackward(pc)
  p_NOP
  jmp      .id(pc)
  jmp      deliAuthor(pc)
  dc       pt_midiext
  dc       pf_end
  dc.b     "MIDI (serial out) [DP]",0
	        
.path dc.b "delimidi",0
 even

.init
	lea	.path(pc),a0 
	moveq	#0<<16|9,d0
	bra		deliLoadAndInit 
      
.id
    cmp.b   #MIDI_SERIAL,midimode(a5)
    bne     id_midi\.no

id_midi
    cmp.l   #"MThd",(a4)
    bne     .no
    cmp.l   #6,4(a4)
    bne     .no
    cmp.w   #3,8(a4)
    bhi     .no
    moveq   #0,d0
    rts
.no
    moveq   #-1,d0
    rts



* In:
*   a0 = path
getFileExtension4:
.1  tst.b   (a0)+
    bne     .1
    subq    #1,a0
    move.b  -(a0),d0
    ror.l   #8,d0
    move.b  -(a0),d0
    ror.l   #8,d0
    move.b  -(a0),d0
    ror.l   #8,d0
    move.b  -(a0),d0
    ror.l   #8,d0
    or.l    #$20202020,d0   * to lowercase
    rts
    
* In:
*   a0 = path
* Out:
*   d0 = true if path has ".mid" or ".midi" extension
;hasMidiExtension:
;    bsr     getFileExtension4
;    cmp.l   #".mid",d0
;    beq     .yes
;    cmp.l   #"midi",d0
;    beq     .yes
;    moveq   #0,d0
;    rts
;.yes
;    moveq   #1,d0
;    rts



******************************************************************************
* MIDI (Timidity, GMPlay)
******************************************************************************


p_midistream:
  jmp      .init(pc)
  p_NOP     * CIA   
  p_NOP     * VB
  jmp       .end(pc)
  jmp      p_sample+p_stop(pc)
  jmp      p_sample+p_cont(pc)
  jmp      p_sample+p_volume(pc)
  p_NOP    * Song
  p_NOP    * Forward
  p_NOP    * Backward
  jmp      p_sample+p_ahiupdate(pc)
  jmp      .id(pc)
  p_NOP    * Author
  dc       pt_midistream
  dc       pf_volume!pf_scope!pf_stop!pf_cont!pf_end!pf_ahi!pf_quadscopePoke
.title
  dc.b     "MIDI                    ",0
.tempFile  dc.b    "T:hippo.midi",0
           even

.id
    tst.b   uusikick(a5)
    beq     .no

    cmp.b   #MIDI_GMPLAY,midimode(a5)
    beq     id_midi

    cmp.b   #MIDI_TIMIDITY,midimode(a5)
    bne     .no

    push    a0
    move.l  (a5),a0
    move    AttnFlags(a0),d0
    pop     a0      
    * Require at least 020
	btst	#AFB_68020,d0
    beq     id_midi\.no
    * ...and an FPU
    and     #AFF_68881!AFF_68882!AFF_FPU40,d0
    bne     id_midi
.no
    moveq   #-1,d0
    rts

.init
    DPRINT  "MIDI stream init"
    lea     .tempFile(pc),a0
    move.l  moduleaddress(a5),a1
    move.l  modulelength(a5),d0
    bsr     plainSaveFile
    bmi     .initError
    DPRINT  "saved to temp"

    * Switch type to sample so correct replayer gets loaded
    move    #pt_sample,playertype(a5)    

    * Start streaming
    lea     .tempFile(pc),a0
    pushpea pipe_Timidity(pc),d0
    cmp.b   #MIDI_TIMIDITY,midimode(a5)
    beq     .ti
    pushpea pipe_GMPlay(pc),d0
.ti
    jsr     startLocalStreaming
    DPRINT  "startStreaming=%lx"
    tst.l   d0
    beq     .streamError

 if DEBUG
    move.l  a0,d0
    DPRINT  "stream is %s"
 endif
    * Point sampleplayer to the pipe stream
    move.l  a0,modulefilename(a5)

    jsr     p_sample+p_init(pc) 
    DPRINT  "Sample init=%lx"
    tst.l   d0
    beq     .ok
    bsr     .deleteTempFile
    * D0 = error code
    rts

.ok
    * Copy some title info
    lea     midimode01,a0
    cmp.b   #MIDI_TIMIDITY,midimode(a5)
    beq     .11
    basereg midimode01,a0
    lea     midimode02(a0),a0
    endb    a0
.11     
    move.l  a0,d0
    move.l  sampleOutputInfoText(a5),d1

    lea     .form(pc),a0
    lea     .title(pc),a3
    jsr     desmsg3

    * Sample init OK
    moveq   #0,d0
    rts
        * "MIDI Timidity 14c-bit"
.form:  dc.b    "MIDI %s %s",0
    even


.initError
    moveq   #ier_error,d0
    rts

.streamError    
    DPRINT  "MIDI stream error!"
    bsr     .deleteTempFile

    ; Send CTRL-C to streamer if possible
    bsr     stopStreaming
    ; If this was midi flushing needs to be done if timidity
    ; is running, othewise flush will get stuck with an empty pipe
    jsr     findLocalStreamProcess
    bne     .flush
    DPRINT  "MIDI: wait for streamer to exit"
    jsr     awaitStreamer
    bra     .1
.flush
    DPRINT  "MIDI: flush and wait for streamer to exit"
    jsr     awaitStreamerAndFlush
.1
    lea     .msgMidi(pc),a1
    jsr     request

    moveq   #ier_error_nomsg,d0
    rts

.msgMidi
    dc.b    "Error starting MIDI!",0
    even

.end
    DPRINT  "MIDI stream end"
    jsr     p_sample+p_end(pc)

.deleteTempFile
    DPRINT  "Delete MIDI temp file"
    push    d0
    pushpea .tempFile(pc),d1
    lore    Dos,DeleteFile
    pop     d0
    rts

pipe_GMPlay:
    dc.l    .gmCurrentDir
    dc.l    .gmPlayCliName
    dc.l    .gmPlayCommand
    dc.l    aiffStreamPipeFile
    dc.l    .setGMPlayDriverEnvVar
    dc.l    0 * no special stack
    dc.l    0 * no poll routine
    dc.l    0 * additional formatting parameter

.gmCurrentDir:   dc.b    "gm:",0
.gmPlayCliName:  dc.b    "gmplay",0
.gmPlayCommand:  dc.b    '%s OUTPUT=file QUIET FREQUENCY=27710 "%s"',10,0
                 even



.setGMPlayDriverEnvVar:
    pushpea .gmEnvVarName(pc),d1
    pushpea .gmEnvVarValue(pc),d2  * value
    moveq   #-1,d3               * size or -1 for null terminated string
    move.l  #GVF_GLOBAL_ONLY,d4  * global variable
    lore    Dos,SetVar           * set it
    DPRINT  "SetVar=%ld"
    rts

.gmEnvVarName:
    dc.b    "CyberSound/SoundDrivers/file_Destination",0
.gmEnvVarValue:
    dc.b    "PIPE:wavHippoStream2/65536/2",0
    even

pipe_Timidity:
    dc.l    .timidityDir
    dc.l    .timidityCliName
    dc.l    .timidityCmd
    dc.l    wavStreamPipeFile
    dc.l    0 * no setup
    dc.l    0 * no special stack
    dc.l    0 * no poll routine
    dc.l    0 * additional formatting parameter

.timidityDir      dc.b    "timidity:",0    
.timidityCliName  dc.b    "timidity",0
.timidityCmd      dc.b    '%s -id -Ow1S -s27710 -o PIPE:wavHippoStream/65536/2 "%s"',10,0
    even


******************************************************************************
* VGM
******************************************************************************

p_vgm:
  jmp      vgmInit(pc)
  p_NOP     * CIA   
  jmp      vgmPollTrigger(pc)     * VB
  jmp       vgmEnd(pc)
  jmp      p_sample+p_stop(pc)
  jmp      p_sample+p_cont(pc)
  jmp      p_sample+p_volume(pc)
  jmp      vgmSong(pc)
  p_NOP    * Forward
  p_NOP    * Backward
  jmp      p_sample+p_ahiupdate(pc)
  jmp      id_vgm(pc)
  p_NOP    * Author
  dc       pt_vgm
  dc       pf_volume!pf_scope!pf_stop!pf_cont!pf_end!pf_ahi!pf_quadscopePoke!pf_song
vgmTitle        ds.b    32    * (too much) empty space for formatting
vgmTempFile     dc.b    "T:hippo."
vgmTempExt      dc.b    "vgm",0,0
vgmPollFile     dc.b    "T:vgmlen",0
* Set to true if actually handling an MDX fil
vgmActuallyMdx  dc.b    0
                even
* VB activated poller: -1 to disable, counts up to a second or so then wraps
vgmPollCount    dc.w    -1 
* Detected number of voices from vgm2wav
vgmVoices       dc.w    0

vgmInit
    ; Reset track number
    clr.w   vgmTrackNumber
    clr.w   vgmVoices

vgmInit0
    DPRINT  "VGM stream init"
 if DEBUG
    move.l  moduleaddress(a5),d0
    DPRINT  "module=%lx"
 endif


    * Temp file should a correct extension for vgm2wav
    move.b  vgmActuallyMdx(pc),d0
    bne     .mdx
    
    move.l  moduleaddress(a5),a4
    bsr     vgmGet4
    lea     vgmTempExt(pc),a0
    move.l  d0,(a0)
    cmp.b   #' ',2(a0)
    bne     .11
    clr.b   2(a0)
    bra     .33
.11
    cmp.b   #' ',3(a0)
    bne     .33
    clr.b   3(a0)
.33

.mdx
    lea     vgmTempFile(pc),a0
    move.l  moduleaddress(a5),a1
    move.l  modulelength(a5),d0
    bsr     plainSaveFile
    bmi     .outOfMem
    DPRINT  "saved to temp"

    bsr     vgmSetTypeName

    * Switch type to sample so correct replayer gets loaded
    move    #pt_sample,playertype(a5)    

    * Start streaming, url:
    lea     vgmTempFile(pc),a0
    * pipe specification:
    pushpea pipe_vgm2wav(pc),d0
    move.b  vgmActuallyMdx(pc),d1
    beq     .44
    pushpea pipe_mdx2wav(pc),d0
.44
    jsr     startLocalStreaming
    DPRINT  "startStreaming=%lx"
    tst.l   d0
    beq     .streamError

 if DEBUG
    move.l  a0,d0
    DPRINT  "VGM stream is %s"
 endif
    * Point sampleplayer to the pipe stream
    move.l  a0,modulefilename(a5)

    jsr     p_sample+p_init(pc) 
    DPRINT  "Sample init=%lx"
    tst.l   d0
    beq     .ok
    bsr     vgmDeleteTempFile
    * D0 = error code
    rts

.ok
    ; Enable polling for music length
    clr.w   vgmPollCount
    ; Update info also
    bsr     vgmInfoText

    * Sample init OK
    moveq   #0,d0
    rts

.outOfMem
    moveq   #ier_nomem,d0
    rts

.initError
    moveq   #ier_error,d0
    rts

.streamError    
    DPRINT  "VGM stream error!"
    bsr     vgmDeleteTempFile

    ; Send CTRL-C to streamer if possible
    bsr     stopStreaming
    ; If this was midi flushing needs to be done if timidity
    ; is running, othewise flush will get stuck with an empty pipe
    jsr     findLocalStreamProcess
    bne     .flush
    DPRINT  "VGM: wait for streamer to exit"
    jsr     awaitStreamer
    bra     .1
.flush
    DPRINT  "VGM: flush and wait for streamer to exit"
    jsr     awaitStreamerAndFlush
.1
    lea     .msg(pc),a1
    move.b  vgmActuallyMdx(pc),d0
    beq     .2
    lea     .msg2(pc),a1
.2
    jsr     request

    moveq   #ier_error_nomsg,d0
    rts

.msg
  dc.b    "Error starting 'vgm2wav'",0
.msg2
  dc.b    "Error starting 'mdx2wav'",0
  even

vgmEnd
    DPRINT  "VGM stream end"
    move.w  #-1,vgmPollCount    * safety
    jsr     p_sample+p_end(pc)
    ; ... fall through ...

vgmDeleteTempFile
    DPRINT  "Delete VGM temp file"
    push    d0
    pushpea vgmTempFile(pc),d1
    lore    Dos,DeleteFile
    pop     d0
    rts

* Generate info text about the format
vgmInfoText:
    lea     -8(sp),sp
    move.l  moduleaddress(a5),a4
    bsr     vgmGet4
    clr.l   (sp)
    clr.l   4(sp)

    move.l  sp,a0
    moveq   #4-1,d1
.l  rol.l   #8,d0
    cmp.b   #" ",d0
    beq     .ll    
    move.b  d0,(a0)+
    dbf     d1,.l
.ll

    move.l  sp,d0
    moveq   #0,d1
    move.w  vgmVoices(pc),d1
    move.l  sampleOutputInfoText(a5),d2

    lea     .form(pc),a0
    move.b  vgmActuallyMdx(pc),d3
    beq     .2
    lea     .formMdx(pc),a0
    move.l  d2,d0
.2
    lea     vgmTitle(pc),a3
    jsr     desmsg3
    lea     8(sp),sp

    rts

* subformat, AHI, voices: max 25 ch
.null     dc.b    0
.form     dc.b    "%s %ldch VGM2WAV %s",0
.formMdx  dc.b    "MDX 8ch MDX2WAV %s",0
          even

vgmSongChangePossible:
    jsr     findLocalStreamProcess
    DPRINT  "vgmSongChangePossible=%lx"
    tst.l   d0
    rts

; stream task is still in Wait even if vgm2wav has exited

vgmSong:
    DPRINT  "vgmSong"
    move.b  vgmActuallyMdx(pc),d1
    beq     .1
    rts
.1

 if DEBUG
	moveq	#0,d0
	move	songnumber(a5),d0
	DPRINT	"Select %ld"
 endif
    move.l  #SIGBREAKF_CTRL_D,d3    * Next track signal
    lea     vgmTrackNumber(pc),a0
    move    (a0),d1
    cmp     d0,d1       * same?
    beq     .x
    move    d0,(a0)
    sub     d1,d0
    bpl.b   .next
    move.l  #SIGBREAKF_CTRL_E,d3    * Previous track signal
.next

    bsr      vgmSongChangePossible
    beq     .x
    lore    Exec,Forbid
    move.l  d0,a1
    move.l  d3,d0
    lob     Signal
    lob     Permit
    DPRINT  "Change track signal!"
    ; Enable polling for music length for this track
    clr.w   vgmPollCount
.x
    rts

 REM
.restart
    DPRINT  "restarting"
    bsr     vgmEnd
    bsr     vgmInit0
    tst.l   d0
    bpl.b   .ok
    DPRINT  "Song change failed %ld"
.ok 
    rts
 EREM

pipe_vgm2wav:
    dc.l    0 * use homelock for current dir
    dc.l    vgmCliName
    dc.l    vgmCmdLq
    dc.l    wavStreamPipeFileLQ
    dc.l    0 * no setup
    dc.l    10000 * large stack
    dc.l    vgmPoll
    dc.l    0 * additional format string parameter
vgmTrackNumber = *-2

vgmCliName          dc.b    "vgm2wav",0
vgmCmdLq            dc.b    '%s -f 22050 -o PIPE:wavHippoStream3/65536/2 -p -l t:vgmlen -i "%s" -r %ld',10 
                    dc.b    0
* This name is recognized in the sample player to engage 22050 Hz out AIFF decoder
wavStreamPipeFileLQ  dc.b    "PIPE:wavHippoStream3",0
                     even

pipe_mdx2wav:
             dc.l    0 * use homelock for current dir
             dc.l    .mdxCliName
             dc.l    .mdxCmdLq
             dc.l    wavStreamPipeFileLQ
             dc.l    0 * no setup
             dc.l    10000 * large stack
             dc.l    mdxPoll * no polling
             dc.l    0 * additional format string parameter

.mdxCliName  dc.b    "mdx2wav",0
.mdxCmdLq    dc.b    '%s "%s" -r 22050 -p t:vgmlen -o PIPE:wavHippoStream3/65536/2',10
             dc.b    0
             even

 
vgmSetTypeName:
    * Set name.
    * vgz filename is "gzData", copy the original filename
 	move.w  #INFO_MODULE_NAME_LEN-1,d1
	move.l	solename(a5),a0
	lea		modulename(a5),a1
    jmp     tee_modnimi\.copy

;    move.l  moduleaddress(a5),a4
;    bsr     vgmGet4
;    lea     vgmTitle(pc),a0
;    move.l  d0,(a0)+
;    rts
 REM
    cmp.l   #"VGM ",d0
    beq     .vgm
    clr.b   (a0)
    rts

.vgm
    move.b  #"v",(a0)+
    * Put version number

    * reverse BCD  0x00000171 -> v1.71
    *              0x17010000
    move.l  8(a4),d0 
    swap    d0
    * 0x1701
    moveq   #'0',d2
    add.b   d2,d0
    move.b  d0,(a0)+
    move.b  #".",(a0)+
    ror     #8,d0
    * d0 = 0x17
    moveq   #$f,d1
    and     d0,d1
    lsr.b   #4,d0
    add.b   d2,d0
    add.b   d2,d1
    move.b  d0,(a0)+
    move.b  d1,(a0)+
    clr.b   (a0)
    rts
 EREM

* In:
*   a4 = module
* Out:
*   d0 = NULL, or a 4-code for supported subtype
vgmGet4:
    move.l  #"VGM ",d0
    cmp.l   #"Vgm ",(a4)
    beq     .ok

    move.l  #"AY  ",d0
    cmp.l   #"ZXAY",(a4)
    beq     .ok

    move.l  #"GBS ",d0
    cmp.l   #("GBS"<<8)+1,(a4)
    beq     .ok

    move.l  #"GYM ",d0
    cmp.l   #"GYMX",(a4)
    beq     .ok

    move.l  #"HES ",d0
    cmp.l   #"HESM",(a4)
    beq     .ok

    move.l  #"KSS ",d0
    cmp.l   #"KSCC",(a4)
    beq     .ok
    cmp.l   #"KSSX",(a4)
    beq     .ok

    move.l  #"NSF ",d0
    cmp.l   #"NESM",(a4)
    beq     .ok

    move.l  #"NSFE",d0
    cmp.l   #"NSFE",(a4)
    beq     .ok

    move.l  #"SAP ",d0
    cmp.l   #("SAP"<<8)+$d,(a4)
    beq     .ok

    move.l  #"SPC ",d0
    cmp.l   #"SNES",(a4)
    beq     .ok
    moveq    #0,d0
.ok 
    tst.l   d0
    rts

;;  case BLARGG_4CHAR('Z','X','A','Y'):  return "AY";
;;  case BLARGG_4CHAR('G','B','S',0x01): return "GBS";
;;  case BLARGG_4CHAR('G','Y','M','X'):  return "GYM";
;;  case BLARGG_4CHAR('H','E','S','M'):  return "HES";
;;  case BLARGG_4CHAR('K','S','C','C'):
;;  case BLARGG_4CHAR('K','S','S','X'):  return "KSS";
;;  case BLARGG_4CHAR('N','E','S','M'):  return "NSF";
;;  case BLARGG_4CHAR('N','S','F','E'):  return "NSFE";
;;  case BLARGG_4CHAR('S','A','P',0x0D): return "SAP";
;;  case BLARGG_4CHAR('S','N','E','S'):  return "SPC";
;;  case BLARGG_4CHAR('V','g','m',' '):  return "VGM";

* Called from VB interrupt.
* Will signal the streamer task using an interval.
* Intent is to make the streamer call the poll callback
* in task scope, which then will check if the song lenght
* info is available.
vgmPollTrigger:
    lea     vgmPollCount(pc),a0
    move    (a0),d0
    bmi     .2
    addq    #1,d0
    and     #$7f,d0
    move    d0,(a0)
    bne     .2

    lore    Exec,Forbid
    move.l  streamerTask(a5),d0
    beq     .1
    move.l  d0,a1
    move.l  #SIGBREAKF_CTRL_D,d0
    lob     Signal 
.1  lob     Permit
.2  rts



* Try to read the file where vgm2wav has written the length info
mdxPoll:
    moveq   #1,d3
    DPRINT  "mdxPoll!"
    bra     vgmPoll0
vgmPoll:
    DPRINT  "vgmPoll!"
    moveq   #0,d3
vgmPoll0:
    lea     vgmPollFile(pc),a0
    jsr     plainLoadFile
    tst.l   d0
    beq     .no 
    move.l  d0,a1
    move.l  d0,a0
    moveq   #1,d1       * default song count
    moveq   #0,d2       * default num of voices
    move.l  (a1)+,d0    * song length
    tst.b   d3
    bne     .mdx
    move.l (a1)+,d1     * song/track count
    move.l (a1)+,d2     * num of voices
.mdx

    move.w  d2,vgmVoices
 if DEBUG
    DPRINT  "vgm length=%ld secs, track count=%ld, voices=%ld"
    tst.l   d0
 endif
    * Store result if there is something
    bmi     .noTime
    divu    #60,d0
    move.w  d0,kokonaisaika(a5)
    swap    d0
    move.w  d0,kokonaisaika+2(a5)
.noTime
    * Validate track count
    subq    #1,d1
    bmi     .1
    cmp     #64,d1
    bhs     .1
    move.w  d1,maxsongs(a5)
.1
    * Stop polling
    move    #-1,vgmPollCount
    * Free a0
    jsr     freemem
    bsr     vgmDeletePollFile

    * Update infobox too
	tst.b	playing(a5)
	beq.b	.no
    bsr     vgmInfoText
    jsr     inforivit_play
.no
    rts


vgmDeletePollFile:  
    DPRINT  "Delete poll file"
    pushpea vgmPollFile(pc),d1
    lore    Dos,DeleteFile
    rts

id_vgm
    tst.b   uusikick(a5)
    beq     .no

    * Check for MDX
    push    a0
    move.l  modulefilename(a5),a0
    bsr     getFileExtension4
    cmp.l   #".mdx",d0
    lea     vgmActuallyMdx(pc),a0
    seq     (a0)
    pop     a0
    beq     .yes

;;;    * Check for VGZ
;;;    push    a0
;;;    move.l  modulefilename(a5),a0
;;;.1  tst.b   (a0)+
;;;    bne     .1
;;;    subq    #1,a0
;;;    moveq   #4-1,d1
;;;.2  ror.l   #8,d0
;;;    move.b  -(a0),d0
;;;    dbf     d1,.2
;;;    or.l    #$20202000,d0
;;;    cmp.l   #"vgz.",d0
;;;    bne     .noGz
;;;    moveq   #0,d0
;;;    move.w  (a4),d0
;;;    cmp.w   #$1f8b,(a4)
;;;.noGz
;;;    pop     a0
;;;    beq     .yes

    bsr     vgmGet4
    beq     .no
.yes
    moveq   #0,d0   * yes
    rts
.no
    moveq   #-1,d0
    rts

******************************************************************************
* VGM Tnt
******************************************************************************

p_vgm_tnt:
  jmp      .vgmTntInit(pc)
  jmp	   .vgmTntCia(pc)
  p_NOP    * VB
  jmp      .vgmTntEnd(pc)
  jmp      .vgmTntStop(pc)
  p_NOP    .vgmTntContinue(pc)
  p_NOP    * Volume
  p_NOP    * Song
  p_NOP    * Forward
  p_NOP    * Backward
  p_NOP    * AHI update
  jmp      id_vgmTnt(pc)
  p_NOP    * Author
  dc       pt_vgm_tnt
  dc       pf_stop!pf_cont!pf_end
  dc.b     "VGM Tnt "
.chip:
  dc.b     "             ",0
  even

.vgmTntInit:
    * Call again to get core if it has been freed
    bsr     openTnt
    beq     .err

    move   #28419/4,d0     * 100Hz
    jsr    init_ciaint_withTempo
    beq.b  .ok2
    jsr    vapauta_kanavat
    moveq  #ier_nociaints,d0
    rts
.ok2
    clr.l    vgmTime(a5)
    clr.l    vgmPlayTime(a5)
    move.l   vgmDataStart(a5),vgmDataCurrent(a5)

    bsr      vgmSetTypeName

    move.l   vgmSampleCount(a5),d0
    divu     #44100,d0
    * d0 = seconds
    ext.l    d0
    divu     #60,d0
    move     d0,kokonaisaika(a5)    * minutes
    swap     d0
    move     d0,kokonaisaika+2(a5) * seconds

    moveq    #0,d0        * ok
    rts
.err
    moveq   #ier_unknown,d0
    rts

.vgmTntEnd:
    bsr     .vgmTntStop      * make silent
    bra     closeTnt

.vgmTntStop:
    move.l  moduleaddress(a5),a0
    tst.l   $74(a0)  * AY8910 clock
    bne     ay8910silence
    rts

.vgmTntContinue:
    move.l  moduleaddress(a5),a0
    tst.l   $74(a0)  * AY8910 clock
    bne     ay8910restore
    rts
    
.vgmTntCia:
    ;moveq   #0,d6  * host time
    ;moveq   #0,d7  * vgm time
    move.l  vgmPlayTime(a5),d6
    move.l  vgmTime(a5),d7
    bsr     .play
    move.l  d6,vgmPlayTime(a5)
    move.l  d7,vgmTime(a5)
    rts

.play
    * 1/50th sec or 20 ms host playtime elapsed
    * 44100/1000*20 = 882 ticks
    * 1/100th sec or 10 ms host playtime elapsed
    * 44100/1000*10 = 441 ticks
    * 1/200th sec or 5 ms host playtime elapsed
    * 44100/1000*5 = 220.5 ticks
;    add.l   #882,d6
    add.l   #441,d6

    * Host behind vgm? 
    cmp.l   d6,d7
    bhs     .out

    * Process VGM events so that vgm time catches up
.proc
    bsr     .process
    cmp.l   d6,d7
    blo     .proc

.out
    rts


.process
    move.l  vgmDataCurrent(a5),a0
    cmp.l   vgmDataEnd(a5),a0
    bhs     .dataEnd2
    tst.l   vgmSampleCount(a5)
    ble     .dataEnd
    moveq   #0,d0
    move.b  (a0)+,d0  
    bsr     .command
.continue
    move.l  a0,vgmDataCurrent(a5)
    rts
 
.dataEnd2
    DPRINT "dataEnd2"
.dataEnd
    DPRINT "dataEnd1"
    bsr     .restart
    bra     .continue

* Out: 
*   a0 = new current position
.restart
    DPRINT "VGM songover, restart"
    st      songover(a5)

    * restart from beginning
    move.l  vgmDataStart(a5),a0
    move.l  moduleaddress(a5),a1
    move.l  $18(a1),d0  * Total # samples
    ilword  d0
    move.l  d0,vgmSampleCount(a5)

    * restart from loop start
    move.l  $20(a1),d1     * loop samples
    beq     .noLoop
    DPRINT "loop restart"

    move.l  $1c(a1),d0  * loop offset
    ilword  d0
    cmp.l   modulelength(a5),d0
    bhs     .noLoop
    DPRINT  "loop ok, start=%ld"
    lea      $1c(a1,d0.l),a0

    ilword   d1
    move.l   d1,vgmSampleCount(a5)
.noLoop
    rts

.command
    ; ---------------------------------
    cmp.b   #$31,d0
    beq     .AY8910_stereo_mask
    cmp.b   #$a0,d0
    beq     .AY8910_write_value
    cmp.b   #$a0!$80,d0
    beq     .AY8910_write_value_2nd
    ; ---------------------------------
    cmp.b   #$5a,d0
    beq     .YM3812_write_value
    cmp.b   #$aa,d0
    beq     .YM3812_write_value_2nd
    ; ---------------------------------
    cmp.b   #$66,d0
    beq     .restart
    ; ---------------------------------
    cmp.b   #$61,d0
    beq     .wait_samples
    cmp.b   #$62,d0
    beq     .wait_735_samples
    cmp.b   #$63,d0
    beq     .wait_882_samples
    ; ---------------------------------    
    cmp.b   #$70,d0
    blo     .cx
    cmp.b   #$7f,d0
    bhi     .cx
    moveq   #0,d1
    move.b  d0,d1
    sub.b   #$70,d1
    addq.b  #1,d1
    bra     .wait_n
.cx
    ; ---------------------------------
    if DEBUG
    and.l    #$ff,d0
    DPRINT    "VGM unknown command=%lx"
 endif
    rts


.wait_samples
    moveq   #0,d1
    move.w  (a0)+,d1
    ror     #8,d1
.wait_n
    add.l   d1,d7
    sub.l   d1,vgmSampleCount(a5)
    rts

.wait_735_samples
    move.l  #735,d1
    bra     .wait_n

.wait_882_samples
    move.l  #882,d1
    bra     .wait_n

.AY8910_stereo_mask
    move.b  (a0)+,d1    * value
    rts

.AY8910_write_value    
    * write dd into aa
    move.b  (a0)+,d1    * aa
    move.b  (a0)+,d2    * dd

    * Store volumes for later
    cmp.b   #8,d1
    bne     .v1
    move.b  d2,ay8910vol1
    bra     .v3
.v1
    cmp.b   #9,d1
    bne     .v2
    move.b  d2,ay8910vol2
    bra     .v3
.v2
    cmp.b   #10,d1
    bne     .v3
    move.b  d2,ay8910vol3
.v3
    bra     ay8910poke

.AY8910_write_value_2nd
    move.b  (a0)+,d1    * aa
    move.b  (a0)+,d2    * dd
    * write dd into aa
    rts
.YM3812_write_value
    move.b  (a0)+,d1    * aa
    move.b  (a0)+,d2    * dd
    * write dd into aa
    rts
.YM3812_write_value_2nd
    move.b  (a0)+,d1    * aa
    move.b  (a0)+,d2    * dd
    * write dd into aa
    rts

;struct TrinityRegData8
;{
;    unsigned char RegIdx, RegData;
;};


* Poke d2 into register d1
ay8910poke:
;    and.l   #$ff,d2
;    and.w   #$ff,d1
;    * tnt_psg, 16 regs here, each 32-bits, write to the low 8 byte
;    move.l  tntPSG1Base(a5),a1
;    lsl.w   #2,d1
;    move.l  d2,(a1,d1.w)
    push    a0
    move.l  _TntBase(a5),a6
    move.l  tntPSG1Core(a5),a0
    * Two TrinityRegData8 structs
    clr.l   -(sp)      
    move.b  d1,(sp)     * RegIdx
    move.b  d2,1(sp)    * RegData
    move.w  #-1,2(sp)   * terminate
    move.l  sp,a1
    jsr     _LVOWriteCoreRegisters(a6)
    addq    #4,sp
    pop     a0
    rts

ay8910silence:
    moveq    #8,d1
    moveq    #0,d2
    bsr      ay8910poke
    moveq    #9,d1
    moveq    #0,d2
    bsr      ay8910poke
    moveq    #10,d1
    moveq    #0,d2
    bra      ay8910poke

ay8910restore:
    moveq    #8,d1
    move.b   ay8910vol1(pc),d2
    bsr      ay8910poke
    moveq    #9,d1
    move.b   ay8910vol2(pc),d2
    bsr      ay8910poke
    moveq    #10,d1
    move.b   ay8910vol3(pc),d2
    bra      ay8910poke

ay8910vol1:    dc.b    0
ay8910vol2:    dc.b    0
ay8910vol3:    dc.b    0
 even

id_vgmTnt:
    DPRINT "id_vgmTnt"
    move.l  a4,a0

    * Check if this VGM is known and supported
    bsr     vgmTntInit
    beq     .no

    * Check for TNT 
    bsr     openTnt
    beq     .no

    * Check for the core needed
    tst.l   tntPSG1Core(a5)
    beq     .no

    moveq    #0,d0    * yes
    rts
.no
    moveq    #-1,d0    * no
    rts
    

* ID: PSG1
* Type: AY-3-8910


_LVOTrinityFind         EQU   -30
_LVOEnumAudioCore       EQU   -36
_LVOOpenAudioCore       EQU   -42
_LVOCloseAudioCore      EQU   -48
_LVOWriteCoreRegisters  EQU   -54

openTnt:
    DPRINT  "openTnt"

;struct TrinityAudioInfo 
;{
;0    ULONG Id;               // 4 byte compatibility id
;4    UWORD Flags;
;6    UWORD Version;          // hi byte major, lo byte minor version
;8    const char Name[16];
;24   const char Author[20];
;44   UWORD Offset;
;46   UWORD Size;
;};

    move.l  _TntBase(a5),d0
    bne     .1
    lea     tntName,a1
    moveq   #1,d0               * LIB_VERSION
    lore	Exec,OpenLibrary
    DPRINT  "TntBase=%lx"
    move.l	d0,_TntBase(a5)
    beq     .x
.1  move.l  d0,a6

    tst.l   tntPSG1Core(a5)
    bne     .ok

    jsr     _LVOTrinityFind(a6)
    DPRINT  "Find=%lx"
    tst.l   d0
    beq     .x

    move.l  #"PSG1",d7
    bsr     .findCore
    DPRINT  "findCore=%lx"
    tst.l   d0
    beq     .x

    move.l  d7,d0
    jsr     _LVOOpenAudioCore(a6)
    DPRINT  "OpenAudioCore=%lx"
    move.l  d0,tntPSG1Core(a5)
.ok
    moveq   #1,d0   * ok
.x
    rts

* In:
*   d5 = Trinity base (not library)
*   d7 = Id to find
* Out:
*   d6 = NULL, or address if found
.findCore:
    moveq   #0,d6       * result
    lea     -256(sp),sp
    clr.l   (sp)        * index: zero
.loopEnum
    move.l  sp,a0       * pointer to index
    moveq   #-1,d0      * flags, anything goes
    lea     4(sp),a1    * pointer to TrinityAudioInfo, space=252
    jsr     _LVOEnumAudioCore(a6)
    DPRINT  "Enum=%lx"
    tst.l   d0
    beq     .out
    lea     4(sp),a0    * TrinityAudioInfo into a0
 if DEBUG
    clr.l   -(sp)
    clr.l   -(sp)
    move.l  (a0),(sp)
    move.l  sp,d0
    DPRINT  "Id=%s"
    addq    #8,sp
 endif
    cmp.l   (a0),d7     * Does it match?
    bne     .loopEnum
    move.w  44(a0),d6   * Get offset and exit
.out
    move.l  d6,d0
    lea     256(sp),sp
    rts


closeTnt:
    move.l  _TntBase(a5),d0
    beq     .x
    move.l  d0,a6
    move.l  tntPSG1Core(a5),d0
    beq     .x
    clr.l   tntPSG1Core(a5)
    move.l  d0,a0
    jsr     _LVOCloseAudioCore(a6)
.x
    rts



vgmTntInit:
    DPRINT    "vgmTntInit"
    move.l  (a0),d0     * id
    cmp.l   #"Vgm ",d0
    bne     .fail

    move.l  4(a0),d0    * EoF offset
    ilword  d0
    lea     4(a0,d0.l),a2
    move.l  a2,vgmDataEnd(a5)

    move.l  $18(a0),d0  * Total # samples
    ilword  d0
    * 4147180 bionic commando 
    * -> 94 sec
    * -> 1 min 34 s
    move.l  d0,vgmSampleCount(a5)
    DPRINT "sample count=%ld"

    move.l  $1c(a0),d0  * loop offset
    ilword  d0
    DPRINT "loop offset=%ld"
    move.l  $20(a0),d0  * loop samples
    ilword  d0
    DPRINT "loop samples=%ld"

    move.l  8(a0),d0    * Header version
    ilword  d0
    DPRINT "header version=%lx"

    * Start of VGM data, prior to v1.50:
    lea     $40(a0),a1  
    cmp.l   #$150,d0
    blo     .old
    * After v1.50:
    move.l  $34(a0),d1  * VGM data offset
    ilword  d1  
 if DEBUG
    push     d0
    move.l   d1,d0
    DPRINT "start offset=%ld"
    pop      d0
 endif
    lea     $34(a0,d1.l),a1
.old
    move.l  a1,vgmDataStart(a5)

    * AY8910, YM3812 only available on v1.51 and newer
    cmp.l   #$151,d0
    blo     .fail

    move.l  $74(a0),d0  * AY8910 clock
    bne     .AY8190
   ; move.l  $50(a0),d0  * YM3812 clock
   ; bne     .YM3812

.fail
    DPRINT  "fail"
    moveq   #0,d0
    rts

.AY8190
;    ilword  d0
;    btst    #30,d0  * 1 = dual chip
;    move.b  $78(a0),d1  * AY8190 chip type
;    move.b  $79(a0),d2  * AY8190 chip flags

    lea      p_vgm_tnt\.chip(pc),a0
    move.l   #"AY81",(a0)+
    move.w   #"90",(a0)+
    clr.b    (a0)
    
    DPRINT  "AY8190"
    moveq   #1,d0
    rts

.YM3812
    ilword  d0
    btst    #30,d0  * 1 = dual chip

    DPRINT  "YM3812"
    moveq   #1,d0
    rts


******************************************************************************
* XMAPlay060
******************************************************************************


p_xmaplay:
    jmp      .init(pc)
    p_NOP                        * CIA
    jmp      .poslen(pc)         * VB
    jmp      .end(pc)
    jmp      .stop(pc)
    jmp      .cont(pc)
    jmp      .vol(pc)
    p_NOP                       * Song
    jmp      .eteen(pc)
    jmp      .taakse(pc)
    p_NOP                       * ahiupdate
    jmp      id_xmaplay(pc)
    jmp      .author(pc)
    dc.w     pt_xmaplay
.flags
    dc pf_cont!pf_stop!pf_volume!pf_kelaus!pf_poslen!pf_end!pf_scope!pf_quadscopePoke!pf_slidePos
	dc.b    "FastTracker2 xmaplay060",0
 even

.author 
    pushpea .a(pc),d0
    rts
.a  dc.b    "8bitbubsy",0
    even
    
    rsset $20
.xmaInit        rs.l    1
.xmaEnd         rs.l    1
.xmaStop        rs.l    1
.xmaCont        rs.l    1
.xmaForward     rs.l    1 
.xmaBackward    rs.l    1   
.xmaGetPosLen   rs.l    1
.xmaSetVolume   rs.l    1
.xmaGetBuffer   rs.l    1

.tempFile   dc.b    "T:hippo-xm",0
    even

.init
    DPRINT  "xmaplay init"
	move.l	(a5),a0
	btst	#AFB_68020,AttnFlags+1(a0)
	bne.b	.okk
	moveq	#ier_hardware,d0
	rts
.okk
	lea	    xmaplayroutines(a5),a0
	jsr	allocreplayer
	beq.b	.ok3
	rts
.ok3

    * Save into a file for XMAplay
    lea     .tempFile(pc),a0
	move.l	moduleaddress(a5),a1
	move.l	modulelength(a5),d0
	bsr	plainSaveFile
	bmi 	.saveError

    DPRINT  "temp file saved"

    lea     .tempFile(pc),a0
    lea     songover(a5),a1
    move.l  xmaplayroutines(a5),a3
    jsr     .xmaInit(a3)
    * d0 = status, 1 = OK, 0 = fail
    * a0 = message or NULL
 if DEBUG
    DPRINT  "xmaInit=%ld mask=%lx"
    push    d0
    move.l  a0,d0
    beq.b   .1
    DPRINT  "msg=%s"
.1  pop     d0
 endif

    pushm   all
    * Rid the temp file
    pushpea .tempFile(pc),d1
    lore    Dos,DeleteFile
    popm    all

    tst.l   d0
    beq    .initError
    
    * d1 = position mask 16.16 FP
    clr.w   d1
    swap    d1
    move.l  d1,.posMask
    pushpea .posMask(pc),ps3m_buffSizeMask(a5)

 if DEBUG
    move.l  a2,d0
    DPRINT  "buf1=%lx"
    move.l  a3,d0
    DPRINT  "buf2=%lx"
 endif

    * a1 = pointer to position of 16.16 FP
    move.l  a1,.posPtr
    * a2 = pointer to buf1 
    move.l  a2,.buf1Ptr
    * a3 = pointer to buf2 
    move.l  a3,.buf2Ptr

    pushpea .ps3mPos(pc),ps3m_playpos(a5)
    pushpea .buf1Ptr(pc),ps3m_buff1(a5)
    pushpea .buf2Ptr(pc),ps3m_buff2(a5)
    move.l  #1,ps3m_sampleDataModulo(a5)

    bsr     .vol

    DPRINT  "xmaplay init ok"
    moveq   #0,d0
    rts

.initError
    moveq   #ier_error,d0
    rts
.saveError
    moveq   #ier_nomem,d0
    rts

* xmaplay
.posPtr     dc.l    0 
.posMask    dc.l    0
.buf1Ptr    dc.l    0
.buf2Ptr    dc.l    0
.ps3mPos    dc.l    0

.poslen
    move.l  xmaplayroutines(a5),a0
    jsr     .xmaGetPosLen(a0)
    move    d0,pos_nykyinen(a5)
    move    d1,pos_maksimi(a5)

    * Update play position 
    * Convert to match PS3M similar value
    * 16.16 FP
    move.l  .posPtr(pc),d0
    beq.b    .2
    move.l  d0,a0
    move.l  (a0),d0
    * to 24.8 FP
    lsr.l   #8,d0
    move.l  d0,.ps3mPos
.2
    rts
.stop
    move.l  xmaplayroutines(a5),a0
    jmp     .xmaStop(a0)
.cont
    move.l  xmaplayroutines(a5),a0
    jmp     .xmaCont(a0)
.vol
    move    mainvolume(a5),d0
    move.l  xmaplayroutines(a5),a0
    jmp     .xmaSetVolume(a0)
.eteen
    move.l  xmaplayroutines(a5),a0
    jmp     .xmaForward(a0)
.taakse
    move.l  xmaplayroutines(a5),a0
    jmp     .xmaBackward(a0)
.end
    move.l  xmaplayroutines(a5),a0
    jmp     .xmaEnd(a0)

* In:
*    a0, a4 = data
* Out:
*    d0 = 0 if accepted and XMAPlay enabled
id_xmaplay  
    tst.b   ahi_muutpois(a5)
    bne     .no
    tst.b   xmaplay(a5)
    beq.b   .no
    push    a0
    jsr     id_xm
    pop     a0
    tst.l   d0
    beq.b   .no
    lea 	xmName(a0),a1
    moveq   #20-1,d0
    jsr     copyNameFromA1
    moveq   #0,d0
    rts
.no
    moveq   #-1,d0
    rts

*******************************************************************************
*** SECTION *******************************************************************
*
* EaglePlayer plugin support 
* Keywords: Delisupport, Eaglesupport
*
******************************************************************************


DELI_LIST_DATA_SLOTS = 64

 STRUCTURE DTN_NoteStruct,0
	APTR	nst_Channels		;pointer to a list of notechannels */
	ULONG	nst_Flags		;misc flags (see below) */
	ULONG	nst_MaxFrequency	;max. frequency of this player (28,867 Hz in DMA mode) */
	UWORD	nst_MaxVolume		;max. volume of this player (in most cases 64) */
	STRUCT	nst_Reserved,18		;reserved for future use (must be 0 for now) */
	LABEL	DTN_NoteStruct_SIZEOF


 STRUCTURE DTN_NoteChannel,0
	APTR	nch_NextChannel		;next channel in the list (NULL if last) */
	ULONG	nch_NotePlayer		;for use by the noteplayer (the deliplayer must ignore this) */
	WORD	nch_Reserved0		;reserved for future use (must be 0 for now) */
	UBYTE	nch_Private		;just what it says */
	UBYTE	nch_Changed		;what has changed since last call */
	WORD	nch_StereoPos		;set this field when the InitNote function is called */
	WORD	nch_Stereo		;describes "where" this channel is supposed to play */
	APTR	nch_SampleStart		;^sampledata */
	ULONG	nch_SampleLength	;size of sample */
	APTR	nch_RepeatStart		;^repeat part of sample */
	ULONG	nch_RepeatLength	;size of repeat part */
	ULONG	nch_Frequency		;frequency (or period) of sample */
	UWORD	nch_Volume		;volume of sample */
	STRUCT	nch_Reserved1,26	;reserved for future use (must be 0 for now) */
	LABEL	DTN_NoteChannel_SIZEOF


NSTB_Dummy	EQU	0	; only a dummy-NoteStruct (no NotePlayer
				; needed)
NSTF_Dummy	EQU	1<<0
NSTB_Period	EQU	1	; Amiga period supplied instead of frequency
NSTF_Period	EQU	1<<1
NSTB_ExtPeriod 	EQU	2	; Extended period (period*4) supplied instead
				; of frequency 
NSTF_ExtPeriod	EQU	1<<2
NSTB_NTSCTiming EQU	3	; Period/ExtPeriod supplied in NTSC instead of
				; PAL 
NSTF_NTSCTiming EQU	1<<3
NSTB_EvenLength EQU	4	; Samplelength supplied as WORD instead of
				; LONG 
NSTF_EvenLength EQU	1<<4
NSTB_AllRepeats EQU	5	; play Repeats even if no One-Shot part was
				; played yet 
NSTF_AllRepeats EQU	1<<5

NSTB_Reverse 	EQU	8	; little endian byte ordering 
NSTF_Reverse 	EQU	1<<8
NSTB_Signed 	EQU	9	; sample data is signed linear
				; (2's complement) 
NSTF_Signed 	EQU	1<<9
NSTB_Unsigned 	EQU	10	;       -"-      unsigned linear 
NSTF_Unsigned 	EQU	1<<10
NSTB_Ulaw 	EQU	11	;       -"-      U-law (logarithmic) 
NSTF_Ulaw 	EQU	1<<11
NSTB_Alaw 	EQU	12	;       -"-      A-law (logarithmic) 
NSTF_Alaw 	EQU	1<<12
NSTB_Float 	EQU	13	;       -"-      IEEE floats 
NSTF_Float 	EQU	1<<13

NSTB_7Bit 	EQU	16	; sample data is in 7-bit format 
NSTF_7Bit 	EQU	1<<16
NSTB_8Bit 	EQU	17	;        -"-        bytes 
NSTF_8Bit 	EQU	1<<17
NSTB_16Bit 	EQU	18	;        -"-        16-bit words 
NSTF_16Bit 	EQU	1<<18
NSTB_24Bit 	EQU	19	;        -"-        24-bit data 
NSTF_24Bit 	EQU	1<<19
NSTB_32Bit 	EQU	20	;        -"-        longwords 
NSTF_32Bit 	EQU	1<<20
NSTB_64Bit 	EQU	21	;        -"-        quadwords 
NSTF_64Bit 	EQU	1<<21

* Load player and initialize module
* in:
*   a0: eagleplayer name
*   d0: required version; major<<16|minor
* out:
*   d0: 0=all ok, negative ier_-code otherwise
deliLoadAndInit:
	jsr	setMainWindowWaitPointer
	bsr.b	loadDeliPlayer 
	tst.l 	d0
	bmi.b 	.loadErr 
	bsr	deliInit
.loadErr	
	jsr 	clearMainWindowWaitPointer
	tst.l	d0
	rts

* in:
*   a0: name
*   d0: required version; major<<16|minor
* out:
*   d0: loaded seglist or negative error code if fail
loadDeliPlayer:
	move.l	d0,d5
	move.l	a0,a3
	* See if can reuse the old player
	move	playertype(a5),d0
	beq.b	.noMod
	cmp	deliPlayerType(a5),d0
	beq	.useOld
.noMod
	bsr	freeDeliPlayer

	bsr 	findDeliPlayer
	move.l	d0,d4
	bmi	.err
	bsr	.load 
	move.l	d0,d3
	move.l	d4,d1
	lore 	Dos,UnLock

	* Remove temporary EP file
	pushpea	epPath(pc),d1
	lore	Dos,DeleteFile

	moveq	#-1,d0	* err flag
	tst.l   d3
	beq.b	.err

	* Get version
	move.l	d3,d0 
	lsl.l	#2,d0
	move.l	d0,a0 
	move.l	#DTP_PlayerVersion,d0
	bsr	deliGetTagFromA0
	beq.b	.noVersion 
	move.l	d0,d6

	* Version check!
	cmp.l	d5,d6
	bhs.b	.ok

	move.l	d3,d1 
	lore Dos,UnLoadSeg

	move.l	a3,d0
	move.l	d5,d1
	clr	d1
	swap	d1
	move	d5,d2
	ext.l	d2
	move.l	d6,d3
	clr	d3 
	swap 	d3 
	move	d6,d4
	ext.l	d4

	move.l	playerbase(a5),a0
	pushpea	p_name(a0),d5
	
	lea	.errMsg(pc),a0 
	jsr	desmsg
	lea	 desbuf(a5),a1
	jsr	request

	moveq	#ier_eagleplayer,d0
	rts

.ok
.noVersion
	move	moduletype(a5),deliPlayerType(a5)
	move.l	d3,d0 
	lsl.l	#2,d0
.err
	rts

.useOld 
	move.l	deliPlayer(a5),d0
	DPRINT	"Using previous delipl 0x%lx"
	rts

.errMsg
	dc.b	"Version mismatch for eagleplayer:",10
	dc.b	'"%s"',10
	dc.b	"Required version: %ld.%ld or newer, found: %ld.%ld",10
	dc.b	'Detected format: "%s"',0
 even


* in:
*   d4 = lock
* out:
*   d0 = seglist or NULL
.load
	lea	-100(sp),sp
	move.l 	d4,d1
	move.l	sp,d2
	moveq	#100,d3 
	jsr 	getNameFromLock
	beq.b 	.err2

 if DEBUG
 	move.l	sp,d0
	DPRINT	"loadDeliPlayer %s"
 endif
 	move.l	sp,d1
	lore 	Dos,LoadSeg
.err2

	lea	100(sp),sp
	tst.l	d0
	rts

epPath		dc.b	"RAM:hippoEP",0
 even


* in:
*   a3: name
* out:
*   d0: lock or negative err
findDeliPlayer	
	* See if this can be loaded from the group
	lea	-4(sp),sp 
	move.l	sp,a0
	* initialize to zero, important
	clr.l	(a0) 
	jsr	allocreplayer
	move.l	(sp),a1
	lea	4(sp),sp
	tst.l	d0
	beq	.epFromGroup

	lea 	.searchPath1(pc),a2 
	bsr 	.tryLock
	bne.b	.ok 
	
* PROGDIR not available on kick13 or asm
 ifeq asm
	tst.b	uusikick(a5)
	beq.b	.skip
	lea 	.searchPath2(pc),a2 
	bsr.b 	.tryLock
	bne.b	.ok 
	lea 	progdir,a2 
	bsr.b 	.tryLock
	bne.b	.ok 
.skip
 endc 

	lea	 .searchPath3(pc),a2 
	bsr.b 	.tryLock
	beq.b	.fail	
.ok
	rts

.fail 
	move.l	playerbase(a5),a0 
	pushpea p_name(a0),d1
	move.l	a3,d0
	lea	.errMsg(pc),a0 
	jsr	desmsg
	lea	 desbuf(a5),a1
	jsr	request
	moveq	#ier_eagleplayer,d0
	rts	
.errMsg
	dc.b	"Could not load eagleplayer:",10
	dc.b	'"%s"',10
	dc.b	'Detected format: "%s"',0
	 even

.tryLock
	lea	-100(sp),sp
	move.l	sp,a1
.path	
	move.b	(a2)+,(a1)+
	bne.b	.path
	subq	#1,a1
	move.l	a3,a0
.name	
	move.b	(a0)+,(a1)+
	bne.b	.name

	move.l	sp,d1
	moveq	#ACCESS_READ,d2
 	lore 	Dos,Lock
	lea	100(sp),sp
	tst.l	d0
	rts
.searchPath1
	dc.b	"RAM:",0
.searchPath2
	dc.b	"PROGDIR:eagleplayers/",0
.searchPath3
	dc.b	"eagleplayer2:eagleplayers/",0
 even

* Copy replay data from group into a file for LoadSeg()
* in:
*   a1 = replayer data from group
.epFromGroup
	push	a1
	lea	epPath(pc),a0 
	* Mem allocation size is here.
	* To get data size this must be subtracted
	move.l	-4(a1),d0
	subq.l	#4,d0
	bsr	plainSaveFile
	pop 	a0 
	jsr	freemem

	tst.l	d0
	beq	.fail

	pushpea	epPath(pc),d1
	moveq	#ACCESS_READ,d2
 	lore 	Dos,Lock
	tst.l	d0 
	beq	.fail
	rts

freeDeliPlayer:
	pushm	all
	tst.l	deliPlayer(a5)
	beq.b	.x

	* DeliCustom is UnloadSegged elsewhere
	cmp	#pt_delicustom,deliPlayerType(a5)
	beq.b 	.skip
	move.l	deliPlayer(a5),d1
	lsr.l	#2,d1
	lore	Dos,UnLoadSeg
	DPRINT	"freeDeliPlayer"
.skip
	clr.l	deliPlayer(a5)
	clr	deliPlayerType(a5)
.x
	bsr.b	freeDeliLoadedFiles
	bsr	freeDeliBase
	popm	all
	rts

freeDeliLoadedFiles
    DPRINT  "freeDeliLoadedFiles"
	tst.l	deliLoadFileArray(a5)
	beq.b 	.xy
	move.l	deliLoadFileArray(a5),a2
.loop
	tst.l 	(a2) 
	beq.b 	.end
 if DEBUG
    movem.l (a2),d0/d1
    DPRINT  "Freemem %lx %lx"
 ENDIF

	move.l	(a2),a1
	move.l	4(a2),d0
	lore 	Exec,FreeMem
	clr.l	(a2)+
	clr.l	(a2)+
	bra.b 	.loop
.end 
	clr.l	deliLoadFileIoErr(a5)
	clr.l	deliLoadFileArray(a5)
.xy 
	rts	


* in:
*   d0 = tag to find
* out:
*   d0 = tag data or NULL if not found
deliGetTag
	* This is a ptr to a seglist, loaded with LoadSeg()
	move.l	deliPlayer(a5),a0
deliGetTagFromA0
	* tag item array
	move.l	16(a0),a0
.loop
    ;cmp.l  #TAG_END,(a0)
    tst.l   (a0)            * TAG_END is NULL
    beq.b   .notFound
    cmp.l   (a0),d0
    bne.b   .notThis
    move.l  4(a0),d0
    rts
.notFound
	moveq   #0,d0
	rts
.notThis
    addq.l  #8,a0
    bra.b   .loop

deliCallFunc	
	tst.l	d0 
	beq.b	.noFunc
	DPRINT	"Call %lx"
	pushm 	d2-d7/a2-a6
	move.l	deliBase(a5),a5
	move.l	d0,a0
	jsr	(a0)
	popm	d2-d7/a2-a6
.noFunc rts

* in:
*   d0: deliplayer or delicustom address from loadseg
* out:
*   d0: 0=all ok, negative ier_-code otherwise
deliInit:
	pushm	d1-a6	
	DPRINT	"deliInit 0x%lx"
	move.l	d0,deliPlayer(a5)
	move	playertype(a5),deliPlayerType(a5)
	bsr	buildDeliBase
	tst.l	d0
	beq	.noMemError
	move.l	deliBase(a5),a4

	* Quite important to clear the old ones away
	* so that they don't get accidentally called
	* on new modules and crash.
	clr.l	deliStoredInterrupt(a5)
	clr.l	deliStoredSetVolume(a5)
	clr.l	deliStoredSetVoices(a5) 
	clr.l	deliStoredNoteStruct(a5) 
	clr.l	deliStoredGetPositionNr(a5)
	clr.l	deliPatternInfo(a5)
	
 if DEBUG
 	move.l	#DTP_PlayerName,d0 
	bsr	deliGetTag 
	beq.b	.noPlr
	DPRINT	"Name: %s"
.noPlr

	bsr	deliShowTags
	bsr	deliShowFlags
 endif

	* Order in DT
	* InitPlayer
	* SubSongRange
	* SubSongRange
	* Volume
	* Volume
	* InitSound (dtg_SndNum=1)
	* SubSongRange	

	move.l	#DTP_DeliBase,d0
	bsr	deliGetTag
	beq.b	.noDBTag
	move.l	d0,a0 
	move.l	a4,(a0)
.noDBTag

	move.l	#EP_EagleBase,d0
	bsr	deliGetTag
	beq.b	.noEBTag
	move.l	d0,a0 
	move.l	a4,(a0)
.noEBTag

	move.l	#DTP_Config,d0  
	bsr	deliGetTag
	bsr	deliCallFunc

	* For ImpulseTracker support:
	move.l	#DTP_InitNote,d0  
	bsr	deliGetTag
	bsr	deliCallFunc

	move.l	#DTP_CustomPlayer,d0
	bsr	deliGetTag
	bne	.checksOk

	* Checks! Run through known ones
	* and accept if one of these accepts.
	
	move.l	#DTP_Check2,d0  
	bsr	deliGetTag
	beq.b	.noCheck2
	bsr	deliCallFunc
	DPRINT	"DTP_Check2: %ld"
	tst.l	d0
	beq.b	.checksOk
.noCheck2	
	move.l	#EP_Check3,d0  
	bsr	deliGetTag
	beq.b	.noCheck3
	bsr	deliCallFunc
	DPRINT	"EP_Check3: %ld"
	tst.l	d0
	beq.b	.checksOk
.noCheck3
	move.l	#EP_Check5,d0  
	bsr	deliGetTag
	;beq.b	.noCheck5
	beq	.checkError
	bsr	deliCallFunc
	DPRINT	"EP_Check5: %ld"
	tst.l	d0
	bne	.checkError
.noCheck5

.checksOk
	bsr	funcENPP_ClearCache  ; Extra safety

	move.l	#EP_InitAmplifier,d0 
	bsr	deliGetTag 
	bsr	deliCallFunc

	move.l	#EP_PatternInit,d0  
	bsr	deliGetTag
	beq.b	.noPattInit
	bsr	deliCallFunc
	move.l	a0,deliPatternInfo(a5)
.noPattInit

	move.l	#EP_Flags,d0
	bsr	deliGetTag
	beq.b	.noFlags
	bsr	deliHandleFlags
.noFlags

	move.l	#DTP_ExtLoad,d0  
	bsr	deliGetTag
	beq.b	.noExtLoad
	bsr	deliCallFunc
	DPRINT	"DTP_ExtLoad: %lx"
	tst.l	d0
	bne	.extLoadError
.noExtLoad

	move.l	#EP_StructInit,d0
	bsr	deliGetTag
	beq.b	.noUPS
	bsr	deliCallFunc	
	move.l	a0,deliUPSStruct(a5)
	;beq	.noUPS
	;move.l	playerbase(a5),a0
	;or	#pf_scope!pf_quadscopeUps,p_liput(a0)
;	DPRINT	"Quadscope supported"
.noUPS
 
	move.l	#DTP_InitPlayer,d0  
	bsr	deliGetTag
	bsr	deliCallFunc	
	* Status is returned in d0, can't rely on status flags
	* here. d0=0 if ok, else not ok
	tst.l	d0
	bne	.initError
	DPRINT	"initPlayer ok"

	bsr	funcENPP_ClearCache  ; Extra safety

	* set default song number
	bsr	    deliGetSongInfo
    tst     songnumber(a5)
    beq     .def
    * Use previosly set songnumber if available
    move    songnumber(a5),d0
.def
	* d0 = def, d1 = min, d2 = max	
	move.l	deliBase(a5),a0
	move	d0,dtg_SndNum(a0)
	move	d0,songnumber(a5)
	move	d1,minsong(a5)
	move	d2,maxsongs(a5)	

	move.l	#DTP_Volume,d0  
	bsr	deliGetTag
	move.l	d0,deliStoredSetVolume(a5)

	move.l	#EP_Voices,d0  
	bsr	deliGetTag
	move.l	d0,deliStoredSetVoices(a5)

	move.l	#DTP_NoteStruct,d0  
	bsr	deliGetTag
	beq.b 	.noNoteStruct
	* This is an address to the struct
	move.l	d0,a0
	move.l	(a0),a0
	move.l	a0,deliStoredNoteStruct(a5)
 if DEBUG 
	bsr	deliShowNoteStruct
 endif 
.noNoteStruct

	move.l	#DTP_InitSound,d0  
	bsr	deliGetTag
	bsr	deliCallFunc	
	* Does not return error code

	DPRINT	"InitSound ok"
	bsr	funcENPP_ClearCache  ; Extra safety

	* Get position info if available
	bsr	deliUpdatePositionInfo

	move.l	#DTP_Interrupt,d0  
	bsr	deliGetTag
	move.l	d0,deliStoredInterrupt(a5)	

	move.l	#DTP_StartInt,d0
	bsr	deliGetTag
	beq.b	.noStartInt
	DPRINT	"using module interrupt"
	bsr	deliCallFunc
	* DTP_StartInt overrides DTP_Interrupt
	clr.l	deliStoredInterrupt(a5)
	bra.b	.skip
.noStartInt

	* see if an interrupt routine is provided.
	* if so, set up a cia interrupt to drive it.
	* otherwise assume the module handles it.
	tst.l	deliStoredInterrupt(a5)
	beq.b	.skip
	* If running PS3M, do not start interrupts.
	* PS3M will handle it.
	cmp	#pt_multi,playertype(a5)
	beq.b 	.skip

	DPRINT	"using hippo interrupt"
 
	* interrupt routine provided, set up an interrupt
	move	dtg_Timer(a4),d0
	jsr	init_ciaint_withTempo
	beq.b	.gotCia
	DPRINT	"cia error"

	* try to clean up
	move.l	#DTP_EndSound,d0  
	bsr	deliGetTag
	bsr	deliCallFunc	
	move.l	#DTP_EndPlayer,d0  
	bsr	deliGetTag
	bsr	deliCallFunc	

	moveq	#ier_nociaints,d0
	bra.b	.ciaError
.gotCia
.skip

 if DEBUG
	moveq	#0,d0
	move	dtg_Timer(a4),d0
	DPRINT	"init ok, dtg_Timer=%ld"
 endif

; TEST RUN
 ifne DELI_TEST_MODE
 	move	#1-1,d0
.bbb
	pushm all
	move.l	deliStoredInterrupt(a5),a0 
	move.l	deliBase(a5),a5
	;jsr	 (a0)
	popm all
	dbf	d0,.bbb
 endc
	* ok
	moveq	#0,d0
.ciaError
.exit
	popm	d1-a6
	rts

.checkError
	moveq	#ier_unknown,d0
	bra.b	.exit
.noMemError
	moveq	#ier_nomem,d0 
	bra.b 	.exit

.initError
	DPRINT	"InitPlayer error: %ld"
	tst.l	deliLoadFileIoErr(a5)
	bne.b	.ioErr
	lea	.initErrMsg(pc),a0 
	bra.b	.showErr

.extLoadError
	tst.l	deliLoadFileIoErr(a5)
	bne.b 	.ioErr
	lore	Dos,IoErr 
	bra.b	.ioErr2

.ioErr
	move.l	deliLoadFileIoErr(a5),d0
.ioErr2
	tst.b	uusikick(a5)
	bne.b	.newIoErr
.oldIoErr
	lea	.ioErrMsg(pc),a0 
.showErr
	jsr	desmsg
.ioErr3
	lea	 desbuf(a5),a1 
	jsr	 request
	moveq	#ier_eagleplayer,d0
	bra.b	.exit

.newIoErr
	tst.l	d0
	beq.b	.oldIoErr

	lea	.ioErrMsg2(pc),a3
	clr.b	(a3)
	move.l	d0,d1 
	pushpea	.ioErrMsg(pc),d2
	pushpea desbuf(a5),d3
	moveq	#100,d4
	lore	Dos,Fault
	move.b	#' ',(a3)
	bra.b	.ioErr3

.initErrMsg 
	dc.b	"Eagleplayer init error (%ld)",0
.ioErrMsg
	dc.b	"Error loading additional module data"
.ioErrMsg2
	dc.b	" (%ld)",0
 even


* Read module info values
* in:
*   d1: info value to find
* out:
*   d0: value, or -1 if not found
deliFindInfoValue
	move.l	#EP_Get_ModuleInfo,d0
	bsr	deliGetTag
	beq.b 	.tryAnother
	bsr	deliCallFunc
	bra.b	.gotIt
.tryAnother
	move.l	#EP_NewModuleInfo,d0 
	bsr	deliGetTag
	beq.b 	.notFound
	move.l	d0,a0
.gotIt
	* a0 = module info table
.loop
	move.l	(a0)+,d0
	beq.b  .end 
	cmp.l	d1,d0 
	beq.b 	.found
	addq.l	#4,a0
	bra.b  .loop
.found 
	move.l (a0),d0 
.end 
	rts
.notFound 
	moveq	#-1,d0 
	rts 

* After InitSound this updates the max position info
deliUpdatePositionInfo	
	clr	pos_maksimi(a5)
	move.l	#EP_GetPositionNr,d0  
	bsr	deliGetTag
	move.l	d0,deliStoredGetPositionNr(a5) 
	beq.b	.noPos
	move.l	#MI_Length,d1
	bsr.b	deliFindInfoValue 
	bmi.b 	.noPos
	beq.b	.noPos
	move	d0,pos_maksimi(a5)
	move.l	playerbase(a5),a0 
	or	#pf_poslen,p_liput(a0)
	rts
.noPos
	move.l	playerbase(a5),a0 
	move	p_liput(a0),d0
	bclr	#pb_poslen,d0
	move	d0,p_liput(a0)
	rts

* out:
*  d0=default song
*  d1=min song
*  d2=max song
deliGetSongInfo
	move.l	#DTP_SubSongRange,d0  
	bsr	deliGetTag
	beq.b	.noSubSongs1
	bsr	deliCallFunc
	move.l	d1,d2
	move.l	d0,d1
	move.l	playerbase(a5),a0 
	or	#pf_song,p_liput(a0)
	DPRINT	"Subsongs def=%ld min=%ld max=%ld"
	rts

.noSubSongs1
	move.l	#DTP_NewSubSongRange,d0  
	bsr	deliGetTag
	beq.b	.noSubSongs2
	move.l	d0,a0
	movem	(a0),d0/d1/d2
	move.l	playerbase(a5),a0 
	or	#pf_song,p_liput(a0)
	DPRINT	"NewSubSongs def=%ld min=%ld max=%ld"
	rts
	
.noSubSongs2
	DPRINT	"No subsongs"
	move.l	playerbase(a5),a0 
	and	#~pf_song,p_liput(a0)
	moveq	#0,d0 
	moveq	#0,d1 
	moveq	#0,d2	
	rts	

* Interrupt play routine, use cached pointers to avoid tag searches
deliInterrupt:
deliPlay:
	move.l	a5,a4
	push	a4
	move.l	deliBase(a5),a5
	move	mainvolume(a4),d0
	move	d0,dtg_SndVol(a5)
	move	d0,EPG_Voice1Vol(a5)
	move	d0,EPG_Voice2Vol(a5)
	move	d0,EPG_Voice3Vol(a5)
	move	d0,EPG_Voice4Vol(a5)

	move.l	deliStoredSetVoices(a4),d0 
	beq.b 	.noSetVoices
	move.l	d0,a0
	* Enable all channels
	moveq	#%1111,d0
	jsr 	(a0)
	move.l	(sp),a4
.noSetVoices

	move.l	deliStoredInterrupt(a4),d0
	beq.b	.noInt
	move.l	d0,a0
 ifne DELI_TEST_MODE
	move	#$500,$dff180
 else
	jsr	(a0)
 endif
	move.l	(sp),a4
.noInt

	move.l	deliStoredSetVolume(a4),d0
	beq.b	.noVol
	move.l 	d0,a0
	jsr	(a0)
	move.l	(sp),a4
.noVol

	move.l	deliStoredGetPositionNr(a4),d0
	beq.b 	.noPos 
	move.l 	d0,a0
	jsr	(a0)
	move.l	(sp),a4
	tst	d0
	bmi.b	.noPos
	move	d0,pos_nykyinen(a4)
.noPos	
	pop 	a4
	
	pushm	a4/a5/a6
	move.l	deliStoredNoteStruct(a4),d0 
	bsr	deliNotePlayer
	popm	a4/a5/a6
	rts

deliEnd:
	pushm	d1-a6
	DPRINT	"deliEnd"
	
	move.l	deliStoredInterrupt(a5),d0
	beq.b	.noIntUsed
	jsr    	rem_ciaint
.noIntUsed

	move.l	#DTP_StopInt,d0
	bsr	deliGetTag
	bsr	deliCallFunc

	move.l	#DTP_EndSound,d0  
	bsr	deliGetTag
	bsr	deliCallFunc

	move.l	#DTP_EndPlayer,d0  
	bsr	deliGetTag
	bsr	deliCallFunc
	
	move.l	#EP_StructEnd,d0  
	bsr	deliGetTag
	bsr	deliCallFunc

	jsr  	clearsound

	move.l	#EP_EjectPlayer,d0
	bsr	deliGetTag
	bsr	deliCallFunc
	
	popm	d1-a6
	rts

deliSong
	bsr.b	deliStop
	bsr	deliGetSongInfo
	* returns
	* d1 = min song
	* d2 = max song
	
	move	songnumber(a5),d0

	* clamp d0 within d1-d2
	jsr	clampWord
	move	d0,songnumber(a5)

	DPRINT	"deliSong set: %ld"
	
	* Put it, wrong number may crash some players
	move.l deliBase(a5),a0
	move	d0,dtg_SndNum(a0)

	move.l	#DTP_InitSound,d0
	bsr	deliGetTag
	bsr	deliCallFunc
	move.l	#DTP_StartInt,d0
	bsr	deliGetTag
	bsr	deliCallFunc
	bra	deliUpdatePositionInfo

* Not sure what exactly should be done with these two.
* Seems to work more or less.
deliStop
	DPRINT	"deliStop"
	move.l	#DTP_EndSound,d0
	bsr	deliGetTag
	;bsr	deliCallFunc	;;**
	move.l	#DTP_StopInt,d0
	bsr	deliGetTag
	bsr	deliCallFunc
	jsr	clearsound
	;move	#$f,$dff096
	rts

deliCont
	DPRINT	"deliCont"
	move.l	#DTP_InitSound,d0
	bsr	deliGetTag
	;bsr	.callFunc
	move.l	#DTP_StartInt,d0
	bsr	deliGetTag
	bsr	deliCallFunc
	move	#$800f,$dff096
	rts

deliForward
	DPRINT	"deliForward"
	move.l	#DTP_NextPatt,d0
	bsr	deliGetTag
	bra	deliCallFunc

deliBackward
	DPRINT	"deliBackward"
	move.l	#DTP_PrevPatt,d0
	bsr	deliGetTag
	bra	deliCallFunc

deliVolume	
	move.l	deliBase(a5),a0
	move	mainvolume(a5),d0
	move	d0,dtg_SndVol(a0)
	move	d0,EPG_Voice1Vol(a0)
	move	d0,EPG_Voice2Vol(a0)
	move	d0,EPG_Voice3Vol(a0)
	move	d0,EPG_Voice4Vol(a0)
	move.l	deliStoredSetVolume(a5),d0
	beq.b	.noVol
	move.l 	d0,a1
	push	a5
	move.l	a0,a5	
	jsr	(a1)
	pop 	a5
.noVol
	rts

deliAuthor
	rts
	;move.l	#DTP_Creator,d0
	;bra	deliGetTag
	
freeDeliBase
	tst.l	deliData(a5)
	beq.b	.x

	move.l deliData(a5),a0 
	jsr 	freemem 
.x	clr.l	deliData(a5)   
    clr.l   deliLoadFileArray(a5)
	rts 



* Build the DeliBase structure, this is not a complete version.
buildDeliBase:
	bsr.b	freeDeliBase

	rsreset 
_eagleJumpTable 	rs.b 	-ENPP_SizeOf
_deliBase		rs.b 	EPG_SizeOf 
_deliPath		rs.b    200
_deliPathArray		rs.b   	200
_upsStructure 		rs.b  	UPS_SizeOF
* Space for 128 (address, length) pairs for dtg_LoadFile 
_loadFileArray		rs.l 	2*DELI_LIST_DATA_SLOTS
_deliDataSize		rs.b	0

	move.l	#_deliDataSize,d0
	move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
	jsr	getmem
	bne.b 	.ok 
	rts
.ok
	move.l 	d0,deliData(a5)
	move.l	d0,a4

	lea	_deliBase(a4),a0 
	move.l	a0,deliBase(a5)

	* InStereo2 uses this private structure
	lea	_upsStructure(a4),a1
	move.l	a1,EPG_UPS_Structure(a0)

	lea	_loadFileArray(a4),a1
	move.l	a1,deliLoadFileArray(a5)

	lea	_deliPath(a4),a1
	move.l	a1,deliPath(a5)
	move.l	a1,dtg_DirArrayPtr(a0)

	lea	_deliPathArray(a4),a1
	move.l	a1,deliPathArray(a5)
	move.l	a1,dtg_PathArrayPtr(a0)

	push	a0
	jsr	getcurrent 
	pop 	a0
	* a3 = node
	
	* Grab path and file parts
	* Name without path to A1
	move.l	l_nameaddr(a3),a1

	tst.b	l_remote(a3)
	beq.b	.notRemote
	* Remote l_nameaddr may contain an extra
	* path part: part1/part2.ext. Skip this
	* as it will confuse file loading later.
.r1	tst.b	(a1)+
	bne.b	.r1
.r2	cmp.b	#"/",-(a1)
	bne.b	.r2
	addq	#1,a1
.notRemote

	move.l	a1,dtg_FileArrayPtr(a0)
	* Full path to A2
	lea	l_filename(a3),a2
	move.l	deliPath(a5),a3
	push	a2
.copy	move.b	(a2)+,(a3)+
	cmp.l	a2,a1
	bne.b	.copy
	clr.b	(a3)		

	* The full path needs to be populated here, too.
	* "Test drive 2" uses it, for example.
	pop	a2
	move.l	deliPathArray(a5),a1
.c2	move.b	(a2)+,(a1)+
	bne.b	.c2 


 if DEBUG
	move.l	dtg_FileArrayPtr(a0),d0
	DPRINT	"File: %s"
	move.l	dtg_DirArrayPtr(a0),d0
	DPRINT	"Dir: %s"
 endif

	move.l	_DosBase(a5),dtg_DOSBase(a0)
	move.l	_IntuiBase(a5),dtg_IntuitionBase(a0)
	move.l	_GFXBase(a5),dtg_GfxBase(a0)
	
	; Illegal address for enforcer
	move.l	#$10000000,dtg_GadToolsBase(a0)
	move.l	#$10000000,dtg_AslBase(a0)

	clr	dtg_SndNum(a0) * this must be correct 
	moveq	#64,d0
	move	d0,dtg_SndVol(a0)
	move	d0,dtg_SndLBal(a0)
	move	d0,dtg_SndRBal(a0)
	clr	dtg_LED(a0)

	move	#%1111,EPG_Voices(a0)
	move	d0,EPG_Voice1Vol(a0)
	move	d0,EPG_Voice2Vol(a0)
	move	d0,EPG_Voice3Vol(a0)
	move	d0,EPG_Voice4Vol(a0)
	move	#255,EPG_Volume(a0)
	move	#255,EPG_Balance(a0)
	move	#255,EPG_LeftBalance(a0)
	move	#255,EPG_RightBalance(a0)

	move.l	moduleaddress(a5),dtg_ChkData(a0) 
	move.l	modulelength(a5),dtg_ChkSize(a0)
	* Default timer value is needed by
	* Sonix Sound Driver
	move	#28419/2,dtg_Timer(a0)

	pea	deliAllocAudio(pc)
	move.l	(sp)+,dtg_AudioAlloc(a0)
	pea	deliFreeAudio(pc)
	move.l	(sp)+,dtg_AudioFree(a0)
	pea	dmawait
	move.l	(sp)+,dtg_WaitAudioDMA(a0)
	pea	.startInt(pc)
	move.l	(sp)+,dtg_StartInt(a0)
	pea	.stopInt(pc)
	move.l	(sp)+,dtg_StopInt(a0)
	pea	.songEnd(pc)
	move.l	(sp)+,dtg_SongEnd(a0)	* may be called from interrupt
	pea	.setTimer(pc)
	move.l	(sp)+,dtg_SetTimer(a0)	* may be called from interrupt
	pea	.allocListData(pc)
	move.l	(sp)+,dtg_AllocListData(a0)
	pea	.freeListData(pc)
	move.l	(sp)+,dtg_FreeListData(a0)
	pea	deliCopyString(pc)
	move.l	(sp)+,dtg_CopyString(a0)
	pea	deliCopyFile(pc)
	move.l	(sp)+,dtg_CopyFile(a0)
	pea	deliCopyDir(pc)
	move.l	(sp)+,dtg_CopyDir(a0)
	pea	deliLoadFile(pc)
	move.l	(sp)+,dtg_LoadFile(a0)
	pea	deliGetListData(pc)
	move.l	(sp)+,dtg_GetListData(a0)
	pea	.cutSuffix(pc)
	move.l	(sp)+,dtg_CutSuffix(a0)

	pea	deliModuleChange(pc)
	move.l	(sp)+,EPG_ModuleChange(a0)

	* Stub the rest
 	lea	.stub(pc),a1
	move.l	a1,dtg_LockScreen(a0)
	move.l	a1,dtg_UnlockScreen(a0)
	move.l	a1,dtg_NotePlayer(a0) 	* may be called from interrupt

	* EaglePlayer negative offset jump table
	lea	eagleJumpTableStart(pc),a1
	lea 	eagleJumpTableEnd(pc),a2	
.jumps	
	move.l	a1,a3
	add	(a1)+,a3
	move.l	a3,-(a0)	; jmp destination
	move	#$4ef9,-(a0) ; jmp
	cmp.l	a1,a2
	bne.b	.jumps
	; Ensure jump table code is flushed
	bra 	funcENPP_ClearCache

.songEnd
	* May be called from interrupt, no logging allowed
	pushm	d0/a0/a5
	lea	var_b,a5
	move.l	playerbase(a5),a0 
	move	p_liput(a0),d0 
	and	#pf_end,d0
	beq.b	.noSongEnd
	st	songover(a5)
.noSongEnd
	popm 	d0/a0/a5
	rts

.setTimer
	* May be called from interrupt, no logging allowed
	push	d0
	move	dtg_Timer(a5),d0
	jsr	ciaint_setTempoFromD0
	pop 	d0 
	rts

.stub
	moveq	#0,d0
.dummyEagleFunc
	rts

.startInt	
	DPRINT 	"deliStartInt"
	moveq	#0,d0
	rts
.stopInt 
	DPRINT	"deliStopInt"
	moveq	#0,d0
	rts
.cutSuffix 
	DPRINT	"cutSuffix"
	moveq	#0,d0
	rts

* AllocListData(Size:d0/Flags:d1)
* In: 
*   d0 = size to allocate
*   d1 = AllocMem flags
* Out:
*   d0 = Pointer to allocated memory
.allocListData
	DPRINT	"allocListData %ld %lx"
	* used by stonetracker
	pushm	d1-a6
	lea	var_b,a5
	move.l	d0,d6
	move.l	d1,d7
	bsr	deliFindEmptyListDataSlot
	bne.b	.err
	move.l	a1,a3 
	move.l	d6,d0
	move.l	d7,d1
    tst.w   deliForceAllocPublicMem(a5)
    beq     .fal
    moveq   #MEMF_PUBLIC,d1
.fal
	lore 	Exec,AllocMem
	tst.l 	d0 
	beq.b 	.err
	* Store into list data slot
	movem.l	d0/d6,(a3)
.allocListDataX
 	popm 	d1-a6
	rts
.err
	moveq	#0,d0
	bra.b 	.allocListDataX
	
* FreeListData(MemBlock:a1)
* In:
*   a1 =  memoryBlock - pointer to the memory block to free, or NULL.
.freeListData
	DPRINT	"freeListData"
	moveq	#0,d0
	rts

deliAllocAudio 
	DPRINT	"deliAudioAlloc"
	pushm	d1-a6
	lea	var_b,a5
	* returns d0=0 on success:
	jsr	varaa_kanavat 
	popm	d1-a6
	rts

deliFreeAudio 
	DPRINT	"deliAudioFree"
	pushm	d1-a6
	lea	var_b,a5
	jsr	vapauta_kanavat
	popm	d1-a6
	rts

deliCopyString move.l a0,d0
	bsr	deliAppendStr
 if DEBUG
	move.l	deliPathArray+var_b,d1
	DPRINT	"copyString %s path=%s"
 endif
	moveq	#0,d0
	rts
deliCopyFile 
	move.l	dtg_FileArrayPtr(a5),a0
	bsr	deliAppendStr
 if DEBUG
	move.l	deliPathArray+var_b,d0
	DPRINT	"copyFile path=%s"
 endif
	moveq	#0,d0
	rts
deliCopyDir 
	move.l	dtg_DirArrayPtr(a5),a0
	bsr	deliAppendStr
 if DEBUG
	move.l	deliPathArray+var_b,d0
	DPRINT	"copyDir path=%s"
 endif
	moveq	#0,d0
	rts
deliLoadFile
 if DEBUG
	move.l	deliPathArray+var_b,d0
	DPRINT	"loadFile '%s'"
 endif
	pushm	d1-a6
	lea 	var_b,a5

	* Find empty loadfile slot
	bsr		deliFindEmptyListDataSlot
	bne		.noSlots
	lea	4(a1),a2

	move.l	#MEMF_CHIP!MEMF_CLEAR,d0
	move.l	deliPathArray+var_b,a0

	* Manipulate path so that the file part is in lowercase.
	* Amiga filesystems are case insensitive,
	* but this will help with Modland being lower case.
	* Eagleplayers may add unpredictable file suffixes here,
	* lowercase is the most likely one to work.
	move.l	a0,a3
.1	tst.b	(a3)+
	bne.b	.1

.2	cmp.l	a0,a3
	beq.b	.3
	cmp.b	#'/',-(a3)
	beq.b	.3
	move.b	(a3),d1
	cmp.b	#'A',d1
	blo.b	.2
	cmp.b	#'Z',d1
	bhi.b	.2
	or.b	#$20,(a3) * lower case alphabet
	bra.b	.2
.3
	
	* a0 <= file path to load
	* a1 <= address to store data address
	* a2 <= address to store length
	jsr	loadfileStraight
	clr.l 	deliLoadFileIoErr(a5)
	move.l	d0,d7
	beq.b	.ok	
	lore 	Dos,IoErr
	move.l	d0,deliLoadFileIoErr(a5)
.ok
	move.l	d7,d0
 if DEBUG
	move.l	(a1),d1
	move.l	(a2),d2
	move.l	deliLoadFileIoErr(a5),d3
	DPRINT "deliLoad=%ld addr=%lx len=%ld err=%ld"
 endif
.noSlots
	popm	d1-a6
	
 * 0 = success, non-0: fail
	rts

* out:
*   a1 = empty slot for (addr,len) pair
deliFindEmptyListDataSlot
	move.l	deliLoadFileArray(a5),a1
	moveq	#0,d0
.find
	cmp	#DELI_LIST_DATA_SLOTS,d0 
	beq.b	.error 
	tst.l	(a1)
	beq.b	.found
	addq.l	#8,a1
	addq	#1,d0
	bra.b 	.find
.found
	moveq	#0,d0
	rts
.error 
	moveq	#-1,d0 
	rts 

* Get loaded data
* in: 
*   d0 = file number. 0 is the original module, 
*                     1 is the 1st loaded file with dtg_LoadFile, etc
deliGetListData 
	DPRINT	"getListData %ld"
	tst.l	d0 
	beq.b	.first

	* Grab (addr,len) so that index 1 corresponds to the first item.
	pushm	d3/a1
	move.l	deliLoadFileArray+var_b,a1
	move	d0,d3
	lsl	#3,d3

 if DEBUG
 	move.l	-8(a1,d3),d0
	move.l	-8+4(a1,d3),d1
	DPRINT	"0x%lx %ld"
 endif
	move.l	-8(a1,d3),a0
	move.l	-8+4(a1,d3),d0
	popm	d3/a1
	rts
.first
 if DEBUG
	move.l	moduleaddress+var_b,d0
	move.l	modulelength+var_b,d1
	DPRINT	"0x%lx %ld"
 endif
	move.l	moduleaddress+var_b,a0
	move.l	modulelength+var_b,d0
	rts

deliAppendStr
	move.l 	dtg_PathArrayPtr(a5),a1 
.1	tst.b 	(a1)+
	bne.b 	.1
	subq	#1,a1
.2	move.b 	(a0)+,(a1)+
	bne.b 	.2
	rts

* First negative offset is first, -6
eagleJumpTableStart
	dr.w funcENPP_AllocSampleStruct
	dr.w funcENPP_NewLoadFile2
	dr.w funcENPP_MakeDirCorrect
	dr.w funcENPP_TestAufHide
	dr.w funcENPP_ClearCache
	dr.w funcENPP_CopyMemQuick
	dr.w funcENPP_GetPassword
	dr.w funcENPP_StringCopy2
	dr.w funcENPP_ScreenToFront
	dr.w funcENPP_WindowToFront
	dr.w funcENPP_GetListData
	dr.w funcENPP_LoadFile    **
	dr.w funcENPP_CopyDir 	 **
	dr.w funcENPP_CopyFile    **
	dr.w funcENPP_CopyString
	dr.w funcENPP_AllocAudio
	dr.w funcENPP_FreeAudio
	dr.w funcENPP_StartInterrupt
	dr.w funcENPP_StopInterrupt
	dr.w funcENPP_SongEnd
	dr.w funcENPP_CutSuffix
	dr.w funcENPP_SetTimer
	dr.w funcENPP_WaitAudioDMA
	dr.w funcENPP_SaveMem
	dr.w funcENPP_FileReq
	dr.w funcENPP_TextRequest
	dr.w funcENPP_LoadExecutable
	dr.w funcENPP_NewLoadFile
	dr.w funcENPP_ScrollText
	dr.w funcENPP_LoadPlConfig
	dr.w funcENPP_SavePlConfig
	dr.w funcENPP_FindTag
	dr.w funcENPP_FindAuthor
	dr.w funcENPP_Hexdez
	dr.w funcENPP_TypeText
	dr.w funcENPP_ModuleChange
	dr.w funcENPP_ModuleRestore
	dr.w funcENPP_StringCopy
	dr.w funcENPP_CalcStringSize
	dr.w funcENPP_StringCMP
	dr.w funcENPP_DMAMask	 	*
	dr.w funcENPP_PokeAdr		*	 
	dr.w funcENPP_PokeLen		*
	dr.w funcENPP_PokePer		*
	dr.w funcENPP_PokeVol		*
	dr.w funcENPP_PokeCommand	* filter toggle
	dr.w funcENPP_Amplifier
	dr.w funcENPP_TestAbortGadget
	dr.w funcENPP_GetEPNrfromMessage
	dr.w funcENPP_InitDisplay
	dr.w funcENPP_FillDisplay
	dr.w funcENPP_RemoveDisplay
	dr.w funcENPP_GetLocaleString
	dr.w funcENPP_SetWaitPointer
	dr.w funcENPP_ClearWaitPointer
	dr.w funcENPP_OpenCatalog
	dr.w funcENPP_CloseCatalog
	dr.w funcENPP_AllocAmigaAudio
	dr.w funcENPP_FreeAmigaAudio
	dr.w funcENPP_RawToFormat
	dr.w funcENPP_FindAmplifier
	dr.w funcENPP_UserCallup5
	dr.w funcENPP_GetLoadListData
	dr.w funcENPP_SetListData
	dr.w funcENPP_GetHardwareType
eagleJumpTableEnd

funcENPP_ClearCache
	;DPRINT "ENPP_ClearCache"
	jmp clearCpuCaches
funcENPP_GetListData
	bra	deliGetListData
funcENPP_LoadFile
	bra	deliLoadFile
funcENPP_CopyDir
	DPRINT "ENPP_CopyDir"
	bra	deliCopyDir
funcENPP_CopyFile
	DPRINT "ENPP_CopyFile"
	bra	 deliCopyFile
funcENPP_CopyString
	DPRINT "ENPP_CopyString"
	bra	deliCopyString
funcENPP_AllocAudio
	DPRINT "ENPP_AllocAudio"
	bra deliAllocAudio
funcENPP_FreeAudio
	DPRINT "ENPP_FreeAudio"
	bra deliFreeAudio
funcENPP_SongEnd
	;DPRINT "ENPP_SongEnd"
	jmp	 dtg_SongEnd(a5)
funcENPP_SetTimer
	;DPRINT "ENPP_SetTimer"
	jmp dtg_SetTimer(a5)
funcENPP_WaitAudioDMA
	;DPRINT "ENPP_WaitAudioDMA"
	jmp dmawait
funcENPP_ModuleChange
	DPRINT "ENPP_ModuleChange"
	bra	deliModuleChange
funcENPP_AllocAmigaAudio
	;DPRINT "ENPP_AllocAmigaAudio"
	bra	deliAllocAudio
funcENPP_FreeAmigaAudio
	;DPRINT "ENPP_FreeAmigaAudio"
	bra deliFreeAudio

* Sequence (kpl14.s):
* - Stop channel DMAs
* - Set sample start and sample length
* - Large DMA wait
* - Enable channel DMAs
* - Small DMA wait
* - Set loopstart and replen for enabled channels

* Sequence (noteplayer):
* - Stop channel DMAs, ENPP_DMAMask
* - Set sample:
*   - ENPP_PokeAdr, ENPP_PokeLen
*   - ENPP_PokeVol, ENPP_PokePer
* - Start channel DMAs, ENPP_DMAMask
* - Set sample loop:
*   - ENPP_PokeAdr, ENPP_PokeLen

* In:
*   d0 = negative: enable DMA, positive: disable DMA
*   d1 = DMA audio flags %abcd
funcENPP_DMAMask
	;move	#$f00,$dff180

	push	d1
	tst	d0
	bpl.b	.clr
	or	#$8000,d1
	move	d1,$dff096
;	* Set scope trigger bits
	or.b	d1,scopeData+scope_trigger+var_b
	jsr	dmawait
	pop 	d1
	rts

.clr
	move	d1,$dff096
	not.b	d1
	* Clear scope trigger bits
	and.b	d1,scopeData+scope_trigger+var_b
	jsr	dmawait
	pop 	d1
	rts

* In:
*   d0 = address
*   d1 = channel 0..3
funcENPP_PokeAdr
	pushm	d2/d3/a0/a1
	moveq	#3,d2
	and	d1,d2
	lsl	#4,d2
	lea	$dff0a0,a0
	move.l	d0,(a0,d2)

	* Set sample start if DMA is not enabled,
	* otherwise set loopstart
 	lea	var_b,a0
 	move	#pf_quadscopePoke,d3
 	move.l	playerbase(a0),a1
 	and	p_liput(a1),d3
 	beq.b	.2

	lea	scopeData(a0),a0
	moveq	#1,d3
	lsl	d1,d3
	and.b	scope_trigger(a0),d3
	bne.b	.1
	move.l	d0,ns_start+scope_ch1(a0,d2)
.1
	move.l	d0,ns_loopstart+scope_ch1(a0,d2)
.2
	popm	d2/d3/a0/a1
	rts
	
* In:
*   d0 = length
*   d1 = channel 0..3
funcENPP_PokeLen
	pushm	d2/d3/a0/a1
	moveq	#3,d2
	and	d1,d2
	lsl	#4,d2
	tst	d0
	bne.b	.nozero
	moveq	#1,d0
.nozero
	lea	$dff0a0,a0
	move	d0,4(a0,d2)

 	* Set sample len if DMA is not enabled,
	* otherwise set looplen
 	lea	var_b,a0
 	move	#pf_quadscopePoke,d3
 	move.l	playerbase(a0),a1
 	and	p_liput(a1),d3
 	beq.b	.2

	lea	scopeData(a0),a0
	moveq	#1,d3
	lsl	d1,d3
	and.b	scope_trigger(a0),d3
	bne.b 	.1
	move	d0,ns_length+scope_ch1(a0,d2)
.1
	move	d0,ns_replen+scope_ch1(a0,d2)
.2
	popm	d2/d3/a0/a1
	rts

* In:
*   d0 = period
*   d1 = channel 0..3
funcENPP_PokePer
	pushm	d2/d3/a0/a1
	moveq	#3,d2
	and	d1,d2
	lsl	#4,d2
	lea	$dff0a0,a0
	move	d0,6(a0,d2)

	lea	var_b,a0
 	move	#pf_quadscopePoke,d3
 	move.l	playerbase(a0),a1
 	and	p_liput(a1),d3
 	beq.b	.1

	lea	scopeData(a0),a0
	move	d0,ns_period(a0,d2)
.1
	popm	d2/d3/a0/a1
	rts

* In:
*   d0 = volume
*   d1 = channel 0..3
funcENPP_PokeVol
	pushm	d2/d3/a0/a1
	moveq	#3,d2
	and	d1,d2
	lsl	#4,d2
	mulu	mainvolume+var_b,d0
	lsr	#6,d0
	lea	$dff0a0,a0
	move	d0,8(a0,d2)

 	lea	var_b,a0
 	move	#pf_quadscopePoke,d3
 	move.l	playerbase(a0),a1
 	and	p_liput(a1),d3
 	beq.b	.1

	lea	scopeData(a0),a0
	CLAMPVOL d0
	move	d0,ns_tempvol(a0,d2)
.1
	popm	d2/d3/a0/a1
	rts

* In:
*   d0 = command
*   d1 = parameter
funcENPP_PokeCommand
	;DPRINT "ENPP_PokeCommand"
	cmp.b	#1,d0 
	bne.b 	.unknown
	* d1=0 -> led off
	* d1=1 -> led on
	tst.b 	d1
	beq.b .off
	bclr	#1,$bfe001
.unknown
	rts
.off 
	bset	#1,$bfe001
	rts

*************** Unimplemented eaglebase functions:

 if DEBUG
funcENPP_Amplifier
	; Called from interrupt, no logging
	;DPRINT "ENPP_Amplifier"
	rts
funcENPP_AllocSampleStruct
	DPRINT "ENPP_AllocSampleStruct"
	rts
funcENPP_NewLoadFile2
	DPRINT "ENPP_NewLoadFile2"
	rts
funcENPP_MakeDirCorrect
	DPRINT "ENPP_MakeDirCorrect"
	rts
funcENPP_TestAufHide
	DPRINT "ENPP_TestAufHide"
	rts
funcENPP_CopyMemQuick
	DPRINT "ENPP_CopyMemQuick"
	rts
funcENPP_GetPassword
	DPRINT "ENPP_GetPassword"
	rts
funcENPP_StringCopy2
	DPRINT "ENPP_StringCopy2"
	rts
funcENPP_ScreenToFront
	DPRINT "ENPP_ScreenToFront"
	rts
funcENPP_WindowToFront
	DPRINT "ENPP_WindowToFront"
	rts
funcENPP_StartInterrupt
	DPRINT "ENPP_StartInterrupt"
	rts
funcENPP_StopInterrupt
	DPRINT "ENPP_StopInterrupt"
	rts
funcENPP_CutSuffix
	DPRINT "ENPP_CutSuffix"
	rts
funcENPP_SaveMem
	DPRINT "ENPP_SaveMem"
	rts
funcENPP_FileReq
	DPRINT "ENPP_FileReq"
	rts
funcENPP_TextRequest
	DPRINT "ENPP_TextRequest"
	rts
funcENPP_LoadExecutable
	DPRINT "ENPP_LoadExecutable"
	rts
funcENPP_NewLoadFile
	DPRINT "ENPP_NewLoadFile"
	rts
funcENPP_ScrollText
	DPRINT "ENPP_ScrollText"
	rts
funcENPP_LoadPlConfig
	DPRINT "ENPP_LoadPlConfig"
	rts
funcENPP_SavePlConfig
	DPRINT "ENPP_SavePlConfig"
	rts
funcENPP_FindTag
	DPRINT "ENPP_FindTag"
	rts
funcENPP_FindAuthor
	DPRINT "ENPP_FindAuthor"
	rts
funcENPP_Hexdez
	DPRINT "ENPP_Hexdez"
	rts
funcENPP_TypeText
	DPRINT "ENPP_TypeText"
	rts
funcENPP_ModuleRestore
	DPRINT "ENPP_ModuleRestore"
	rts
funcENPP_StringCopy
	DPRINT "ENPP_StringCopy"
	rts
funcENPP_CalcStringSize
	DPRINT "ENPP_CalcStringSize"
	rts
funcENPP_StringCMP
	DPRINT "ENPP_StringCMP"
	rts
funcENPP_TestAbortGadget
	DPRINT "ENPP_TestAbortGadget"
	rts
funcENPP_GetEPNrfromMessage
	DPRINT "ENPP_GetEPNrfromMessage"
	rts
funcENPP_InitDisplay
	DPRINT "ENPP_InitDisplay"
	rts
funcENPP_FillDisplay
	DPRINT "ENPP_FillDisplay"
	rts
funcENPP_RemoveDisplay
	DPRINT "ENPP_RemoveDisplay"
	rts
funcENPP_GetLocaleString
	DPRINT "ENPP_GetLocaleString"
	rts
funcENPP_SetWaitPointer
	DPRINT "ENPP_SetWaitPointer"
	rts
funcENPP_ClearWaitPointer
	DPRINT "ENPP_ClearWaitPointer"
	rts
funcENPP_OpenCatalog
	DPRINT "ENPP_OpenCatalog"
	rts
funcENPP_CloseCatalog
	DPRINT "ENPP_CloseCatalog"
	rts
funcENPP_RawToFormat
	DPRINT "ENPP_RawToFormat"
	rts
funcENPP_FindAmplifier
	DPRINT "ENPP_FindAmplifier"
	rts
funcENPP_UserCallup5
	DPRINT "ENPP_UserCallup5"
	rts
funcENPP_GetLoadListData
	DPRINT "ENPP_GetLoadListData"
	rts
funcENPP_SetListData
	DPRINT "ENPP_SetListData"
	rts
funcENPP_GetHardwareType
	DPRINT "ENPP_GetHardwareType"
	rts
 else 
funcENPP_Amplifier
funcENPP_AllocSampleStruct
funcENPP_NewLoadFile2
funcENPP_MakeDirCorrect
funcENPP_TestAufHide
funcENPP_CopyMemQuick
funcENPP_GetPassword
funcENPP_StringCopy2
funcENPP_ScreenToFront
funcENPP_WindowToFront
funcENPP_StartInterrupt
funcENPP_StopInterrupt
funcENPP_CutSuffix
funcENPP_SaveMem
funcENPP_FileReq
funcENPP_TextRequest
funcENPP_LoadExecutable
funcENPP_NewLoadFile
funcENPP_ScrollText
funcENPP_LoadPlConfig
funcENPP_SavePlConfig
funcENPP_FindTag
funcENPP_FindAuthor
funcENPP_Hexdez
funcENPP_TypeText
funcENPP_ModuleRestore
funcENPP_StringCopy
funcENPP_CalcStringSize
funcENPP_StringCMP
funcENPP_TestAbortGadget
funcENPP_GetEPNrfromMessage
funcENPP_InitDisplay
funcENPP_FillDisplay
funcENPP_RemoveDisplay
funcENPP_GetLocaleString
funcENPP_SetWaitPointer
funcENPP_ClearWaitPointer
funcENPP_OpenCatalog
funcENPP_CloseCatalog
funcENPP_RawToFormat
funcENPP_FindAmplifier
funcENPP_UserCallup5
funcENPP_GetLoadListData
funcENPP_SetListData
funcENPP_GetHardwareType
	rts
 endif

* NotePlayer implementation from EaglePlayer sources
deliNotePlayer
	tst.l	d0
	bne.b 	.DT_NotePlayer
	rts
.DT_NotePlayer:	

		;movem.l	a4-a6,-(a7)
		;move.l	PufferAdr(pc),a5
		;move.l	DT_NoteStruct(a5),d0
		;beq	.Return
		move.l	d0,a4
		move.l	4(a4),d7	;Flags
				
		move.l	(a4),d0
		beq	.Return
		move.l	d0,a4

		*--------- neue Note (= DMA off) ---------*
		move.l	a4,a0
		moveq	#4-1,d2
		moveq	#0,d1
		moveq	#1,d3
.pass1		move.b	11(a0),d0
		and.b	#2,d0		;NCHF_Sample
		beq.s	.skip
		or.l	d3,d1		;DMA Mask
.skip		lsl.l	#1,d3
		move.l	(a0),d0
		beq.s	.Last1
		move.l	d0,a0		*add #NoteStruct1-NoteStruct0,a0
		dbf	d2,.pass1
.Last1:
		tst.l	d1
		beq.s	.nostopDMA
		moveq	#0,d0		;D0.w neg=enable ; 0/pos=disable
					;D1 = Maske (LONG !!)
		jsr	ENPP_DMAMask(a5)
		moveq	#0,d0		;D0.w neg=enable ; 0/pos=disable
.nostopDMA:	;move.l	d1,-(a7)
		move.l	d1,d6
	
		*---------- Neue Note setzen -------------*
		move.l	a4,a0
		moveq	#4-1,d2
		moveq	#0,d1
.pass2		move.b	11(a0),d0
		and.b	#2,d0				;NCHF_Sample
		beq.s	.skip2

		move.l	$10(A0),d0			;SampleStart
		jsr	ENPP_PokeAdr(A5)

		moveq	#0,d0
		move.w	nch_SampleLength(a0),d0
		btst	#4,d7
		bne.s	.pokeword1
		move.l	nch_SampleLength(A0),d0		;NCH_SampleLength ;SampleLen
		lsr.l	#1,d0				;Bytes -> Words
.pokeword1:
		jsr	ENPP_PokeLen(a5)
.skip2:		addq	#1,d1
		move.l	(a0),d0
		beq.s	.Last2
		move.l	d0,a0		;add #NoteStruct1-NoteStruct0,a0
		dbf	d2,.pass2
.Last2:

		*-------- Volume/Period neu setzen -------*
		move.l	a4,a0
		moveq	#4-1,d2
		moveq	#0,d1
.pass3
		move.b	11(a0),d0
		and.b	#$10,d0				;NCHF_Volume
		beq.s	.skip3

		move	nch_Volume(a0),d0			;Volume
		jsr	ENPP_PokeVol(a5)
.skip3:		move.b	11(a0),d0
		and.b	#8,d0				;NCHF_Frequency
		beq.s	.skip4

; Only Amiga periods supported in Hippo

;		moveq	#0,d0
;		move.w	$20(A0),d0			;Period (or Frequency)
;		btst	#2,d7
;		bne.s	.extper				;4*Period ?
;		btst	#1,d7				
;		bne.s	.per				;1*Period ?
;							;Frequenz in Period umrechnen
;		moveq	#0,d0
;		move.l	$20(a0),d3			;Frequenz
;		beq	.per				;== 0 ? -> weiter
;		lsr.l	#1,d3
;		move.l	#3546895/2,d0		;Amiga Audiorate
;		divu	d3,d0			;
;		and.l	#$ffff,d0
;		bra.s	.per
;.extper
;		lsr	#2,d0				;noch ersetzen durch DirektWrite bei 4*Per
;.per
		move.w	nch_Frequency(A0),d0		;Period (or Frequency)
		jsr	ENPP_PokePer(a5)
.skip4:		addq	#1,d1
		move.l	(a0),d0
		beq.s	.Last3
		move.l	d0,a0		;add.w #NoteStruct1-NoteStruct0,a0
		dbf	d2,.pass3
.Last3:

		*----- DMA starten (wenn erforderlich) ----*
		;move.l	(a7)+,d1
		move.l	d6,d1
		tst.l	d1
		beq.s	.NostartDMA
		move	#$8000,d0	;D0.w neg=enable ; 0/pos=disable
					;D1 = Maske (LONG !!)
		jsr	ENPP_DMAMask(a5)

		*------ Repeatadr/Repeatlen poken --------*
.NostartDMA:	move.l	a4,a0
		moveq	#4-1,d2
		moveq	#0,d1
.pass4		move.b	11(a0),d0
		and.b	#4!32!64,d0			;NCHF_Repeat
		beq.s	.skip5

		move.l	nch_RepeatStart(a0),d0		;RepeatStart
		jsr	ENPP_PokeAdr(A5)

		moveq	#0,d0
		move.w	nch_RepeatLength(a0),d0		;Repeatlen
		btst	#4,d7
		bne.s	.pokeword2
		move.l	nch_RepeatLength(A0),d0		;NCH_SampleLength ;SampleLen
		lsr.l	#1,d0				;Bytes -> Words
.pokeword2:
		jsr	ENPP_PokeLen(a5)
.skip5:
		clr.b	11(a0)
		addq	#1,d1
		move.l	(a0),d0
		beq.s	.Last
		move.l	d0,a0		*add #NoteStruct1-NoteStruct0,a0
		dbf	d2,.pass4
.Last:

.Return:
;		jsr	ENPP_Amplifier(a5)

		*moveq	#0,d1
		*moveq	#0,d0
		;movem.l	(a7)+,a4-a6
		rts

deliModuleChange
	pushm	all
	DPRINT	"deliModuleChange"
 if DEBUG
	move.l	EPG_ARG1(a5),d0 
	move.l	EPG_ARG2(a5),d1 
	move.l	EPG_ARG3(a5),d2 
	DPRINT	"Start=%lx len=%ld patches=%lx"
	move.l	EPG_ARG4(a5),d0
	move.l	EPG_ARG5(a5),d1 
	DPRINT	"arg4=%lx arg5=%lx"
 endif
	
	; additional args not supported, lol!
	moveq	#1,d0
	cmp.l	EPG_ARG4(a5),d0 
	bne.b	.notSupp
	
	moveq	#-2,d0
	cmp.l	EPG_ARG5(a5),d0 
	bne.b 	.notSupp

	tst.l	EPG_ARG1(a5)
	beq.b	.notSupp

	tst.l	EPG_ARG3(a5)
	beq.b	.notSupp

	tst.l	EPG_ARG2(a5)
	beq.b	.notSupp

	* Data to patch
	move.l	EPG_ARG1(a5),a0
	* PatchTable 
	move.l	EPG_ARG3(a5),a1 
	* Length of data to patch
	move.l 	EPG_ARG2(a5),d1 
	
	* Keep within data limits
	move.l	var_b+modulelength,d2
	cmp.l	d2,d1
	blo.b	.ok
	move.l	d2,d1
	DPRINT	"capped"
.ok

	bsr.b 	.patch
	popm	all
	bra	funcENPP_ClearCache
	
.notSupp
	DPRINT	"Unsupported params!"
	rts

* in:
*  a1 = patch table
*  a0 = data
*  d1 = len
.patch
	* End bound is at a4
	lea	(a0,d1.l),a4
	* PatchTable start at d1
	move.l	a1,d1
.loop
	* find from a3 to a4
	move.l	a0,a3
	* Get code to find
	move.l	d1,a2
	add	(a1),a2
.findCode
	* read data word
	move	(a3),d7
	* check bounds
	cmp.l	a4,a3
	bhs.b	.notFound
	* see if the 1st word is found here
	cmp	(a2),d7
	beq.b	.found
.notF	
	* continue search from the next word 
	addq	#2,a3
	bra.b	.findCode

.found
	* compare the rest
	* get length in words minus one
	move	2(a1),d6
	* data to search from
	move.l	a3,a6
	* what to search
	move.l	a2,a5
.cmp	cmpm.w	(a5)+,(a6)+
	bne.b	.notF
	dbf	d6,.cmp
	* Found correct data at a3
	* apply patch
	
	* patch address relative to patch table start
	move.l	d1,a5
	add	4(a1),a5
	* length of the code to overwrite with the patch
	move	2(a1),d6
; JSR x = $4eB9 xxxx xxxx
; NOP   = $4e71
	* write "jsr <patch address>"
	move	#$4eb9,(a3)+
	move.l	a5,(a3)+
	* that was three words
	subq	#3,d6	
	bmi.b	.NoNop
	* fill the rest with NOPs
.nopFill	
	move	#$4e71,(a3)+
	dbf	d6,.nopFill
.NoNop	
	* try to apply patch again, fixes Mark Cooksey
	bra.b	.loop
.notFound
	* next patch
	addq	#6,a1
	tst	(a1)
	bne.b	.loop
	rts
	

* Maps some EP flags into hippo flags
* in:
*    d0 = EPF_Flags
deliHandleFlags
	move.l	playerbase(a5),a0
	move 	p_liput(a0),d1

	bclr	#pb_end,d1
	btst	#EPF_Songend,d0 
	beq.b 	.1
	bset	#pb_end,d1
.1	
	bclr	#pb_song,d1
	btst	#EPF_NextSong,d0
	beq.b 	.2
	bset	#pb_song,d1
.2
	bclr	#pb_volume,d1
	btst	#EPF_Volume,d0
	beq.b 	.3
	bset	#pb_volume,d1
.3
;	bclr	#pb_kelauseteen,d1
;	btst	#EPF_NextPatt,d0
;	beq.b 	.4
;	bset	#pb_kelauseteen,d1
;.4
;	bclr	#pb_kelaustaakse,d1
;	btst	#EPF_PrevPatt,d0
;	beq.b 	.5
;	bset	#pb_kelaustaakse,d1
;.5
	move	d1,p_liput(a0)
	rts



 if DEBUG
deliShowTags
	move.l	deliPlayer(a5),a0
	move.l	16(a0),a0
.tloop
	movem.l	(a0)+,d0/d1

	move.l	d0,d2
	sub.l	#DTP_TagBase,d2
	bmi.b	.next
	lsl.l	#2,d2
	lea	tagsTable(pc),a1
	add.l	d2,a1

	cmp.l	#tagsTableEnd,a1
	blo.b 	.okTag
.next
	move.l	d0,d2
	sub.l	#EP_TagBase,d2
	bmi.b	.unknown
	lsl.l	#2,d2
	lea	tagsTable2(pc),a1
	add.l	d2,a1
	
	cmp.l	#tagsTable2,a1
	bhs.b	.okTag
.unknown
	DPRINT  "Tag? %lx: %lx"
	bra.b	.oddTag
.okTag
	move.l	d1,d2
	move.l	(a1),d1
	DPRINT  "Tag %lx %s: %lx"
.oddTag
	tst.l	(a0) 
	bne.b	.tloop
	rts

tagsTable
 dc.l EDTP_InternalPlayer
 dc.l EDTP_CustomPlayer 
 dc.l EDTP_RequestDTVersion
 dc.l EDTP_RequestKickVersion
 dc.l EDTP_PlayerVersion
 dc.l EDTP_PlayerName   
 dc.l EDTP_Creator    	
 dc.l EDTP_Check1   
 dc.l EDTP_Check2   
 dc.l EDTP_ExtLoad    	
 dc.l EDTP_Interrupt    
 dc.l EDTP_Stop   	 
 dc.l EDTP_Config   	
 dc.l EDTP_UserConfig   
 dc.l EDTP_SubSongRange 
 dc.l EDTP_InitPlayer   
 dc.l EDTP_EndPlayer    
 dc.l EDTP_InitSound    
 dc.l EDTP_EndSound   	
 dc.l EDTP_StartInt   	
 dc.l EDTP_StopInt    	
 dc.l EDTP_Volume   	
 dc.l EDTP_Balance    	
 dc.l EDTP_Faster   	
 dc.l EDTP_Slower   
 dc.l EDTP_NextPatt   
 dc.l EDTP_PrevPatt   
 dc.l EDTP_NextSong   	
 dc.l EDTP_PrevSong   
 dc.l EDTP_SubSongTest  
 dc.l EDTP_NewSubSongRange
 dc.l EDTP_DeliBase  	
 dc.l EDTP_Flags   	
 dc.l EDTP_CheckLen   	
 dc.l EDTP_Description  
 dc.l EDTP_Decrunch   	
 dc.l EDTP_Convert    	
 dc.l EDTP_NotePlayer   
 dc.l EDTP_NoteStruct   
 dc.l EDTP_NoteInfo   	
 dc.l EDTP_NoteSignal   
 dc.l EDTP_Process    	
 dc.l EDTP_Priority   	
 dc.l EDTP_StackSize    
 dc.l EDTP_MsgPort    	
 dc.l EDTP_Appear   	
 dc.l EDTP_Disappear   	
 dc.l EDTP_ModuleName   
 dc.l EDTP_FormatName   
 dc.l EDTP_AuthorName   
 dc.l EDTP_InitNote  
 dc.l EDTP_NoteAllocMem
 dc.l EDTP_NoteFreeMem
 dc.l EDTP_PlayerInfo
 dc.l EDTP_Patterns
 dc.l EDTP_Duration
 dc.l EDTP_SampleData
 dc.l EDTP_MiscText

tagsTableEnd
 
tagsTable2
	dc.l EEP_Get_ModuleInfo	
	dc.l EEP_Free_ModuleInfo	
	dc.l EEP_Voices		
	dc.l EEP_SampleInit		
	dc.l EEP_SampleEnd		
	dc.l EEP_Save
	dc.l EEP_ModuleChange		
	dc.l EEP_ModuleRestore	
	dc.l EEP_StructInit		
	dc.l EEP_StructEnd		
	dc.l EEP_LoadPlConfig		
	dc.l EEP_SavePlConfig		
	dc.l EEP_GetPositionNr	
	dc.l EEP_SetSpeed		
	dc.l EEP_Flags		
	dc.l EEP_KickVersion		
	dc.l EEP_PlayerVersion	
	dc.l EEP_CheckModule		
	dc.l EEP_EjectPlayer
	dc.l EEP_Date			
	dc.l EEP_Check3
	dc.l EEP_SaveAsPT		
	dc.l EEP_NewModuleInfo	
	dc.l EEP_FreeExtLoad
	dc.l EEP_PlaySample		
	dc.l EEP_PatternInit		
	dc.l EEP_PatternEnd		
	dc.l EEP_Check4
	dc.l EEP_Check5
	dc.l EEP_Check6
	dc.l EEP_CreatorLNr
	dc.l EEP_PlayerNameLNr
	dc.l EEP_PlayerInfo		
	dc.l EEP_PlaySampleInit
	dc.l EEP_PlaySampleEnd
	dc.l EEP_InitAmplifier	
	dc.l EEP_CheckSegment
	dc.l EEP_Show
	dc.l EEP_Hide
	dc.l EEP_LocaleTable
	dc.l EEP_Helpnodename
	dc.l EEP_AttnFlags
	dc.l EEP_EagleBase
	dc.l EEP_Check7		
	dc.l EEP_Check8		
	dc.l EEP_SetPlayFrequency
	dc.l EEP_SamplePlayer
tagsTable2End

EDTP_InternalPlayer   	dc.b "DTP_InternalPlayer",0 ; obsolete
EDTP_CustomPlayer   	dc.b "DTP_CustomPlayer",0 ; player is a customplayer
EDTP_RequestDTVersion   	dc.b "DTP_RequestDTVersion",0 ; minimum DeliTracker version needed
EDTP_RequestKickVersion   	dc.b "DTP_RequestKickVersion",0 ; minimum KickStart version needed
EDTP_PlayerVersion   	dc.b "DTP_PlayerVersion",0 ; actual player version & revision
EDTP_PlayerName   	dc.b "DTP_PlayerName",0 ; name of this player
EDTP_Creator    	dc.b "DTP_Creator",0 ; misc string
EDTP_Check1   	dc.b "DTP_Check1",0 ; Check Format before loading
EDTP_Check2   	dc.b "DTP_Check2",0 ; Check Format after file is loaded
EDTP_ExtLoad    	dc.b "DTP_ExtLoad",0 ; Load additional files
EDTP_Interrupt    	dc.b "DTP_Interrupt",0 ; Interrupt routine
EDTP_Stop   	dc.b "DTP_Stop",0 ; Clear Patterncounter
EDTP_Config   	dc.b "DTP_Config",0 ; Config Player
EDTP_UserConfig   	dc.b "DTP_UserConfig",0 ; User-Configroutine
EDTP_SubSongRange   	dc.b "DTP_SubSongRange",0 ; Get min&max subsong number
EDTP_InitPlayer   	dc.b "DTP_InitPlayer",0 ; Initialisize the Player
EDTP_EndPlayer    	dc.b "DTP_EndPlayer",0 ; Player clean up
EDTP_InitSound    	dc.b "DTP_InitSound",0 ; Soundinitialisation routine
EDTP_EndSound   	dc.b "DTP_EndSound",0 ; End sound
EDTP_StartInt   	dc.b "DTP_StartInt",0 ; Start interrupt
EDTP_StopInt    	dc.b "DTP_StopInt",0 ; Stop interrupt
EDTP_Volume   	dc.b "DTP_Volume",0 ; Set Volume
EDTP_Balance    	dc.b "DTP_Balance",0 ; Set Balance
EDTP_Faster   	dc.b "DTP_Faster",0 ; Incease playspeed
EDTP_Slower   	dc.b "DTP_Slower",0 ; Decrease playspeed
EDTP_NextPatt   	dc.b "DTP_NextPatt",0 ; Jump to next pattern
EDTP_PrevPatt   	dc.b "DTP_PrevPatt",0 ; Jump to previous pattern
EDTP_NextSong   	dc.b "DTP_NextSong",0 ; Play next subsong
EDTP_PrevSong   	dc.b "DTP_PrevSong",0 ; Play previous subsong
EDTP_SubSongTest   	dc.b "DTP_SubSongTest",0 ; Test, if given subsong is vaild
EDTP_NewSubSongRange   	dc.b "DTP_NewSubSongRange",0 ; enhanced replacement for EDTP_SubSongRange
EDTP_DeliBase  	dc.b "DTP_DeliBase",0 ; the address of a pointer where DT
EDTP_Flags   	dc.b "DTP_Flags",0 ; misc Flags (see below)
EDTP_CheckLen   	dc.b "DTP_CheckLen",0 ; Length of the Check Code
EDTP_Description   	dc.b "DTP_Description",0 ; misc string
EDTP_Decrunch   	dc.b "DTP_Decrunch",0 ; pointer to Decrunch Code
EDTP_Convert    	dc.b "DTP_Convert",0 ; pointer to Converter Code
EDTP_NotePlayer   	dc.b "DTP_NotePlayer",0 ; pointer to a NotePlayer Structure
EDTP_NoteStruct   	dc.b "DTP_NoteStruct",0 ; the address of a pointer to the
EDTP_NoteInfo   	dc.b "DTP_NoteInfo",0 ; a pointer where DT stores a pointer
EDTP_NoteSignal   	dc.b "DTP_NoteSignal",0 ; pointer to NoteSignal code
EDTP_Process    	dc.b "DTP_Process",0 ; pointer to process entry code
EDTP_Priority   	dc.b "DTP_Priority",0 ; priority of the process
EDTP_StackSize    	dc.b "DTP_StackSize",0 ; stack size of the process
EDTP_MsgPort    	dc.b "DTP_MsgPort",0 ; a pointer where DT stores a pointer
EDTP_Appear   	dc.b "DTP_Appear",0 ; open your window, if you can
EDTP_Disappear   	dc.b "DTP_Disappear",0 ; go dormant
EDTP_ModuleName   	dc.b "DTP_ModuleName",0 ; get the name of the current module
EDTP_FormatName   	dc.b "DTP_FormatName",0 ; get the name of the module format
EDTP_AuthorName   	dc.b "DTP_AuthorName",0 ; not implemented yet
EDTP_InitNote   	dc.b "DTP_InitNote",0 ; NoteStruct initialization
EDTP_NoteAllocMem dc.b "DTP_NoteAllocMem",0
EDTP_NoteFreeMem dc.b "DTP_NoteFreeMem",0
EDTP_PlayerInfo dc.b "DTP_PlayerInfo",0
EDTP_Patterns dc.b "DTP_Patterns",0
EDTP_Duration dc.b "DTP_Duration",0
EDTP_SampleData dc.b "DTP_SampleData",0
EDTP_MiscText dc.b "DTP_MiscText",0

EEP_Get_ModuleInfo	dc.b "EP_Get_ModuleInfo",0
EEP_Free_ModuleInfo	dc.b "EP_Free_ModuleInfo",0
EEP_Voices			dc.b "EP_Voices",0
EEP_SampleInit		dc.b "EP_SampleInit",0
EEP_SampleEnd		dc.b "EP_SampleEnd",0
EEP_Save	    	dc.b "EP_Save",0
EEP_ModuleChange	dc.b "EP_ModuleChange",0
EEP_ModuleRestore	dc.b "EP_ModuleRestore",0
EEP_StructInit		dc.b "EP_StructInit",0
EEP_StructEnd		dc.b "EP_StructEnd",0
EEP_LoadPlConfig	dc.b "EP_LoadPlConfig",0
EEP_SavePlConfig	dc.b "EP_SavePlConfig",0
EEP_GetPositionNr	dc.b "EP_GetPositionNr",0
EEP_SetSpeed		dc.b "EP_SetSpeed",0
EEP_Flags		    dc.b "EP_Flags",0
EEP_KickVersion		dc.b "EP_KickVersion",0
EEP_PlayerVersion	dc.b "EP_PlayerVersion",0
EEP_CheckModule		dc.b "EP_CheckModule",0
EEP_EjectPlayer		dc.b "EP_EjectPlayer",0
EEP_Date		    dc.b "EP_Date",0
EEP_Check3		    dc.b "EP_Check3",0
EEP_SaveAsPT		dc.b "EP_SaveAsPT",0
EEP_NewModuleInfo	dc.b "EP_NewModuleInfo",0
EEP_FreeExtLoad		dc.b "EP_FreeExtLoad",0
EEP_PlaySample		dc.b "EP_PlaySample",0
EEP_PatternInit		dc.b "EP_PatternInit",0
EEP_PatternEnd		dc.b "EP_PatternEnd",0
EEP_Check4	     	dc.b "EP_Check4",0
EEP_Check5		    dc.b "EP_Check5",0
EEP_Check6		    dc.b "EP_Check6",0
EEP_CreatorLNr		dc.b "EP_CreatorLNr",0
EEP_PlayerNameLNr	dc.b "EP_PlayerNameLNr",0
EEP_PlayerInfo		dc.b "EP_PlayerInfo",0
EEP_PlaySampleInit	dc.b "EP_PlaySampleInit",0
EEP_PlaySampleEnd	dc.b "EP_PlaySampleEnd",0
EEP_InitAmplifier	dc.b "EP_InitAmplifier",0
EEP_CheckSegment	dc.b "EP_CheckSegment",0
EEP_Show	     	dc.b "EP_Show",0
EEP_Hide		    dc.b "EP_Hide",0
EEP_LocaleTable		dc.b "EP_LocaleTable",0
EEP_Helpnodename	dc.b "EP_Helpnodename",0
EEP_AttnFlags		dc.b "EP_AttnFlags",0
EEP_EagleBase		dc.b "EP_EagleBase",0
EEP_Check7	    	dc.b "EP_Check7",0
EEP_Check8		    dc.b "EP_Check8",0
EEP_SetPlayFrequency dc.b "EP_SetPlayFrequency",0
EEP_SamplePlayer    dc.b "EP_SamplePlayer",0                  
 even

deliShowFlags
	move.l	#EP_Flags,d0
	bsr	deliGetTag
	beq	.noFlags
	btst	#EPF_Songend,d0
	beq.b	.f10
	DPRINT	"EPF_Songend"
.f10
	btst	#EPF_Restart,d0
	beq.b	.f11
	DPRINT	"EPF_Restart"
.f11
	btst	#EPF_Disable,d0
	beq.b	.f12
	DPRINT	"EPF_Disable"
.f12
	btst	#EPF_NextSong,d0
	beq.b	.f13
	DPRINT	"EPF_NextSong"
.f13
	btst	#EPF_PrevSong,d0
	beq.b	.f14 
	DPRINT	"EPF_PrevSong"
.f14 
	btst	#EPF_NextPatt,d0
	beq.b	.f15
	DPRINT	"EPF_PrevPatt"
.f15 
	btst	#EPF_Volume,d0
	beq.b	.f16
	DPRINT	"EPF_Volume"
.f16 
	btst	#EPF_Balance,d0
	beq.b	.f17
	DPRINT	"EPF_Balance"
.f17 
	btst	#EPF_Voices,d0
	beq.b	.f18
	DPRINT	"EPF_Voices"
.f18 
	btst	#EPF_Save,d0
	beq.b	.f19
	DPRINT	"EPF_Save"
.f19
	btst	#EPF_Analyzer,d0
	beq.b	.f20
	DPRINT	"EPF_Analyzer"
.f20
	btst	#EPF_ModuleInfo,d0
	beq.b	.f21
	DPRINT	"EPF_ModuleInfo"
.f21
	btst	#EPF_SampleInfo,d0
	beq.b	.f22 
	DPRINT	"EPF_SampleInfo"
.f22 
	btst	#EPF_Packable,d0
	beq.b	.f23
	DPRINT	"EPF_Packable"
.f23 
	btst	#EPF_InternalUPSStructure,d0
	beq.b	.f24
	DPRINT	"EPF_InternalUPSStructure"
.f24 
	btst	#EPF_RestartSong,d0
	beq.b	.f25
	DPRINT	"EPF_RestartSong"
.f25 
	btst	#EPF_LoadFast,d0
	beq.b	.f26
	DPRINT	"EPF_LoadFast"
.f26 
	btst	#EPF_EPAudioAlloc,d0
	beq.b	.f27
	DPRINT	"EPF_EPAudioAlloc"
.f27 
	btst	#EPF_VolBalVoi,d0
	beq.b	.f28
	DPRINT	"EPF_VolBalVoi"
.f28 
	btst	#EPF_CalcDuration,d0
	beq.b	.f29
	DPRINT	"EPF_CalcDuration"
.f29 
	 
.noFlags
	rts 

deliShowNoteStruct
	move.l	deliStoredNoteStruct(a5),d0
	beq 	.x

	DPRINT	"NoteStruct: %lx"

	move.l	nst_MaxFrequency(a0),d0 
	DPRINT	"MaxFreq: %ld"
	moveq	#0,d0
	move	nst_MaxVolume(a0),d0 
	DPRINT	"MaxVol: %ld"

	move.l	nst_Flags(a0),d1 
	move.l	d1,d0 
	DPRINT	"Flags: %lx"
	
	moveq	#0,d0
	btst	#NSTB_Period,d1
	sne	d0
	DPRINT	"NSTB_Period: %lx"

	btst	#NSTB_ExtPeriod,d1
	sne	d0
	DPRINT	"NSTB_ExtPeriod: %lx"

	btst	#NSTB_NTSCTiming,d1
	sne	d0
	DPRINT	"NSTB_NTSCTiming: %lx"

	btst	#NSTB_EvenLength,d1
	sne	d0
	DPRINT	"NSTB_EvenLength %lx"

	btst	#NSTB_AllRepeats,d1
	sne	d0
	DPRINT	"NSTB_AllRepeats %lx"

	btst	#NSTB_Reverse,d1
	sne	d0
	DPRINT	"NSTB_Reverse %lx"

	btst	#NSTB_Signed,d1
	sne	d0
	DPRINT	"NSTB_Signed %lx"

	btst	#NSTB_Unsigned,d1
	sne	d0
	DPRINT	"NSTB_Unsigned %lx"

	btst	#NSTB_Ulaw,d1
	sne	d0
	DPRINT	"NSTB_Ulaw %lx"

	btst	#NSTB_Alaw,d1
	sne	d0
	DPRINT	"NSTB_Alaw %lx"

	btst	#NSTB_Float,d1
	sne	d0
	DPRINT	"NSTB_Float %lx"

	btst	#NSTB_7Bit,d1
	sne	d0
	DPRINT	"NSTB_7Bit %lx"

	btst	#NSTB_8Bit,d1
	sne	d0
	DPRINT	"NSTB_8Bit %lx"

	btst	#NSTB_16Bit,d1
	sne	d0
	DPRINT	"NSTB_16Bit %lx"

	btst	#NSTB_24Bit,d1
	sne	d0
	DPRINT	"NSTB_24Bit %lx"

	btst	#NSTB_32Bit,d1
	sne	d0
	DPRINT	"NSTB_32Bit %lx"

	btst	#NSTB_64Bit,d1
	sne	d0
	DPRINT	"NSTB_64Bit %lx"

.x
	rts


 endif ; DEBUG

****************************************************************************
*
* File load and save utilities
*
***************************************************************************

* In:
*   a0 = path
* Out:
*   a0 = pointer to the last component of string path
findFilePart:
    move.l  a0,a1
.findEnd
	tst.b	(a0)+
	bne.b	.findEnd
.loop
    cmp.l   a0,a1
    beq     .isSep
	cmp.b	#":",-1(a0)
	beq.b	.isSep
	cmp.b	#"/",-1(a0)
	beq.b	.isSep
    subq    #1,a0
    bra     .loop
.isSep
	* Filename part start position in a0
    rts

* Loads a file
* in:
*  a0 = file path
* out: 
*  d0 = loaded file address, or NULL if error
*  d1 = length
plainLoadFile:
	pushm	d2-a6
	moveq	#0,d7
    moveq   #0,d5

	move.l	_DosBase(a5),a6
	move.l	a0,d1
	move.l	#MODE_OLDFILE,d2
	lob	Open
	move.l	d0,d6
	beq.b	.openErr

	move.l	d6,d1		
	moveq	#0,d2	
	moveq	#1,d3
	lob	Seek
	move.l	d6,d1
	moveq	#0,d2	
	moveq	#1,d3
	lob	Seek
	move.l	d0,d5		* file length
	move.l	d6,d1
	moveq	#0,d2
	moveq	#-1,d3
	lob	Seek			* start of file

	move.l	d5,d0		
	moveq	#MEMF_PUBLIC,d1
	jsr	getmem
	move.l	d0,d7
	beq.b	.noMem

	move.l	d6,d1		* file
	move.l	d7,d2		* destination
	move.l	d5,d3		* pituus
	lob	Read
	* d0 = -1 on error, read bytes otherwise
	tst.l	d0 
	bpl.b 	.ok

	move.l	d7,a0 
	jsr	freemem 
	moveq	#0,d7
.ok

.noMem 
	move.l	d6,d1
	lore 	Dos,Close

.openErr 

	move.l	d7,d0
	move.l  d5,d1
	popm	d2-a6 
	rts

* Saves a file
* in:	
*  a0 = file path
*  a1 = data address
*  d0 = data length
* out: 
*  d0 = Written bytes or -1 if error
plainSaveFile:
	pushm	d1-a6
 if DEBUG
    move.l   a0,d1
    DPRINT "Saving %ld bytes to %s"
 endif
	moveq	#-1,d7
	move.l	a1,d4
	move.l 	d0,d5

	move.l	_DosBase(a5),a6
	move.l	a0,d1
	move.l	#MODE_NEWFILE,d2
	lob	Open
	move.l	d0,d6
	beq.b	.openErr

	move.l	d6,d1	* file
	move.l	d4,d2	* buffer
	move.l	d5,d3  	* len
	lob 	Write
	move.l  d0,d7 

	move.l	d6,d1 
	lob		Close
.openErr 
	move.l	d7,d0
 if DEBUG
    DPRINT  "->%ld"
    tst.l   d0
 endif
	popm	d1-a6 
	rts

***************************************************************************
*
* Frequency spectrum scope
* Integer FFT
*
***************************************************************************

  ifne FEATURE_SPECTRUMSCOPE
spectrum:

	;incdir
	include	"hippo_fft.s"

; Length of the mixed data, to be passed to FFT
MIX_LENGTH = FFT_LENGTH

; Sample data bytes to be copied. Should be enough so that mixing
; process has enough data, as it interpolates according to current
; channel period. 
; For HIPC.WingsOfDeath (Level 1) this buffer is not long enough
; so either make it larger or do range check using mask.
SAMPLE_LENGTH = MIX_LENGTH*2
SAMPLE_LENGTH_MASK = 255

 if SAMPLE_LENGTH<>256
   fail "Assumed to be 256"
 endif

spectrumInitialize
	SDPRINT	"Spectrum init"

VOLUME_TABLE_LEN = $40*$100*2
MULU_TABLE_LEN = SCOPE_DRAW_AREA_HEIGHT_DEFAULT*2
EXP_TABLE_LEN = SCOPE_DRAW_AREA_HEIGHT_DEFAULT
SINE_TABLE_LEN = 1024*2

SPECTRUM_TOTAL set VOLUME_TABLE_LEN+MULU_TABLE_LEN+EXP_TABLE_LEN*4+SINE_TABLE_LEN
SPECTRUM_TOTAL set SPECTRUM_TOTAL+4*SAMPLE_LENGTH ; bytes
SPECTRUM_TOTAL set SPECTRUM_TOTAL+2*FFT_LENGTH*2  ; words

	clr.b	s_spectrumInitialized(a4)

	move.l	#SPECTRUM_TOTAL,d0
	move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
	jsr	getmem
	move.l	d0,s_spectrumMemory(a4)
	beq.b	.x
	move.l	d0,a0
	move.l	a0,s_spectrumVolumeTable(a4)
	add.l	#VOLUME_TABLE_LEN,a0
	move.l	a0,s_spectrumMuluTable(a4)
	add	#MULU_TABLE_LEN,a0
	move.l	a0,s_spectrumExpTable(a4)
	add	#EXP_TABLE_LEN*4,a0
	move.l	a0,s_spectrumSineTable(a4)
	add	#SINE_TABLE_LEN,a0
	move.l	a0,s_spectrumChannel1(a4)
	add	#SAMPLE_LENGTH,a0
	move.l	a0,s_spectrumChannel2(a4)
	add	#SAMPLE_LENGTH,a0
	move.l	a0,s_spectrumChannel3(a4)
	add	#SAMPLE_LENGTH,a0
	move.l	a0,s_spectrumChannel4(a4)
	add	#SAMPLE_LENGTH,a0
	move.l	a0,s_spectrumMixedData(a4)
	add	#FFT_LENGTH*2,a0
	move.l	a0,s_spectrumImagData(a4)

	bsr     prepareSpectrumSineTable
	bsr 	prepareSpectrumVolumeTable
	bsr 	prepareSpectrumMuluTable
	bsr 	prepareSpectrumExpTable
    st	s_spectrumInitialized(a4)
	moveq	#1,d0
	rts
	
.x	SDPRINT "Spectrum init failed"
	moveq	#0,d0
	rts


spectrumUninitialize
	SDPRINT	"Spectrum uninit"
	clr.b	s_spectrumInitialized(a4)
	move.l	s_spectrumMemory(a4),a0
	clr.l	s_spectrumMemory(a4)
	jmp	freemem
	
prepareSpectrumVolumeTable
	move.l	s_spectrumVolumeTable(a4),a0
	moveq	#0,d0
.v
	moveq	#0,d1
.byte
	move	d1,d2
	ext	d2
	muls	d0,d2
	; Here could do some scaling if needed to suit the graph
	move	d2,(a0)+

	addq	#1,d1
	cmp	#256,d1
	bne.b	.byte

	addq	#1,d0
	cmp	#64,d0
	bne.b	.v
	moveq	#1,d0
	rts

; in:
;    d0 = volume
; out:
;    a2 = table
getSpectrumVolumeTable
	mulu	mainvolume(a5),d0
	lsr	#6,d0
	CLAMPVOL d0
	tst	d0
	bne.b	.1
	moveq	#1,d0
.1	subq	#1,d0
	lsl	#8,d0
	add	d0,d0
	move.l	s_spectrumVolumeTable(a4),a2
	add	d0,a2
	rts

prepareSpectrumMuluTable
	move.l	s_spectrumMuluTable(a4),a0
	moveq	#0,d0
	moveq	#SCOPE_DRAW_AREA_HEIGHT_DEFAULT-1,d1
.l	move	d0,(a0)+
	add	#SCOPE_DRAW_AREA_WIDTH_DEFAULT/8,d0
	dbf	d1,.l
	rts


; Creates a table to for mapping FFT magnitudes into dB levels.
; Magnitude for each value would be: sqr(real^2+image^2)
; Maximum value for real or image is 0x7fff.
; The end result is such that low frequencies visually not overpowering
; and the graph is more even between frequencies.

prepareSpectrumExpTable
	move.l	s_spectrumExpTable(a4),a2

	; Do this:
	; local s, i; s = 0; for (i = 0; i < 64; i++, s=s-0.15) print(0x7fff*exp(s));

	move.l	#1000,d0
	lore	FFP,SPFlt
	move.l	d0,d2
	* Adjust exponential curve shape:
	;move.l	#155,d0
	move.l	#160,d0
	lob	SPFlt
	move.l	d2,d1
	lob	SPDiv
	move.l	d0,d5
	
	moveq	#EXP_TABLE_LEN-1,d7
	moveq	#FFP_zero,d6
.loop
	move.l	d6,d0
	lore	MT,SPExp
	move.l 	#FFP_7fff,d1
	lore	FFP,SPMul
	* Squared:
	move.l	d0,d1
	lob	SPMul
	lob	SPFix
	move.l	d0,(a2)+

	move.l	d6,d0
	move.l	d5,d1
	lob	SPSub
	move.l	d0,d6
	dbf	d7,.loop

	move.l	s_spectrumExpTable(a4),a2
	moveq	#EXP_TABLE_LEN-1-1,d7
	* Calculate averages
	addq.l	#4,a2
.loop2
	move.l	(a2),d0
	add.l	-4(a2),d0
	lsr.l	#1,d0
	move.l	d0,-4(a2)
	addq.l	#4,a2
	dbf	d7,.loop2

	* Reverse the table so that loudnessFFT can 
	* use post-increment instead of pre-decrement, which
	* is slower.
	move.l	s_spectrumExpTable(a4),a0
	lea	EXP_TABLE_LEN*4(a0),a1
	moveq	#EXP_TABLE_LEN/2-1,d7
.reverse
	move.l	(a0),d0
	move.l	-(a1),(a0)+
	move.l	d0,(a1)
	dbf	d7,.reverse
	rts
 

; Calculate loudness values for the FFT
;
;in:
;  a0 = result array reals
;  a1 = result array imaginary
;out:
;  a0 = result (overwritten input array)

loudnessFFT
	move.l	s_spectrumExpTable(a4),a3	
	moveq	#FFT_LENGTH/2-1,d7
	move.l	a0,a6
.l1
	* Calculate re^2 + im^2.
	* This is the squared magnitude of the complex value.
	move	(a0)+,d0
	muls	d0,d0
	move	(a1)+,d1
	muls	d1,d1
	add.l	d1,d0

	* Find the slot in the table where the value lands.
	* The index represents the decibel value with range 0..64

* Forward search, loud values are searched first.
* Typically forward search is wasteful since
* on average module loudnesses are on the lower half
* of the search table. For snare/drum hits and similar
* forward search is better, but those happen rarely.
* DMU.ferry_tell is exceptionally loud, for this one
* the forward search is better.

* Reverse search, quiet values are searched first.
* With a few test modules this takes much less steps
* compared to the forward search.
* Test with two mods, loop iteration counts:
* normal count:  1b570b  1c53b9
* reverse count:  cf5af   bed25

* Reverse search is used here by reversing the search table 
* in prepareSpectrumExpTable.

	move.l	a3,a2
	moveq	#EXP_TABLE_LEN-1,d1
	* this loop is may run 4096 times in the worst case
.l2	cmp.l	(a2)+,d0
	* If the 1st cmp succeeds, the loop breaks without
	* d1 decrementing.
	dbls	d1,.l2

	* Use the DBcc counter directly.
	* See if all entries were searched (not likely to happen).
	tst	d1
	bpl.b	.notEnd
	moveq	#0,d1
.notEnd
	move.b	d1,(a6)+

	dbf	d7,.l1
	rts


* Precalculated FFP constants
FFP_2PIper1024 	= $c90fdb39 * 2PI divided by 1024
FFP_7fff 	= $fffe004f
FFP_zero        = 0

* This calculates a 1024 entry sine table with 16-bit
* range.
prepareSpectrumSineTable
	move.l	_FFPBase(a5),d6
	move.l	_MTBase(a5),d5

	move.l	s_spectrumSineTable(a4),a2
 
	* D4 = multiplier 
	* D3 = step
	* D2 = current

	moveq	#FFP_zero,d2
	move.l	#FFP_2PIper1024,d3
	move.l	#FFP_7fff,d4

	move	#1024-1,d7
.loop
	move.l	d2,d0
	move.l	d5,a6
	lob	SPSin
	move.l	d4,d1
	move.l	d6,a6
	lob	SPMul
	lob	SPFix
	* fix_fft uses values shifted by one
	asr.l	#1,d0 
	move	d0,(a2)+

	move.l	d2,d0
	move.l	d3,d1
	lob	SPAdd
	move.l	d0,d2

	dbf	d7,.loop   
	rts

runSpectrumScope
	tst.b	s_spectrumInitialized(a4)
	beq	.x

	cmp	#pt_multi,playertype(a5)
    bne.b   .notMulti
    tst.b   ahi_use_nyt(a5)
    beq.b   .ps3m
.notMulti
    cmp     #pt_xmaplay,playertype(a5)
    beq.b   .ps3m
    jsr     playSidInRESIDMode
    bne.b   .ps3m
	cmp	#pt_sample,playertype(a5)
	beq.b	.sample
	bra.b	.normal

.ps3m
	bsr	spectrumGetPS3MSampleData
	bra.b	.go
.sample
	bsr	spectrumGetSampleData
    beq     .x 
	bra.b	.go
.normal
	bsr	spectrumCopySamples
* A500 average = 2ms
	bsr	spectrumMixSamplesNew
* A500 average = 4ms

.go
	move.l	s_spectrumMixedData(a4),a0
	move.l	s_spectrumSineTable(a4),a2
	bsr	windowFFT
* A500 average = 2ms

	move.l	s_spectrumMixedData(a4),a0
	move.l	s_spectrumImagData(a4),a1
	move.l	s_spectrumSineTable(a4),a2
	bsr	sampleFFT
* A500 average = 39ms (old: 52ms)

	move.l	s_spectrumMixedData(a4),a0
	move.l	s_spectrumImagData(a4),a1
	bsr	loudnessFFT
* A500 average = 8ms

	bsr	drawFFT
* A500 average = 1ms

	* Vertical fill
	
	tst.b	s_bufferIsChip(a4)
	beq.b	.cpuFill

	lore	GFX,OwnBlitter

	move.l	s_draw1(a4),a0
	;addq	#2,a0 * horiz offset
	;moveq	#2,d0 * modulo
	moveq	#0,d0 * modulo
	lea	40(a0),a1 * target is one line below
	lea	$dff000,a2

	lob	WaitBlit
	move.l	a0,$50(a2)	* A
	move.l	a1,$48(a2)	* C
	move.l	a1,$54(a2)	* D
	move	d0,$60(a2)	* C
	move	d0,$64(a2)	* A
	move	d0,$66(a2)	* D
	move.l	#-1,$44(a2) * masks
	move.l	#$0b5a0000,$40(a2)	* D = A not C
	* Height: 65 px
	* Width 19*16 = 304 px
	;move	#65*64+19,$58(a2)
	move	#65*64+20,$58(a2)
	lob	DisownBlitter
	
;	bsr.b	drawScales
	
.x	rts

.cpuFill
	moveq	#65,d1
	jmp		cpuVerticalFill

* Test visualization
 REM
drawScales
	lob	WaitBlit
	move.l	s_draw1(a4),a0
	moveq	#SCOPE_DRAW_AREA_HEIGHT_DEFAULT/2,d0
	mulu	s_scopeDrawAreaModulo(a4),d0
	add.l	d0,a0
	moveq	#SCOPE_DRAW_AREA_WIDTH_DEFAULT/32-1,d0
.l	move.l	#-1,(a0)+
	dbf	d0,.l
	rts
 EREM

spectrumCopySamples
	push	a4

	move.l	a4,a6
	lea	scopeData+scope_ch1(a5),a3
	move.l	s_spectrumChannel1(a6),a4
	bsr.b	.copySample
	lea	scopeData+scope_ch2(a5),a3
	move.l	s_spectrumChannel2(a6),a4
	bsr.b	.copySample
	lea	scopeData+scope_ch3(a5),a3
	move.l	s_spectrumChannel3(a6),a4
	bsr.b	.copySample
	lea	scopeData+scope_ch4(a5),a3
	move.l	s_spectrumChannel4(a6),a4
	bsr.b	.copySample
	pop	a4
	rts

* in
*   a3 = scope channel block
*   a4 = sample data destination buffer
.copySample
	; Destination buffer
	;lea	channelData(a3),a4

	* For clearing data
	moveq	#0,d3
	
	tst	ns_period(a3)
	beq.b	.empty
	tst	ns_tempvol(a3)
	beq.b	.empty

	* Insanity check value
	lea	1024.w,a0

	move.l	ns_start(a3),a1
	cmp.l	a0,a1 * insanity check
	blo.b	.empty
	move.l	ns_loopstart(a3),d1
	cmp.l	a0,d1 * insanity check
	bhs.b	.jolt

.empty
	moveq	#SAMPLE_LENGTH/4/8-1,d1
.c
	move.l	d3,(a4)+
	move.l	d3,(a4)+
	move.l	d3,(a4)+
	move.l	d3,(a4)+
	move.l	d3,(a4)+
	move.l	d3,(a4)+
	move.l	d3,(a4)+
	move.l	d3,(a4)+
	dbf	d1,.c
	rts

.jolt	
	* a1 = sample start
	* d1 = loopstart
	moveq	#0,d5
	move	ns_length(a3),d5	* Sample length in words

	; See if enough data to copy all in one block
	cmp	#SAMPLE_LENGTH/2,d5
	bhs.b	.large

	; sample length 2, ie. empty sample?
	cmp	#2,d5
	bls.b	.empty

	; Small sample, or large sample with not a lot remaining

	moveq	#0,d0
	move	ns_replen(a3),d0

	; this loop is active when there is some data to be copied
	moveq	#SAMPLE_LENGTH/2-1,d7	* words to copy
.small
	; sample word
	; source pointer can be odd
	move.b	(a1)+,(a4)+
	move.b	(a1)+,(a4)+
	
	subq.l	#1,d5			* one word copied, check length
	dbmi	d7,.small

	* Sample data exhausted (d5 = -1), 
	* or buffer full (d7 = -1)
	tst	d7
	bmi.b	.full

	* Continue with loop data
	cmp	#2,d0
	bls.b	.emptyRepeat

	; sample repeat	starts
	; repeat length
	move.l	d0,d5
	; repeat data start
	move.l	d1,a1
	* continue copy 
	bra.b	.small
.full
	rts

.emptyRepeat
	move	d3,(a4)+
	dbf	d7,.emptyRepeat
	rts

.large
	* Check source address evenness
	move.w	a1,d0
	ror.b	#1,d0
	bpl.b	.evenCopy
	moveq	#SAMPLE_LENGTH/16-1,d0
	* copy from odd address
.oddCopy
 rept 16
	move.b	(a1)+,(a4)+
 endr
	dbf	d0,.oddCopy
	rts

* Copy SAMPLE_LENGTH bytes, 256 bytes that is
	if SAMPLE_LENGTH<>256	
		fail 256 assumed here
	endif
* Free: d0-d7, a0,a2,a3 = 44 bytes at a time
.evenCopy
	* 000-044
	movem.l	(a1)+,d0-d7/a0/a2/a3
	movem.l	d0-d7/a0/a2/a3,(a4)
	* 044-088
	movem.l	(a1)+,d0-d7/a0/a2/a3
	movem.l	d0-d7/a0/a2/a3,44(a4)
	* 088-132
	movem.l	(a1)+,d0-d7/a0/a2/a3
	movem.l	d0-d7/a0/a2/a3,44*2(a4)
	* 132-176
	movem.l	(a1)+,d0-d7/a0/a2/a3
	movem.l	d0-d7/a0/a2/a3,44*3(a4)
	* 172-220
	movem.l	(a1)+,d0-d7/a0/a2/a3
	movem.l	d0-d7/a0/a2/a3,44*4(a4)
	* 220-256 (36 bytes)
	movem.l	(a1),d0-d7/a0
	movem.l	d0-d7/a0,44*5(a4)
	rts

; in:
;    d0 = period
; out:
;    d1 = 8+8 fixed point sample skip value ff000000aa, ff = fractions
calcSampleStep
	* sanity check, 100 corresponds to about 35 kHz
	cmp	#100,d0
	bhs.b .1
	moveq	#100,d0
.1
	move.l	clockconstant(a5),d1 * PAL or NTSC clock constant
	divu	d0,d1		* playback frequency in hertz
	ext.l	d1
	lsl.l	#8,d1
	divu	#8000,d1	* resampling destination frequency
	;divu	#16000,d1	* resampling destination frequency
	;divu	#20000,d1	* resampling destination frequency
	;divu	#24000,d1	* resampling destination frequency
	;divu	#28000,d1	* resampling destination frequency
	ext.l	d1
	ror.l	#8,d1

	; 8000 dest frequency means that the FFT scale goes
	; from 0 to 4000.
	rts


 REM ***********
spectrumMixSamples
	lea	scopeData+scope_ch1(a5),a1
	move.l	s_spectrumChannel1(a4),a0
	moveq	#1,d4
	bsr.b	.mixSample

	lea	scopeData+scope_ch2(a5),a1
	move.l	s_spectrumChannel2(a4),a0
	moveq	#0,d4
	bsr.b	.mixSample

	lea	scopeData+scope_ch3(a5),a1
	move.l	s_spectrumChannel3(a4),a0
	moveq	#0,d4
	bsr.b	.mixSample

	lea	scopeData+scope_ch4(a5),a1
	move.l	s_spectrumChannel4(a4),a0
	moveq	#0,d4
	;bsr.b	.mixSample
	;rts

.mixSample
	move	ns_tempvol(a1),d0
	bsr	getSpectrumVolumeTable
	; out: a2 = voltab

	move	ns_period(a1),d0
	bsr.b	calcSampleStep
	; result in d1

	move.l	s_spectrumMixedData(a4),a1

	moveq	#0,d6
	moveq	#0,d0
	move	#SAMPLE_LENGTH_MASK,d3
	moveq	#MIX_LENGTH/4-1,d7
	
	* Copy or add?
	tst	d4
	beq.b	.add
.m1
	; move to buffer (first set)
	rept	4
	; sample byte
	moveq	#0,d5
	move.b	(a0,d0.w),d5
	; volume scaled byte
	add	d5,d5
	; copy
	move.w	(a2,d5.w),(a1)+

	; next source sample
	add.l	d1,d0
	addx.w	d6,d0
	endr

	; safety: keep offset within data buffer
	and	d3,d0

	dbf	d7,.m1
	rts
.add
; add to buffer
.m2
	rept	4
	; sample byte
	moveq	#0,d5
	move.b	(a0,d0.w),d5
	; volume scaled byte
	add	d5,d5
	move.w	(a2,d5.w),d4
	; add to mix buffer
	add.w	d4,(a1)+

	; next source sample
	add.l	d1,d0
	addx.w	d6,d0
	endr

	; safety: keep offset within data buffer
	and	d3,d0
	dbf	d7,.m2
	rts
 EREM *****************


* Mix four channels into one for input to the FFT
* Two channels at a time
spectrumMixSamplesNew
	lea	scopeData+scope_ch1(a5),a1
	move	ns_tempvol(a1),d0
	bsr	getSpectrumVolumeTable
	move.l	a2,a3
	; a3 = ch1 voltab
	move	ns_period(a1),d0
	bsr.b	calcSampleStep
	move.l	d1,d2
	; d2 = ch1 step

	lea	scopeData+scope_ch2(a5),a1
	move	ns_tempvol(a1),d0
	bsr	getSpectrumVolumeTable
	; a2 = ch2 voltab
	move	ns_period(a1),d0
	bsr.b	calcSampleStep
	; d1 = ch2 step

	move.l	s_spectrumChannel1(a4),a0	
	move.l	s_spectrumChannel2(a4),a1	
	move.l	s_spectrumMixedData(a4),a6

	; ch1 pos
	moveq	#0,d0
	; ch2 pos
	moveq	#0,d4
	; addx zero
	moveq	#0,d6

	push	a5
	lea	(SAMPLE_LENGTH_MASK).w,a5
	exg	d1,a5

	moveq	#MIX_LENGTH/2-1,d7
.loop
	rept	2
	moveq	#0,d5
	move.b	(a0,d0.w),d5  ; ch1 byte
	add	d5,d5
	move.w	(a3,d5.w),d5  ; volume scaled byte

	moveq	#0,d3
	move.b	(a1,d4.w),d3 ; ch2 byte
	add	d3,d3
	add.w	(a2,d3.w),d5 ; ch1+ch2
	move	d5,(a6)+     ; to output

	add.l	d2,d0 	; next ch1 byte
	addx.w	d6,d0
	add.l	a5,d4   ; next ch2 byte
	addx.w	d6,d4
	endr

	; Buffer index safety
	and.w	d1,d0
	and.w	d1,d4

	dbf	d7,.loop

	pop	a5

	lea	scopeData+scope_ch3(a5),a1
	move	ns_tempvol(a1),d0
	bsr	getSpectrumVolumeTable
	move.l	a2,a3
	; a3 = ch3 voltab
	move	ns_period(a1),d0
	bsr	calcSampleStep
	move.l	d1,d2
	; d2 = ch3 step

	lea	scopeData+scope_ch4(a5),a1
	move	ns_tempvol(a1),d0
	bsr	getSpectrumVolumeTable
	; a2 = ch4 voltab
	move	ns_period(a1),d0
	bsr	calcSampleStep
	; d1 = ch4 step

	move.l	s_spectrumChannel3(a4),a0	
	move.l	s_spectrumChannel4(a4),a1	
	move.l	s_spectrumMixedData(a4),a6

	; ch3 pos
	moveq	#0,d0
	; ch4 pos
	moveq	#0,d4

	push	a5
	lea	(SAMPLE_LENGTH_MASK).w,a5
	exg	d1,a5

	moveq	#MIX_LENGTH/2-1,d7
.loop2
	rept	2
	moveq	#0,d5
	move.b	(a0,d0.w),d5 ; ch3 byte
	add	d5,d5
	move.w	(a3,d5.w),d5

	moveq	#0,d3
	move.b	(a1,d4.w),d3 ; ch4 byte
	add	d3,d3
	add.w	(a2,d3.w),d5  * ch3+ch4
	add	d5,(a6)+      * ch1+ch2+ch3+ch4

	add.l	d2,d0 ; next ch3 sample
	addx.w	d6,d0
	add.l	a5,d4 ; next ch4 sample
	addx.w	d6,d4
	endr
	
	* Safety check for buffer indexes
	and.w	d1,d0
	and.w	d1,d4
	
	dbf	d7,.loop2

	pop	a5
	rts

drawFFT
	; FFT data is here.
	; The other half is mirror of the first.
	move.l	s_spectrumMixedData(a4),a0
	move.l	s_draw1(a4),a1
	move.l	s_spectrumMuluTable(a4),a2

;%11111000 00000000 ror #5
;%00000111 11000000 ror #5
;%00000000 00111110 ror #5
;%11110000 00000001 ror #8
;%00000001 11110000

	; Bitmask to draw with
	move	#%0111100000000000,d6
	; Bitmask to detect word boundary collisions
	move	#%1111100000000000,d5

	; Take the 1st half
	moveq	#FFT_LENGTH/2-1,d7
	* Y-table index
	moveq	#0,d1
.loop
	move.b	(a0)+,d1  * Get value in range 0..64
	add.b	d1,d1     * Word index 0..128
	* Y-address from table
	move	(a2,d1),d0
	* Draw bits
	or.w	d6,(a1,d0)

	* Shift bit mask
	ror.w 	#5,d6
	* Shift also this and see if should continue to following word
	ror.w	#5,d5
	bmi.b	.2
	
	dbf	d7,.loop
.x	rts		

.2
	* Draw data point which is split between words
	subq	#1,d7
	bmi.b	.x

	* Get another value	
	move.b	(a0)+,d1
	add.b	d1,d1
	move	(a2,d1),d0

	* Bits that go into the 2nd byte
	or.b	d6,1(a1,d0)
	* Bits that go into the 3rd
	move	d6,d4
	ror.w	#8,d4
	or.b	d4,2(a1,d0)
	* Moving on to next 16 pixels
	addq.l	#2,a1

	ror.w	#5,d5
	ror.w 	#5,d6
	dbf	d7,.loop
	rts

spectrumGetPS3MSampleData
	move.l	ps3m_playpos(a5),a0
	move.l	(a0),d0
	lsr.l	#8,d0
	move.l	ps3m_buffSizeMask(a5),a0
	move.l	(a0),d1
    moveq   #4,d4   * scale factor

	move.l	ps3m_buff1(a5),a0
	move.l	(a0),a0
	move.l	ps3m_buff2(a5),a1
	move.l	(a1),a1
	move.l	s_spectrumMixedData(a4),a2
	moveq	#FFT_LENGTH-1,d7    * = 128

    jsr     playSidInRESIDMode
    bne    .resid

.loop
	move.b	(a0,d0.l),d2
	move.b	(a1,d0.l),d3
	ext	d2
	ext	d3
	add	d3,d2
	asl	d4,d2   * scaling!
	move	d2,(a2)+
	addq.l	#1,d0
    * End bound check
    and.l   d1,d0
	dbf	d7,.loop
	rts

.resid * 1 or 2 SIDs
    move.l  residBufPtr3,d4
    bne     .resid3

    * buffer size is in d1, it can be 277
    * or down to 46.
    move.l  ps3m_sampleDataModulo(a5),d4
.rloop
	move.b	(a0,d0.l),d2
	move.b	(a1,d0.l),d3
	ext	d2
	ext	d3
	add	d3,d2
	asl	    #5,d2   * scaling!
    move	d2,(a2)+
	add.l	d4,d0
    * See if data ran out:
    cmp.l   d1,d0
    blo.b   .2
    moveq   #0,d0
.2
	dbf	d7,.rloop
    rts

.resid3 * 3 SIDs
    move.l  d4,a6

    * buffer size is in d1, it can be 277
    * or down to 46.
    move.l  ps3m_sampleDataModulo(a5),d4
.rloop2
	move.b	(a0,d0.l),d2    * sid1
	move.b	(a1,d0.l),d3    * sid2
	ext	d2
	ext	d3
	add	d3,d2
	move.b	(a6,d0.l),d3    * sid3
    ext     d3
    add     d3,d2

	asl	    #5,d2   * scaling!
    move	d2,(a2)+
	add.l	d4,d0
    * See if data ran out:
    cmp.l   d1,d0
    blo.b   .22
    moveq   #0,d0
.22
	dbf	d7,.rloop2
    rts

spectrumGetSampleData
	jsr	samples0
    bne .gotData
    rts
.gotData
	* d5 = follow offset
	* d4 = buffer size mask

    bsr     getSampleDataModulo
    * d0 = sample data modulo, 1 or 2

	move.l	s_spectrumMixedData(a4),a3
	moveq	#FFT_LENGTH/2-1,d7

	move.l	samplepointer(a5),a1
	move.l	(a1),a1
	
	tst.b	samplestereo(a5)
	bne.b	.stereo

	* mono	
.mloop
	move.b	(a1,d5.l),d2
	ext	d2
	asl	#5,d2 * scale
	move	d2,(a3)+
	
	add.l	d0,d5
	cmp.l	d4,d5
	blo.b	.1
	moveq	#0,d5
.1
	dbf	d7,.mloop
    moveq   #1,d0
	rts

.stereo
	move.l	samplepointer2(a5),a2
	move.l	(a2),a2
.sloop
	move.b	(a1,d5.l),d2
	move.b	(a2,d5.l),d3
	ext	d2
	ext	d3
	add	d3,d2
	asl	#4,d2 * scale
	move	d2,(a3)+

	add.l	d0,d5
	cmp.l	d4,d5
	blo.b	.2
	moveq	#0,d5
.2
	dbf	d7,.sloop
	rts

  endif ; FEATURE_SPECTRUMSCOPE


***************************************************************************
*
* Region and clipping for filebox
*
***************************************************************************

createlistBoxRegion
	bsr.b	disposeListBoxRegion

	lore	GFX,NewRegion
	move.l	d0,listBoxRegion(a5)
	beq.b	.x

	lea	-ra_SIZEOF(sp),sp
	move.l	sp,a1
	moveq	#30+WINX,d0
	;moveq	#62+WINY,d1
	move	fileBoxTopEdge(a5),d1
	move	WINSIZX(a5),d2
	sub	#10,d2

	;move	#127+WINY,d3
	move	fileBoxTopEdge(a5),d3
	add		#127-62-1,d3 * magic constant

	add	boxy(a5),d3
    sub BOTTOM_MARGIN(a5),d3
	add	windowleft(a5),d0
	add	windowtop(a5),d1
	add	windowtop(a5),d3

	; Adjust the end X so that it matches the 
	; markline highlight
	subq	#3,d2
	; Adjust the start x so that font will not bleed outside
	; the markline highlight
	addq	#1+2,d0

	move	d0,ra_MinX(a1)
	move	d1,ra_MinY(a1)
	move	d2,ra_MaxX(a1)
	move	d3,ra_MaxY(a1)

	move.l	listBoxRegion(a5),a0
	lob	OrRectRegion
	lea	ra_SIZEOF(sp),sp
.x	tst.l	d0
	rts


disposeListBoxRegion
	pushm	all
	move.l	listBoxRegion(a5),d0
	beq.b	.x
	clr.l	listBoxRegion(a5)
	move.l	d0,a0
	lore	GFX,DisposeRegion
.x	popm	all
	rts

createInfoBoxRegion
	bsr		disposeInfoBoxRegion
	lore	GFX,NewRegion
	move.l	d0,infoBoxRegion(a5)
	beq.b	.x

	lea	-ra_SIZEOF(sp),sp
	move.l	sp,a1
	moveq	#7+WINX,d0
	;moveq	#62+WINY,d1
	move	infoBoxTopEdge(a5),d1
	move	WINSIZX(a5),d2
	sub		#10+1,d2 * margin

	move	d1,d3	
	add		infoBoxHeight(a5),d3

	add	windowleft(a5),d0
	add	windowtop(a5),d1
	add	windowtop(a5),d3


	move	d0,ra_MinX(a1)
	move	d1,ra_MinY(a1)
	move	d2,ra_MaxX(a1)
	move	d3,ra_MaxY(a1)
	
	move.l	infoBoxRegion(a5),a0
	lob	OrRectRegion
	lea	ra_SIZEOF(sp),sp
.x	tst.l	d0
	rts


disposeInfoBoxRegion
	pushm	all
	move.l	infoBoxRegion(a5),d0
	beq.b	.x
	clr.l	infoBoxRegion(a5)
	move.l	d0,a0
	lore	GFX,DisposeRegion
.x	popm	all
	rts

setListBoxClip
	pushm	all
	tst.l	listBoxRegion(a5)
	beq.b	.x
	move.l	windowbase(a5),a0
	move.l	wd_WLayer(a0),a0
	move.l	listBoxRegion(a5),a1
	lore	Layers,InstallClipRegion
	; d0 = previous clip region or NULL
	move.l	d0,listBoxClipRegion(a5)
	; Out of memory is also possible, this
	; is visible in some flag somewhere.
.x	popm	all
	rts


removeListBoxClip
	move.l	listBoxClipRegion(a5),a1
removeClip
	move.l	windowbase(a5),a0
	move.l	wd_WLayer(a0),a0
	; Null is ok here for a1
	lore	Layers,InstallClipRegion
	rts

setInfoBoxClip
	pushm	all
	tst.l	infoBoxRegion(a5)
	beq.b	.x
	move.l	windowbase(a5),a0
	move.l	wd_WLayer(a0),a0
	move.l	infoBoxRegion(a5),a1
	lore	Layers,InstallClipRegion
	; d0 = previous clip region or NULL
	move.l	d0,infoBoxClipRegion(a5)
	; Out of memory is also possible, this
	; is visible in some flag somewhere.
.x	popm	all
	rts


removeInfoBoxClip
	move.l	infoBoxClipRegion(a5),a1
	bra		removeClip
	
***************************************************************************
*
* Row button layout
*
***************************************************************************
 
; Store the original gadget gg_Widht and gg_LeftEdge 
; for relative layouting later when window size changes.
initializeButtonRowLayout
	lea	row1Gadgets,a0
	bsr.b	.do
	lea	row2Gadgets,a0
;	bsr.b	.do
	
.do
.1	tst	(a0)
	beq.b	.2
	move.l	a0,a1
	add	(a0)+,a1
	move	gg_Width(a1),(a0)+
	move	gg_LeftEdge(a1),(a0)
	; Remove left border
	subq	#8,(a0)+
	bra.b	.1
.2
	rts


layoutGadgetsHorizontal:
horizontalLayout:
	* Set correct font for calculating text widths for buttons
	move.l	rastport(a5),a1
	move.l	listfontbase(a5),a0
	lore	GFX,SetFont	
	bsr.b	.it
	move.l	rastport(a5),a1
	move.l	fontbase(a5),a0
	lore	GFX,SetFont	
	rts

.it
    ; Position slider - play mode change button
    ; As wide as the window minus some borders and bonus
    tst.b   showPositionSlider(a5)
    beq     .noPos
    move	winstruc+nw_Width,d0
    sub	    #8+8+2,d0
    sub	    #18+2,d0      ; mode button width
    lea     gadgetPositionSlider,a0
    lea     gadgetPlayModeChangeButton-gadgetPositionSlider(a0),a1
    move    d0,gg_Width(a0)

    move    gg_TopEdge(a0),gg_TopEdge(a1)
    move    gg_Height(a0),gg_Height(a1)
    move    gg_LeftEdge(a0),d0
    add     gg_Width(a0),d0
    move    d0,gg_LeftEdge(a1)
    addq    #1+2,gg_LeftEdge(a1)
    subq    #2,gg_TopEdge(a1)
    addq    #4,gg_Height(a1)
.noPos
	
  if DEBUG
	moveq	#0,d1
	move	winstruc+nw_Width,d1
	move	d1,d0
	; remove left and right borders
	sub     #8+8,d1 
	lsl.l	#8,d1
	; original width without borders
	divu	#264-8-8,d1
	ext.l	d1
	DPRINT	"Layout width=%ld mul=%ld"
  endif

	lea	row1Gadgets,a0
	bsr.b	.do
	lea	row2Gadgets,a0
;	bsr.b	.do


.do
.1	tst	(a0)
	beq.b	.2
	move.l	a0,a1
	add	(a0),a1

	moveq	#0,d1
	move	winstruc+nw_Width,d1
	; remove left and right borders
	sub	#8+8,d1 
	lsl.l	#8,d1
	; original width without borders
	divu	#264-8-8,d1
	move.l	d1,d2
	
	mulu	4(a0),d1
	lsr.l	#8,d1
	; add left border
	addq	#8,d1
	move	d1,gg_LeftEdge(a1)

	mulu	2(a0),d2
	lsr.l	#8,d2
	move	d2,gg_Width(a1)

	bsr.b	.centerContent
	addq	#6,a0
	bra.b	.1
.2
	rts

; in:
;   a1 = gadget
.centerContent
	tst.l	gg_GadgetText(a1)
	bne.b	centerGadgetText
	move	gg_Flags(a1),d0
	and	#GFLG_GADGIMAGE,d0
	bne.b	.centerImage
	rts

.centerImage
	move.l	gg_GadgetRender(a1),a2	
	move	gg_Width(a1),d3
	sub	ig_Width(a2),d3
	lsr	#1,d3
	move	d3,ig_LeftEdge(a2)
	rts

* In:
*   a1 = gadget
centerGadgetText:
	push	a0
	move.l	gg_GadgetText(a1),a2

	move.l	it_IText(a2),a0
	move.l	a0,d0
.c	tst.b	(a0)+
	bne.b	.c
	sub.l	d0,a0
	subq	#1,a0
	* string length in d0
	move.l	a0,d0

	; Calculate text length in pixels using
	; the current rastport draw modes.
	push	a1
	move.l	rastport(a5),a1
	move.l	it_IText(a2),a0
	lore	GFX,TextLength
	pop	a1

	; center	
	move	gg_Width(a1),d3
	sub	d0,d3
	bpl.b	.p
	moveq	#0,d3
.p
	;;;addq	#1,d3 * round up
	lsr		#1,d3
	move	d3,it_LeftEdge(a2)
	
	pop	a0
	rts
	
***************************************************************************
*
* Vertical layout
* Layout vertical
* VerticalLayout
* LayooutVertical
*
***************************************************************************

layoutGadgetsVertical:
verticalLayout:
	DPRINT	"layoutGadgetVertical"

	*** Infobox

	move	listFontHeight(a5),d1
	add		d1,d1
	addq	#1,d1
	move	d1,infoBoxHeight(a5)

	move	infoBoxTopEdge(a5),d0
	add		d1,d0
	addq	#4,d0 ; margin

	*** Button row 1
    add     windowtop(a5),d0
   
    tst.b   showPositionSlider(a5)
    beq     .noPos
    * Add position slider here
    lea     gadgetPositionSlider,a0
    addq    #2,d0
    move    d0,gg_TopEdge(a0)
    move    #10-1,gg_Height(a0)
    add     #12,d0
.noPos

	move	d0,buttonRow1TopEdge(a5)

	moveq	#13,d1
	tst.b	altbuttons(a5)
	beq.b	.norm1
	add		d1,d1
.norm1
	lea		.setTopAndHeight(pc),a2
	lea		row1Gadgets,a0
	bsr		.forEachGadget
	
	*** Button row 2

	add		d1,d0
	add		#1,d0 ; margin

	* Height is either normal or double
	moveq	#13,d1
	tst.b	altbuttons(a5)
	beq.b	.norm2
	add		d1,d1
.norm2
	* ..or font height if it is taller
	move	listFontHeight(a5),d2
	cmp		d2,d1
	bhs.b	.3
	move	d2,d1
.3	

	lea		row2Gadgets,a0
	bsr		.forEachGadget

	lea		.centerTextVertical(pc),a2
	lea		row2Gadgets,a0
	bsr		.forEachGadget

	bsr		.makeVolumeSliderKnob
	bsr		.setButtonImages

	add		d1,d0
	addq	#4,d0 ; margin
    sub     windowtop(a5),d0
	move	d0,fileBoxTopEdge(a5)

	*** Left side gadgets

    add     windowtop(a5),d0
	* Align mode button and file slider with filebox
	lea		gadgetListModeChangeButton,a0
	subq	#2,d0
	move	d0,gg_TopEdge(a0)

    move    #13,gg_Height(a0)   * Large mode button
    tst.b   altbuttons(a5)
    beq     .noAlt1
    addq    #7,gg_Height(a0)    * Normal mode button
.noAlt1


	lea		gadgetFileSlider,a1
	add		gg_Height(a0),d0
	addq	#3,d0
	move	d0,gg_TopEdge(a1)
 	rts
	
* in:
*   a0 = gadget row
*   a2 = callback with a1=gadget
.forEachGadget
.1	tst	(a0)
	beq.b	.2
	move.l	a0,a1
	add	(a0),a1
	addq	#6,a0
	jsr		(a2)
	bra.b	.1
.2	rts

.setTopAndHeight:
	move	d0,gg_TopEdge(a1)
	move	d1,gg_Height(a1)
	cmp.l	#gadgetVolumeSlider,a1
	bne.b	.x
	addq	#2,gg_TopEdge(a1)
	subq	#4,gg_Height(a1)
.x	rts

.centerTextVertical
	tst.l	gg_GadgetText(a1)
	beq.b	.noText
	move	gg_Height(a1),d3
	move.l	gg_GadgetText(a1),a3
	move.l	#list_text_attr,it_ITextFont(a3)
	move.l	it_ITextFont(a3),a4
	sub		ta_YSize(a4),d3
	addq	#1,d3 * round up
	lsr		#1,d3
	move	d3,it_TopEdge(a3)
.noText
	rts

.setButtonImages
	lea		gadgets,a3
	basereg	gadgets,a3
	lea		button1im,a4
	basereg	button1im,a4

	lea		gadgetPlayButton(a3),a0
	lea		button1im(a4),a1
	lea		button1imDouble(a4),a2
	bsr		.setImage
	lea		gadgetInfoButton(a3),a0
	lea		button2im(a4),a1
	lea		button2imDouble(a4),a2
	bsr		.setImage
	lea		gadgetStopButton(a3),a0
	lea		button3im(a4),a1
	lea		button3imDouble(a4),a2
	bsr		.setImage
	lea		gadgetEjectButton(a3),a0
	lea		button4im(a4),a1
	lea		button4imDouble(a4),a2
	bsr		.setImage
	lea		gadgetNextButton(a3),a0
	lea		button5im(a4),a1
	lea		button5imDouble(a4),a2
	bsr		.setImage
	lea		gadgetPrevButton(a3),a0
	lea		button6im(a4),a1
	lea		button6imDouble(a4),a2
	bsr		.setImage
	lea		gadgetNextSongButton(a3),a0
	lea		button12im(a4),a1
	lea		button12imDouble(a4),a2
	bsr		.setImage
	lea		gadgetPrevSongButton(a3),a0
	lea		button13im(a4),a1
	lea		button13imDouble(a4),a2
	bsr		.setImage
	lea		gadgetForwardButton(a3),a0
	lea		kela2im(a4),a1
	lea		kela2imDouble(a4),a2
	bsr		.setImage
	lea		gadgetRewindButton(a3),a0
	lea		kela1im(a4),a1
	lea		kela1imDouble(a4),a2
	bsr		.setImage
	endb	a3
	endb	a4	
	rts

.setImage
	move.l	gg_GadgetRender(a0),a6
	tst.b	altbuttons(a5)
	bne.b	.useLarge
	move.l	a1,ig_ImageData(a6)
	move	#8,ig_Height(a6)
	move	#3,ig_TopEdge(a6)
	cmp.l	#button2im,a1
	bne.b	.notI
	* One is 1 pix taller
	addq	#1,ig_Height(a6)
	subq	#1,ig_TopEdge(a6)
.notI
	rts
.useLarge
	move.l	a2,ig_ImageData(a6)
	move	#15,ig_Height(a6)
	move	#5,ig_TopEdge(a6)
	rts


* in:
*   d1 = row height
.makeVolumeSliderKnob
	* Make slider knob for volume slider
	move	d1,d3

    lea     gadgetVolumeSlider,a1
    move.l  gg_GadgetRender(a1),a1
	subq	#4,d3 * magic constant
	move	d3,ig_Height(a1)

	* Source data
	lea		horizPropGadgetGfxNormal,a2
	tst.b	uusikick(a5)
	bne.b	.newKnob
	lea		horizPropGadgetGfxNormal_kick13,a2
.newKnob
	* Target buffer
	lea		slider1im,a3

	* d2 = offset to 2nd plane in destination
	move	d3,d2
	add		d2,d2

	move	9*2(a2),(a3,d2) * line 0, bpl 2
	move	(a2)+,(a3)+ * line 0, bpl 1
	subq	#1,d3
.lineLoop
	move	9*2(a2),(a3,d2) * line n, bpl 2
	move	(a2),(a3)+ * line n, bpl 1
	subq	#1,d3
	cmp		#1,d3
	bne.b	.lineLoop
	add		#7*2,a2	* get to the last data line
	move	9*2(a2),(a3,d2) * line last, bpl 2
	move	(a2),(a3)+ * line last, bpl 1
	rts



***************************************************************************
*
* Modland, Aminet integration using UHC
*
***************************************************************************

SEARCH_MODLAND          = 0
SEARCH_AMINET           = 1
SEARCH_MODULES          = 2
SEARCH_HVSC             = 3
SEARCH_AMIGAREMIX       = 4
SEARCH_RKO              = 5
SEARCH_STATIONS         = 6
SEARCH_RECENT_PLAYLISTS = 7
SEARCH_TURRAN           = 8

modlandSearch
	moveq	#SEARCH_MODLAND,d7
	bra 	remoteSearch

aminetSearch
	moveq	#SEARCH_AMINET,d7
	bra 	remoteSearch

modulesSearch
	moveq	#SEARCH_MODULES,d7
	bra 	remoteSearch

hvscSearch
	moveq	#SEARCH_HVSC,d7
	bra 	remoteSearch

amigaRemixSearch
	moveq	#SEARCH_AMIGAREMIX,d7
	bra 	remoteSearch

rkoSearch
	moveq	#SEARCH_RKO,d7
	bra 	remoteSearch

stationsSearch
	moveq	#SEARCH_STATIONS,d7
	bra 	remoteSearch

recentPlaylistsSearch
	moveq	#SEARCH_RECENT_PLAYLISTS,d7
	bra 	remoteSearch

turranSearch
	moveq	#SEARCH_TURRAN,d7
	bra 	remoteSearch

* Requests a search pattern from the user,
* then creates an executable shell script to launch
* UHC search using the given search pattern.
* The search result file is imported as a normal modulelist.
*
* in:
*  d7 = remote type enumeration
remoteSearch
	tst.b	uhcAvailable(a5)
	bne.b	.go
	rts
.go
	jsr		lockMainWindow

	lea	.srh(pc),a0
	jsr		printbox
	bra.b	.srhh
.srh
	dc.b	"Searching...",0
 even
.srhh

    * Keep track of the recent playlists search operation
    * status for later. Start by assuming failure.
    cmp.b   #SEARCH_RECENT_PLAYLISTS,d7
    bne     .1sr
    st      recentPlaylistsLastSearchFailed(a5)
.1sr

	* Prepare script into desbuf(a5)

    lea     .genericSearchCmd(pc),a0
	lea 	.modlandResultsPath(pc),a1
	cmp.b	#SEARCH_MODLAND,d7
	beq.b	.1
	lea 	.modulesResultsPath(pc),a1
    cmp.b   #SEARCH_MODULES,d7
    beq.b   .1
	lea 	.hvscResultsPath(pc),a1
    cmp.b   #SEARCH_HVSC,d7
    beq.b   .1
	lea 	.amigaRemixResultsPath(pc),a1
    cmp.b   #SEARCH_AMIGAREMIX,d7
    beq     .1
	lea 	.rkoResultsPath(pc),a1
    cmp.b   #SEARCH_RKO,d7
    beq.b   .1
	lea		.stationsSearchCmd(pc),a0
	lea 	.stationsResultsPath(pc),a1
    cmp.b   #SEARCH_STATIONS,d7
    beq     .1
	lea		.recentPlaylistsSearchCmd(pc),a0
	lea 	.recentPlaylistsResultsPath(pc),a1
    cmp.b   #SEARCH_RECENT_PLAYLISTS,d7
    beq     .1
	lea		.turranSearchCmd(pc),a0
	lea 	.turranResultsPath(pc),a1
    cmp.b   #SEARCH_TURRAN,d7
    beq     .1	
	lea		.aminetSearchCmd(pc),a0
	lea 	.aminetResultsPath(pc),a1
.1
    pushpea .pathCmd(pc),d0  * path cmd
    move.l  a1,d1       * search cmd/search name
 	move.l	#gadgetSearchStringBuffer,d2		* search terms
	jsr		desmsg

	* Save it into a file for execution
	lea		desbuf(a5),a0
	move.l	a0,a1
.findEnd
	tst.b	(a0)+
	bne.b	.findEnd
    
	* Find length for saving
	move.l	a0,d0
	sub.l	a1,d0
    subq.l  #1,d0 * exclude terminating zero

	lea		remoteScriptPath(pc),a0
	; data in a1
	bsr		plainSaveFile
	tst.l	d0
	bmi		.exit

    ; Redirect output to file, this contains error messages.
    ; Output is not used here!
    move.l  #searchOut,d1
    move.l  #MODE_NEWFILE,d2
    lore    Dos,Open
    move.l  d0,d4
    beq     .exit

	pushpea	remoteExecute(pc),d1
	moveq	#0,d2       * input
	move.l	d4,d3	    * output
    move.l  nilfile(a5),d3
	lob     Execute
	DPRINT	"Execute status=%ld"

    move.l  d4,d1
    lob     Close

	* Prepare results path into stack
	lea		-100(sp),sp

	pushpea	.uhcTempDirVar(pc),d1
	move.l	sp,d2
	moveq	#50,d3
	move.l	#GVF_GLOBAL_ONLY,d4
	lob		GetVar
	tst.l	d0
	bpl.b	.gotVar
	moveq	#0,d0
	bra     .bail
.gotVar

	lea		.modlandResultsPath(pc),a0
	cmp.b	#SEARCH_MODLAND,d7
	beq.b	.a
	lea		.aminetResultsPath(pc),a0
	cmp.b	#SEARCH_AMINET,d7
	beq.b	.a
	lea		.modulesResultsPath(pc),a0
    cmp.b   #SEARCH_MODULES,d7
    beq.b   .a
    lea     .hvscResultsPath(pc),a0
    cmp.b   #SEARCH_HVSC,d7
    beq.b   .a
    lea     .amigaRemixResultsPath(pc),a0
    cmp.b   #SEARCH_AMIGAREMIX,d7
    beq     .a
    lea     .rkoResultsPath(pc),a0
    cmp.b   #SEARCH_RKO,d7
    beq     .a
    lea     .stationsResultsPath(pc),a0
    cmp.b   #SEARCH_STATIONS,d7
    beq     .a
    lea     .recentPlaylistsResultsPath(pc),a0
    cmp.b   #SEARCH_RECENT_PLAYLISTS,d7
    beq     .a
    lea     .turranResultsPath(pc),a0
.a

	* Jump to after the variable
	lea		(sp,d0.l),a1
.co	move.b	(a0)+,(a1)+
	bne.b	.co

	* Read the results file
	move.l	sp,a0
	move.l	a0,d0
	DPRINT	"loading %s"
 	bsr	plainLoadFile
	lea		100(sp),sp	* get rid of results path
	DPRINT	"Results=%lx"
.bail
	tst.l	d0
	beq		.exit
	; d0 = data
	; d1 = len
	
	DPRINT	"Importing"
	jsr		obtainModuleList
	pushm	all
	* free previous list
	bsr		freeSearchList
	popm	all

	; start of data
	move.l	d0,a3
	; end of data
	lea		(a3,d1.l),a4
	; destination list
	lea searchResultsListHeader(a5),a2
	
	* Determine line header to use to add the "http://" -base address
	* to each line.
	pushpea	.modlandLine(pc),d6
	moveq	#.modlandLineE-.modlandLine,d4
	cmp.b	#SEARCH_MODLAND,d7
	beq.b	.2
	cmp.b	#SEARCH_AMINET,d7
	beq.b	.aa
	pushpea	.modulesLine(pc),d6
	moveq	#.modulesLineE-.modulesLine,d4	
    cmp.b   #SEARCH_MODULES,d7
    beq.b   .2
	pushpea	.hvscLine(pc),d6
	moveq	#.hvscLineE-.hvscLine,d4	
    cmp.b   #SEARCH_HVSC,d7
    beq.b   .2
	pushpea	.turranLine(pc),d6
	moveq	#.turranLineE-.turranLine,d4	
    cmp.b   #SEARCH_TURRAN,d7
    beq.b   .2
	pushpea	.amigaRemixLine(pc),d6
	moveq	#.amigaRemixLineE-.amigaRemixLine,d4	
    cmp.b   #SEARCH_AMIGAREMIX,d7
    beq     .2
	pushpea	.rkoLine(pc),d6
	moveq	#.rkoLineE-.rkoLine,d4	
    cmp.b   #SEARCH_RKO,d7
    beq     .2
    moveq   #0,d6   * No base header to prepend
    * Additional space for readable name
    moveq   #100,d4  * Base header length, add extra space in this case
    cmp.b   #SEARCH_STATIONS,d7
    beq     .2
    * RECENT_PLAYLISTS
    pushpea	.recentPlaylistsLine(pc),d6 
    * Add extra space for visible name
	move.l	#.recentPlaylistsLineE-.recentPlaylistsLine+100,d4	
	bra.b	.2
.aa
	pushpea	.aminetLine(pc),d6
	moveq	#.aminetLineE-.aminetLine,d4	

;	* Aminet mirror is populated after aminetsearch has been done,
;	* so get it here.
;	bsr		getUHCAminetMirror
;	move.l	uhcAminetMirrorPath(a5),d6
;	beq.b	.noAminet
;	move.l	d6,a0
;.flen
;	tst.b	(a0)+
;	bne.b	.flen
;	move.l	a0,d4
;	sub.l	d6,d4 * string length in d4
.2
    ; ---------------------------------

	* Import data
	* This will also set l_remote and l_nameaddr
	* to correct values for remote files.

    * Set filter for modland entries
	lea		.modlandFilter(pc),a0
	cmp.b	#SEARCH_MODLAND,d7
	beq.b	.yesModl
    * Default: no filter
	sub.l	a0,a0
.yesModl

    * Check if playlist entries already have an url.
    * If yes, let's not append the default baseurl in d6.
    * New data is in a3.
    cmp.b   #"h",(a3)
    bne     .3
    cmp.b   #"t",1(a3)
    bne     .3
    cmp.b   #"t",2(a3)
    bne     .3
    cmp.b   #"p",3(a3)
    bne     .3
    * Playlist entry started with an url, let's not append
    * the default.
    moveq   #0,d6

.3	
    jsr		importModuleProgramFromDataSkipHeader
    move.l	d0,modamount(a5)
    DPRINT  "modsFromLastSearch=%ld"

    * Keep track of the recent playlists search operation
    * status for later.
    cmp.b   #SEARCH_RECENT_PLAYLISTS,d7
    bne     .1sr2
    * Failed if got zero items
    tst.l   d0
    seq     recentPlaylistsLastSearchFailed(a5)
.1sr2

	move.l	a3,a0   
	jsr		freemem

    bsr     .postProcessSearchResults
    
	tst.b	autosort(a5)
	beq.b	.noSort
	jsr		engageSearchResultsMode
    * Sort will select the 1st item
    * engageSearcuResultsMode will clear the selection,
    * so do it in this order?
	jsr		sortButtonAction
	jsr		releaseModuleList
    bra     .sortX
.noSort
.sorted
	jsr		releaseModuleList
.exit
	jsr		engageSearchResultsMode
.sortX
	jmp		unlockMainWindow
    

.postProcessSearchResults
    ; ---------------------------------
    * Postprocess step
    ; Get readable name from search results
    ; for stations, playlists

    moveq   #0,d3
   
    cmp.b   #SEARCH_RECENT_PLAYLISTS,d7
    beq     .s22
    cmp.b   #SEARCH_STATIONS,d7
    bne     .s2
.s22

    lea     searchResultsOut(pc),a0
    jsr     plainLoadFile
    move.l  d0,d3
    beq     .s2
    tst.l   d1
    beq     .s2
    move.l  d3,a2

    ; Find column for "Name" for radio stations
    ; Find column for "Title" for playlists
    ; This loop does not have boundary checks!
.z1 
    cmp.b   #SEARCH_STATIONS,d7
    beq     .rs1
    moveq   #5-1,d1 * chars to skip over
    cmp.b   #"T",(a2)+
    bne.b   .z1
    cmp.b   #"i",(a2)
    bne.b   .z1
    cmp.b   #"t",1(a2)
    bne.b   .z1
    cmp.b   #"l",2(a2)
    beq.b   .pl1
    bra     .z1
.rs1
    moveq   #4-1,d1 * chars to skip over
    cmp.b   #"N",(a2)+
    bne.b   .z1
    cmp.b   #"a",(a2)
    bne.b   .z1
    cmp.b   #"m",1(a2)
    bne.b   .z1
    cmp.b   #"e",2(a2)
    bne.b   .z1
.pl1
    * d0 = Name start column
    move.l  a2,d0
    subq.l  #1,d0
    add     d1,a2   * skip to the next space to find out the next column
.z2 cmp.b   #" ",(a2)+
    beq     .z2
    * d1 = name end column
    move.l  a2,d1
    * d1 = name length
    sub.l   d0,d1
    subq.l  #1,d1
    * Set upper limit to not overflow buffer,
    * this was allocated earlier.
    cmp.l   #99,d1
    bls.b   .z3
    moveq   #99,d1
.z3
    * d0 = name offset
    sub.l   d3,d0
    subq.l  #4,d0
    
    * skip header, 1st line starts with "0"
.s0 cmp.b   #"0",(a2)+
    bne     .s0
    subq    #1,a2

    jsr     getVisibleModuleListHeader
    move.l  a0,a3
.s1
	TSTNODE	a3,a3
	beq.b	.s2
    st      l_remote(a3)
    lea     l_filename(a3),a1
    
    * Find end of filename, after it there are extra bytes
    * for the visible name.
.s4 tst.b   (a1)+
    bne     .s4
    ; after the NULL put the extra name
    move.l  a1,l_nameaddr(a3)
    st      l_separateName(a3)

    * Copy name, starts here
    add     d0,a2
    move    d1,d2
.s7 move.b  (a2)+,(a1)+
    subq    #1,d2
    bne     .s7
    clr.b   (a1)

    * Skip to next line
.s3 cmp.b   #10,(a2)+
    bne     .s3
	bra.b	.s1
.s2

    * Free loaded searchout file data
    move.l  d3,a0
    jmp     freemem
    

* Modland whitelist
* In:
*   a3 = name to check, ends with 10 or 0
* Out:
*   d0 = true if ok, false otherwise
.modlandFilter
	pushm	a0/a1
	lea		.modlandPostfixes(pc),a0
	lea		.modlandPrefixes(pc),a1
	bsr		filterName

; if DEBUG
;	tst.l	d0
;	bne.b	.ok
;	DPRINT	"->REJECTED"
;.ok
; endif

	popm	a0/a1
	rts

.modlandPostfixes
	dc.l	"adsc"
	dc.l	"ahx "
	dc.l	"aon "
	dc.l	"aps "
	dc.l	"avp "
	dc.l	"bd  "
	dc.l	"bp  "
	dc.l	"bp3 "
	dc.l	"bss "
	dc.l	"cm  "
	dc.l	"cus "
	dc.l	"dbm "
	dc.l	"dbm0"
	dc.l	"digi"
	dc.l	"dl  "
	dc.l	"dln "
	dc.l	"dm  "
	dc.l	"dm2 " 
	dc.l	"dmu "
	dc.l	"dum "
	dc.l	"dw  "
	dc.l	"dz  "
	dc.l	"ea  "
	dc.l	"fc  "
	dc.l	"fp  "
	dc.l	"fred"
	dc.l	"ftm "
	dc.l	"glue"
	dc.l	"gmc "
	dc.l	"hip "
	dc.l	"hip7"
	dc.l	"hipc"
	dc.l	"is  "
	dc.l	"is20"
	dc.l	"it  "
	dc.l	"jam "
	dc.l	"jb  "
	dc.l	"jd  "
	dc.l	"jpo "
	dc.l	"jt  "
	dc.l	"kh  "
	dc.l	"ma  "
	dc.l	"mc  "
	dc.l	"mk2 "
	dc.l	"ml  "
	dc.l	"mm8 "
	dc.l	"mmd0"
	dc.l	"mmd1"
	dc.l	"mmd2"
	dc.l	"mmd3"
	dc.l	"mmdc"
	dc.l	"mod "
	dc.l	"mod "
	dc.l	"mon "
	dc.l	"mtm "
	dc.l	"mug "
	dc.l	"mxtx"
	dc.l	"okta"
	dc.l	"osp "
	dc.l	"prt "
	dc.l	"psid"
	dc.l	"rh  "
	dc.l	"s3m "
	dc.l	"sa  "
	dc.l	"sc  "
	dc.l	"sfx "
	dc.l	"sid "
	dc.l	"sid2"
	dc.l	"smod"
	dc.l	"sng "
	dc.l	"soc "
	dc.l	"sog "
	dc.l	"spn "
	dc.l	"sqt "
	dc.l	"sun "
    dc.l    "syn "
	dc.l	"tcb "
	dc.l	"tf  "
	dc.l	"thx "
	dc.l	"vss "
	dc.l	"wb  "
	dc.l    "tme "
	dc.l	"xm  "
    dc.l    "vgm " * vgm2wav
    dc.l    "vgz " *
    dc.l    "ay  " *
    dc.l    "gbs " *
    dc.l    "gym " *
    dc.l    "hes " *
    dc.l    "kss " *
    dc.l    "nsf " *
    dc.l    "nsfe" *
    dc.l    "sap " *
    dc.l    "spc " * 
    dc.l    "mdx " *
	dc.l	0
;todo: synmod

.modlandPrefixes
	dc.l	"mdat"
	dc.l	"jpn."
	dc.l	"mcr."
	dc.l	"qts."
    dc.l    "cust"
	dc.l	0

.aminetLine
	dc.b	"http://de.aminet.net/aminet/",0
.aminetLineE

.modlandLine
	dc.b	"http://ftp.modland.com/pub/modules/",0
.modlandLineE

.modulesLine
	dc.b	"http://www.modules.pl/",0
.modulesLineE

.hvscLine
    dc.b    "http://hvsc.csdb.dk/",0     
.hvscLineE

.amigaRemixLine
    dc.b    "http://uhc.amigaremix.com/",0
.amigaRemixLineE

.rkoLine
    dc.b    "http://uhc.remix.kwed.org/",0
.rkoLineE

.turranLine
    dc.b    "http://ftp2.grandis.nu/turran/FTP/",0
.turranLineE

.recentPlaylistsLine
	dc.b	"http://asciiarena.se/",0
.recentPlaylistsLineE

.uhcTempDirVar
	dc.b	"UHC/TEMPDIR",0

.pathCmd
    dc.b    'path "${UHCBIN}C" "${UHCBIN}S" ADD',0

.genericSearchCmd
	dc.b	"%s",10     ; path
	dc.b 	'%s SEARCHLIMIT=10000 %s',10  ; search, terms
	dc.b	0

.modlandResultsPath
	dc.b	"modlandsearch",0
.aminetResultsPath
	dc.b	"aminetsearch",0
.aminetSearchCmd
	dc.b	"%s",10
	dc.b 	'%s mods/ %s',10
	dc.b	0
.turranSearchCmd
	dc.b	"%s",10
	dc.b 	'%s collection/music/ %s',10
	dc.b	0

.modulesResultsPath
	dc.b	"modulessearch",0
.hvscResultsPath
	dc.b	"hvscsearch",0
.amigaRemixResultsPath
	dc.b	"amigaremixsearch",0
.rkoResultsPath
	dc.b	"rkosearch",0
.turranResultsPath
	dc.b	"turransearch",0
.stationsResultsPath
	dc.b	"stationsearch",0
.stationsSearchCmd
	dc.b	"%s",10
	dc.b 	'uhcmirrorsearch SEARCHLIMIT=1000 SEARCHRESULTTO=T:searchresults %s %s',10
	dc.b	0
.recentPlaylistsResultsPath
	dc.b	"playlistsearch",0
.recentPlaylistsSearchCmd
	dc.b	"%s",10
	dc.b 	'uhcmirrorsearch SEARCHRESULTTO=T:searchresults %s',10
	dc.b	0



remoteExecute
       dc.b    "execute "
remoteScriptPath
       dc.b    "T:hip",0

searchOut = nilname
;searchOut
;        dc.b    "T:searchout",0
searchResultsOut
        dc.b    "T:searchresults",0
 even

* Set list node remote type and
* set l_nameaddr to be proper for showing to user.
* In:
*   a0 = list node
configRemoteNode:
	pushm	d0/a0-a4
	st		l_remote(a0)
    ;DPRINT  "configRemoteNode"
    
 	lea		l_filename(a0),a1
	move.l	a1,a2
.findEnd2
	tst.b	(a1)+
	bne.b	.findEnd2

    ; check if there is "#name=" somewhere.
    ; before it is the url, after it a visible name
    ; end bound:
    move.l  a1,d0
    subq.l  #8,d0
    bmi     .noHash * very short string?
    move.l  d0,a3
    move.l  a2,a4
.hash1
    cmp.l   a4,a3
    beq     .noHash
    cmp.b   #"#",(a4)+
    bne     .hash1
    cmp.b   #"n",0(a4)
    bne     .hash1
    cmp.b   #"a",1(a4)
    bne     .hash1
    cmp.b   #"m",2(a4)
    bne     .hash1
    cmp.b   #"e",3(a4)
    bne     .hash1
    cmp.b   #"=",4(a4)
    bne     .hash1
    ; found it!
    ; terminate file path and store nameaddr
    clr.b   -1(a4)
    addq    #5,a4
    move.l  a4,l_nameaddr(a0)
    st      l_separateName(a0)
 if DEBUG
    ;move.l  a4,d0
    ;DPRINT  "#name=%s"
 endif
    bra     .x
.noHash


	moveq	#2-1,d0
    * a2 points to l_filename,
	* l_filename is odd here

    * For some remote sites 
    * take the last file part only to avoid redundancy
	* "captain/captain_-_space_debris"

    ifeq l_filename&1
        fail Assumed uneven here
    endif

    cmp.l   #"remi",11(a2)  * odd+odd = even offset
    bne.b   .4
    cmp.l   #"x.kw",15(a2)
    beq.b   .3
.4
    cmp.l   #"amig",11(a2)
    bne.b   .2
    cmp.l   #"arem",15(a2)
    beq.b   .3
.2
	cmp.l	#"modu",11(a2)
	bne.b	.1
	cmp.l	#"les.",15(a2)
	bne.b	.1
.3
	moveq	#1-1,d0
.1

.findSlash
	cmp.l	a1,a2
	beq.b	.break * safety check
	cmp.b	#"/",-(a1)
	bne.b	.findSlash
	dbf	d0,.findSlash
	addq	#1,a1
.break
	move.l	a1,l_nameaddr(a0)

;    move.l  a1,d0
;    DPRINT  "nameaddr=%s"

.x
	popm	d0/a0-a4
	rts



*
* Loads a remote file into a file using aget.
* in:
*   a0 = url
*   a1 = buffer for output file path
*   a2 = target dir OPTIONAL
* out:
*   d0 = true: ok, false: some error

fetchRemoteFileToTarget:
	pushm	d1-a6
    bra     fetchRemoteFile\.0
fetchRemoteFile:
	pushm	d1-a6
    lea     .destinationDir(pc),a2
.0:
 if DEBUG
	move.l	a0,d0
	DPRINT	"fetchRemoteFile: %s"
 endif
    tst.b   uhcAvailable(a5)
    beq     .exit

	moveq	#0,d7	* status: fail
    move.l  a2,a6   * target path

	* Temporary target file path, the last part of the url
	move.l	a0,a2
.end
	tst.b	(a2)+
	bne.b	.end
    move.l  a2,a4
.sl	cmp.b	#"/",-(a2)
	bne.b	.sl
	addq	#1,a2

	move.l	a1,a3
	* Build temp file path into a3
.target1
    move.b  (a6)+,(a3)+
    bne.b   .target1
    subq    #1,a3
    cmp.b   #":",-1(a3)
    beq     .target2
    move.b  #"/",(a3)+
.target2

    * Max 24 chars to be friendly to the file system
    moveq   #24-1,d1
    moveq   #0,d0
.copy
    addq    #1,d0
	move.b	(a2)+,d2
    * Remove suspect chars such as ()*?'"
    cmp.b   #"(",d2
    beq     .sanity
    cmp.b   #")",d2
    beq     .sanity
    cmp.b   #"*",d2
    beq     .sanity
    cmp.b   #"?",d2
    bne     .gog
.sanity
    moveq   #"_",d2
.gog
    move.b  d2,(a3)+
	dbeq	d1,.copy
    cmp     #4,d0
    bls.b   .skip
    * Then copy four chars from the end of the original string
    * to the end, this will preserve the file extension
    * and include null
    move.b  -(a4),-(a3)
    move.b  -(a4),-(a3)
    move.b  -(a4),-(a3)
    move.b  -(a4),-(a3)
    move.b  -(a4),-(a3)
.skip

	* Source url in a0
	* Destination file in a1

    moveq   #0,d5
    moveq   #0,d6
    move.l  a0,d4

    * Get a temp buffer    
    move.l  #$10000,d0
    moveq   #MEMF_PUBLIC,d1
    jsr     getmem
    move.l  d0,a4
    tst.l   d0
    beq     .memError

 if DEBUG
    move.l  a1,d0
    DPRINT  "output=%s"
 endif
    move.l  a1,d1
	move.l	#MODE_NEWFILE,d2
	lore	Dos,Open
    DPRINT  "output open=%lx"
	move.l	d0,d5
    beq     .writeError
    * d5 = output file

    push    d4
	jsr		inforivit_downloading
	jsr		setMainWindowWaitPointer
    pop     a0

    * Streamer could have been started earlier.
    * It may also have finished already by now, if file is small.
    * a0 = url
    jsr     startStreaming
    DPRINT  "startStreaming=%lx"
    tst.l   d0
    beq     .streamError

    move.l  a0,d1
    move.l  #MODE_OLDFILE,d2
    lore    Dos,Open
    DPRINT  "input open=%lx"
    move.l  d0,d6
    beq     .readError


    * d6 = stream handle
    * a4 = temporary buffer

.loop
    * Enable input handler special mode
    move.b  hotkey(a5),-(sp)
    move.b  #1,hotkey(a5)
    clr.w   rawkeyinput(a5)

    * Read from input 
    move.l  d6,d1       * in file
    move.l  a4,d2       * buffer
    move.l  #$10000,d3  * length
    lore    Dos,Read
    DPRINT  "read=%ld bytes"

    move.b  (sp)+,hotkey(a5)
    cmp.w   #$45,rawkeyinput(a5)
    bne     .5
    moveq   #-1,d0
.5

    move.l  d0,d4       * bytes read
    * d0 = bytes read, 0 = EOF, -1 = error
    bmi.b   .readError


    move.l  d5,d1       * out file
    move.l  a4,d2       * buffer
    move.l  d4,d3       * length
    lob     Write
    tst.l   d0
    bmi     .writeError
    cmp.l   d0,d4
    bne     .writeError
    cmp.l   #$10000,d4
    beq     .loop

    DPRINT  "pipe written to local file"
	* Set status to ok
	moveq	#1,d7 

.memError
.streamError
.writeError  
.readError
    move.l  d6,d1
    beq.b   .x1
    lore    Dos,Close
.x1 move.l  d5,d1
    beq     .x2
    lore    Dos,Close
.x2
    move.l  a4,a0
    jsr     freemem

    * This stream job is finished.
    move    #-1,streamReturnCode(a5)

    * See if there was an error message
    bsr     showStreamerError
    tst.l   d0
    beq     .exit
    * status: error 
    moveq   #0,d7
.exit
	jsr		clearMainWindowWaitPointer
	move.l	d7,d0
	popm	d1-a6
    DPRINT	"fetchRemoteFile status=%ld"
	rts

.destinationDir 
    dc.b    "T:",0
    even

* Checks if UHC is installed, also checks version
initializeUHC
	tst.b	uusikick(a5)
	beq     .no

	lea		-30(sp),sp
	pushpea	.uhcBinVar(pc),d1
	move.l	sp,d2
	moveq	#29,d3
	move.l	#GVF_GLOBAL_ONLY,d4
	lore	Dos,GetVar
	lea		30(sp),sp
	tst.l	d0
    bmi     .no

    lea     .tags(pc),a0
    basereg .tags,a0
    move.l  nilfile(a5),.out(a0)
    move.l  a0,d2
    endb    a0

    pushpea .versCmd(pc),d1
    lob     SystemTagList
    * d0 = version return code, 0 if OK, 5 if WARN
    tst.l   d0
    seq     uhcAvailable(a5)    
.no
 if DEBUG   
    moveq   #1,d0
    and.b   uhcAvailable(a5),d0
    DPRINT  "uhc available: %lx"
 endif
	rts

.tags
    dc.l    SYS_Output,0
.out = *-4
    dc.l    TAG_END

.versCmd        dc.b    "version UHC:C/aget 0 84",0
.uhcBinVar	    dc.b	"UHCBIN",0
 even


;getUHCAminetMirror
;	pushm	d1-a6
;	move.l	uhcAminetMirrorPath(a5),a0
;	clr.l	uhcAminetMirrorPath(a5)
;	jsr		freemem
;
;	moveq	#100,d0
;	move.l	#MEMF_CLEAR!MEMF_PUBLIC,d1
;	jsr		getmem
;	move.l	d0,uhcAminetMirrorPath(a5)
;	move.l	d0,a3
;
;	pushpea	.aminetMirrorPath(pc),d1
;	move.l	d0,d2
;	addq.l	#.httpE-.http,d2
;	moveq	#90,d3
;	move.l	#GVF_GLOBAL_ONLY,d4
;	lore	Dos,GetVar
;	tst.l	d0
;	bmi.b	.x
;
;	lea		.http(pc),a1
;	moveq	#.httpE-.http,d0
;.c1	move.b	(a1)+,(a3)+
;	dbf	d0,.c1
;	
;.x
;	popm	d1-a6
;	rts
;
;.http	dc.b	"http://"
;.httpE
;
;.aminetMirrorPath
;	dc.b	"UHC/AMINETMIRROR",0
;	even

deinitUHC
;	move.l	uhcAminetMirrorPath(a5),a0
;	jmp		freemem
	rts
	
freeSearchList
	move.l	(a5),a6		* execbase
	lea	searchResultsListHeader(a5),a2
.loop
	* a0: list, a1: destroyed, d0: node, or zero
	move.l	a2,a0
	lob	RemHead
	beq.b	.listFreed
	move.l	d0,a0
	jsr	freemem
	bra.b	.loop

.listFreed
	cmp.b 	#LISTMODE_SEARCH,listMode(a5)
	bne.b	.no
	clr.l	modamount(a5)
.no
	rts




* In:
*   a0 = acceptable postfixes
*   a1 = acceptable prefixes
*   a3 = name to check, ends with 10 or 0
* Out:
*   Z or no Z

filterName:
	pushm	d1/d6/d7
	* From a3:
	bsr	getPreAndPostfixFromPath
	moveq	#1,d0 * resut: true
	
.1	move.l	(a0)+,d1
	beq.b	.2
	cmp.l	d1,d6
	beq.b	.ok
	bra.b	.1
.2

.3	move.l	(a1)+,d1
	beq.b	.4
	cmp.l	d1,d7
	beq.b	.ok
	bra.b	.3
.4
	* result: false, not found
	moveq	#0,d0
.ok
	popm	d1/d6/d7
	* Set Z to reject, clear Z to accept
	rts

* in:
*   a3 = path
* out:
*   d6 = postfix
*   d7 = prefix   
getPreAndPostfixFromPath
	pushm	d0-d5/a0-a6
	move.l	a3,a4	* start address, low bound
.1
	move.b	(a3)+,d0
	beq.b	.2
	cmp.b	#10,d0
	bne.b	.1
.2
	move.l	a3,a5	* end address, high bound

	* Find the start of the name 
	move.l	a3,a0	* 
	move.l	a4,a1	* start address for boundary check
	jsr		nimenalku

	* Build 4 chars prefix into d7
	moveq	#0,d7
	moveq	#4-1,d0
.p1
	cmp.l	a5,a0	* check for high bound
	beq.b	.p2
	rol.l	#8,d7
	move.b	(a0)+,d7
	dbf		d0,.p1
.p2

	* Build 4 chars postfix into d6
	moveq	#0,d6
	moveq	#4-1,d0
	subq	#1,a3	* back up to NULL or 10
.p3	cmp.l	a4,a3 * low bound check
	beq.b	.p4
	move.b	-(a3),d1
	cmp.b	#".",d1
	beq.b	.p4
	ror.l	#8,d6
	move.b	d1,d6
	dbf		d0,.p3
.p6
	tst		d0
	bmi.b	.p4
.p5	
	ror.l	#8,d6
	dbf	d0,.p5
.p4
	ror.l	#8,d6

	* Force lowercase
	move.l	#$20202020,d0
	or.l	d0,d6
	or.l	d0,d7

;	move.l	d6,.bob
;	move.l	#.bob,d0
;	move.l	d6,d1
;	DPRINT	"post=%s %lx"

	popm	d0-d5/a0-a6
	rts

;.bob	ds.b	10

fetchAndSaveCurrentModule:
    DPRINT  "fetchAndSaveCurrentModule"
    pushm   all
    * Can't do this if the pipe streamer is already running
    jsr     streamIsAlive
    bne     .err
    
    jsr     getcurrent
    beq     .err
    tst.b   l_remote(a3)
    beq     .err
    push    a3
    jsr     dir_req    
    * d7 = request 
    popm    a3
    beq     .err

    lea	-200(sp),sp	* space for output path

    move.l  d7,a2
    move.l  16(a2),a2
    tst.b   (a2)
    beq     .2
  
    * Ensure start from scratch
    move    #-1,streamReturnCode(a5)

    * a2 = target path
	move.l	sp,a1
	lea	    l_filename(a3),a0	
    jsr	    fetchRemoteFileToTarget
    DPRINT  "fetchRemoteFile=%ld"
    lea     .fail(pc),a1
    tst.l   d0
    beq     .3
    lea     .okTxt(pc),a1
.3 
    jsr     request
.2
    tst.l   d7
    beq     .1
    move.l	d7,a1
	lore    Req,rtFreeRequest
.1
    jsr     inforivit_play
    lea     200(sp),sp
.x
    popm    all
    rts

.err    
    jsr      beep
    bra     .x

.okTxt   dc.b   "Saved!",0
.fail   dc.b    "Failed!",0
 even

***************************************************************************
*
* List sort algorithm
*
***************************************************************************


; Jogeir Liljedahl folder
; comb sort:  compares=25294, swaps=9211
; quick sort: compares=23220, swaps=11771

* FSUAE 020
* Modsanth-unsorted-prg

* comb sort: 20s, comps 734000 swaps 265000
*            sorted list: 1s

* comb sort: 2s, comps 184000 swaps 22500
* weights        sorted list: 1s

* quick sort: 26s, comps 658000 swaps 338000
*            sorted list: 28s

* quick sort: 27s, comps 704000 swaps 400000
* tail recurs

* quick sort: 22s, comps 704000 swaps 400000
* tail recurs
* rand pivo

* quick sort: 20s, comps 381000 swaps 350000
* rand pivot     sorted list: 20s

	
 if DEBUG
sortSwaps	dc.l	0
sortComps	dc.l	0
 endif

* Weight is 64 chars
COMB_WEIGHT = 64

* in:
*   a2 = start of array of [node pointer, empty pointer] to sort
*   d7 = number of items to sort
combSortNodeArray
	move.l	d7,d0
	;moveq	#COMB_WEIGHT,d1
	;jsr		mulu_32
	lsl.l	#6,d0  	* x64
	move.l	#MEMF_CLEAR!MEMF_PUBLIC,d1
	jsr		getmem
	move.l	d0,-(sp)	 * store for later freemem
	beq		.exit
	move.l	d0,a5
	move.l	a2,a4		* input data
	move.l	d7,d6		* input count
	moveq	#"A",d1
	moveq	#"Z",d2
	
.weights
	* get node address
	move.l	(a4),a3
	* weight address at a5, store it to the empty slot beside the node pointer
	move.l	a5,4(a4)
	* fill in weight
	move.l	a5,a0

	moveq	#COMB_WEIGHT-1,d0

	* Use the divider status byte as the first 
	* comparison so that directories are sorted first.
	* This is either: 0, $7f, $ff.
	move.b	l_divider(a3),d3
	addq.b	#2,d3
	* Now it is: 2, $81, $03. Normal file is a 2, so dividers
	* get to the top.
	move.l	l_nameaddr(a3),a3
	bra.b	.1
.w
	move.b	(a3)+,d3
	beq.b	.3
.1
	* Lower chase compared chars if possible
	cmp.b	d1,d3
	blo.b	.2
	cmp.b	d2,d3
	bhi.b	.2
	or.b	#$20,d3
.2	move.b	d3,(a0)+
	dbf		d0,.w
.3
	lea		COMB_WEIGHT(a5),a5
	addq.l	#SORT_ELEMENT_LENGTH,a4
	subq.l	#1,d6
	bne.b	.weights

	bsr.b	.doCombSort

.exit
	move.l	(sp)+,a0
	move.l	a0,d0
	jsr		freemem
	tst.l	d0	* zero on out-of-mem
	rts

.doCombSort
	move.l	a2,a0
	* Constant = 1
	moveq	#1,d5

; Comb sort the array.

;	Lea.l	List(Pc),a0
;	Move.l	#ListSize,d7	; Number of values

	Move.l	d7,d1		; d1=Gap
.MoreSort
;	lsl.l	#8,d1
;	Divu.w	#333,d1		; 1.3*256 = 332.8
;	ext.l	d1

	move.l	d1,d0 
	lsl.l	#8,d0 
	move.l	#333,d1
	jsr	 	divu_32
	move.l	d0,d1

	Cmp.l	d5,d1		; if gap<1 then gap:=1
	Bpl.b	.okgap
	Moveq	#1,d1
.okgap:
	Move.l	d7,d2		; d2=Top
	Sub.l	d1,d2		; D2=NMAX-gap
	
	Move.l	a0,a1
	
 ;     Lea.l   (a1,d1.w*2),a2  ; a2=a1+gap
 ;   move    d1,d6
 ;   mulu    d5,d6
 ;   lea     (a1,d6.l),a2

;	move.l	d1,d6
;	lsl.l	#5,d6 
;	lea		(a1,d6.l),a2
 
	move.l	d1,d0
	* x8 - SORT_ELEMENT_LENGTH
	lsl.l	#3,d0	
	lea		(a1,d0.l),a2

	MoveQ	#0,d0		; d0=Switch



.Loop:	

 if DEBUG
	addq.l	#1,sortComps
 endif
	* Compare nodes a1 and a2
	* Get weight addresses for nodes
	move.l	4(a1),a3
	move.l	4(a2),a4

    * Compare weights in batches of 4 bytes 
  rept (COMB_WEIGHT/4)-1
  	cmpm.l	(a3)+,(a4)+
	bne.b	.notokval
  endr
	cmpm.l	(a3)+,(a4)+
	beq.b	.okval
.notokval
    ;bmi.b   .okval
	bhs.b	.okval

 if DEBUG
	addq.l	#1,sortSwaps
 endif

;	Move.w	(a1)+,d3
;	Cmp.w	(a2)+,d3
;	Bmi	.okval
;	Beq	.okval

;	Move.w	-2(a1),d3	; swap
;	Move.w	-2(a2),-2(a1)
;	Move.w	d3,-2(a2)

	* swap 8 bytes entry [node address, weight address]
	* Advance indexes
	movem.l	(a1),d3/d6
	move.l	(a2),(a1)+
	move.l	4(a2),(a1)+
	move.l	d3,(a2)+
	move.l	d6,(a2)+
	
	* Set flag, something swapped
	Moveq	#1,d0
	bra		.ok1
.okval:
	* Advance indexes
	addq.l	#SORT_ELEMENT_LENGTH,a1
	addq.l	#SORT_ELEMENT_LENGTH,a2
.ok1

	subq.l	#1,d2 
	bne	.Loop

	cmp.l	d5,d1	; gap < 1 ?
	Bne	.MoreSort
	Tst.w	d0		; Any entries swapped ?
	Bne	.MoreSort
	Rts


***************************************************************************
*
* Network data streaming using aget and pipe
*
***************************************************************************

* Name returned for aget style stream (network bytes)
streamPipeFile      dc.b    "PIPE:hippoStream",0
* Name returned for WAV style stream (Timidity)
wavStreamPipeFile  dc.b    "PIPE:wavHippoStream",0
* Name returned for PCM/AIFF style stream (GMPlay)
aiffStreamPipeFile dc.b    "PIPE:wavHippoStream2",0
agetHeadersFile     dc.b    "T:agetheaders",0
                    even

* Start local pipe stream
* In:
*   d0 = PIPE stream config
startLocalStreaming:
    * Reset the aget return code to uninitialized value
    move.w  #-1,streamReturnCode(a5)
    bra     startStreaming0

startNewStreaming:
    * Reset the aget return code to uninitialized value
    move.w  #-1,streamReturnCode(a5)
    ; ... fall through

* Starts streaming given url into the name pipe using a separate process
* Returns if streaming is ongoing already or has been finished.
* In:
*   a0 = url
*   d0 = PIPE stream config, or NULL for aget operation
* Out:
*   a0 = stream name to read from
*   d0 = true, or false if error
startStreaming:
    moveq   #0,d0
startStreaming0:
    pushm   d1-d7/a1-a6
    DPRINT  "*** startStreaming *** local=%lx"
    move.l  d0,d4

    push    a0
    lore    Exec,Forbid
    move.l  streamerTask(a5),d6
    move.w  streamReturnCode(a5),d7
    lob     Permit
    pop     a0

 if DEBUG
    push    d0
    move.l  d6,d0
    move    d7,d1
    ext.l   d1
    DPRINT  "task=%lx returnCode=%ld"
    pop     d0
 endif

    * Task is already running?
    tst.l   d6
;    bne     .y
    beq     .nope
    * Exit early, reurn pipe file
    tst.l   streamLocalConfig(a5)
    bne     .localIsActive
    bra     .y
.nope
    * Task is not running, did it finish the previous operation?
    * streamReturnCode(a5) is -1 if not done.
    tst.w   d7
    bpl     .y

    * Store local stream config, or NULL
    move.l  d4,streamLocalConfig(a5)

;    tst.l   streamerTask(a5)
;    bne     .y
    jsr     setMainWindowWaitPointer

    DPRINT  "startStreaming"
    bsr     freeStreamerUrl
 if DEBUG
    move.l  a0,d0
    DPRINT  "url=%s"
 endif
    move.l  a0,d5   * URL pointer here for later
    move.l  a0,a1
.1  tst.b   (a1)+
    bne     .1
    move.l  a1,d0
    sub.l   a0,d0
    moveq   #MEMF_PUBLIC,d1
    jsr     getmem
    move.l  d0,streamerUrl(a5)
    beq   .x
    move.l  d0,a1
.2  move.b  (a0)+,(a1)+
    bne     .2

    ; Clear SINGLE for later use
    moveq   #0,d0
    moveq   #SIGF_SINGLE,d1
    lore    Exec,SetSignal

    ;-----------------------------------
    ; Local pipe stream start
    tst.l   streamLocalConfig(a5)
    beq     .notLocalPipe
    DPRINT  "start local pipe stream"
    pushpea wavStreamerProcessTags(pc),d1
    bra     .isLocalPipe
.notLocalPipe
    ;-----------------------------------
    ; UHC stream start

    moveq   #0,d0   * status: fail
    tst.b   uhcAvailable(a5)
    beq     .x

    DPRINT  "Start aget"
    * Capture aget output into a file
    pushpea agetOutputFile(pc),d1
    move.l  #MODE_NEWFILE,d2
    lore    Dos,Open
    DPRINT  "aget output open=%lx"
    move.l  d0,streamerProcessOutputHandle
    beq     .x
    pushpea streamerProcessTags(pc),d1

.isLocalPipe

;    pushpea streamerProcessTags(pc),d1
    lore    Dos,CreateNewProc
    DPRINT  "CreateNewProc=%lx"
    beq     .error

    DPRINT  "waiting for streamer start"

    * Wait here until the task is fully running
    moveq   #SIGF_SINGLE,d0
    lore    Exec,Wait

    tst.l   streamerTask(a5)
    bne.b   .ok
    DPRINT  "Streamer task failed to start"
    bra     .error
.ok
    
    ; ---------------------------------
    ;; MIDI stream? 
    * streamerUrl(a5) no longer valid
    tst.l   streamLocalConfig(a5)
    beq     .notLocalPipee
 if DEBUG
    move.l  d5,d0
    DPRINT  "Local pipe verify: %s"
 endif
    * Wait a bit and check if it's still running
    moveq   #2*50,d1
    lore    Dos,Delay
    bsr     findLocalStreamProcess
    DPRINT  "Local pipe process=%lx"
    * status fail?
    tst.l   d0
    beq     .x
    DPRINT  "Local pipe verified"
.localIsActive
    move.l  streamLocalConfig(a5),a0
    move.l  localStream_pipe(a0),a0
    DPRINT  "Local pipe bypass"
    bra     .localPipeStream
.notLocalPipee
    ; ---------------------------------

    * Wait here until things are looking good
    DPRINT  "verify stream"
.verifyLoop
    moveq   #1*50,d1
    lore    Dos,Delay
    * Test #1: Is it running anymore?
    tst.l   streamerTask(a5)
    bne     .runs
    * Nope, is there an error? 
    tst.l   streamerError(a5)
    beq     .done
    * There was, stop here
    DPRINT  "streamer erroneus stop!"
    moveq   #0,d0
    bra     .x
.runs  

    * Test #2: is there some output in the stdout?
    * There should be either progress info or an error msg.
    move.l  streamerProcessOutputHandle(pc),d1
	moveq	#0,d2
	moveq	#OFFSET_CURRENT,d3
    lob     Seek
    DPRINT  "Seek=%ld"
    tst.l   d0
    beq     .verifyLoop

.done
    
    
    lea     agetHeadersFile(pc),a0
    bsr     plainLoadFile
    DPRINT  "load headers=%lx len=%ld"
    tst.l   d1
    bne     .gotHeaders
    DPRINT  "no header data"
    bra     .error
.gotHeaders
    push    d0
    bsr     parseAgetHeaders
    pop     a0
    jsr     freemem


    bsr     streamIsMpegAudio
    bne.b   .isMpeg
    bsr     streamGetContentLength
    tst.l   d0
    bne.b   .gotLen
    ; Not mpeg, does not have length, alert alert
    DPRINT  "unsupported streaming format"
    bra     .error
.gotLen
.isMpeg 

 if DEBUG
    bsr     streamIsMpegAudio
    push    d0
    bsr     streamGetContentLength
    pop     d1
    DPRINT  "streamer started! length=%ld mpeg/audio=%ld"
 endif

.y
    lea     streamPipeFile(pc),a0


.localPipeStream
    moveq   #1,d0   * status: ok
.x
    DPRINT  "status=%lx (0 is fail)"

    jsr     clearMainWindowWaitPointer
    popm    d1-d7/a1-a6
    rts

.error
    DPRINT  "error! closing output"
;    move.l  streamerProcessOutputHandle(pc),d1
;    beq.b   .er
;    clr.l   streamerProcessOutputHandle
;    lore    Dos,Close
;.er
    moveq   #0,d0   * status: error
    bra     .x

streamerProcessTags
    dc.l    NP_Output
streamerProcessOutputHandle
    dc.l    0
    * By default output handle is closed by CreateNewProc
    * Close it ourselves
    dc.l    NP_CloseOutput,0
    dc.l    NP_Name,.name
    dc.l    NP_Entry,streamerEntry
    dc.l    TAG_END

.name
    dc.b    "HiP-streamer",0
agetOutputFile
    dc.b    "T:agetout",0
    even

* SystemTagList will auto-close the parent streams
* with SYS_Asynch=TRUE
wavStreamerProcessTags
    dc.l    NP_Entry,streamerEntry
    dc.l    NP_Name,streamerProcessOutputHandle\.name
    dc.l    NP_CloseOutput,0
    dc.l    NP_CloseInput,0
    dc.l    TAG_END


* Checks whether streamer is alive
* Out:
*    Z clear: alive, Z set: not alive
streamIsAlive:
    tst.l    streamerTask(a5)
 if DEBUG
    pushm   d0
    move.l  streamerTask(a5),d0
    beq.b   .1
    DPRINT  "streamIsAlive=%lx"
.1  tst.l   d0
    popm    d0
 endif
    rts

******************************************************************************
*
* Streamer process
*
*
streamerEntry:

    rsreset
.uhcPathFormatted   rs.b    50
.agetCmdFormatted   rs.b    100
.buffer             rs.b    0
.agetArgsFormatted  rs.b    1000
.varsSize           rs.b    0
   
    lea     var_b,a5
    lea     -.varsSize(sp),sp
    move.l  sp,a4

    DPRINT  "stream:task started"
    sub.l   a1,a1
    lore    Exec,FindTask
    move.l  d0,streamerTask(a5)
  
    bsr     freeStreamerError

    * Remove previous headers if any
    pushpea agetHeadersFile(pc),d1
    lore    Dos,DeleteFile

    ; ---------------------------------
    ; Local stream check
    
    tst.l   streamLocalConfig(a5)
    bne     .handleLocalStream

    ; ---------------------------------
    ; Launch with "aget"
    
    pushpea .envVarName(pc),d1     * variable name
    pushpea .uhcPathFormatted(a4),d2     * output buffer
    moveq   #50-1,d3            * space available
    move.l  #GVF_GLOBAL_ONLY,d4 * global variable
    lob     GetVar
    tst.l   d0
    bmi     .error
    

    pushpea .uhcPathFormatted(a4),d0
    DPRINT  "stream:UHCBIN=%s"

    lea     .agetCmd(pc),a0
    lea     .agetCmdFormatted(a4),a3
    jsr     desmsg3

    pushpea .agetCmdFormatted(a4),d0
    DPRINT  "stream:cmd=%s"

    pushpea .agetCmdFormatted(a4),d1
    lob     LoadSeg
    move.l  d0,d6
    beq     .error
    DPRINT  "stream:LoadSeg=%lx"

    pushpea agetHeadersFile(pc),d0
    move.l	streamerUrl(a5),d1
    lea     .args(pc),a0
    lea     .agetArgsFormatted(a4),a3
    jsr     desmsg3

    bsr     freeStreamerUrl

.argsDone
    * length of args
    lea     .agetArgsFormatted(a4),a0
    move.l  a0,a1
.fe   
    tst.b   (a0)+
    bne.b   .fe
    move.l  a0,d4
    sub.l   a1,d4
    subq.l  #1,d4   

 ifne DEBUG
    pushpea .agetArgsFormatted(a4),d0
    DPRINT  "stream:args=%s"
    move.l  d4,d0
    DPRINT  "stream:len=%ld"
 endif
    bsr     .notify

    move.l  d6,d1       * seglist
    move.l  #4096*2,d2  * stack size, 8k recommended for aget
    pushpea .agetArgsFormatted(a4),d3 * argptr
                          * d4 = arg size
    lore    Dos,RunCommand
    * aget return code in d0, 0 = OK
    move.l  d0,d5
    DPRINT  "stream:runCommand=%ld (0=OK)"

    move.l  d6,d1
    beq.b   .a
    lob     UnLoadSeg
    DPRINT  "stream:UnLoadSeg"
.a

    * Manual closing of the output file handle, so it can be read below.
    bsr     .closeOutputHandle

    * Check aget output for errors.
    moveq   #0,d7
    tst.l   d5
    beq     .t
    DPRINT  "stream:load output"

    * Read the file
	lea		agetOutputFile(pc),a0
	bsr		plainLoadFile
    DPRINT  "stream:aget message grabbed, addr=%lx len=%ld"
    move.l  d1,streamerErrorLength(a5)
    move.l  d0,d7
	beq.b	.t
    tst.l   d1
    bne     .t
    * It should never be empty, free it and quit
    move.l  d7,a0
    jsr     freemem
    moveq   #0,d7
.t

.x
    ;----------------------------------

    DPRINT  "stream:task stopped"
    lea     .varsSize(sp),sp
    lore    Exec,Forbid
    move.w  d5,streamReturnCode(a5)
    move.l  d7,streamerError(a5)
    clr.l   streamerTask(a5)
    rts

.notify
    ; Notify main task
    move.l  owntask(a5),a1
    moveq   #SIGF_SINGLE,d0
    lore    Exec,Signal
    rts

.error
    DPRINT  "stream:start error"
    bsr     .notify
    bra     .x

.closeOutputHandle:
    lea     streamerProcessOutputHandle(pc),a0
    move.l  (a0),d1
    clr.l   (a0)
    tst.l    d1
    beq.b   .b
 if DEBUG
    move.l  d1,d0
    DPRINT  "stream:close output handle=%lx"
 endif
    lore    Dos,Close
    DPRINT  "stream:Close agetout"
.b
    rts



.handleLocalStream:
    DPRINT  "stream:local stream"
    * clear stream error msg address to be returned, not used here
    moveq   #0,d7 
    moveq   #0,d5

    * Local stream config in a3!
    move.l  streamLocalConfig(a5),a3
    move.l  localStream_setup(a3),d0
    beq     .noLocalSetup
    move.l  d0,a0
    jsr     (a0)
.noLocalSetup

    move.l  localStream_cliName(a3),d0
    move.l  localStream_command(a3),a0

    * Store this so graceful exit can be done later
    move.l  d0,currentLocalStreamCliName(a5)
    move.l	streamerUrl(a5),d1
    move.l  localStream_additionalParam(a3),d2
    lea     .buffer(a4),a3
    jsr     desmsg3

 if DEBUG
    pushpea .buffer(a4),d0
    DPRINT  "stream:cmd=%s"
 endif

    ; Change current dir to "timidity:" or "gm:"
    move.l  streamLocalConfig(a5),a3
    move.l  localStream_currentDir(a3),d1   * if null Lock takes SYS:
    bne     .hasCurrent

    move.l  homelock(a5),d1
    lore    Dos,DupLock
    bra     .useHome
.hasCurrent
    moveq	#ACCESS_READ,d2
	lore    Dos,Lock
.useHome
    DPRINT  "stream:current dir lock=%lx"
    move.l  d0,.sysCurrentDir
    beq     .error

    lea     .sysTags(pc),a0
    move.l  a0,d2

    * Set default stack
    move.l  #10000,4(a0)
    move.l  localStream_stack(a3),d1
    beq     .defaultStack
    * Modified stack requested
    move.l  d1,4(a0)
.defaultStack

    ; Launch timidity
    pushpea .buffer(a4),d1
    lore    Dos,SystemTagList
    DPRINT  "stream:SystemTagList=%ld"
    cmp.l   #-1,d0
    bne     .ok
    * Free any resources in case of failure

    DPRINT  "stream:error cleanup!"
    move.l  .sysCurrentDir(pc),d1
    lob     UnLock
    bra     .error
.ok

    ; Notify main task that we are on
    DPRINT  "stream:notify main task"
    bsr     .notify
    
.waitLoop
    move.l  #SIGBREAKF_CTRL_C,d0

    move.l  streamLocalConfig(a5),a3
    tst.l   localStream_poll(a3)
    beq     .noPoll
    bset    #SIGBREAKB_CTRL_D,d0
    DPRINT  "stream:Wait for CTRL-D"
.noPoll
    ; Wait for stopping
    DPRINT  "stream:Wait for CTRL-C"
    lore    Exec,Wait
    btst    #SIGBREAKB_CTRL_D,d0
    beq     .noCtrlD
    DPRINT  "stream:CTRL-D received, call poll routine"
    move.l  streamLocalConfig(a5),a3
    move.l  localStream_poll(a3),a3
    jsr     (a3)
    bra     .waitLoop
.noCtrlD
    DPRINT  "stream:CTRL-C received!"

.breakLoop
    DPRINT  "stream:break loop"
    bsr     findLocalStreamProcess
    beq     .notFound

    DPRINT  "stream:Signaling CTRL-C to cli cmd"
    move.l  d0,a1
    move.l  #SIGBREAKF_CTRL_C,d0
    lore    Exec,Signal

    DPRINT  "stream:wait!"
    moveq   #50,d1
    lore    Dos,Delay
    bra     .breakLoop
    
.notFound
    DPRINT  "stream:not found -> exit"
.midiExit
    DPRINT  "stream:midi exit"
    moveq   #0,d5
    moveq   #0,d7
    bra     .x

.sysTags
    dc.l    NP_StackSize,10000
    dc.l    NP_ExitCode,.exitCode
    dc.l    SYS_Asynch,1
    dc.l    NP_CurrentDir,0
.sysCurrentDir = *-4
    dc.l    TAG_END


.exitCode
    DPRINT  "stream:NP_ExitCode called! return=%lx"
    rts

.envVarName
    dc.b    "UHCBIN",0

.agetCmd
    dc.b	'%sC/aget',0


.args
;	dc.b	'"%s" PIPE:hippoStream/65536/2 ONLYPROGRESS DUMPHEADERS=%s',10,0
;	dc.b	'"%s" PIPE:hippoStream/65536/2 MINIMIZEDELAY ONLYPROGRESS DUMPHEADERS=%s',10,0
;	dc.b	'"%s" PIPE:hippoStream/16384/4 MINIMIZEDELAY ONLYPROGRESS DUMPHEADERS=%s BUFSIZE=4096',10,0
;	dc.b	'"%s" PIPE:hippoStream/32768/4 MINIMIZEDELAY ONLYPROGRESS DUMPHEADERS=%s',10,0
;	dc.b	'"%s" PIPE:hippoStream/65536/8 MINIMIZEDELAY ONLYPROGRESS DUMPHEADERS=%s BUFSIZE=8192',10,0
;	dc.b	'"%s" PIPE:hippoStream/65536/2 MINIMIZEDELAY ONLYPROGRESS DUMPHEADERS=%s BUFSIZE=4096',10,0
;	dc.b	'"%s" PIPE:hippoStream/65536/2 MINIMIZEDELAY ONLYPROGRESS DUMPHEADERS=%s BUFSIZE=131072',10,0
;	dc.b	'"%s" PIPE:hippoStream/65536/2 MINIMIZEDELAY ONLYPROGRESS DUMPHEADERS=%s',10,0
;	dc.b	'"%s" PIPE:hippoStream/4096/128 ONLYPROGRESS DUMPHEADERS=%s BUFSIZE=262144',10,0
	dc.b	'TO=PIPE:hippoStream/65536/2 ONLYPROGRESS DUMPHEADERS=%s BUFSIZE=8192 URL="%s"',10,0


 even

* Find the CLI process "timidity"
* Out:
*   d0 = process address or null
findLocalStreamProcess:
    pushm   d2-d7/a2-a6
    lea     -64(sp),sp
    moveq   #0,d4
    lore    Dos,MaxCli
    move.l  d0,d6
    moveq   #1,d5
.cliLoop
    move.l  d5,d1
    lob     FindCliProc
    move.l  d0,d4
    beq     .noCLI
    move.l  d0,a0
    move.l  pr_CLI(a0),d0
    lsl.l   #2,d0   * BPTR->APTR
    move.l  d0,a0
    tst.l   cli_Module(a0)
    beq     .noCLI  
    move.l  cli_CommandName(a0),d0
    lsl.l   #2,d0   * BPTR->APTR
    move.l  d0,a0
    * Convert BCPL string
    move.b  (a0)+,d1
    lea     (sp),a1
.cliCp
    move.b  (a0)+,(a1)+
    subq.b  #1,d1
    bne     .cliCp
    clr.b   (a1)
    * See if this CLI is "timidity","gmplay"
    lea     (sp),a0
    move.l  currentLocalStreamCliName(a5),a1
.cliCmp
    cmpm.b  (a0)+,(a1)+
    bne     .noCLI
    tst.b   -1(a1)
    bne     .cliCmp
    * Found!
    lea     64(sp),sp
 if DEBUG
    pushm   all
    move.l  4.w,a6
    sub.l   a1,a1
    lob     FindTask
    move.l  d0,d1
    move.l  d4,d0
    DPRINT  "findLocalStreamProcess=%lx task=%lx"
    popm    all
 endif
    move.l  d4,d0
    popm    d2-d7/a2-a6
    rts

.noCLI
    addq    #1,d5
    cmp     d6,d5
    bne     .cliLoop
    * Not found!
    lea     64(sp),sp
 if DEBUG
    pushm   all
    move.l  4.w,a6
    sub.l   a1,a1
    lob     FindTask
    DPRINT  "findLocalStreamProcess=NULL task=%lx"
    popm    all
 endif
    popm    d2-d7/a2-a6
    moveq   #0,d0
    rts

* Frees the previous aget error if any
freeStreamerError:
    move.l  streamerError(a5),a0
    clr.l   streamerError(a5)
    jmp     freemem
    
freeStreamerUrl:
    pushm   a0/a1
    lea     streamerUrl(a5),a1
    move.l  (a1),a0
    clr.l   (a1)
    jsr     freemem
    popm    a0/a1
    rts



* Sends the ctrl+c signal to the streamer task if it is running
stopStreaming:
    DPRINT  "*** stopStreaming"

    lore    Exec,Forbid
    move.l  streamerTask(a5),d0
    bne     .3
    DPRINT  "streamer not running"
    bra     .4
.3
    move.l  d0,a1
    move.l  #SIGBREAKF_CTRL_C,d0
    lob     Signal 
    DPRINT  "signal sent"
.4 
    lob     Permit
    rts

* Waits for the streamer task to exit if it is running.
* Used after startStreaming failure.
awaitStreamerAndFlush:
    moveq   #1,d0
    bra     awaitStreamer0

* Waits for the streamer task to exit if it is running.
* Used after sample playing stopped to confirm the
* streamer is done. No flushing as sample task will
* do it by itself.
awaitStreamer:
    moveq   #0,d0

awaitStreamer0:
    DPRINT  "*** await streamer, flush=%ld" 
    tst.l   streamerTask(a5)
    beq     .4
    DPRINT  "awaiting!" 
    jsr	    setMainWindowWaitPointer
    move.l  _DosBase(a5),a6

    moveq   #0,d5
    * Flush pipe file if possible if requested
    tst.b   d0
    beq     .noFlush
    pushpea streamPipeFile(pc),d1
	move.l	#MODE_OLDFILE,d2
    lob     Open
    DPRINT  "open=%lx"
    move.l  d0,d5
.noFlush

    moveq   #0,d4   * num of Delay calls
    moveq   #0,d3   * num of bytes flushed
    moveq   #0,d6   * FGetC return code
.loop   

.5 
    tst.l   streamerTask(a5)
    beq     .continue
    tst.l   d5
    beq     .6
    tst.l   d6
    bmi     .6
    move.l  d5,d1
    lob     FGetC
    addq.l  #1,d3
    move.l  d0,d6
    bpl     .5
.6
    DPRINT  "wait"
    moveq   #50*1,d1
    lob     Delay
    addq.w  #1,d4
    cmp.w   #10,d4
    bhs     .jammed
    bra     .loop
.continue   

    move.l  d5,d1
    beq.b   .3
    lob     Close
.3

 if DEBUG
    move.l  d3,d0
    move.l  d4,d1
    DPRINT  "task closed, flushed %ld, waited %ld" 
 endif
.1
    jsr	clearMainWindowWaitPointer
.4
    * This stream job is done.
    * After awaiting a new stream should be started
    move    #-1,streamReturnCode(a5)
    rts

.jammed
    DPRINT  "streamer stop timeout! abandoning task"
    clr.l   streamerTask(a5)
    bra     .1


* Display streamer error and free it
* Out:
*   d0 = true: error was shown, false: no error
showStreamerError:
    pushm   d1-a6
    moveq   #0,d0
    tst.b   disableShowStreamerError(a5)
    bne     .exit
    move.l  streamerError(a5),d0
	tst.l	d0
	beq	.exit
 if DEBUG
    move.l  streamerErrorLength(a5),d1
    DPRINT  "showStreamerError addr=%lx len=%ld"
 endif
    move.l  streamerErrorLength(a5),d7 
    beq     .exit
	* Mangle a null terminated line changed error msg, horrible
	lea		-200(sp),sp
	move.l	sp,a1
	move.l	d0,a0
    move    #200-1,d6   * total allowed length

.f	moveq	#60,d2      * row length
.e	move.b	(a0)+,(a1)+
    cmp.b   #"%",-1(a1) * formatting character: will confuse reqtools
    bne     .h
    move.b  #"_",-1(a1)
.h
    subq    #1,d6
    beq     .g
    subq    #1,d7
    beq     .g
	subq	#1,d2
	bne.b	.e
	move.b	#10,(a1)+
    bra     .f
    
.g	clr.b	(a1)
	move.l	sp,a1
	jsr		request
	lea		200(sp),sp

	bsr     freeStreamerError
	* Status: error shown
	moveq	#1,d0
.exit
    popm    d1-a6
    rts


* In:
*    d0 = HTTP headers in ReadArgs format
*    d1 = length of data
* Out:
*    d0 = true if succeeded
parseAgetHeaders:
    pushm   d1-a6
    DPRINT  "parseAgetHeaders"
    move.l  d0,d6
    move.l  d1,d7

    move.l  _DosBase(a5),a6

    bsr     freeStreamHeaderArgs

    pushpea .template(pc),d1
    pushpea streamHeaderArray(a5),d2
    pushpea streamRDA(a5),d3

    move.l  d3,a1
    moveq   #RDA_SIZEOF-1,d0
.c  clr.b   (a1)+
    dbf     d0,.c

    move.l  d3,a1
    move.l  d6,RDA_Source+CS_Buffer(a1)
    move.l  d7,RDA_Source+CS_Length(a1)

    lob     ReadArgs
    move.l  d0,streamHeaderRDArgs(a5)
    DPRINT  "ReadArgs=%lx"

    move.l  streamHeaderIcyName(a5),d0
    beq     .11
    bsr     .clean
.11
    move.l  streamHeaderIcyDescription(a5),d0
    beq     .22
    bsr     .clean
.22

  if DEBUG
    move.l  streamHeaderContentLength(a5),d0
    beq.b   .1
    move.l  d0,a0
    move.l  (a0),d0
    DPRINT  "Content-Length: %ld"
.1  move.l  streamHeaderContentType(a5),d0
    beq.b   .2
    DPRINT  "Content-Type: %s"
.2  move.l  streamHeaderIcyName(a5),d0
    beq     .3  
    DPRINT  "Icy-Name: %s"
.3  move.l  streamHeaderIcyDescription(a5),d0
    beq     .4
    DPRINT  "Icy-Description: %s"
.4
  endif

   
    popm    d1-a6
    rts

.clean
    * Overwrite UTF8 with latin1
    move.l  d0,a0
    bra     utf8StrToLatin1

.template
     dc.b "CONTENT-LENGTH/K/N,CONTENT-TYPE/K,ICY-NAME/K,ICY-DESCRIPTION/K,REST/M",0
    even


freeStreamHeaderArgs:
    DPRINT  "freeStreamHeaderArgs"
    * Avoid crashing on kick 1.3
    move.l  streamHeaderRDArgs(a5),d1
    beq.b   .x
    clr.l   streamHeaderRDArgs(a5)
    lore    Dos,FreeArgs
.x  
    lea     streamHeaderArray(a5),a0
    clr.l   (a0)+
    clr.l   (a0)+
    clr.l   (a0)+
    clr.l   (a0)+
    clr.l   (a0)+
    rts

* Returns true if the current stream is a radio station.
* Out: 
*   d0 = true or false
streamIsRadioStation:
    bsr     streamIsMpegAudio
    beq     .no
    bsr     streamGetContentLength
    tst.l   d0
    bne     .no
    moveq   #1,d0
    rts
.no
    moveq   #0,d0
    rts

* Returns the content length based on HTTP headers.
* Out:
*    d0 = length, or NULL if not available
streamGetContentLength:
    moveq   #0,d0
    move.l  streamHeaderContentLength(a5),d1
    beq.b   .x
    move.l  d1,a0
    move.l  (a0),d0
.x  rts


* Checks Content-Type. If it starts with "audio/mpeg" returns true
* Out:
*    d0 = true if "audio/mpeg", false otherwise
streamIsMpegAudio:
    moveq   #0,d0
    move.l  streamHeaderContentType(a5),d1
    beq     .x 
    move.l  d1,a0
    lea     .mimeAudioMpega(pc),a1
.cmp
    cmpm.b  (a1)+,(a0)+
    bne     .x
    tst.b   (a1)
    bne     .cmp
    moveq   #1,d0
.x  tst.l   d0
    rts

.mimeAudioMpega
    dc.b    "audio/mpeg",0

 even

* In-place convert a UTF8 string to Latin1
* In:
*   a0 = text, utf8
utf8StrToLatin1:
    move.l  a0,a1
.l  bsr     utf8ToLatin1Char
    move.b  d0,(a1)+
    tst.b   (a0)
    bne     .l
    clr.b   (a1)
    rts

* In:
*   a0 = pointer to utf8 char
* Out:
*   d0 = latin1 char
*   a0 = pointer to next utf8 char
utf8ToLatin1Char:
    moveq   #0,d0

    * Get utf8 char length to d1
    moveq   #1,d1
    move.b  (a0),d0
    bpl     .x * 1 byte
    moveq   #2,d1  
    moveq   #$20,d2
    and.b   d0,d2
    beq     .2 * 2 byte
    moveq   #3,d1
    moveq   #$10,d2
    and.b   d0,d2
    beq     .y
    moveq   #4,d1
    moveq   #$08,d2
    and.b   d0,d2
    beq     .y
    moveq   #5,d1
    moveq   #$04,d2
    and.b   d0,d2
    beq     .y
    moveq   #6,d1
    bra     .y
.2
    * Two bytes
    and	    #$1f,d0
    lsl     #6,d0
    moveq   #0,d2
    move.b  1(a0),d2
    sub.w   #$80,d2
    or.w    d2,d0
    bra     .x
.y
    moveq   #"_",d0
.x
    cmp     #$ff,d0
    bhi     .y

    add.l   d1,a0
    rts



***************************************************************************
*
* Position slider
*
***************************************************************************

* User has moved the slider
positionSliderMoved:
    tst.b   showPositionSlider(a5)
    bne     .yes
    rts
.yes
;    DPRINT  "positionSliderMoved"
    lea     gadgetPositionSlider,a2
    move.l	gg_SpecialInfo(a2),a0

    move.w  pi_Flags(a0),d0
    and.w   #KNOBHIT,d0
    bne     .knob

    * User clicked elsewhere, not the knob
    move    mousex(a5),d1
    sub     gg_LeftEdge(a2),d1
    mulu    #$ffff,d1
    divu    gg_Width(a2),d1

    * Move knob to the clicked position
    move.l  a2,a3
    pushm   a0/a2
    bsr     refreshPositionSlider\.setProp
    movem.l  (sp)+,a0/a2 ; AsmOne
    ;popm    a0/a2

.knob
    * User dragged the knob
    * Reset knobhit after the user has released the button
    * so it can be again automatically updated below.
    and     #~KNOBHIT,pi_Flags(a0)

    tst.b   playing(a5)
    beq     .x

    cmp     #pt_sample,playertype(a5)
    bne     .notSample
    jsr     getMp3DurationInSeconds
    tst.l   d1
    beq     .notSample
    * d0 = pos
    * d1 = len
    move.l  d1,d0

    * a2 = gadget
	jsr	nappilasku
    * d0 = position in secs
    DPRINT  "mp3 position=%ld"
    jmp pleaseMp3Seek

.notSample

    move    pos_maksimi(a5),d0
    subq    #1,d0
    bmi     .x
    beq     .x

    * a2 = gadget
	jsr	nappilasku

    cmp     pos_nykyinen(a5),d0
    beq     .x
    DPRINT  "Selected pos=%ld"

    sub     pos_nykyinen(a5),d0
    bpl     .forward
    neg     d0
    DPRINT  "backward %ld"
    * Prevent detecting songend
    st      kelattiintaakse(a5)
.l1
    push    d0
    move.l  playerbase(a5),a0
    jsr     p_taakse(a0)
    pop     d0
    subq    #1,d0
    bne     .l1

.x

	rts

.forward
    DPRINT  "forward %ld"
.l2
    push    d0
    move.l  playerbase(a5),a0
    jsr     p_eteen(a0)
    pop     d0
    subq    #1,d0
    bne     .l2
    rts

* Update slider position based on current status
refreshPositionSlider:  
    tst.b   showPositionSlider(a5)
    bne     .yes
.no
    rts
.yes    
    * Zipped window?
    tst.b   kokolippu(a5)
	beq.b   .no

    ;DPRINT  "refreshPositionSlider"
    
    lea     gadgetPositionSlider,a3
    tst.b   playing(a5)
    bne     .enable
.disable
    move.l  a3,a0
    jsr     disableGadget
    * move to neutral position when disabled
    moveq   #0,d1
    bra     .setProp    
    
.enable
    
    * Mp3 special case:

    cmp     #pt_sample,playertype(a5)
    bne     .notSample
    jsr     getMp3DurationInSeconds
    * d0 = position
    * d1 = length
    tst.l   d1
    beq     .notSample

    move.l  a3,a0
    pushm   d0/d1
    jsr     enableButton
    popm    d1/d2

    mulu    #65535,d1
    divu    d2,d1
    bra     .setProp

* Disable but move if position info available
.disable2
    move.l  a3,a0
    jsr     disableGadget
    move.l  playerbase(a5),a1
    move    p_liput(a1),d0
    and     #pf_poslen,d0
    bne     .moveProp
;    cmp     #pt_sid,playertype(a5)
;    beq     .sid
;.sidx
;    rts
;.sid
    * If the length is known use that.
    tst.l   kokonaisaika(a5)
    beq     .no
    move.l	aika2(a5),d1
	sub.l	aika1(a5),d1            * can be negative
    ble     .no
    mulu    #$ffff,d1
    move.w  kokonaisaika(a5),d0     * mins
    mulu    #60,d0
    add.w   kokonaisaika+2(a5),d0   * secs
    divu    d0,d1
    bra     .setProp

.notSample
    move.l  playerbase(a5),a1
    move    p_liput(a1),d0
    move    d0,d1
    and     #pf_slidePos,d1
    beq     .disable2
    move    d0,d1
    and     #pf_kelaus,d1
    cmp     #pf_kelaus,d1
    bne     .disable2
    jsr     isImpulseTrackerActive  * IT special case
    beq     .disable2

    move.l  a3,a0
    jsr     enableButton

.moveProp

    * d1 = HorizPot
    moveq   #0,d1
    move    pos_maksimi(a5),d2
    subq    #1,d2
    bmi     .z
    beq     .z
    move    pos_nykyinen(a5),d1
    mulu    #65535,d1
    divu    d2,d1
.z

.setProp
    * a0 = gadget
    move.l  a3,a0
    move.l	gg_SpecialInfo(a0),a1
    * d0 = Flags
    move	pi_Flags(a1),d0
    move    d0,d5
    * see if user has fondling the knob
    and     #KNOBHIT,d5
    bne     .hit

    * d2 = VertPot
    moveq   #0,d2
    * d3 = HorizBody
    move    pi_HorizBody(a1),d3
    * d4 = VertBody
    moveq   #0,d4
    * d5 = NumGad
    moveq   #1,d5
    * a1 = window
	move.l	windowbase(a5),a1
    * a2 = requester
    sub.l   a2,a2

    move.l	gg_SpecialInfo(a3),a4
    cmp     pi_HorizPot(a4),d1
    beq     .noChange
    lore    Intui,NewModifyProp
.noChange
    rts

.hit
    DPRINT  "knob hit!"
    rts

***************************************************************************
*
* Clipboard
*
***************************************************************************

 ifne FEATURE_PASTE
readClipboard:
    DPRINT  "a"
; IFF types that may be text
.ID_FTXT         equ     'FTXT'
.ID_CHRS         equ     'CHRS'

    moveq   #0,d7   * STATUS: error
    sub.l   a4,a4   * iff handle

    lea     .iffParseName(pc),a1
	lore	Exec,OldOpenLibrary
    tst.l   d0
    beq     .exit
    move.l  d0,a6

    DPRINT  "b %lx"

    lob     AllocIFF
    tst.l   d0
    beq     .exit
    move.l  d0,a4
    
    DPRINT  "c %lx" 

    moveq   #0,d0 ; default unit
    lob     OpenClipboard
    move.l  d0,iff_Stream(a4)
    beq     .exit

    DPRINT  "d %lx"

    move.l  a4,a0
    lob     InitIFFasClip

    DPRINT  "e"

    move.l  a4,a0
    moveq   #IFFF_READ,d0
    lob     OpenIFF
    tst.l   d0
    beq     .exit

    DPRINT  "f %lx"

    move.l  a4,a0
    move.l  #.ID_FTXT,d0
    move.l  #.ID_CHRS,d1
    lob     StopChunk
    tst.l   d0
    beq     .exit

    DPRINT  "g %lx"

.loop
    move.l  a4,a0
    move.l  #IFFPARSE_SCAN,d0
    lob     ParseIFF
    DPRINT  "f %lx"

    cmp.l   #IFFERR_EOC,d0
    beq     .loop
    tst.l   d0
    beq     .exit

    DPRINT  "h"

    move.l  a4,a0
    lob     CurrentChunk
    DPRINT  "i"
    * a0 = node
    move.l  a0,d0
    beq     .loop
    cmp.l   #.ID_FTXT,cn_Type(a0)
    bne     .loop
    cmp.l   #.ID_CHRS,cn_ID(a0)
    bne     .loop
    DPRINT  "j"

    move.l  a4,a0
    move.l  #.bob,a1
    move.l  #32,d0
    lob     ReadChunkBytes
    tst.l   d0
    bmi     .loop

    move.l  #.bob,d0
    DPRINT  "got=%s"


.exit
    move.l  a4,d0
    beq     .2
    tst.l   iff_Stream(a4)
    beq     .3
    move.l  iff_Stream(a4),a0
    lob     CloseClipboard
.3
    move.l  a4,a0
    lob     CloseIFF
    move.l  a4,a0
    lob     FreeIFF
.2

    move.l  a6,d0
    beq     .1
    move.l  d0,a1
    lore    Exec,CloseLibrary
.1
    move.l  d7,d0
    rts

.bob    ds.b    64

.iffParseName   dc.b    "iffparse.library",0
    even
 endif

***************************************************************************
*
* STIL database
*
***************************************************************************

* Out:
*   a0 = text data, should be freed
*   d0 = text length or NULL or NEGATIVE on failure
getSTILInfo:
    DPRINT  "getSTILInfo"
    pushm   d1-d7/a1-a6

    move.l  modulefilename(a5),d0
    beq     .1
    DPRINT  "%s"
    move.l  d0,a0
    bsr     doGetSTILInfo
    DPRINT  "doGetStilInfo addr=%lx len=%lx"
    tst.l   d0
    ble     .1
    move.l  d0,a0
    move.l  d1,d0
.1
    DPRINT  "result=%ld"
    popm    d1-d7/a1-a6
    rts
    

* In:
*   a0 = module path
* Out:
*   d0 = ok: positive, zero: error, negative: STIL.txt missing
*   a0 = text buffer, to be freed after use
doGetSTILInfo:
    bsr     getStilHash
    tst.l   d0
    beq     .exitStil
    move.l  d0,d5

    ; ---------------------------------
    ; Load STIL index

    push    d5
    ; Try to create the index first, slow
    pushm   all
    bsr     createStilIndex
    popm    all
    bsr     loadSTILIndex
    * d0 = address
    * d1 = length
    DPRINT  "loadSTILIndex=%lx %ld"
    pop     d5
    tst.l   d0
    beq     .fileErr

    move.l  d0,a0
    move.l  d0,a1
    add.l   d1,a1
    addq.l  #4,a0 * skip data length 
    * a0 = start of index
    * a1 = end of index
.f1 
    * Read fnv1
    move.b  (a0)+,d3
    rol.l   #8,d3
    move.b  (a0)+,d3
    rol.l   #8,d3
    move.b  (a0)+,d3
    rol.l   #8,d3
    move.b  (a0)+,d3
    cmp.l   d5,d3
    beq     .found
    * Skip data offset
    addq    #3,a0
    cmp.l   a1,a0
    blo     .f1
     * out of data, not found
    moveq   #0,d0
    bra     .f4
    
.found
    ; ---------------------------------
    * Was a match
    * Grab 3 data offset bytes after text
 
    moveq   #0,d0
    move.b  (a0)+,d0
    rol.l   #8,d0
    move.b  (a0)+,d0
    rol.l   #8,d0
    move.b  (a0)+,d0
 
    * Read next data offset
    addq    #4,a0
    moveq   #0,d1
    move.b  (a0)+,d1
    rol.l   #8,d1
    move.b  (a0)+,d1
    rol.l   #8,d1
    move.b  (a0)+,d1
    sub.l   d0,d1  
    * d1 = length
    bpl     .len
    * If accessing the last item the following length is zero
    * so we end up here, exit with fail!
    moveq   #0,d0
    bra     .loadErr
.len

    bsr     loadSTILEntry
    tst.l   d0
    beq     .loadErr
    move.l  d0,a0
.f4
.loadErr
.exitStil
    rts
.fileErr
    moveq   #-1,d0
    bra     .loadErr

* In:
*   a0 = module path
* Out:
*   d0 = fnv1 hash or null if error
getStilHash:
    lea     -200(sp),sp
    ; ---------------------------------
    ; Search for known STIL path parts from the module path.
    ; /DEMOS /GAMES /MUSICIANS
    ; If not found, exit.

.loop
    move.b  (a0)+,d0
    beq     .exitFail
    cmp.b   #"/",d0
    bne     .loop

    lea     .demos(pc),a2
    bsr     .find
    bne     .ok1
    lea     .games(pc),a2
    bsr     .find
    bne     .ok1
    lea     .musicians(pc),a2
    bsr     .find
    bne     .ok1
    bra     .loop


.demos      dc.b    "DEMOS/",0
.games      dc.b    "GAMES/",0
.musicians  dc.b    "MUSICIANS/",0
    even

.find:
    move.l  a0,a1
.loop2
    move.b  (a1)+,d0
    beq     .not
    move.b  (a2)+,d1
    beq     .yes
    bsr     .upperCaseD0
    cmp.b   d1,d0
    beq     .loop2
.not
    moveq   #0,d0
    rts
.yes
    moveq   #1,d0
    rts

.exitFail
    moveq   #0,d0
    bra     .exitStil

.ok1
    ; ---------------------------------
    ; Copy from STIL-looking bit onwards and uppercase it

    subq.l  #1,a0
    move.l  sp,a2
.copy1
    move.b  (a0)+,d0
    beq     .copied
    bsr     .upperCaseD0
    move.b  d0,(a2)+
    bra     .copy1
.copied

    ; ---------------------------------
    ; Check for ".sid" extension

    cmp.b   #".",-4(a2)
    bne     .exitFail
    cmp.b   #"S",-3(a2)
    bne     .exitFail
    cmp.b   #"I",-2(a2)
    bne     .exitFail
    cmp.b   #"D",-1(a2)
    bne     .exitFail
    ; Remove it since it's not in the STIL data either
    clr.b   -4(a2)

    ; ---------------------------------
    ; Calculate fnv1 into d5
    move.l  sp,a0
    bsr     fnv1
 if DEBUG
    move.l  sp,d1
    DPRINT  "fnv1=%lx %s"
 endif
.exitStil:
    lea     200(sp),sp
    rts


.upperCaseD0
    cmp.b	#'a',d0
    blo 	.up1
    cmp.b	#'z',d0
    bhi 	.up1
    and.b   #$df,d0 * to uppper
.up1
    rts    	
    


* Out:
*  d0 = index data pointer, or NULL
*  d1 = index data lenght
loadSTILIndex:
    move.l  stilIndexPtr(a5),d0
    bne     .ok

    pushpea stilIndexName(pc),d1
    move.l  #MODE_OLDFILE,d2
    lore    Dos,Open
    move.l  d0,d7
    beq     .err
    
    ; ---------------------------------
    * Find index length
	move.l	d7,d1		
	moveq	#0,d2	
	moveq	#1,d3
	lob	Seek
	move.l	d7,d1
	moveq	#0,d2	
	moveq	#1,d3
	lob	Seek
	move.l	d0,d5		* file length
	move.l	d7,d1
	moveq	#0,d2
	moveq	#-1,d3
	lob	Seek			* start of file

    ; ---------------------------------
    * reserve some empty to the end to detect the last item
    move.l  d5,d0
    addq.l  #8,d0
    move.l  #MEMF_PUBLIC!MEMF_CLEAR,d1
    jsr     getmem
    beq     .err


    move.l  d0,stilIndexPtr(a5)
    move.l  d7,d1
    move.l  d0,d2
    move.l  d5,d3
    jsr     setMainWindowWaitPointer	
    lob     Read
	jsr	    clearMainWindowWaitPointer
    push    d0

    move.l  d7,d1
    lob     Close
    
    cmp.l   (sp)+,d5
    bne     .err
.ok
    move.l  stilIndexPtr(a5),d0
    move.l  d0,a0
    move.l  -4(a0),d1   * length
    rts

.err
    moveq   #0,d0
    rts
    
* In:
*   d0 = Data offset
*   d1 = Length to read
* Out:
*   d0 = Allocated buffer, to be freed with freemem()
*   d1 = Length of data in buffer (not size of the buffer)
loadSTILEntry:
    move.l  d0,d4
    move.l  d1,d5
    moveq   #0,d7

    move.l  d5,d0
    lsl.l   #2,d0    * allocate 4x times as much
    move.l  #MEMF_PUBLIC!MEMF_CLEAR,d1
    jsr     getmem
    move.l  d0,d6
    beq     .err
    
    pushpea stilDataName(pc),d1
    move.l  #MODE_OLDFILE,d2
    lore    Dos,Open
    move.l  d0,d7
    beq     .err

    move.l  d7,d1
    move.l  d4,d2   
    move.l  #OFFSET_BEGINNING,d3
    lob     Seek
    cmp.l   #-1,d0
    beq     .err

    move.l  d7,d1 * file
    move.l  d6,d2 * dest
    add.l   d5,d2 * use the 2nd half of the buffer
    add.l   d5,d2
    move.l  d5,d3 * len
    lob     Read
    cmp.l   d5,d0
    bne     .err

    move.l  d7,d1
    beq     .2
    lob     Close
.2
    ; The data contains the title of the following item,
    ; add null 
    move.l  d6,a1
    add.l   d5,a1   * the 2nd half
    add.l   d5,a1
    add.l   d5,a1   * the end of the buffer
.3  cmp.l   d6,a1 * limit check
    beq     .5
    cmp.b   #"/",-(a1)
    bne     .3
    cmp.b   #10,-1(a1)
    bne     .3
    cmp.b   #13,-2(a1)
    bne     .4
    subq    #1,a1
.4
    * Null terminate before the following item
    clr.b   -1(a1)
.5
    * Source data: 2nd half
    move.l  d6,a0   
    add.l   d5,a0
    add.l   d5,a0
    * Destination: 1st half
    move.l  d6,a1
    pushm   d5/d6
    bsr     convertStilEntry
    popm    d0/d1
    exg     d0,d1
    * d0 = buffer addr
    * d1 = length
    * success
    rts

.err
    move.l  d6,a0
    jsr     freemem
    move.l  d7,d1
    beq     .1
    lore    Dos,Close
.1
    moveq   #0,d0
    rts

freeSTILData: 
    DPRINT  "freeSTIL"
    move.l  stilIndexPtr(a5),a0
    jmp     freemem


* Formats and line wraps the STIL entry text.
* in:
*   a0 = STIL entry text, null terminated
*   a1 = output buffer
convertStilEntry:
    DPRINT  "convertStilEntry"
    moveq   #0,d7       * comment flag
.loop
    tst.b   (a0)
    beq     .x
    bsr     .get4
    * d0 = four chars
    * d1 = two chars

    * Skip the first line with path: /MUSICIANS/G/Gray_Matt/Tusker.sid
    move    d1,d2
    and.w   #$ff00,d2
    cmp.w   #"/"<<8,d2
    bne     .1
    bsr     .skipLine
    bra     .loop
.1
    * ---------------------------------
    * COMMENT
    cmp.l   #"COMM",d0
    bne     .2
    * Store comment start at a2
    move.l  a0,a2
.com
    bsr     .skipLine
    bsr     .get4
    cmp.l   #"    ",d0  * COMMENT continued
    beq     .com
    * a0 now at the end of the comment +4
    * Null teminate the comment
    clr.b   -5(a0)
    tst.b   d7
    bne     .not1st
    * Label th 1st comment differently
    lea     -1(a2),a0
    move.b  #"S",(a0)
    move.b  #"T",1(a0)
    move.b  #"I",2(a0)
    move.b  #"L",3(a0)
    st      d7
    bra     .was1st
.not1st
    * Wrap from start of comment to end
    lea     -4(a2),a0
.was1st
    bsr     wrapLines
    * a0 now points to the line after the comment section
    bsr     putNewLine
    bra     .loop
.2
    * ---------------------------------
    cmp.w   #"(#",d1    * Song number
    bne     .3
    lea     .song1(pc),a2
.s1 move.b  (a2)+,(a1)+
    bne     .s1
    subq    #1,a1
    lea     -2(a0),a2
.s2 move.b  (a2)+,(a1)+
    cmp.b   #")",(a2)
    bne     .s2
    lea     .song2(pc),a2
.s3 move.b  (a2)+,(a1)+
    bne     .s3
    subq    #1,a1
    bsr     putNewLine
    bsr     .skipLine
    bra     .loop
.3
    * ---------------------------------
    cmp.l   #"   N",d0  * NAME
    bne     .4
    lea     -1(a0),a2
    bra     .field
    * ---------------------------------
.4
    cmp.l   #" AUT",d0  * AUTHOR
    bne     .5
    lea     -3(a0),a2
    bra     .field
    * ---------------------------------
.5
    cmp.l   #"  TI",d0  * TITLE
    bne     .6
    lea     -2(a0),a2
    bra     .field
    * ---------------------------------
.6
    cmp.l   #" ART",d0  * ARTIST
    bne     .7
    lea     -3(a0),a2
    bra     .field
    * ---------------------------------
.7
    bsr     .skipLine
    bra     .loop

.field:
    * Skip to the end of line and null terminate
    bsr     .skipLine
    clr.b   -1(a0)
    * Wrap from the start
    move.l  a2,a0
    bsr     wrapLines
    * a0 now at the start of the next line
    bsr     putNewLine
    bra     .loop
.x    
    rts

    
.get4
    move.b  (a0)+,d0
    rol.w   #8,d0
    move.b  (a0)+,d0
    move.w  d0,d1
    swap    d0
    move.b  (a0)+,d0
    rol.w   #8,d0
    move.b  (a0)+,d0
    rts

.skipLine
    cmp.b   #10,(a0)+
    bne     .skipLine
    rts

.song1  
    dc.b    ILF,ILF2,"*** Song ",0
.song2
    dc.b    " ***",0
    even


* Wraps given text to output until null encountered
* in:
*   a0 = input text with line changes 10 and terminating null
*   a1 = output buffer
wrapLines:
.LIMIT = 39
	moveq	#0,d1
	moveq	#0,d2
.loop
    cmp     #.LIMIT,d2
    beq     .newLine
.get
    move.b  (a0)+,d0
    beq     .eof
    * Eat line changes in input and any whitespaces after it
    cmp.b   #13,d0
    beq     .get
    cmp.b   #10,d0
    bne     .noLf
.eatSpaces1
    cmp.b   #" ",(a0)
    bne     .ate1
    addq    #1,a0
    bra     .eatSpaces1
.ate1
    * Output a space if input has a linechange
    moveq   #" ",d0
    bra     .noBr
.noLf
    * Got a char, check if it's a break character
    bsr     .isBreaker
    bne     .noBr
    * Notice that we have a break char
    addq    #1,d1
.noBr
    * Output char
    move.b  d0,(a1)+
    addq    #1,d2
    bra     .loop
    
.newLine
    * Limit reached
    * Insert a linebreak here if there's a break character here
    bsr     .isBreaker
    beq     .y1
    * There was not, see if there was a break ealier
    tst     d1
    beq     .y1
    * There was, rewind to it
.fb
    subq    #1,a0
    subq    #1,a1
    move.b  (a0),d0
    bsr     .isBreaker
    bne     .fb
    
.y1
    * Put linechange here and extra space for indentation
    moveq   #0,d1 * reset break notifier
    moveq   #1,d2 * reset counter
    bsr     putNewLine
    move.b  #" ",(a1)+
    * Eat spaces after line change in output
.eatSpaces2
    cmp.b   #" ",(a0)
    bne     .loop
    addq    #1,a0
    bra     .eatSpaces2

.eof
	rts

* Sets Z if d0 is a break character
.isBreaker
    cmp.b   #" ",d0
    beq     .is
    cmp.b   #"-",d0
    beq     .is
    cmp.b   #"_",d0
.is
    rts

putNewLine
	;move.b	#10,(a1)+
	;rts
    move.b   #ILF,(a1)+
    move.b   #ILF2,(a1)+
    rts

* before using fileConverter 154452
* after: 154084

* Creates the STIL.idx file from STIL.txt
createStilIndex:
    DPRINT  "createStilIndex"
    rsreset
.storeNextOffset  rs.w    1
.varsSize         rs.b    0

    moveq   #.varsSize/2-1,d0
.sk clr.w   -(sp)
    dbf     d0,.sk
    move.l  sp,a4

    * Input file
    lea     stilDataName(pc),a0
    * Output file
    lea     stilIndexName(pc),a1

    lea     .callback(pc),a3
    lea     .progressMsg(pc),a2
    moveq   #0,d0
    moveq   #0,d1
    bsr     fileConverter

    lea     .varsSize(sp),sp
    rts


.progressMsg
    dc.b    "Creating STIL index %02.2ld%lc",0
    even

* Callback inputs:
*    a0 = input line
*    a1 = output buffer
*    a4 = callback user data
*    d6 = current input read position
*    d7 = current output write position
* Outputs:
*    d0 = bytes to write or 0 
.callback:
    * Skip lines that are not the title line
    cmp.b   #"/",(a0)
    bne     .next

    ; Convert to uppercase
    ; Check for extension and remove it
    move.l  a0,a2
    bsr     convertA2ToUpperCaseRemoveSidExt
    beq     .next   * if SID ext missing for some reason

    * Calc fnv1 from a0, now uppser cased
    bsr     fnv1

    * hash into output    
    move.l  d0,(a1)

    * flag for the next line
    st  .storeNextOffset(a4)

    * Write 4 bytes at a0
    move.l  a1,a0   
    moveq   #4,d0
    rts

.next
    tst.b   .storeNextOffset(a4)
    beq     .next2
    clr.b   .storeNextOffset(a4)

    * Store three byte offset
    move.l  a1,a0
    swap    d6
    move.b  d6,(a1)+
    rol.l   #8,d6
    move.b  d6,(a1)+
    rol.l   #8,d6
    move.b  d6,(a1)+
    moveq   #3,d0
    rts

.next2
    moveq   #0,d0
    rts

* Convert SID file path in A2 
* In:
*   a2 = pointer to text, null terminated
* Out:
*   a2 = Uppercased, extension removed
*   d0 = true if SID extension found and removed, false otherwise
convertA2ToUpperCaseRemoveSidExt:
    moveq   #'a',d1
    moveq   #'z',d2
    move.b  #$df,d3
    bra     .ugo
.ucase1
    cmp.b	d1,d0
    blo 	.up1
    cmp.b	d2,d0
    bhi 	.up1
    and.b   d3,d0 * to upper
.up1
    move.b  d0,(a2)+
.ugo
    move.b  (a2),d0
    bne     .ucase1

    cmp.b   #"D",-1(a2)
    bne     .err
    cmp.b   #"I",-2(a2)
    bne     .err
    cmp.b   #"S",-3(a2)
    bne     .err
    cmp.b   #".",-4(a2)
    bne     .err
    clr.b   -4(a2)
    moveq   #1,d0
    rts
.err
    moveq   #0,d0
    rts

* In:
*   a0 = string with null termination
* Out:
*   d0 = fnv1 hash
fnv1:
    move.l  #$811c9dc5,d0 * hval
    move.l  #$01000193,d1 * prime
    lea     mulu_32,a2
    bra     .go
.loop
    jsr     (a2)
    eor.b   d2,d0
.go
    move.b  (a0)+,d2
    bne     .loop
.x     
    rts

* STIL stuff is run in info window context which
* has a correclty set current dir, no need for PROGDIR: then
stilDataName:   dc.b "STIL.txt",0
stilIndexName:  dc.b "STIL.idx",0

slDataName:     dc.b "PROGDIR:"
slDataNameO:    dc.b "Songlengths.md5",0
slIndexName:    dc.b "PROGDIR:"
slIndexNameO:   dc.b "Songlengths.idx",0
 even

***************************************************************************
*
* STIL Songlengths database for SIDs
*
***************************************************************************

* hip len 155084 before using fileConverter here
* after,  154452

* Creates Songlengths.idx from HVSC's Songlengths.md5
* Out:
*    d0 = true on success
createSLIndex:
    DPRINT  "createSLIndex"
    rsreset
.lastHash         rs.l    1
.lineBuffer       rs.l    1
.outBuffer        rs.l    1
.varsSize         rs.b    0

    moveq   #.varsSize/2-1,d0
.sk clr.w   -(sp)
    dbf     d0,.sk
    move.l  sp,a4

    * Input file
    lea     slDataName(pc),a0
    tst.b   uusikick(a5)
    bne     .n1
    addq.l  #slDataNameO-slDataName,a0
.n1
    * Output file
    lea     slIndexName(pc),a1
    tst.b   uusikick(a5)
    bne     .n2
    addq.l  #slIndexNameO-slIndexName,a1
.n2
    lea     .progressMsg(pc),a2
    moveq   #0,d1       * no finalize callback
    lea     .callback(pc),a3
    moveq   #0,d0       * no index space
    bsr     fileConverter

    lea     .varsSize(sp),sp
    rts

* Callback inputs:
*    a0 = input line
*    a1 = output buffer
*    a4 = callback user data
*    d7 = current output write position
* Outputs:
*    d0 = bytes to write or 0 
.callback:
    move.l  a0,.lineBuffer(a4)
    move.l  a1,.outBuffer(a4)
    move.l  a0,a2

    * Skip lines that are not the title line
    cmp.b   #";",(a2)
    bne     .dataLine

    * Handle ;-line with path

    ; Convert to uppercase
    ; Check for extension and remove it
    bsr     convertA2ToUpperCaseRemoveSidExt
    beq     .next   * if SID ext missing for some reason

    ; ---------------------------------
    ; Calc hash of the uppercased string
    move.l  .lineBuffer(a4),a0
    addq.l  #2,a0       * skip ; and space
    bsr     fnv1
    move.l  d0,.lastHash(a4)
.next
    moveq   #0,d0   * exit, write nothing
    rts

.dataLine
    move.l  .lastHash(a4),d0
    beq     .next

    * a2 points to the first time
    ; 1887c86a8a60ddbad5b904e3c1a87818=6:08 0:09 0:09 0:08 0:10 0:09 0:09 0:09 0:06 0:09 0:08 0:08 0:12

* ; /DEMOS/A-F/Fist_of_the_North_Star-Ita_OST_Remix.sid
* 25dbae1938a4ebc963c7fc64410ee6be=2:51.374    
    
* ; /MUSICIANS/Z/Zardax/Halfway_Thru.sid
* 760b9415bc14f37cada675b8fab91a37=3:39.345

    * skip over the md5 part
    move.l  .lineBuffer(a4),a2
    lea     33(a2),a2
    
    move.l  .outBuffer(a4),a1
    clr.w   (a1)+    * item length, use 1 or 2 bytes if needed
    move.l  d0,(a1)+ * Write hash
       
.timeLoop
    moveq   #$f,d0
    and.b   (a2)+,d0     * read mins
    mulu    #60,d0       * to secs
    cmp.b   #":",(a2)+
    beq     .t1
    mulu    #10,d0       * tens of mins
    moveq   #$f,d1
    and.b   -1(a2),d1    * read mins
    mulu    #60,d1       * to secs
    add.w   d1,d0        * total secs from mins
    addq    #1,a2        * skip :
.t1 
    moveq   #$f,d1
    and.b   (a2)+,d1     * read tens of secs
    mulu    #10,d1
    add.w   d1,d0
    moveq   #$f,d1
    and.b   (a2)+,d1     * read secs
    add.w   d1,d0           
    bne     .nz
    * under 1 sec, round to 1
    moveq   #1,d0
.nz
    cmp.w   #$7f,d0     * decide size of write
    bls     .sml
    or      #$8000,d0   * indicate WORD
    * write total secs, WORD
    ror.w   #8,d0
    move.b  d0,(a1)+
    ror.w   #8,d0
.sml
    move.b  d0,(a1)+    * write small secs
    cmp.b   #".",(a2)   * fractions of secs?
    bne     .t2
    * skip over 1-3 numbers
.skip
    move.b  (a2),d0
    beq     .t3
    cmp.b   #13,d0
    beq     .t3
    cmp.b   #10,d0
    beq     .t3
    cmp.b   #" ",d0
    beq     .t2
    addq    #1,a2
    bra     .skip
.t2
    * a2 now points to 13,10 or space
    cmp.b   #" ",(a2)+
    beq     .timeLoop
.t3

    * Calc entry length
    move.l  a1,d0
    move.l  .outBuffer(a4),a3
    sub.l   a3,d0

    * One byte length, or word length
    cmp.w   #$7f,d0
    bls     .small
    * Store entry length
    * Two large entries at the moment found in data
    move.b  d0,1(a3)
    ror.w   #8,d0
    move.b  d0,(a3)
    ror.w   #8,d0
    or.b     #$80,(a3)  * high bit indicates word length
    bra     .large
.small
    * Store small entry length
    addq    #1,a3    
    subq.l  #1,d0
    move.b  d0,(a3)
.large
    clr.l   .lastHash(a4)
    move.l  a3,a0
    * write d0 bytes from a0
    rts


.progressMsg
    dc.b    "Indexing SID lengths %02.2ld%lc",0
    even


* Read and generate HVSC songlengths index if possible
* Out:
*  d0 = index data pointer, or NULL
loadSLIndex:
    DPRINT  "loadSLIndex"
    tst.b   slLoadAttempted(a5)
    bne     .ok

    move.l  slIndexPtr(a5),d0
    bne     .has
    bsr     createSLIndex    
    DPRINT  "createSLIndex=%ld"
.has
    lea     slIndexName(pc),a0
    tst.b   uusikick(a5)
    bne     .n2
    addq.l  #slIndexNameO-slIndexName,a0
.n2
    jsr     setMainWindowWaitPointer 
    jsr     plainLoadFile
    jsr     clearMainWindowWaitPointer
    DPRINT  "load=%lx"
    move.l  d0,slIndexPtr(a5)
    st      slLoadAttempted(a5)
.ok
    rts


freeSLData: 
    DPRINT  "freeSL"
    move.l  slIndexPtr(a5),a0
    clr.l   slIndexPtr(a5)
    jmp     freemem



***************************************************************************
*
* Audacious-UADE songlength database (not for SIDs)
* Metadata database
*
***************************************************************************

USL_INDEX_SIZE = 32
UME_INDEX_SIZE = 64

USL_INDEX_SIZE_BYTES = USL_INDEX_SIZE*8 ; pairs of (offset,length)
UME_INDEX_SIZE_BYTES = UME_INDEX_SIZE*8

USL_HEADER_SIZE_BYTES = USL_INDEX_SIZE_BYTES+4
UME_HEADER_SIZE_BYTES = UME_INDEX_SIZE_BYTES+4

    include "md5.s" 

* Called once on startup
initializeUslUme:
    DPRINT  "initializeUslUme"
    bsr     uslCreateIndex
    bsr     umeCreateIndex

    bsr     uslLoadIndex
    bsr     umeLoadIndex
    rts


* These formats already have length information,
* skip these.
uslIgnoreFormats:
    cmp.w   #pt_prot,playertype(a5)
    beq     .reject
    cmp.w   #pt_sid,playertype(a5)
    beq     .reject
    cmp.w   #pt_sample,playertype(a5)
.reject
    rts

umeIgnoreFormats:
    cmp.w   #pt_sid,playertype(a5)
    beq     .reject
    cmp.w   #pt_sample,playertype(a5)
.reject
    rts

readUsl:
    DPRINT  "readUsl"
    tst.l   uslIndexPtr(a5)
    beq     .noData

    bsr     uslIgnoreFormats
    beq     .reject

    lea     uslSongLengthData(a5),a0
    tst.w   (a0)
    bne     .hasIt

    bsr     calcModuleMD5
    bsr     uslLoadData
    bsr     uslFind
    DPRINT  "uslFind=%ld"
.noData
.hasIt
.reject
    rts


readUme:
    DPRINT  "readUme"
    tst.l   umeIndexPtr(a5)
    beq     .noData

    bsr     umeIgnoreFormats
    beq     .reject

    move.l  umeMetaDataPtr(a5),d0
    beq     .no
    move.l  d0,a0
    tst.b   (a0)
    bne     .hasIt
.no
    bsr     calcModuleMD5
    bsr     umeLoadData
    bsr     umeFind
.noData
.hasIt
.reject
    rts


calcModuleMD5:
    tst.l   uslMD5(a5)            
    bne     readUme\.reject

    lea     -MD5Ctx_SIZEOF(sp),sp

    move.l  sp,a0
    bsr     MD5_Init

    move.l  sp,a0
    move.l  moduleaddress(a5),a1
    
    * Special case for XPK, exact decompressed length
    * is not the allocated mem length
    move.l  lod_xpkOutLen(a5),d0
    bne     .1
    move.l  modulelength(a5),d0
.1
    DPRINT  "calcModuleMD5 length=%ld"

    * Show wait pointer if 68000 or long enough
    move.l  (a5),a2
    btst    #AFB_68020,AttnFlags+1(a2)
    beq     .12
    cmp.l   #200000,d0
    blo     .11
.12
    jsr     setMainWindowWaitPointer
.11

 if DEBUG
    pushm   all
    bsr     startMeasure
    popm    all
 endif
    bsr     MD5_Update
 if DEBUG
    bsr     stopMeasure
    DPRINT  "MD5 took %ld ms"
 endif

    move.l  sp,a0
    bsr     MD5_Final
    DPRINT  "MD5: %08lx %08lx %08lx %08lx"
    move.l  d0,uslMD5(a5)
    swap    d1
    move.w  d1,uslMD5+4(a5)
    
    lea     MD5Ctx_SIZEOF(sp),sp

    jmp     clearMainWindowWaitPointer
 

uslLoadIndex:
    DPRINT  "uslLoadIndex"
    bsr     uslOpen
    beq     .y
    move.l  #USL_HEADER_SIZE_BYTES,d0
    moveq   #0,d1
    jsr     getmem
    move.l  d0,uslIndexPtr(a5)
    beq     .x

    move.l  d7,d1		        * file
	move.l	uslIndexPtr(a5),d2	* destination
	move.l	#USL_HEADER_SIZE_BYTES,d3  * pituus
	lob	    Read
    DPRINT  "read=%ld"
.x
    bsr     uslClose
.y
    rts


umeLoadIndex:
    DPRINT  "umeLoadIndex"
    bsr     umeOpen
    beq     .y

    move.l  #UME_HEADER_SIZE_BYTES,d0
    moveq   #0,d1
    jsr     getmem
    move.l  d0,umeIndexPtr(a5)
    beq     .x

    move.l  d7,d1		        * file
	move.l	umeIndexPtr(a5),d2	* destination
	move.l	#UME_HEADER_SIZE_BYTES,d3   * pituus
	lob     Read
    DPRINT  "read=%ld"

    * Allocate some space for the metadata txt
    moveq   #$7f,d0
    moveq   #0,d1
    jsr     getmem
    move.l  d0,umeMetaDataPtr(a5)
.x
    bsr     umeClose
.y
    rts


uslLoadData:
    DPRINT  "uslLoadData"
    tst.l   uslIndexPtr(a5)
    beq     .noDataError
    move.l  uslDataPtr(a5),d0
    beq     .load
    DPRINT  "check previous"
    * Check if already have it
    move.l  d0,a0
    move.b  (a0),d0
    lsr.b   #3,d0           * 5-bit index
    move.b  uslMD5(a5),d1
    lsr.b   #3,d1
    cmp.b   d0,d1
    beq     .gotIt
.load
    bsr     uslFreeData
    bsr     uslOpen
    beq     .error

    * Access index
    move.b  uslMD5(a5),d0
    lsr.b   #3,d0
    and.w   #$1f,d0     * 5-bit index!
    lsl     #3,d0       * 8 byte element index
    move.l  uslIndexPtr(a5),a0
    movem.l 4(a0,d0),d4/d5
    * d4 = file offset, d5 = block length

    move.l  d7,d1   * fh
    move.l  d4,d2   * offset   
    move.l  #OFFSET_BEGINNING,d3
    lob     Seek

    move.l  d5,d0
    moveq   #0,d1
    jsr     getmem
    move.l  d0,uslDataPtr(a5)
    beq     .error2

    move.l  d7,d1   * fh
    move.l  d0,d2   * target
    move.l  d5,d3   * len
    lore    Dos,Read
    DPRINT  "read=%ld"

.error2
    bsr     uslClose
.error
    rts
.gotIt
    DPRINT  "already had it"
    rts
.noDataError
    DPRINT  "no data available"
    rts


umeLoadData:
    DPRINT  "umeLoadData"
    tst.l   umeIndexPtr(a5)
    beq     .noDataError
    move.l  umeDataPtr(a5),d0
    beq     .load
    DPRINT  "check previous"
    * Check if already have it
    move.l  d0,a0
    move.b  (a0),d0
    lsr.b   #2,d0           * 6-bit index
    move.b  uslMD5(a5),d1
    lsr.b   #2,d1
    cmp.b   d0,d1
    beq     .gotIt
.load
    bsr     umeFreeData
    bsr     umeOpen
    beq     .error

    * Access index
    move.b  uslMD5(a5),d0
    lsr.b   #2,d0
    and.w   #$3f,d0     * 6 bits!
    lsl     #3,d0       * 8 byte element index
    move.l  umeIndexPtr(a5),a0
    movem.l 4(a0,d0),d4/d5
    * d4 = file offset, d5 = block length

    move.l  d7,d1   * fh
    move.l  d4,d2   * offset   
    move.l  #OFFSET_BEGINNING,d3
    lob     Seek

    move.l  d5,d0
    moveq   #0,d1
    jsr     getmem
    move.l  d0,umeDataPtr(a5)
    beq     .error2

    move.l  d7,d1   * fh
    move.l  d0,d2   * target
    move.l  d5,d3   * len
    lore    Dos,Read
    DPRINT  "read=%ld"

.error2
    bsr     umeClose
.error
    rts
.gotIt
    DPRINT  "already had it"
    rts
.noDataError
    DPRINT  "no data available"
    rts

    

uslClearSongData:
    DPRINT  "uslClearSongData"
	lea	    uslSongLengthData(a5),a2
    moveq   #8-1,d0
.cl clr.l   (a2)+
    dbf     d0,.cl
    rts


uslUmeClear:
    clr.l   uslMD5(a5)
    clr.w   uslMD5+4(a5)

umeClear:
    move.l  umeMetaDataPtr(a5),d0
    beq     .1
    move.l  d0,a0
    clr.b   (a0)
.1  
    rts

uslFind:
    moveq   #0,d0       * result in d0
    move.l  uslDataPtr(a5),d1
    beq     .x
    move.l  d1,a0
    move.l  -4(a0),d1       * mem area length
    lea	    (a0,d1.l),a1    * search end bound
    movem.w uslMD5(a5),d1/d2/d3
    and.w   #$0fff,d1       * ignore top 4 bits
.find
    ; ---------------------------------
	* First 16 bits, top 4 bits (song count) ignored
	move.b  (a0),d4
    moveq   #$f,d0
    and.b	d4,d0
    rol	    #8,d0
	move.b	1(a0),d0
	cmp.w   d1,d0
	bne     .skip

    move.b	2(a0),d0
    rol	    #8,d0
	move.b	3(a0),d0
	cmp.w	d2,d0
	bne	    .skip

    * Last 16 bits
	move.b	4(a0),d0
	rol	    #8,d0
	move.b	5(a0),d0
	cmp.w	d3,d0
	bne	    .skip
    ; ---------------------------------
    * found it!
    * read song count
    bsr     uslClearSongData
	lsr.b	#4,d4
	addq	#6,a0
	lea	    uslSongLengthData(a5),a1 
.sl
	moveq	#0,d0
	move.b	(a0)+,d0    
	bpl	    .sml
	and	    #$7f,d0         * 16-bit length
	lsl	    #8,d0
	move.b	(a0)+,d0
.sml	
    DPRINT  "--- song length=%ld"
	move.w	d0,(a1)+
	subq.b	#1,d4
	bne     .sl
    DPRINT  "--- found"
	rts
    ; ---------------------------------
.skip
    * read song count
	lsr.b	#4,d4	
	addq	#6,a0	* skip over md5sum
.songs
	tst.b	(a0)+
	bpl     .small
	addq	#1,a0	* 16-bit length
.small
	subq.b	#1,d4
	bne	.songs
    ; ---------------------------------
	cmp.l	a1,a0
	blo	    .find
.x
    DPRINT  "--- not found"
	moveq	#0,d0
	rts

    
umeFind:
    DPRINT  "umeFind"
    * Empty any previous data
    move.l  umeMetaDataPtr(a5),d0
    beq     .x
    move.l  d0,a1
    clr.b   (a1)

    moveq   #0,d0       * result in d0
    move.l  umeDataPtr(a5),d1
    beq     .x
    move.l  d1,a0
    move.l  -4(a0),d1       * mem area length
    lea	    (a0,d1.l),a1    * search end bound

    movem.w uslMD5(a5),d1/d2/d3

.find
    ; ---------------------------------
	* First 16 bits
    move.b	(a0),d0
    rol	    #8,d0
	move.b	1(a0),d0
	cmp.w	d1,d0
	bne	    .skip

    move.b	2(a0),d0
    rol	    #8,d0
	move.b	3(a0),d0
	cmp.w	d2,d0
	bne	    .skip

    * Last 16 bits
	move.b	4(a0),d0
	rol	    #8,d0
	move.b	5(a0),d0
	cmp.w	d3,d0
	bne	    .skip
    ; ---------------------------------
    * found it!
	addq	#6,a0
    move.l  umeMetaDataPtr(a5),a2
    * get 4 strings
    moveq   #4-1,d3
.sl
    moveq   #0,d0
    move.b  (a0)+,d0
    subq.b  #1,d0
    beq     .em
    lea     (a0,d0),a3   * str end
.loop
    jsr     utf8ToLatin1Char    * read (a0)+
    cmp.b   #"~",d0
    bne     .1
    move.b  #",",(a2)+
    moveq   #" ",d0
.1
    move.b  d0,(a2)+
    cmp.l   a3,a0
    bne     .loop

.em clr.b   (a2)+
    dbf     d3,.sl

    move.l  umeMetaDataPtr(a5),d0
    DPRINT  "+++ found %s"
	rts
    ; ---------------------------------
.skip
    * skip 4 strings
	addq	#6,a0
    moveq   #4-1,d4
    moveq   #0,d0
.skip4
    move.b  (a0),d0     
    add.w   d0,a0
    dbf     d4,.skip4
    ; ---------------------------------
.go	
	cmp.l	a1,a0
	blo	    .find
.x
    DPRINT  "+++ not found"
	moveq	#0,d0
	rts

uslGetSongLength:
    DPRINT  "uslGetSongLength"

    ; Do not clobber PT, SID, Sample data
    bsr     uslIgnoreFormats
    beq     .1

    clr.l   kokonaisaika(a5)
    lea     uslSongLengthData(a5),a0
    tst.w   (a0)
    beq     .x

    moveq   #0,d0
    move    songnumber(a5),d0
    sub     minsong(a5),d0
    DPRINT  "song=%ld"
    cmp     #$f,d0      * upper limit check
    bhi     .x      
    add     d0,d0
    move    (a0,d0),d0
    DPRINT  "length=%ld"
    divu    #60,d0
    move    d0,kokonaisaika(a5)
    swap    d0
    move    d0,kokonaisaika+2(a5)
.x
.1
    rts

uslFreeIndex:
    DPRINT  "uslFreeIndex"
    move.l  uslIndexPtr(a5),a0
    clr.l   uslIndexPtr(a5)
.free
    jmp     freemem

umeFreeIndex:
    DPRINT  "umeFreeIndex"
    move.l  umeMetaDataPtr(a5),a0
    clr.l   umeMetaDataPtr(a5)
    bsr     uslFreeIndex\.free
    move.l  umeIndexPtr(a5),a0
    clr.l   umeIndexPtr(a5)
    bra     uslFreeIndex\.free

uslFreeData:
    DPRINT  "uslFreeData"
    move.l  uslDataPtr(a5),a0
    clr.l   uslDataPtr(a5)
    bra     uslFreeIndex\.free

umeFreeData:
    DPRINT  "umeFreeData"
    move.l  umeDataPtr(a5),a0
    clr.l   umeDataPtr(a5)
    bra     uslFreeIndex\.free

uslOpen:
    lea     uslFile(pc),a0
    tst.b   uusikick(a5)
    bne     .1
    lea     uslFileOld(pc),a0
.1
    move.l  a0,d1
	move.l	#MODE_OLDFILE,d2
	lore    Dos,Open
    move.l  d0,d7
    rts

umeOpen:
    lea     umeFile(pc),a0
    tst.b   uusikick(a5)
    bne     .1
    lea     umeFileOld(pc),a0
.1  bra     uslOpen\.1

uslClose:
umeClose:
    move.l  d7,d1
    beq     .1
	lore    Dos,Close
.1  rts


uslFile:	 dc.b	"PROGDIR:"
uslFileOld   dc.b   "songlengths.db",0
uslDataName  dc.b   "PROGDIR:"
uslDataNameO dc.b   "songlengths.tsv",0
umeFile:	 dc.b	"PROGDIR:"
umeFileOld   dc.b   "metadata.db",0
umeDataName  dc.b   "PROGDIR:"
umeDataNameO dc.b   "combined.tsv",0
     even


* Creates Songlengths.db from Audacious-UADE songlengths.tsv
* Out:
*    d0 = true on success
uslCreateIndex:
    DPRINT  "uslCreateIndex"
    rsreset
.lastIndex        rs.w    1     * Based on the top bits of the MD5sum
.indexPtr         rs.l    1     
.index            rs.l    USL_INDEX_SIZE+1    * Build index here
.varsSize         rs.b    0

    moveq   #.varsSize/2-1,d0
.sk clr.w   -(sp)
    dbf     d0,.sk
    move.l  sp,a4

    * Input file
    lea     uslDataName(pc),a0
    tst.b   uusikick(a5)
    bne     .n1
    lea     uslDataNameO(pc),a0
.n1
    * Output file
    lea     uslFile(pc),a1
    tst.b   uusikick(a5)
    bne     .n3
    lea     uslFileOld(pc),a1
.n3
    * Initial values:
    move    #-1,.lastIndex(a4)
    pea     .index(a4)
    move.l  (sp)+,.indexPtr(a4)

    lea     .progressMsg(pc),a2
    lea     .finalizeCallback(pc),a3
    move.l  a3,d1
    lea     .callback(pc),a3
    move    #USL_INDEX_SIZE_BYTES,d0     * index space
    bsr     fileConverter

    lea     .varsSize(sp),sp
    rts

* Finalize callback inputs:
*    d7 = output file handle
*    a4 = callback user data
*    a6 = DOSBase
.finalizeCallback:
    * Write the index at the header 
    lea     .index(a4),a3

    move.l  d7,d1   * fh
    moveq   #0,d2   * offset
    moveq   #OFFSET_CURRENT,d3
    lob     Seek    
    move.l  d0,USL_INDEX_SIZE*4(a3)   * last position

    move.l  d7,d1   * fh
    moveq   #4,d2   * offset, start of index
    moveq   #OFFSET_BEGINNING,d3
    lob     Seek    

    moveq   #USL_INDEX_SIZE-1,d6
.loop
    move.l  (a3)+,d0     * offset of data block
    move.l  (a3),d1      * next offset
    sub.l   d0,d1        * block size
    movem.l d0/d1,-(sp)

    move.l  d7,d1   * file
    move.l  sp,d2   * source
    moveq   #8,d3   * len
    lob     Write

    addq    #8,sp
    dbf     d6,.loop
    rts


* Callback inputs:
*    a0 = input line
*    a1 = output buffer
*    a4 = callback user data
*    d6 = current input read position
*    d7 = current output write position
* Outputs:
*    d0 = bytes to write or 0 
.callback:
    move.l  a0,d0

    move.l  a1,a5 * stash this, start of the entry
    
    * Read 8 chars of MD5
    moveq   #8-1,d3
    bsr     .readHex
 
    * Read 4 chars of MD5
    moveq   #4-1,d3
    bsr     .readHex

    * Build index from the top 5 bits
    move.b  (a5),d0
    lsr.b   #3,d0
    cmp.b   .lastIndex(a4),d0
    beq     .noidx
    move.b  d0,.lastIndex(a4)

    * Write current position to the next index slot
    move.l  .indexPtr(a4),a0
    move.l  d7,(a0)+
    move.l  a0,.indexPtr(a4)
.noidx

    bsr     .skipTab
    bsr     .skipTab

    * song count
    moveq   #0,d4
.getNums
    bsr     .getNumber
    beq     .noMore
    add.l   #500,d2  * round
    divu    #1000,d2 * ms->s
    cmp.w   #$7f,d2 
    bls     .sml
    ror.w   #8,d2
    or.b    #$80,d2
    move.b  d2,(a1)+
    ror.w   #8,d2
.sml 
    move.b  d2,(a1)+
    addq    #1,d4
    cmp     #$f,d4      * limit check for songs
    blo     .getNums
    
.noMore
    * put song count to the first 4 bytes
    lsl.b   #4,d4
    and.b   #$0f,(a5)
    or.b    d4,(a5)  

    * How many bytes to write
    move.l  a1,d0
    sub.l   a5,d0
    * What to write
    move.l  a5,a0
    rts


.readHex:
    moveq   #0,d1
.md5a
* 0..9 = $30..$39
* a..f = $61..$66
    rol.w   #4,d1
    move.b  (a0)+,d0
    cmp.b   #$61,d0
    bhs     .n13
    sub.b   #$30,d0
    bra     .n23
.n13
    sub.b   #$61-10,d0
.n23
    or.b    d0,d1
    btst    #0,d3
    bne     .n33
    move.b  d1,(a1)+
    clr.b   d1
.n33
    dbf     d3,.md5a
    rts


.skipTab
.t	cmp.b	#9,(a0)+
    bne     .t
    rts


.getNumber
    bsr     .findNumberStart
    beq     .gx   
    move.l  a0,a2
    bsr     .findNumberEnd
    beq     .gx   
    move.l  a0,a3

* last char at a0
* first char at a2
* build into d2
	moveq	#0,d2 
	moveq	#1,d3
.numL
    moveq   #$f,d0
    and.b	-(a0),d0
    cmp.l   #$ffff,d3
    bhi     .large
    mulu.w  d3,d0
    bra     .small
.large  
    move.l	d3,d1
    jsr	    mulu_32
.small
    add.l	d0,d2

    ; mul d3 by 10
    move.l  d3,d0
    lsl.l   #3,d3  * x8
    add.l   d0,d3  * +1
    add.l   d0,d3  * +1

    cmp.l   a2,a0
    bne     .numL

    move.l   a3,a0
    moveq    #1,d1 
    rts
.gx
.eof
.noN
    moveq    #0,d1
    rts

.findNumberStart
.fn1 
    move.b  (a0)+,d0
    beq     .eof
    bsr     .isNum
    beq     .fn1
    subq    #1,a0
    moveq   #1,d1
    rts

.findNumberEnd
.fn2  
    move.b  (a0)+,d0
    beq     .eof
    bsr     .isNum
    bne     .fn2
    subq    #1,a0
    moveq   #1,d1
    rts


.isNum
    cmp.b   #"0",d0
    blo     .noN
    cmp.b   #"9",d0
    bhi     .noN
    moveq   #1,d1   * yes number
    rts


.progressMsg
    dc.b    "Creating song lengths %02.2ld%lc",0
    even



* Creates metadata.db from Audacious-UADE combined.tsv
* Out:
*    d0 = true on success
umeCreateIndex:
    DPRINT  "umeCreateIndex"
    rsreset
.lastIndex        rs.w    1     * Based on the top 4 bits of the MD5sum
.indexPtr         rs.l    1     
.index            rs.l    UME_INDEX_SIZE+1    * Build index here
.varsSize         rs.b    0

    move    #.varsSize/2-1,d0
.sk clr.w   -(sp)
    dbf     d0,.sk
    move.l  sp,a4

    * Input file
    lea     umeDataName(pc),a0
    tst.b   uusikick(a5)
    bne     .n1
    lea     umeDataNameO(pc),a0
.n1
    * Output file
    lea     umeFile(pc),a1
    tst.b   uusikick(a5)
    bne     .n3
    lea     umeFileOld(pc),a1
.n3
    * Initial values:
    move    #-1,.lastIndex(a4)
    pea     .index(a4)
    move.l  (sp)+,.indexPtr(a4)

    lea     .progressMsg(pc),a2
    lea     .finalizeCallback(pc),a3
    move.l  a3,d1
    lea     .callback(pc),a3
    move    #UME_INDEX_SIZE_BYTES,d0     * index space
    bsr     fileConverter

    lea     .varsSize(sp),sp
    rts

* Finalize callback inputs:
*    d7 = output file handle
*    a4 = callback user data
*    a6 = DOSBase
.finalizeCallback:
    * Write the index at the header 
    lea     .index(a4),a3

    move.l  d7,d1   * fh
    moveq   #0,d2   * offset
    moveq   #OFFSET_CURRENT,d3
    lob     Seek    
    move.l  d0,UME_INDEX_SIZE*4(a3)   * last position

    move.l  d7,d1   * fh
    moveq   #4,d2   * offset, start of index
    moveq   #OFFSET_BEGINNING,d3
    lob     Seek    

    moveq   #UME_INDEX_SIZE-1,d6
.loop
    move.l  (a3)+,d0     * offset of data block
    move.l  (a3),d1      * next offset
    sub.l   d0,d1        * block size
    movem.l d0/d1,-(sp)

    move.l  d7,d1   * file
    move.l  sp,d2   * source
    moveq   #8,d3   * len
    lob     Write

    addq    #8,sp
    dbf     d6,.loop
    rts


* Callback inputs:
*    a0 = input line
*    a1 = output buffer
*    a4 = callback user data
*    d6 = current input read position
*    d7 = current output write position
* Outputs:
*    d0 = bytes to write or 0 
.callback:
; Format:
; [md5]<TAB>[authors]<TAB>[publishers]<TAB>[album]<TAB>[year]

    move.l  a0,d0
    move.l  a1,a5 * stash this, start of the entry
    
    * Read 8 chars of MD5
    moveq   #8-1,d3
    bsr     uslCreateIndex\.readHex
 
    * Read 4 chars of MD5
    moveq   #4-1,d3
    bsr     uslCreateIndex\.readHex

    * Build index from the top 6 bits
    move.b  (a5),d0
    lsr.b   #2,d0           
    cmp.b   .lastIndex(a4),d0
    beq     .noidx
    move.b  d0,.lastIndex(a4)

    * Write current position to the next index slot
    move.l  .indexPtr(a4),a2
    move.l  d7,(a2)+
    move.l  a2,.indexPtr(a4)
.noidx
    addq    #1,a0   * skip 1st tab

    * get this many strings
    moveq   #4-1,d0
.strs
    move.l  a1,a2   * grab start ptr
    clr.b   (a1)+   * placeholder for length
    moveq   #9,d2   * tab
    bra     .lop0
.lop
    move.b  d0,(a1)+
.lop0
    move.b  (a0)+,d0
    beq     .end
    cmp.b   d2,d0
    bne     .lop
.end
    * write string length in front
    move.l  a1,d1
    sub.l   a2,d1
    move.b  d1,(a2)

    dbf     d0,.strs

    * How many bytes to write
    move.l  a1,d0
    sub.l   a5,d0
    * What to write
    move.l  a5,a0
    rts





.progressMsg
    dc.b    "Creating metadata %02.2ld%lc",0
    even

*********************************************************************
*
* Buffered file converter
*
* In:
*   a0 = input file name
*   a1 = output file name
*   a2 = progress message
*   a3 = file converter callback
*        Callback inputs:
*           a0 = input line
*           a1 = output buffer
*           a4 = callback user data
*           d6 = current input file position
*           d7 = current output file position
*        Outputs:
*           d0 = bytes to write or 0 
*   a4 = callback user data 
*   d0 = space to reserve for header om top of the default 4
* Out:
*   d0 = true on success
fileConverter:
.inputBufferLength  = 10*1024
.lineBufferLength   = 4096
.outBufferLength    = 1024
.pushBufferLength   = 12*1024
.workMemLen = .inputBufferLength+.lineBufferLength+.outBufferLength+.pushBufferLength

    rsreset
.workMem          rs.l    1  
.inputFile        rs.l    1 * input file name
.outputFile       rs.l    1 * output file name
.progressMsg      rs.l    1 * progress message
.lineCallback     rs.l    1 * callback to convert one input line
.lineCallbackData rs.l    1 * callback user data
.finalizeCallback rs.l    1 * called last, d7=FH, a6=DOSBase
.inLength         rs.l    1 * input file len
.inFH             rs.l    1 * input file handle
.outFH            rs.l    1 * output file handle
.inputBuffer      rs.l    1 * read chunks from input file
.lineBuffer       rs.l    1 * read and uppercase line from the buffer
.outBuffer        rs.l    1 * create output data entries here
.pushBuffer       rs.l    1 * push buffer
.pushBufferPos    rs.l    1 * position in the push buffer
.lastRead         rs.l    1 * bytes form the last input read
.totalRead        rs.l    1 * total bytes read
.lastProgress     rs.w    1 * to detect if progress needs to be displayed
.headerSpace      rs.w    1 * add this much bytes to the front of the file
.pushedBytes      rs.l    1 * number of bytes pushed to output
.globalInputOffset rs.l   1 * current input offset incremented in chunks
.inputOffset      rs.l    1 * current input offset in bytes
.count            rs.l    1 * debug info
.freeze           rs.b    1
                  rs.b    1 * pad
.slVars           rs.b    0

    DPRINT "fileConverter"
    pushm   d1-a6
    moveq   #.slVars/2-1,d7
.sk clr.w   -(sp)
    dbf     d7,.sk
    move.l  sp,a6

 if DEBUG
    pushm   all
    jsr     startMeasure
    popm    all
 endif

    move.w  d0,.headerSpace(a6)
    move.l  d1,.finalizeCallback(a6)
    move.l  a0,.inputFile(a6)
    move.l  a1,.outputFile(a6)
    move.l  a2,.progressMsg(a6)
    move.l  a3,.lineCallback(a6)
    move.l  a4,.lineCallbackData(a6)

    move.l  a6,a4
    ; ---------------------------------
    * Open input
    move.l  .inputFile(a4),d1
    move.l  #MODE_OLDFILE,d2
    lore    Dos,Open
    DPRINT  "open=%lx"
    move.l  d0,.inFH(a4)
    move.l  d0,d7
    beq     .exit       * bail out quickly

    ; ---------------------------------
    * Find length
	move.l	d7,d1		
	moveq	#0,d2	
	moveq	#1,d3
	lob	Seek
	move.l	d7,d1
	moveq	#0,d2	
	moveq	#1,d3
	lob	Seek
	move.l	d0,d5		* file length
    move.l  d0,.inLength(a4)
	move.l	d7,d1
	moveq	#0,d2
	moveq	#-1,d3
	lob	Seek			* start of file
    DPRINT  "len=%lx"

    ; ---------------------------------
    * Try to open idx
    move.l  .outputFile(a4),d1
    move.l  #MODE_OLDFILE,d2
    lob     Open
    DPRINT  "old idx=%lx"
    move.l  d0,d6
    move.l  d0,.outFH(a4)
    bne     .yesIdx
    ; ---------------------------------
    * No previous idx, create new
.doNew
    move.l  .outputFile(a4),d1
    move.l  #MODE_NEWFILE,d2
    lob     Open
    DPRINT  "new idx=%lx"
    move.l  d0,d6
    move.l  d0,.outFH(a4)
    beq     .exit
    bra     .writeLen
.yesIdx
    ; ---------------------------------
    * Read txt length from the start
    clr.l   -(sp)
    move.l  d6,d1   * file
    move.l  sp,d2   * dest
    moveq   #4,d3   * len
    lob     Read
    * Go back to start
	move.l	d6,d1
	moveq	#0,d2
	moveq	#-1,d3
	lob	Seek		
    ; ---------------------------------
    * Compare txt length and the length stored in idx
    * If same, exit
    cmp.l   (sp)+,d5
    beq     .exit
    * Do new - close OLDFILE handle
    DPRINT  "Replacing old index"
    move.l  d6,d1
    lob     Close
    bra     .doNew
.writeLen

	jsr	    setMainWindowWaitPointer
	jsr   	freezeMainWindowGadgets
    st      .freeze(a4)

    ; ---------------------------------
    ; Allocate buffers
    move.l  #.workMemLen,d0
    move.l  #MEMF_PUBLIC!MEMF_CLEAR,d1
    jsr     getmem
    beq     .exit
    DPRINT  "AllocMem=%lx"
    move.l  d0,.workMem(a4)
    move.l  d0,a0
    move.l  a0,.inputBuffer(a4)
    lea     .inputBufferLength(a0),a0
    move.l  a0,.lineBuffer(a4)
    lea     .lineBufferLength(a0),a0
    move.l  a0,.outBuffer(a4)
    lea     .outBufferLength(a0),a0
    move.l  a0,.pushBuffer(a4)
    move.l  a0,.pushBufferPos(a4)

    ; ---------------------------------
    * Write the txt length into the idx
    move.l  d5,-(sp)
    move.l  d6,d1   * file
    move.l  sp,d2   * source
    moveq   #4,d3   * len
    add.l   d3,.pushedBytes(a4)
    lob     Write
    DPRINT  "Write=%lx"
    addq    #4,sp   * pop
    cmp.l   #-1,d0
    beq     .exit
    * d0 = -1 on error

    * Write additional space
    move.w  .headerSpace(a4),d4
    beq     .noSpc
    lsr.w   #1,d4
    subq.w  #1,d4
    clr.w   -(sp)
.spc
    move.l  d6,d1   * file
    move.l  sp,d2   * source
    moveq   #2,d3   * len
    add.l   d3,.pushedBytes(a4)
    lob     Write
    dbf     d4,.spc    
    addq    #2,sp
.noSpc
    ; ---------------------------------
    * Read a chunk of txt
    DPRINT  "readLoop"
    move.l  .lineBuffer(a4),a3  * target buffer for a line
.readLoop
    move.l  .inFH(a4),d1
    move.l  .inputBuffer(a4),d2
    move.l  #1024*10,d3
    lob     Read
    ;;DPRINT  "read=%ld"
    add.l   d0,.totalRead(a4)
    move.l  d0,.lastRead(a4)
    
    ; ---------------------------------
    ; Print progress information
    pushm   all
    move.l  .totalRead(a4),d0
    moveq   #99,d1
    jsr     mulu_32
    move.l  .inLength(a4),d1
    jsr     divu_32

    cmp.w   .lastProgress(a4),d0
    beq     .skipPrg
    move.w  d0,.lastProgress(a4)

    moveq   #"%",d1
    move.l  .progressMsg(a4),a0
    lea     -64(sp),sp
    move.l  sp,a3
    jsr     desmsg3
     
    move.l  sp,a0
    jsr     printbox
    lea     64(sp),sp
.skipPrg
    popm    all

    ; ---------------------------------
    ; Bytes read in d0, check for EOF
    tst.l   d0
    beq     .stopLoop
    bmi     .stopLoop
    ; ---------------------------------
    ; Read bytes until line change
    move.l  .inputBuffer(a4),a0 * start of source
    lea     (a0,d0),a1          * end 
    moveq   #13,d1              * loop constants
    moveq   #10,d2
.lineLoop
    move.b  (a0)+,d0
    cmp.b   d1,d0
    beq     .cr
    cmp.b   d2,d0
    beq     .lf
    * Copy one char, check if data exhausted
    move.b  d0,(a3)+
.continue
    cmp.l   a1,a0
    blo     .lineLoop

    * Update global input data offset
    add.l   #1024*10,.globalInputOffset(a4)
    * See if we got a full chunk last time, read more if so
    cmp.l   #1024*10,.lastRead(a4)
    beq     .readLoop
    * Exit - call this a success
    bra     .stopLoop

.continueLineLoop:
    moveq   #13,d1              * loop constants
    moveq   #10,d2
    bra     .continue

.lf
.cr
    ; A whole line read, null terminate
    clr.b   (a3)
    * Preserve a0, a1!
    pushm   a0/a1
    ; ---------------------------------
    pushm   d1-d7/a2-a6
    * Provide current input data position
    * relative to the input buffer
    move.l  a0,d0
    sub.l   .inputBuffer(a4),d0
    * Relative the input file
    add.l   .globalInputOffset(a4),d0
    * Use the previous value as the new one
    * points to the next line.
    move.l  .inputOffset(a4),d6
    move.l  d0,.inputOffset(a4)

    * Read line here   
    move.l  .lineBuffer(a4),a0
    * Write data here
    move.l  .outBuffer(a4),a1

    * Provide current output write position
    move.l  .pushedBytes(a4),d7

    move.l  .lineCallback(a4),a3
    move.l  .lineCallbackData(a4),a4
    * Convert data
    jsr     (a3)
    * d0 = number of bytes to write
    * a0 = here are the bytes
    popm    d1-d7/a2-a6
    * Write if requested
    tst.l   d0
    bne     .doWrite
    moveq   #1,d0
    bra     .noWri
.doWrite
    bsr     .push
.noWri
    popm    a0/a1
    addq.l  #1,.count(a4)
    ; ---------------------------------
    * Stop on push error
    tst.l   d0
    beq     .stopLoop

.next
    ; ---------------------------------
    ; Start getting a new line 
    move.l  .lineBuffer(a4),a3
    ; Ignore 10 if the line ended with 13 ealier
    cmp.b   #10,(a0)
    bne     .continueLineLoop
    addq    #1,a0
    bra     .continueLineLoop

.stopLoop   
    * Write remaining
    bsr     .pushWrite

.exit
 if DEBUG
    move.l  .count(a4),d0
    DPRINT  "exiting, wrote %ld entries"
 endif
    ; ---------------------------------
    tst.l   .count(a4)
    beq     .noFinal
    move.l  .finalizeCallback(a4),d0
    beq     .noFinal
    move.l  d0,a0
    move.l  _DosBase(a5),a6
    move.l  .outFH(a4),d7
    push    a4
    move.l  .lineCallbackData(a4),a4
    jsr     (a0)
    pop     a4
.noFinal
    ; ---------------------------------
    move.l  .workMem(a4),a0
    jsr     freemem
    move.l  .inFH(a4),d1
    beq     .x1
    lob     Close
.x1 move.l  .outFH(a4),d1
    beq     .x2
    lob     Close
.x2
    tst.b   .freeze(a4)
    beq     .nf
    jsr	    unfreezeMainWindowGadgets
	jsr	    clearMainWindowWaitPointer
    jsr     forceRefreshList
.nf

 if DEBUG
    bsr     stopMeasure
    divu.w  #1000,d0
    ext.l   d0
    DPRINT  "FileConverter took %ld s"
 endif
    lea     .slVars(sp),sp
	popm    d1-a6
    rts

* In:
*   a0 = data pointer
*   d0 = length of data
* Out: 
*   d0 = true on success, false otherwise
.push:
    add.l   d0,.pushedBytes(a4)
    move.l  .pushBufferPos(a4),d3
    sub.l   .pushBuffer(a4),d3
    cmp.l   #10*1024,d3
    blo     .noPush
    pushm   d0/a0
    bsr     .pushWrite
    tst.l   d0
    popm    d0/a0
    bmi     .fail
.noPush
    move.l  .pushBufferPos(a4),a1
    subq    #1,d0
.cp move.b  (a0)+,(a1)+
    dbf     d0,.cp
    move.l  a1,.pushBufferPos(a4)
    moveq   #1,d0 * ok
    rts
.fail
    moveq   #0,d0 * bad
    rts

.pushWrite:
    move.l  .pushBufferPos(a4),d3
    sub.l   .pushBuffer(a4),d3    * len
    beq     .noWrite
    move.l  .pushBuffer(a4),d2    * src
    move.l  .outFH(a4),d1         * file
    lore    Dos,Write
    ;DPRINT  "write=%ld"
    move.l  .pushBuffer(a4),.pushBufferPos(a4)
.noWrite
    rts


***************************************************************************
*
* Info box scroll
*
***************************************************************************

SCROLL_UPDATE_RATE = 4  * update each x/50 sec

initInfoScroller:
    pushm   all
    DPRINT  "initInfoScroller"
    rsreset
.rastport   rs.b    rp_SIZEOF
.text       rs.b    512
.rows       rs.w    1
.vars       rs.b    0

    lea     -.vars(sp),sp
    move.l  sp,a4

    * Reset to initial state
    clr     infoScrollPos(a5)
    clr.b   infoScrollEnabled(a5)
    move    #30,infoScrollWaitTicks(a5)

    clr     .rows(a4)
    lea     .text(a4),a3
    bsr     .putType

    * Exit if no metadata 
    move.l  umeMetaDataPtr(a5),d0
    beq     .e
    move.l  d0,a0
    tst.b   (a0)
    beq     .e
    
    * Put four meta fields if available, from a0
    lea     metaData1,a1
    moveq   #9-1,d0
    bsr     .putMeta

    lea     metaData2,a1
    moveq   #12-1,d0
    bsr     .putMeta

    lea     metaData3,a1
    moveq   #9-1,d0
    bsr     .putMeta

    lea     metaData4,a1
    moveq   #6-1,d0
    bsr     .putMeta

    * 1st and last line are the same to allow smooth looping
    bsr     .putType
    clr.b   (a3)

    ; ---------------------------------

    move.l  _GFXBase(a5),a6
    lea     .rastport(a4),a1
    lob     InitRastPort

    lea     .rastport(a4),a1
	move.l	listfontbase(a5),a0
	lob     SetFont

    move.l	pen_1(a5),d0
    lea     .rastport(a4),a1
	lob     SetAPen

    * Area width
    move	WINSIZX(a5),d0          * size x
    sub     #7+WINX+4,d2
    sub     windowleft(a5),d2       * dest x
    * To be safe double the size horizontally
    add     d0,d0

    ; ---------------------------------
	move.l	listfontbase(a5),a1
	move    tf_YSize(a1),d1
    move    d1,infoScrollLineHeight(a5)
    mulu    .rows(a4),d1

    * Determine content height to be scrolled
    * so that it will loop nicely
    move    d1,d2
    sub     infoScrollLineHeight(a5),d2
    move    d2,infoScrollLength(a5)

    add      infoScrollLineHeight(a5),d1 * safety

    tst.l   infoScrollBitplane(a5)
    beq     .1
    cmp.w   infoScrollBitplaneW(a5),d0
    bhi     .2
    cmp.w   infoScrollBitplaneH(a5),d1
    bls     .3          * old is larger, do nothing
.2  
    * Need to reallocate
    pushm   d0/d1
    bsr     infoScrollFree
    popm    d0/d1
.1
    move    d0,infoScrollBitplaneW(a5)
    move    d1,infoScrollBitplaneH(a5)
    lob     AllocRaster
    move.l  d0,infoScrollBitplane(a5)
    beq     .x
.3
    moveq   #1,d0
    move    infoScrollBitplaneW(a5),d1
    move    infoScrollBitplaneH(a5),d2
    lea     infoScrollBitMap(a5),a0
    move.l  a0,rp_BitMap+.rastport(a4)
    move.l  infoScrollBitplane(a5),bm_Planes(a0)
    lob     InitBitMap

    * Empty target
    lea     .rastport(a4),a1
    moveq   #0,d0
    lob     SetRast

    moveq   #0,d0
	move.l	listfontbase(a5),a1
	move    tf_Baseline(a1),d1
    lea     .text(a4),a0
    bsr     .print

    ; All ok so far
    st      infoScrollEnabled(a5)
.x
.e
    lea     .vars(sp),sp
    popm    all
    rts

.putType:
    * "Type: "
    lea     tyyppi1b_t,a0
    moveq   #6-1,d0
.c1 move.b  (a0)+,(a3)+
    dbf     d0,.c1

    lea     moduletype(a5),a0
.c2 move.b  (a0)+,(a3)+
    bne     .c2
    subq    #1,a3
    move.b  #10,(a3)+
    addq    #1,.rows(a4)
    rts

* In:
*   a0 = metadata
*   a3 = output buffer
*   a1 = title string
*   d0 = title string length -1
.putMeta:
    tst.b   (a0)+
    beq     .m2
    * title
.c5 move.b  (a1)+,(a3)+
    dbf     d0,.c5
    * text
    subq    #1,a0
.c6 move.b  (a0)+,d0
    beq     .zz
    * Split to another line if there is ", "
    cmp.b   #",",d0
    bne     .z
    cmp.b   #" ",(a0)
    bne     .z
    addq    #1,a0
    addq    #1,.rows(a4)
    move.b  #10,(a3)+
    moveq   #".",d0
    move.b  d0,(a3)+
    move.b  d0,(a3)+
.z
    move.b  d0,(a3)+
    bra     .c6
.zz move.b  #10,(a3)+
    addq    #1,.rows(a4)
.m2
    rts

.print
    pushm   all
    lea     .rastport(a4),a4
    jmp     doPrint


infoScrollFree:
    move.l  infoScrollBitplane(a5),d0
    beq     .1
    move.l  d0,a0
    clr.l   infoScrollBitplane(a5)    
    move    infoScrollBitplaneW(a5),d0
    move    infoScrollBitplaneH(a5),d1
    lore    GFX,FreeRaster
.1  rts


drawInfoScroller:   
    tst.b   playing(a5)
    beq     .x
    tst.b   infoScrollEnabled(a5)
    beq     .x
    tst.w   infoScrollWaitTicks(a5)
    bne    .doWait

    moveq   #7+WINX+4-1+1,d2
    add     windowleft(a5),d2       * dest x
    
	move	infoBoxTopEdge(a5),d3
    add     windowtop(a5),d3        
    move    infoBoxHeight(a5),d5   
    lsr     #1,d5
    add     d5,d3
    addq    #1,d3                   * dest y
 
    move	WINSIZX(a5),d4          * size x - width of area
    sub     #10,d4                 
    sub     d2,d4

	move.l	listfontbase(a5),a0
	move    tf_YSize(a0),d5         * size y - one row

    moveq   #0,d0                   * src x

    * src y using easing
    moveq   #8,d1
    sub     infoScrollMoveTicks(a5),d1
    move.b  .easing(pc,d1),d1  
    mulu    infoScrollLineHeight(a5),d1
    lsr     #4,d1
    add     infoScrollPos(a5),d1

    move.b  #$c0,d6                 * minterm: copy
    move.l	rastport(a5),a1	     	* dest
    lea     infoScrollBitMap(a5),a0  * src
    lore    GFX,BltBitMapRastPort

    tst.w   infoScrollMoveTicks(a5)
    bne    .doScroll
.x
    rts

.easing
 dc.b 0,9,13,15,16,16,16,16 ; easeOutExpo
 

.doScroll
    subq    #1,infoScrollMoveTicks(a5)
    bne     .scr
    move    infoScrollLineHeight(a5),d0
    add     d0,infoScrollPos(a5)
    move    #30,infoScrollWaitTicks(a5)
    rts
.scr
    move    infoScrollPos(a5),d0
    cmp     infoScrollLength(a5),d0
    blt     .1
    clr     d0
.1  move    d0,infoScrollPos(a5)
    rts

.doWait
    subq    #1,infoScrollWaitTicks(a5)
    bne     .wai
    move    #8,infoScrollMoveTicks(a5) * easing size
.wai
    rts

***************************************************************************
*
* Performance measurement with timer.device
*
***************************************************************************

 if DEBUG
openTimer
	move.l	(a5),a0
	move	LIB_VERSION(a0),d0
	cmp	#36,d0
	blo.b	.x
	move.l	a0,a6

	lea	.timerDeviceName(pc),a0
	moveq	#UNIT_ECLOCK,d0
	moveq	#0,d1
	lea	timerRequest(a5),a1
	lob	OpenDevice		; d0=0 if success
	tst.l	d0
	seq	timerOpen(a5)
.x	rts

.timerDeviceName dc.b	"timer.device",0
	even

closeTimer
	tst.b	timerOpen(a5)
	beq.b	.x
	clr.b	timerOpen(a5)
	move.l	(a5),a6
	lea	timerRequest(a5),a1
	lob	CloseDevice
.x	rts

startMeasure
	tst.b	timerOpen(a5)
	beq.b	.x
	push	a6	
	move.l	IO_DEVICE+timerRequest(a5),a6
	lea	clockStart(a5),a0
	lob	ReadEClock
	pop 	a6
.x	rts

; out: d0: difference in millisecs
stopMeasure
	tst.b	timerOpen(a5)
	bne.b	.x
	moveq	#-1,d0
	rts
.x	pushm	d2-d4/a6
	move.l	IO_DEVICE+timerRequest(a5),a6
	lea	clockEnd(a5),a0
	lob	ReadEClock
    * D0 will be 709379 for PAL.
	move.l	d0,d2
	; d2 = ticks/s
	divu	#1000,d2
	; d2 = ticks/ms
	ext.l	d2
	
	; Calculate diff between start and stop times
	; in 64-bits
	move.l	EV_HI+clockEnd(a5),d0
	move.l	EV_LO+clockEnd(a5),d1
	move.l	EV_HI+clockStart(a5),d3
	sub.l	EV_LO+clockStart(a5),d1
	subx.l	d3,d0

	; Turn the diff into millisecs
	; Divide d0:d1 by d2
	jsr	divu_64
	; d0:d1 is now d0:d1/d2
	; take the lower 32-bits
	move.l	d1,d0
	popm	d2-d4/a6
	rts

  endif

*******************************************************************************
* Playereit‰

		;incdir
* Protracker code
kplayer		incbin	kpl
		;incdir	asm:player/pl/

* FImp decruncher code
fimp_decr	incbin	fimp_dec.bin

shr_decr	include	ShrinklerDecompress.s

* in:
*    a4 = data
* out:
*    d0 = size
getDeshrinkledSize
	move.l	shr_safety_margin(a4),d0
	bpl.b	.pos
	moveq	#0,d0
.pos	add.l	shr_uncompressed_size(a4),d0
	rts

* in:
*    a4 = data in
*    a1 = output buffer
deshrinkle
	move.l	a4,a0
	moveq	#FLAG_PARITY_CONTEXT,d7
	and.l	shr_flags(a0),d7
	* Skip header
	add	shr_header_size(a0),a0
	* Skip id and header size
	addq	#8,a0
	bra	ShrinklerDecompress


xpkname         dc.b    "xpkmaster.library",0
ppname          dc.b    "powerpacker.library",0
medplayername1  dc.b    "medplayer.library",0
medplayername2  dc.b    "octaplayer.library",0
medplayername3  dc.b    "octamixplayer.library",0
sidname         dc.b    "playsid.library",0
mlinename       dc.b    "mline.library",0
xfdname         dc.b    "xfdmaster.library",0
_MTName         dc.b    "mathtrans.library",0
_FFPName        dc.b    "mathffp.library",0
                even

	section	plrs,data

*******************************************************************************
*
* UI structures
* - Font definitions
* - Window structures
* - Gadgets
*

topaz_text_attr
	dc.l	topaz		* ta_Name
	dc	8		* ta_YSize
	dc.b	0		* ta_Style
	dc.b	0		* ta_Flags

text_attr
	dc.l	topaz		* ta_Name
	dc	8		* ta_YSize
	dc.b	0		* ta_Style
	dc.b	0		* ta_Flags

topaz	dc.b	"topaz.font",0
 even


mini_text_attr
	dc.l	.mini	* ta_Name
	dc	8		* ta_YSize
	dc.b	0		* ta_Style
	dc.b	0		* ta_Flags
;	dc.b	FPF_PROPORTIONAL * ta_Flags

.mini	dc.b	"mini4.font",0
 even

list_text_attr
	dc.l	topaz	* ta_Name
	dc	8	*	 ta_YSize
	dc.b	0	* ta_Style
	dc.b	0	* ta_Flags


* Main window
* STRUCTURE NewWindow
winstruc
	* nw_LeftEdge
	dc	360	;vas.yl‰k.x-koord.
	* nw_TopEdge
	dc	23	;---""--- y-koord
	* nw_Width
wsizex	dc	0	* sizex
	* nw_Height
wsizey	dc	0	* 181+25 ja 11
	* nw_DetailPen, nw_BlockPen
colors	dc.b	2,1	;palkin v‰rit
	* nw_IDCMPFlags
idcmpmw	dc.l	idcmpflags
	* nw_Flags
	dc.l	wflags
	* nw_FirstGadget
 	dc.l	0		* gadgets
	* nw_CheckMark
	dc.l	0	
	* nw_Title
	dc.l	windowname1
	* nw_Screen
	dc.l	0	;screen struc
	* bw_BitMap
	dc.l	0	;bitmap struc
	* nw_MinWidth, nw_MinHeight
	dc	0,0		* min x,y
	* nw_MaxWidth, nw_MaxHeight
	dc	0,512
	* nw_Type
	dc	WBENCHSCREEN
	dc.l	.t

*** Kick2.0+ window extension
* pubscreen, zip window

.t	dc.l	WA_PubScreenName,pubScreenNameTags+var_b	
	dc.l	WA_PubScreenFallBack,TRUE
	* Needed by ZipWindow (kick2.0)
	* Pointer to four words, LeftEdge, TopEdge, Width, Height
	dc.l	WA_Zoom,windowZippedPos+var_b 	
	dc.l	TAG_END

* Main window gadgets
gadgets
	;incdir
	include	gadgets/gadgets16_new3.s


* Prefs-window
winstruc2
	dc	0,0
prefssiz
	dc	452,170
colors2	dc.b	2,1
	dc.l	idcmpflags2
	dc.l	wflags2
 	dc.l	0		* gadgets
	dc.l	0	
	dc.l	.w
	dc.l	0	;screen struc
	dc.l	0	;bitmap struc
	dc	0,0	* min x,y
	dc	1000,1000 * max x,y
	dc	WBENCHSCREEN
	dc.l	enw_tags

.w	dc.b	"HippoPrefs"
wreg2
 ifne ANNOY
	dc.b	" - Unregistered version!",0
 else
	dc.b	0
 endif

 even

* Scope window
winstruc3
	dc	259
	dc	157
quadsiz	dc	340,85
	dc.b	2,1	;palkin v‰rit
	dc.l	idcmpflags3
	dc.l	wflags3
	dc.l	0
	dc.l	0	
;quadtitl
	dc.l	.t
	dc.l	0
	dc.l	0	
	dc	0,0	* min x,y
	dc	1000,1000 * max x,y
	dc	WBENCHSCREEN
	dc.l	enw_tags

.t	dc.b	"HippoScope"
wreg3
 ifne ANNOY
	dc.b	" - Unregistered version!",0
 else
 	dc.b	0
 endif
 even

* Pop up selector window used in prefs
winlistsel
	dc	0,0	* paikka 
winlistsiz
	dc	0,0	* koko
;	dc.b	2,1	;palkin v‰rit
	dc.b	0,0	;palkin v‰rit
	dc.l	idcmpflags4
	dc.l	wflags4
	dc.l	0
	dc.l	0	
	dc.l	0	; title
	dc.l	0
	dc.l	0	
	dc	0,0	 * min x,y
	dc	1000,1000 * max x,y
	dc	WBENCHSCREEN
	dc.l	enw_tags

* Prefs windows gadgets
gadgets2	include gadgets/prefs_main2.s
sivu0		include	gadgets/prefs_sivu0.s
sivu1		include	gadgets/prefs_sivu1.s
sivu2		include	gadgets/prefs_sivu2.s
sivu3		include	gadgets/prefs_sivu3.s
sivu4		include	gadgets/prefs_sivu4.s
sivu5		include	gadgets/prefs_sivu5.s
sivu6		include	gadgets/prefs_sivu6.s

* This is the "Favorites" button that belongs to prefs "sivu0" page.
* It should be the "next gadget" for gadget "bUu22", which is the "autosort" 
* button :-)
* I drew the button using the GadEdit tool but after exporting as source
* the data was not exactly same as the original, creating extra stuff
* and other odd things, so I copy-pasted the new bit here.

prefsFavorites dc.l prefsSaveState
       dc.w 406,121,28,12,3,1,1
       dc.l 0
       dc.l 0,prefsFavoritest,0,0
       dc.w 0
       dc.l 0
prefsFavoritest        dc.b 1,0,1,0
       dc.w -146,2
       dc.l 0,prefsFavoritestx,0
prefsFavoritestx       dc.b "Favorite modules..",0
       even

* "Save state" button
prefsSaveState
       dc.l 0
       dc.w 406,121-42,28,12,3,1,1
       dc.l 0
       dc.l 0,prefsSaveStatet,0,0
       dc.w 0
       dc.l 0
prefsSaveStatet        dc.b 1,0,1,0
       dc.w -146,2
       dc.l 0,prefsSaveStatetx,0
prefsSaveStatetx  
	     dc.b "Keep list on exit ",0
       even

* "Button tooltips" button copypasted from above, 
* x-coordinates adjusted manually.

prefsTooltips dc.l prefsAltButtons
       dc.w 214,107,28,12,3,1,1
       dc.l 0
       dc.l 0,prefsTooltipst,0,0
       dc.w 0
       dc.l 0
prefsTooltipst        dc.b 1,0,1,0
       dc.w -198,2
       dc.l 0,prefsTooltipstx,0
prefsTooltipstx 
       dc.b "Button tooltips.........",0
       even

prefsAltButtons 
       dc.l prefsQuadraScope
       dc.w 214,107+14,28,12,3,1,1
       dc.l 0
       dc.l 0,prefsAltButtonst,0,0
       dc.w 0
       dc.l 0
prefsAltButtonst        dc.b 1,0,1,0
       dc.w -198,2
       dc.l 0,prefsAltButtonstx,0
prefsAltButtonstx 
      ;dc.b "Bizarre buttons.........",0
      ;dc.b "Unconventional buttons..",0
       dc.b "Big buttons.............",0

prefsBarsText
	dc.b	"Bars",0
	even

prefsQuadraScope 
       dc.l prefsQuadraScopeBars
       dc.w 406-70,51+14+14,28,12,3,1,1
       dc.l 0,0,.t,0,0
       dc.w 0
       dc.l 0
.t        
       dc.b 1,0,1,0
       dc.w -146+70,2
       dc.l 0,.tx,.t2
.tx
       dc.b "Quadra",0
       even
.t2    
       dc.b 1,0,1,0
       dc.w -146+70+5*8,2-14-14
       dc.l 0,.tx2,0
.tx2	dc.b	 "-- Scopes --",0
 even

prefsQuadraScopeBars
       dc.l prefsQuadraScopeF
       dc.w 406,51+14+14,28,12,3,1,1
       dc.l 0,0,.t,0,0
       dc.w 0
       dc.l 0
.t        
       dc.b 1,0,1,0
       dc.w -40+4,2
       dc.l 0,prefsBarsText,0


prefsQuadraScopeF
       dc.l prefsQuadraScopeFBars
       dc.w 406-70,51+14+14+14,28,12,3,1,1
       dc.l 0,0,.t,0,0
       dc.w 0
       dc.l 0
.t        
       dc.b 1,0,1,0
       dc.w -146+70,2
       dc.l 0,.tx,0
.tx
       dc.b "Fill quad",0
       even

prefsQuadraScopeFBars
       dc.l prefsHippoScope
       dc.w 406,51+14+14+14,28,12,3,1,1
       dc.l 0,0,.t,0,0
       dc.w 0
       dc.l 0
.t        
       dc.b 1,0,1,0
       dc.w -40+4,2
       dc.l 0,prefsBarsText,0

prefsHippoScope
       dc.l prefsHippoScopeBars
       dc.w 406-70,51+14+14+14+14,28,12,3,1,1
       dc.l 0,0,.t,0,0
       dc.w 0
       dc.l 0
.t        
       dc.b 1,0,1,0
       dc.w -146+70,2
       dc.l 0,.tx,0
.tx
       dc.b "Hippo",0
       even

prefsHippoScopeBars
       dc.l prefsPatternScope
       dc.w 406,51+14+14+14+14,28,12,3,1,1
       dc.l 0,0,.t,0,0
       dc.w 0
       dc.l 0
.t        
       dc.b 1,0,1,0
       dc.w -40+4,2
       dc.l 0,prefsBarsText,0


prefsPatternScope
       dc.l prefsPatternScopeXL
       dc.w 406-70,51+14+14+14+14+14+14,28,12,3,1,1
       dc.l 0,0,.t,0,0
       dc.w 0
       dc.l 0
.t        
       dc.b 1,0,1,0
       dc.w -146+70,2
       dc.l 0,.tx,0
.tx
       dc.b "Pattern",0
       even
 even

prefsPatternScopeXL
       dc.l prefsSpectrumScope
       dc.w 406,51+14+14+14+14+14+14,28,12,3,1,1
       dc.l 0,0,.t,0,0
       dc.w 0
       dc.l 0
.t        
       dc.b 1,0,1,0
       dc.w -40+4,2
       dc.l 0,.tx,0
.tx
       dc.b "XL",0
 even

prefsSpectrumScope
       dc.l prefsSpectrumScopeBars
       dc.w 406-70,51+14+14+14+14+14,28,12,3,1,1
       dc.l 0,0,.t,0,0
       dc.w 0
       dc.l 0
.t        
       dc.b 1,0,1,0
       dc.w -146+70,2
       dc.l 0,.tx,0
.tx
       dc.b "Spectrum",0
       even

prefsSpectrumScopeBars
       dc.l prefsListFont
       dc.w 406,51+14+14+14+14+14,28,12,3,1,1
       dc.l 0,0,.t,0,0
       dc.w 0
       dc.l 0
.t        
       dc.b 1,0,1,0
       dc.w -40+4,2
       dc.l 0,prefsBarsText,0

; Button to select list font, on prefs page 2
prefsListFont
	dc.l	0 ; LAST ONE
	dc.w 120+37,93,(122+6*8)/2,12,0,1,1
	dc.l 0,0,0,0,0
	dc.w 0
	dc.l 0


prefsPlaySidMode 
       dc.l prefsEnableXMAPlay
       ; left, top, width, height
       dc.w 214-80+4-8-8,107+28-14-12-2-14,100-8+8+8,12,3,1,1
       dc.l 0
       dc.l 0,.t,0,0
       dc.w 0
       dc.l 0
.t     dc.b 1,0,1,0
       dc.w -198+80-4+8+8,2
       dc.l 0,.tx,0
.tx 
       dc.b "PlaySid mode",0
       even

prefsResidMode
       dc.l prefsResidFilter
       ; left, top, width, height
       dc.w 214-80+4-16,107+28-12-2-14,100-8+16,12,3,1,1
       dc.l 0
       dc.l 0,.t,0,0
       dc.w 0
       dc.l 0
.t     dc.b 1,0,1,0
       dc.w -198+80-4+16,2
       dc.l 0,.tx,0
.tx 
       dc.b "reSID mode...",0
       even

prefsResidFilter
       dc.l prefsResidBoost
       ; left, top, width, height
       dc.w 214-80+4-16,107+28-14,100-8+16,12,3,1,1
       dc.l 0
       dc.l 0,.t,0,0
       dc.w 0
       dc.l 0
.t     dc.b 1,0,1,0
       dc.w -198+80-4+16,2
       dc.l 0,.tx,0
.tx 
       dc.b "reSID filter",0
       even

prefsResidBoost
       dc.l prefsMHIEnable
       ; left, top, width, height
       dc.w 214-80+4-16,107+28,100-8+16,12,3,1,1
       dc.l 0
       dc.l 0,.t,0,0
       dc.w 0
       dc.l 0
.t     dc.b 1,0,1,0
       dc.w -198+80-4+16,2
       dc.l 0,.tx,0
.tx 
       dc.b "reSID boost..",0
       even

prefsMHIEnable
       dc.l prefsMHILib
       ; left, top, width, height
       dc.w 214-80+4-12-12-6,107+28-14-12-2-14-28,28,12,3,1,1
       dc.l 0
       dc.l 0,.t,0,0
       dc.w 0
       dc.l 0
.t     dc.b 1,0,1,0
       dc.w -198+80-4+16+14,2
       dc.l 0,.tx,0
.tx 
       dc.b "Enable MHI",0
       even

prefsMHILib
       dc.l prefsMedFastRamMode 
       ; left, top, width, height
       dc.w 214-80+4,107+28-14-12-2-14-28,100-8,12,3,1,1
       dc.l 0
       dc.l 0,0,0,0
       dc.w 0
       dc.l 0


prefsEnableXMAPlay dc.l prefsResidMode
       ; left, top, width, height
       ;dc.w 214-80+4+64,107-12-2,28,12,3,1,1
       dc.w 214-80+4+64+160+40+4,107-12-2+14+14,28,12,3,1,1
       dc.l 0
       dc.l 0,.t,0,0
       dc.w 0
       dc.l 0
.t     dc.b 1,0,1,0
       dc.w -198+80-4-64+32+4+2,2
       dc.l 0,.tx,0
.tx 
;       dc.b "Enable xmaplay060......",0
       dc.b "Enable xmaplay060",0
       even


prefsMedFastRamMode dc.l prefsMidiMode 
       ; left, top, width, height
       dc.w 214-80+4+64+160+40+4,107-12-2+14+14-14-14-8,28,12,3,1,1
       dc.l 0
       dc.l 0,.t,0,0
       dc.w 0
       dc.l 0
.t     dc.b 1,0,1,0
       dc.w -198+80-4-64+32+4+2,2
       dc.l 0,.tx,0
.tx 
       dc.b "MED FastMemPlay...",0
       even


prefsMidiMode
       dc.l 0  ;;;;;;;; END
       ; left, top, width, height
       dc.w 214-80+4-16,107+28-4*14,100-8+16,12,3,1,1
       dc.l 0
       dc.l 0,.t,0,0
       dc.w 0
       dc.l 0
.t     dc.b 1,0,1,0
       dc.w -198+80-4+16,2
       dc.l 0,.tx,0
.tx 
       dc.b "MIDI mode....",0
       even

; Gadget
gadgetListModeChangeButton:
	; gg_NextGadget
	dc.l gadgetResize
	; gg_LeftEdge
	dc 9
	; gg_TopEdge
	dc 64
	; gg_Width
	dc 18
	; gg_Height
	dc 13
	; gg_Flags
	dc GFLG_GADGIMAGE
	; gg_Activation
	dc GACT_RELVERIFY
	; gg_GadgetType
	dc GTYP_BOOLGADGET
	; gg_GadgetRender
	dc.l gadgetListModeChangeButtonImage
	; gg_SelectRender
	dc.l 0
	; gg_GadgetText
	dc.l 0
	; gg_MutualExclude
	dc.l 0
	; gg_SpecialInfo
	dc.l 0
	; gg_GadgetId
	dc.w 0
	; gg_UserData
	dc.l 0


; Image
gadgetListModeChangeButtonImage
	; ig_LeftEdge
	dc 4
	; ig_TopEdge
	dc 3
	; ig_Width
	dc 9+1
	; ig_Height
	dc 7
	; ig_Depth
	dc 1
	; ig_ImageData
gadgetListModeChangeButtonImagePtr
	dc.l	listImage
	; ig_PlanePick
	dc.b 1
	; ig_PlaneOff
	dc.b 0
	; ig_NextImage
	dc.l 0

gadgetResize:
	; gg_Next
	dc.l	gadgetPositionSlider
	; gg_LeftEdge: relative to right edge
	dc.w	-5
	; gg_TopEdge: relative to bottom edge
	dc.w	-5
	; gg_Width, gg_Height
	dc.w	6,6
	; gg_Flags
	dc.w	GFLG_RELRIGHT!GFLG_RELBOTTOM!GFLG_GADGIMAGE
	; gg_Activation
	dc.w	0
	; gg_GadgetType
	dc.w	GTYP_SIZING
	; gg_GadgetRender
	dc.l	gadgetResizeImage
	; gg_SelectRender
	dc.l	0
	; gg_GadgetText
	dc.l	0	
	; gg_MutualExclude
	dc.l	0
	; gg_SpecialInfo
	dc.l	0
	; gg_GadgetId
	dc.w	0
	; gg_UserData
	dc.l	0


gadgetResizeInfoWindow:
	; gg_Next
	dc.l	0
	; gg_LeftEdge: relative to right edge
	dc.w	-5
	; gg_TopEdge: relative to bottom edge
	dc.w	-5
	; gg_Width, gg_Height
	dc.w	6,6
	; gg_Flags
	dc.w	GFLG_RELRIGHT!GFLG_RELBOTTOM!GFLG_GADGIMAGE
	; gg_Activation
	dc.w	0
	; gg_GadgetType
	dc.w	GTYP_SIZING
	; gg_GadgetRender
	dc.l	gadgetResizeImage
	; gg_SelectRender
	dc.l	0
	; gg_GadgetText
	dc.l	0	
	; gg_MutualExclude
	dc.l	0
	; gg_SpecialInfo
	dc.l	0
	; gg_GadgetId
	dc.w	0
	; gg_UserData
	dc.l	0

; Image
gadgetResizeImage
	; ig_LeftEdge
	dc 0
	; ig_TopEdge
	dc 0
	; ig_Width
	dc 6
	; ig_Height
	dc 6
	; ig_Depth
	dc 2
	; ig_ImageData
	dc.l	resizeGadgetImage
	; ig_PlanePick
	dc.b %11
	; ig_PlaneOff
	dc.b 0
	; ig_NextImage
	dc.l 0


GADGET_ID_SEARCH_STRING       = 1000
GADGET_ID_SEARCH_SOURCE       = 1001
GADGET_ID_LOCAL_SEARCH_STRING = 1002

gadgetSearchString:
	; gg_NextGadget
	dc.l 0
	; gg_LeftEdge
	dc 0
	; gg_TopEdge
	dc 64
	; gg_Width
	dc 50
	; gg_Height
	dc 10
	; gg_Flags
	dc GFLG_STRINGEXTEND
	; gg_Activation
	dc GACT_RELVERIFY
	; gg_GadgetType
	dc GTYP_STRGADGET
    ; gg_GadgetRender
	dc.l 0
	; gg_SelectRender
	dc.l 0
	; gg_GadgetText
	dc.l 0
	; gg_MutualExclude
	dc.l 0
	; gg_SpecialInfo
	dc.l gadgetSearchStringStringInfo
	; gg_GadgetId
	dc.w GADGET_ID_SEARCH_STRING
	; gg_UserData
	dc.l 0


gadgetSearchStringStringInfo:
    dc.l    gadgetSearchStringBuffer     ; si_Buffer
    dc.l    0   ; si_UndoBuffer
    dc.w    0   ; si_BufferPos
    dc.w    49  ; si_MaxChars
    dc.w    0   ; si_DispPos
    dc.w    0   ; si_UndoPos
    dc.w    0   ; si_NumChars
    dc.w    0   ; si_DispCount
    dc.w    0   ; si_CLeft
    dc.w    0   ; si_CTop
    dc.l    .extension ; si_Extension
    dc.l    0   ; si_LongInt


.extension  dc.l    0   ; sex_Font
            dc.b    1,0 ; sex_Pens
            dc.b    1,0 ; sex_ActivePens
            dc.l    0   ; sex_InitialModes
            dc.l    0   ; sex_EditHook
            dc.l    0   ; sex_WorkBuffer
            ds.b    16  ; sex_Reserved


gadgetSearchSource:
    ; gg_NextGadget
	dc.l 0
	; gg_LeftEdge
	dc 0
	; gg_TopEdge
	dc 64
	; gg_Width
	dc 100
	; gg_Height
	dc 13
	; gg_Flags
	dc 0
	; gg_Activation
	dc GACT_RELVERIFY
	; gg_GadgetType
	dc GTYP_BOOLGADGET
    ; gg_GadgetRender
	dc.l 0
	; gg_SelectRender
	dc.l 0
	; gg_GadgetText
	dc.l gadgetSearchSourceIText
	; gg_MutualExclude
	dc.l 0
	; gg_SpecialInfo
	dc.l 0
  	; gg_GadgetId
	dc.w GADGET_ID_SEARCH_SOURCE
	; gg_UserData
	dc.l 0


gadgetSearchSourceIText
    dc.b    1   ; it_FrontPen
    dc.b    0   ; it_BackPen
    dc.b    0 ;RP_JAM1  ; it_DrawMode
    dc.b    0   ; it_KludgeFill00
    dc.w    3   ; it_LeftEdge
    dc.w    2   ; it_TopEdge
    dc.l    list_text_attr  ; it_ITextFont
gadgetSearchSourceTextPtr:
    dc.l    0   ; it_IText
    dc.l    0   ; it_NextText


* Rename the gadgets defined above to something not crazy
* 1st row
gadgetPlayButton 	EQU  button1
gadgetInfoButton	EQU  button2
gadgetStopButton	EQU  button3
gadgetEjectButton	EQU  button4
gadgetNextButton	EQU  button5
gadgetPrevButton        EQU  button6
gadgetForwardButton     EQU  kela2
gadgetRewindButton      EQU  kela1
gadgetNextSongButton    EQU  button12
gadgetPrevSongButton    EQU  button13
* 2nd row
gadgetAddButton         EQU  button7
gadgetDelButton         EQU  button8
gadgetNewButton   	EQU  button11
gadgetPrefsButton	EQU  button20
gadgetVolumeSlider	EQU  slider1
gadgetFileSlider        EQU  slider4
gadgetSortButton        EQU  lilb2
gadgetMoveButton        EQU  lilb1 
gadgetPrgButton         EQU  plg

; Index to gadget and the original gg_Width and gg_LeftEdge
row1Gadgets
	dr	gadgetPrevButton
	dc	0,0
	dr	gadgetPrevSongButton
	dc	0,0
	dr	gadgetRewindButton
	dc	0,0
	dr	gadgetPlayButton
	dc	0,0
	dr 	gadgetForwardButton
	dc	0,0
	dr	gadgetNextSongButton
	dc	0,0
	dr	gadgetNextButton
	dc	0,0
	dr	gadgetStopButton
	dc	0,0
	dr	gadgetEjectButton
	dc	0,0
	dr	gadgetInfoButton
	dc	0,0
	dc	0 ; END
	
row2Gadgets
	dr	gadgetVolumeSlider
	dc	0,0
	dr	gadgetNewButton
	dc	0,0
	dr	gadgetAddButton
	dc	0,0
	dr	gadgetDelButton
	dc	0,0
	dr	gadgetPrgButton
	dc	0,0
	dr	gadgetMoveButton
	dc	0,0
	dr	gadgetSortButton
	dc	0,0
	dr	gadgetPrefsButton
	dc	0,0
	dc	0 ; END



gadgetFileSliderInitialHeight = 67-16+2

* Contains gadget-routine pairs that determine
* the right mouse button actions when button is released
rightButtonActionsList	
	* New -> Clear
	dr.w	gadgetNewButton
	dc.l	rbutton9
	* Prefs -> zoom file box
	dr.w	gadgetPrefsButton
	dc.l	zoomfilebox
	* S -> Find in list 
	dr.w	gadgetSortButton
    dc.l	find_new
	* Move -> Add divider
	dr.w	gadgetMoveButton
	dc.l	add_divider
	* Add -> Insert
	dr.w 	gadgetAddButton
	dc.l	rinsert
	* Load Prg -> Save Prg
	dr.w	gadgetPrgButton
	dc.l	rsaveprog
	* > -> Fast forward
	dr.w 	gadgetForwardButton
	dc.l	rbutton_kela2_turbo
	* Del -> Nuke file
	dr.w	gadgetDelButton
	dc.l	hiiridelete  
	* i -> About
	dr.w 	gadgetInfoButton
	dc.l	aboutButtonAction
	* Play -> Random play
	dr.w	gadgetPlayButton
	dc.l	soitamodi_random
    * List mode change -> popup
    dr.w    gadgetListModeChangeButton
    dc.l    toggleListModePopup
    * Play mode change -> popo
    dr.w    gadgetPlayModeChangeButton
    dc.l    togglePlayModePopup
	dc.w	0 ; END
 

* Contains tooltip data for mainwindow gadgets
tooltipList
	dr.w 	gadgetPlayButton,.play
	dr.w	gadgetInfoButton,.info
	dr.w	gadgetStopButton,.stop
	dr.w	gadgetEjectButton,.eject 
	dr.w	gadgetNextButton,.next
	dr.w	gadgetPrevButton,.prev
	dr.w	gadgetAddButton,.add
.addButtonToolTipOffset = *-2
	dr.w	gadgetDelButton,.del
	dr.w 	gadgetNewButton,.new
	dr.w	gadgetNextSongButton,.nextSong
	dr.w	gadgetPrevSongButton,.prevSong
	dr.w	gadgetPrefsButton,.prefs
	dr.w	gadgetSortButton,.sort
	dr.w 	gadgetMoveButton,.move
	dr.w	gadgetPrgButton,.prg 
	dr.w	gadgetForwardButton,.forward
	dr.w	gadgetRewindButton,.rewind
	dr.w	gadgetListModeChangeButton,.listModeChange
    * This should be before source, as it may overlap the source button
	dr.w	gadgetSearchString,.searchString 
	dr.w	gadgetSearchSource,.searchSource
	dr.w	gadgetPlayModeChangeButton,.playModeChange
	dc.w	0 ; END
 
.play
	dc.b	34,2
	dc.b	"LMB: Play or restart chosen module",0
	dc.b	"RMB: Play a random module",0
.info
	dc.b	21,2
	dc.b	"LMB: Show module info",0
	dc.b	"RMB: Show about info",0
.stop
	dc.b	25,1
	dc.b	"Stop or continue playback",0
.eject
	dc.b	29,1
	dc.b	"Stop and eject current module",0
.next
	dc.b	16,1
	dc.b	"Play next module",0
.prev
	dc.b	20,1
	dc.b	"Play previous module",0
.add
	dc.b	47,2
	dc.b	"LMB: Add new modules to the list",0
	dc.b	"RMB: Insert new modules after the chosen module",0
.add2
	dc.b	40,1
	dc.b	"LMB: Add selected entry to the main list",0

.del
	dc.b	35,4
	dc.b	"LMB: Remove chosen module",0
	dc.b	"RMB: Remove from list and from disk",0
	dc.b	"     RMB on a divider will remove",0
	dc.b    "     the divided list section",0
.new
	dc.b	29,2
	dc.b	"LMB: Clear list and add files",0
	dc.b	"RMB: Clear list",0
.nextSong
	dc.b	17,1
	dc.b	"Play next subsong",0
.prevSong
	dc.b	21,1
	dc.b	"Play previous subsong",0
.prefs
	dc.b	21,2
	dc.b	"LMB: Open preferences",0
	dc.b    "RMB: Zoom file box",0
.sort
	dc.b	25,3
	dc.b	"LMB: Sort list   [S]",0
	dc.b	"RMB: Find module [F]",0
    dc.b    "     Find next   [CTRL+F]",0
.move
	dc.b	26,4
	dc.b	"LMB: Move chosen module,",0
	dc.b    "     press again to insert",0
	dc.b    "     the moved module",0
	dc.b	"RMB: Add divider",0
.prg
	dc.b	24,2
	dc.b	"LMB: Load module program",0
	dc.b	"RMB: Save module program",0
.forward
	dc.b	36,4
	dc.b	"LMB: Skip module forward",0
	dc.b    "     or play faster if can't skip",0
	dc.b	"RMB: Play even faster!",0
	dc.b    "Stop fast playback by pressing again",0
.rewind
	dc.b	20,1
	dc.b	"Skip module backward",0
;.listModeChange
;	dc.b	38,2
;	dc.b	"LMB: Toggle list mode",0
;	dc.b	"     Normal > Favorites > File browser",0
.listModeChange
	dc.b	21,6
	dc.b	"LMB: Toggle list mode",0
	dc.b	"    - Main playlist",0
	dc.b    "    - Favorites list",0
	dc.b    "    - File browser",0
	dc.b    "    - Search view",0
    dc.b    "RMB: Open popup",0 
.searchSource
	dc.b	20,2
	dc.b	"Select search source",0
    dc.b    "to search from",0
.searchString
	dc.b	18,1
	dc.b	"Enter search terms",0
.playModeChange
	dc.b	17,6
    dc.b    "Select play mode:",0
    dc.b	" - List repeat",0
    dc.b	" - List once",0
    dc.b	" - Module repeat",0
    dc.b	" - Module once",0
    dc.b	" - List random",0
  even

*** Samplename ikkuna
swinstruc:
	dc	0	;vas.yl‰k.x-koord.
	dc	0	;---""--- y-koord
swinsiz	dc	361-5,150-13*8-2
colors3	dc.b	2,1	;palkin v‰rit
	dc.l	sidcmpflags
sflags	dc.l	swflags
	dc.l	gAD1	;1. gadgetti
	dc.l	0	
	dc.l	.w
	dc.l	0	;screen struc
	dc.l	0	
	dc	0,0,0,0,WBENCHSCREEN
	dc.l	enw_tags

.w	dc.b	"HippoInfo"
wreg1
 ifne ANNOY
	dc.b	" - Unregistered version!",0
 else
 	dc.b	0
 endif

 even

* Slider for the module info window
gAD1	
    dc.l gadgetResizeInfoWindow
	dc.w 9,14,16,127-13*8,GFLG_GADGHNONE,9,3
	dc.l gAD1gr,0,0,0,gAD1s
	dc.w 0
	dc.l 0
gAD1gr	dc.w 0,0,6,4,0
	dc.l 0
	dc.b 0,0
	dc.l 0
gAD1s	dc.w 5,65535,0,0,0
	dc.w 0,0,0,0,0,0



gadgetPositionSlider
        ;dc.l 0 ; next
        dc.l gadgetPlayModeChangeButton
        * left, top:
        dc.w 9,50
        * width, height:
        dc.w 54,12
        dc.w 7      * gg_Flags
        dc.w GACT_RELVERIFY * gg_Activation
        dc.w 3      * gg_GadgetType
        dc.l .slider1gr,0,0,0,.slider1s
        dc.w 0 ; id
        dc.l 0
.slider1gr        dc.w 0,0,11,9,2
        dc.l pslider2im
        dc.b 3,0
        dc.l 0
.slider1s        dc.w 2,65535,0,0,0
        dc.w 0,0,0,0,0,0

; Gadget
gadgetPlayModeChangeButton:
	; gg_NextGadget
	dc.l 0
	; gg_LeftEdge
	dc 9
	; gg_TopEdge
	dc 50
	; gg_Width
	dc 18
	; gg_Height
	dc 13
	; gg_Flags
	dc GFLG_GADGIMAGE
	; gg_Activation
	dc GACT_RELVERIFY
	; gg_GadgetType
	dc GTYP_BOOLGADGET
	; gg_GadgetRender
	dc.l gadgetPlayModeChangeButtonImage
	; gg_SelectRender
	dc.l 0
	; gg_GadgetText
	dc.l 0
	; gg_MutualExclude
	dc.l 0
	; gg_SpecialInfo
	dc.l 0
	; gg_GadgetId
	dc.w 0
	; gg_UserData
	dc.l 0


; Image
gadgetPlayModeChangeButtonImage
	; ig_LeftEdge
	dc 4
	; ig_TopEdge
	dc 3
	; ig_Width
	dc 9+1
	; ig_Height
	dc 7
	; ig_Depth
	dc 1
	; ig_ImageData
gadgetPlayModeChangeButtonImagePtr
	dc.l	listImage
	; ig_PlanePick
	dc.b 1
	; ig_PlaneOff
	dc.b 0
	; ig_NextImage
	dc.l 0


*** Kick2.0+ window extension
* Asetetaan pubscreen

enw_tags
	dc.l	WA_PubScreenName,pubScreenNameTags+var_b	
	dc.l	WA_PubScreenFallBack,TRUE
	dc.l	TAG_END
	


*** file ja infoslider imagestruktuurit


slimage		dc	0	* leftedge
		dc	0	* topedge
		dc	16	* width
slimheight	dc	8	* heigh
		dc	2	* depth
		dc.l	slim	* data
		dc.b	%11	* planepick
		dc.b	0	* planeon/onff
		dc.l	0	* nextimage

slimage2	dc	0	* leftedge
		dc	0	* topedge
		dc	16	* width
slim2height	dc	8	* heigh
		dc	2	* depth
		dc.l	slim2	* data
		dc.b	%11	* planepick
		dc.b	0	* planeon/onff
		dc.l	0	* nextimage


; Vertical slider graphics, these are copied in the
; actual output gfx buffer depending on the slider size

; kickstart 2.0+
; Bitplane 1
slim1a	dc	%0000000000000000	; top line
.slim2a	dc	%0000000000000001	; middle lines
.slim3a	dc	%0111111111111111	; bottom line
; Bitplane 2
.slim1b	dc	%1111111111111110
.slim2b	dc	%1000000000000000
.slim3b	dc	%0000000000000000
 
; kickstart 1.3
; Bitplane 1
slim1a_kick13
.slim1a	dc	%1111111111111110	; top line
.slim2a	dc	%1000000000000000	; middle lines
.slim3a	dc	%0000000000000000	; bottom line
; Bitplane 2
.slim1b	dc	%0000000000000000
.slim2b	dc	%0000000000000001
.slim3b	dc	%0111111111111111


** PC -> Amiga somekinda text conversion table
asciitable
	DC.B	$00,$01,$02,$03,$04,$05,$06,$07
	DC.B	$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
	DC.B	$3E,$3C,$12,$21,$B6,$A7,$2D,$17
	DC.B	$18,$19,$1A,$1B,$60,$2D,$1E,$1F
	DC.B	$20,$21,$22,$23,$24,$25,$26,$27
	DC.B	$28,$29,$2A,$2B,$2C,$2D,$2E,$2F
	DC.B	$30,$31,$32,$33,$34,$35,$36,$37
	DC.B	$38,$39,$3A,$3B,$3C,$3D,$3E,$3F
	DC.B	$40,$41,$42,$43,$44,$45,$46,$47
	DC.B	$48,$49,$4A,$4B,$4C,$4D,$4E,$4F
	DC.B	$50,$51,$52,$53,$54,$55,$56,$57
	DC.B	$58,$59,$5A,$5B,$5C,$5D,$5E,$5F
	DC.B	$60,$61,$62,$63,$64,$65,$66,$67
	DC.B	$68,$69,$6A,$6B,$6C,$6D,$6E,$6F
	DC.B	$70,$71,$72,$73,$74,$75,$76,$77
	DC.B	$78,$79,$7A,$7B,$7C,$7D,$7E,$7F
	DC.B	$C7,$DC,$E9,$E2,$E4,$E0,$E5,$E7
	DC.B	$EA,$EB,$E8,$CF,$CE,$CC,$C4,$C5
	DC.B	$C8,$E6,$C6,$D4,$F6,$D2,$FB,$F9
	DC.B	$FF,$D6,$DC,$E7,$A3,$D8,$52,$66
	DC.B	$E1,$CD,$D3,$DA,$D1,$D1,$AA,$AA
	DC.B	$BF,$2E,$2E,$BD,$BC,$A1,$AB,$BB
	DC.B	$AA,$AE,$D1,$7C,$7C,$7C,$7C,$2E
	DC.B	$2E,$7C,$7C,$2E,$27,$27,$27,$2E
	DC.B	$60,$5E,$2E,$7C,$2D,$7C,$7C,$7C
	DC.B	$60,$2E,$5E,$2E,$7C,$3D,$7C,$5E
	DC.B	$5E,$2E,$2E,$60,$60,$2E,$2E,$7C
	DC.B	$7C,$27,$2E,$D8,$5F,$7C,$7C,$AF
	DC.B	$61,$DF,$72,$6E,$45,$D3,$B5,$74
	DC.B	$FE,$D8,$4F,$F0,$2D,$F8,$C9,$6E
	DC.B	$3D,$B1,$3E,$3C,$66,$4A,$F7,$3D
	DC.B	$B0,$B7,$B7,$56,$6E,$B2,$B7,$20

	section	mini,data_c

* 2 bitplane image, 96x66 pixels
hippohead	incbin	gfx/hip.raw

tickdata	dc	$001c,$0030,$0060,$70c0,$3980,$1f00,$0e00

* 16x4 pixeli‰

* %00 = tausta
* %10 = musta
* %01 = valkoinen
* %11 = sininen

korvadata
	dc.b	%01000000,%00000000	* 1 bpl
	dc.b	%10100000,%00000000     
	dc.b	%10010000,%00000000
	dc.b	%11111000,%00000000

	dc.b	%10000000,%00000000	* 2 bpl
	dc.b	%01000000,%00000000
	dc.b	%01100000,%00000000
	dc.b	%00000000,%00000000

* Sininen patterni mukana
korvadata2
	dc.b	%01010101,%00000000	* 1 bpl
	dc.b	%10101010,%00000000
	dc.b	%10010101,%00000000
	dc.b	%11111010,%00000000

	dc.b	%10010101,%00000000	* 2 bpl
	dc.b	%01001010,%00000000
	dc.b	%01100101,%00000000
	dc.b	%00000010,%00000000


*** Slider2im
; Vertical slider image normal size
; Width: 11 pixels
; Height: 9 pixels
juustoim	
juust0im	
meloniim	
eskimOim
kellokeim
kelloke2im
pslider1im
pslider2im
sIPULIim
sIPULI2im
ahiG4im
ahiG5im
ahiG6im
nAMISKA5im

horizPropGadgetGfxNormal
	; bitplane 1
	dc.w %0000000000000000 * row 1
	dc.w %0000000000100000 * row 2..n-1
	dc.w %0000000000100000 * row 2..n-1
	dc.w %0000000000100000 * row 2..n-1
	dc.w %0000000000100000 * row 2..n-1
	dc.w %0000000000100000 * row 2..n-1
	dc.w %0000000000100000 * row 2..n-1
	dc.w %0000000000100000 * row 2..n-1
	dc.w %0111111111100000 * row n
	; bitplane 2
	dc.w %1111111111000000
	dc.w %1000000000000000
	dc.w %1000000000000000
	dc.w %1000000000000000
	dc.w %1000000000000000
	dc.w %1000000000000000
	dc.w %1000000000000000
	dc.w %1000000000000000
	dc.w %0000000000000000

horizPropGadgetGfxNormal_kick13
	; bitplane 1
	dc.w %1111111111000000
	dc.w %1000000000000000
	dc.w %1000000000000000
	dc.w %1000000000000000
	dc.w %1000000000000000
	dc.w %1000000000000000
	dc.w %1000000000000000
	dc.w %1000000000000000
	dc.w %1000000000000000
	; bitplane 2
	dc.w %0000000000000000
	dc.w %0000000000100000
	dc.w %0000000000100000
	dc.w %0000000000100000
	dc.w %0000000000100000
	dc.w %0000000000100000
	dc.w %0000000000100000
	dc.w %0000000000100000
	dc.w %0111111111100000

* Width: 11 pixels
* Height: 9+8 pixels
;
;slider1imDouble
;horizPropGadgetGfxDouble
;	; bitplane 1
;	dc.w %0000000000000000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0111111111100000
;	; bitplane 2
;	dc.w %1111111111000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %0000000000000000
;
;horizPropGadgetGfxDouble_kick13
;	; bitplane 1
;	dc.w %1111111111000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %1000000000000000
;	dc.w %0000000000000000
;	; bitplane 2
;	dc.w %0000000000000000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0000000000100000
;	dc.w %0111111111100000
;
;

button1im	
	dc	%1100000000000000				
	dc	%1111000000000000				
	dc	%1111110000000000				
	dc	%1111111000000000				
	dc	%1111110000000000				
	dc	%1111000000000000				
	dc	%1100000000000000				
	dc	%0000000000000000				

button1imDouble

	dc	%1000000000000000				
	dc	%1100000000000000				
	dc	%1110000000000000				
	dc	%1111000000000000				
	dc	%1111100000000000				
	dc	%1111110000000000				
	dc	%1111111000000000				
	dc	%1111111000000000				
	dc	%1111110000000000				
	dc	%1111100000000000				
	dc	%1111000000000000				
	dc	%1110000000000000				
	dc	%1100000000000000				
	dc	%1000000000000000				
	dc	%0000000000000000				

button2im
	dc	%0111000000000000				
	dc	%0111000000000000				
	dc	%0000000000000000				
	dc	%1111000000000000				
	dc	%0111000000000000				
	dc	%0111000000000000				
	dc	%0111000000000000				
	dc	%0111000000000000				
	dc	%1111110000000000				

button2imDouble
	dc	%0000000000000000				
	dc	%0111000000000000				
	dc	%0111000000000000				
	dc	%0111000000000000				
	dc	%0000000000000000				
	dc	%1111000000000000				
	dc	%1111000000000000				
	dc	%0111000000000000				
	dc	%0111000000000000				
	dc	%0111000000000000				
	dc	%0111000000000000				
	dc	%0111000000000000				
	dc	%0111000000000000				
	dc	%0111000000000000				
	dc	%1111110000000000				
	dc	%1111110000000000				
	dc	%0000000000000000				
	dc	%0000000000000000				

button3im
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%0000000000000000				

button3imDouble
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%1111001111000000				
	dc	%0000000000000000				
	dc	%0000000000000000				

button4im
	dc	%0000011000000000				
	dc	%0001111110000000
	dc	%0111111111100000				
	dc	%1111111111110000				
	dc	%0000000000000000				
	dc	%1111111111110000				
	dc	%1111111111110000				
	dc	%0000000000000000				

button4imDouble
	dc	%0000000000000000				
	dc	%0000011000000000				
	dc	%0000111100000000
	dc	%0001111110000000
	dc	%0011111111000000				
	dc	%0111111111100000				
	dc	%1111111111110000				
	dc	%1111111111110000				
	dc	%0000000000000000				
	dc	%0000000000000000				
	dc	%1111111111110000				
	dc	%1111111111110000				
	dc	%1111111111110000				
	dc	%1111111111110000				
	dc	%0000000000000000				
	dc	%0000000000000000				

button5im
	dc	%1100000110000011
	dc	%1111000111100011
	dc	%1111110111111011
	dc	%1111111111111111
	dc	%1111110111111011
	dc	%1111000111100011
	dc	%1100000110000011
	dc	%0000000000000000				

button5imDouble
	dc	%1000000100000011
	dc	%1100000110000011
	dc	%1110000111000011
	dc	%1111000111100011
	dc	%1111100111110011
	dc	%1111110111111011
	dc	%1111111111111111
	dc	%1111111111111111
	dc	%1111110111111011
	dc	%1111100111110011
	dc	%1111000111100011
	dc	%1110000111000011
	dc	%1100000110000011
	dc	%1000000100000011
	dc	%0000000000000000					
	dc	%0000000000000000				

button6im
	dc	%1100000110000011
	dc	%1100011110001111
	dc	%1101111110111111
	dc	%1111111111111111
	dc	%1101111110111111
	dc	%1100011110001111
	dc	%1100000110000011
	dc	%0000000000000000				

button6imDouble
	dc	%1100000010000001
	dc	%1100000110000011
	dc	%1100001110000111
	dc	%1100011110001111
	dc	%1100111110011111
	dc	%1101111110111111
	dc	%1111111111111111
	dc	%1111111111111111
	dc	%1101111110111111
	dc	%1100111110011111
	dc	%1100011110001111
	dc	%1100001110000111
	dc	%1100000110000011
	dc	%1100000010000001
	dc	%0000000000000000				
	dc	%0000000000000000				

button12im
	dc	%1100000110000000
	dc	%1111000110000000
	dc	%1111110110000000
	dc	%1111111110000000
	dc	%1111110110000000
	dc	%1111000110000000
	dc	%1100000110000000
	dc	%0000000000000000

button12imDouble
	dc	%1000000110000000
	dc	%1100000110000000
	dc	%1110000110000000
	dc	%1111000110000000
	dc	%1111100110000000
	dc	%1111110110000000
	dc	%1111111110000000
	dc	%1111111110000000
	dc	%1111110110000000
	dc	%1111100110000000
	dc	%1111000110000000
	dc	%1110000110000000
	dc	%1100000110000000
	dc	%1000000110000000
	dc	%0000000000000000
	dc	%0000000000000000	

button13im
	dc	%1100000110000000
	dc	%1100011110000000
	dc	%1101111110000000
	dc	%1111111110000000
	dc	%1101111110000000
	dc	%1100011110000000
	dc	%1100000110000000
	dc	%0000000000000000				

button13imDouble
	dc	%1100000010000000
	dc	%1100000110000000
	dc	%1100001110000000
	dc	%1100011110000000
	dc	%1100111110000000
	dc	%1101111110000000
	dc	%1111111110000000
	dc	%1111111110000000
	dc	%1101111110000000
	dc	%1100111110000000
	dc	%1100011110000000
	dc	%1100001110000000
	dc	%1100000110000000
	dc	%1100000010000000
	dc	%0000000000000000				
	dc	%0000000000000000				


kela1im
	dc	%0000011000001100
	dc	%0001111000111100
	dc	%0111111011111100
	dc	%1111111111111100
	dc	%0111111011111100
	dc	%0001111000111100
	dc	%0000011000001100
	dc	%0000000000000000				

kela1imDouble
	dc	%0000001000000100
	dc	%0000011000001100
	dc	%0000111000011100
	dc	%0001111000111100
	dc	%0011111001111100
	dc	%0111111011111100
	dc	%1111111111111100
	dc	%1111111111111100
	dc	%0111111011111100
	dc	%0011111001111100
	dc	%0001111000111100
	dc	%0000111000011100
	dc	%0000011000001100
	dc	%0000001000000100
	dc	%0000000000000000				
	dc	%0000000000000000				

kela2im	
	dc	%1100000110000000
	dc	%1111000111100000
	dc	%1111110111111000
	dc	%1111111111111100
	dc	%1111110111111000
	dc	%1111000111100000
	dc	%1100000110000000
	dc	%0000000000000000				

kela2imDouble
	dc	%1000000100000000
	dc	%1100000110000000
	dc	%1110000111000000
	dc	%1111000111100000
	dc	%1111100111110000
	dc	%1111110111111000
	dc	%1111111111111100
	dc	%1111111111111100
	dc	%1111110111111000
	dc	%1111100111110000
	dc	%1111000111100000
	dc	%1110000111000000
	dc	%1100000110000000
	dc	%1000000100000000
	dc	%0000000000000000				
	dc	%0000000000000000				


* height 8
* width 16

favoriteImage:
	dc	%0111011100000000				
	dc	%1111111110000000				
	dc	%1111111110000000				
	dc	%0111111100000000				
	dc	%0011111000000000				
	dc	%0001110000000000				
	dc	%0000100000000000				

favoriteImageBig:
	dc	%0000000000000000
	dc	%0000000000000000
	dc	%0111011100000000				
	dc	%1111111110000000				
	dc	%1111111110000000				
	dc	%1111111110000000				
	dc	%1111111110000000				
	dc	%0111111100000000				
	dc	%0011111000000000				
	dc	%0001110000000000				
	dc	%0000100000000000				
	dc	%0000000000000000
	dc	%0000000000000000
	dc	%0000000000000000



listImage:
	dc	%1101111111000000
	dc	%0000000000000000				
	dc	%1101111111000000
	dc	%0000000000000000
	dc	%1101111111000000
	dc	%0000000000000000
	dc	%1101111111000000

listImageBig:
	dc	%0000000000000000
	dc	%0000000000000000
	dc	%1101111111000000
	dc	%0000000000000000
	dc	%1101111111000000
	dc	%0000000000000000				
	dc	%1101111111000000
	dc	%0000000000000000
	dc	%1101111111000000
	dc	%0000000000000000
	dc	%1101111111000000
	dc	%0000000000000000
	dc	%0000000000000000
	dc	%0000000000000000

fileBrowserImage:
	dc	%1111111100000000
	dc	%1011001010000000				
	dc	%1011111001000000
	dc	%1000000001000000
	dc	%1011111101000000
	dc	%1010000101000000
	dc	%1111111111000000

fileBrowserImageBig:
	dc	%0000000000000000
	dc	%0000000000000000
	dc	%1111111100000000
	dc	%1011001010000000				
	dc	%1011001001000000				
	dc	%1011111001000000
	dc	%1000000001000000
	dc	%1011111101000000
	dc	%1010000101000000
	dc	%1010000101000000
	dc	%1010000101000000
	dc	%1111111111000000
	dc	%0000000000000000
	dc	%0000000000000000

searchImage:
	dc	%0001110000000000
	dc	%0010001000000000
	dc	%0101000100000000
	dc	%0100000100000000
	dc	%0010001100000000
	dc	%0001111100000000
	dc	%0000000110000000

searchImageBig:
	dc	%0000000000000000
	dc	%0000000000000000
	dc	%0001110000000000
	dc	%0010001000000000
	dc	%0101000100000000
	dc	%0100000100000000
	dc	%0100000100000000
	dc	%0010001100000000
	dc	%0001111100000000
	dc	%0000000110000000
	dc	%0000000110000000
	dc	%0000000000000000
	dc	%0000000000000000
	dc	%0000000000000000

resizeGadgetImage:
	; plane 1
	dc	%0000010000000000
	dc	%0001010000000000
	dc	%0011010000000000
	dc	%0111010000000000
	dc	%0000010000000000
	dc	%1111110000000000
	; plane 2
	dc	%1111100000000000
	dc	%1000000000000000
	dc	%1000000000000000
	dc	%1000000000000000
	dc	%1000000000000000
	dc	%0000000000000000

; repeat list, play list once, repeat module, plauy module once,
; reanbdom
; 10 px wide
playModeRepeatListImage
        ;0123456789
	dc	%0100000000000000				
	dc	%0100001000000000				
	dc	%0100011100000000				
	dc	%0100111110000000				
	dc	%0100001000000000				
	dc	%0100001000000000				
	dc	%0011110000000000				

        ;0123456789
playModePlayListImage
	dc	%0000010000000000				
	dc	%0000010000000000				
	dc	%0000010000000000				
	dc	%0000010000000000				
	dc	%0001111100000000				
	dc	%0000111000000000				
	dc	%0000010000000000				

        ;0123456789
playModeRepeatModuleImage
	dc	%1111111100000000				
	dc	%0000000010000000				
	dc	%0001000010000000				
	dc	%0011000010000000				
	dc	%0111111100000000				
	dc	%0011000000000000				
	dc	%0001000000000000				

        ;0123456789
playModePlayModuleImage
	dc	%0000000000000000				
	dc	%0000000100000000				
	dc	%0000000110000000				
	dc	%1111111111000000				
	dc	%0000000110000000				
	dc	%0000000100000000				
	dc	%0000000000000000				

        ;0123456789
playModeRandomImage
	dc	%0010000100000000				
	dc	%0001001000000000				
	dc	%0000110000000000				
	dc	%0001001000000000				
	dc	%0010000100000000				
	dc	%0111001110000000				
	dc	%0010000100000000				


	section	mah,bss_c

* Tyhj‰ sample PS3M:lle ja BPSoundMon2.0:lle.
ps3memptysample
nullsample	ds.l	1

* tilaa filebox-sliderin imagelle
slim:	ds	410*2

* sampleinfo-slideri
slim2:	ds	410*2

* volume slider image
slider1im
	* Space for 30 rows, 16 pixels, two bitplanes
	ds.w	30*2

	section	udnm,bss_p

		cnop 0,4
* Global variables
var_b		ds.b	size_var

gadgetSearchStringBuffer:     
    ds.b    50
gadgetLocalSearchStringBuffer:     
    ds.b    50

* Copy of Protracker module header data for the info window
ptheader	ds.b	950
 end
